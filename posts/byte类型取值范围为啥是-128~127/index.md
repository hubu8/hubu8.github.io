# byte类型取值范围为啥是-128~127


<!--more-->

一个字节是8个比特位，int类型有4个字节，也就是有32个比特位。

### 基本数据类型：

```
1 基本类型：byte 二进制位数：8   一个字节8个bit位
2 包装类：java.lang.Byte
3 最小值：Byte.MIN_VALUE=-128
4 最大值：Byte.MAX_VALUE=127
```

```
1 基本类型：short 二进制位数：16
2 包装类：java.lang.Short
3 最小值：Short.MIN_VALUE=-32768
4 最大值：Short.MAX_VALUE=32767
```

```
1 基本类型：int 二进制位数：32
2 包装类：java.lang.Integer
3 最小值：Integer.MIN_VALUE=-2147483648
4 最大值：Integer.MAX_VALUE=2147483647
```

```
1 基本类型：long 二进制位数：64
2 包装类：java.lang.Long
3 最小值：Long.MIN_VALUE=-9223372036854775808
4 最大值：Long.MAX_VALUE=9223372036854775807
```

```
1 基本类型：float 二进制位数：32
2 包装类：java.lang.Float
3 最小值：Float.MIN_VALUE=1.4E-45
4 最大值：Float.MAX_VALUE=3.4028235E38
```

```
1 基本类型：double 二进制位数：64
2 包装类：java.lang.Double
3 最小值：Double.MIN_VALUE=4.9E-324
4 最大值：Double.MAX_VALUE=1.7976931348623157E308
```

```
1 基本类型：char 二进制位数：16
2 包装类：java.lang.Character
3 最小值：Character.MIN_VALUE=0
4 最大值：Character.MAX_VALUE=65535
```

### 我们来看看为啥byte的取值范围是-128~127

我们都知道，1个byte占8个bit位，二进制为表示10100000，其中首位(最高位)是符号位，剩下的是数值位，所以能表示byte数值的只有7位，那么它的最大值很容易的用二进制表示为：1111111计算得到26+25+24+23+22+21+20 = 127,由于首位是符号位，所以很容易地得出byte的取值范围是-127~127，也就是1111 1111 ~ 0111 1111,那么-128是怎么来的呢？

计算机底层定义了 0000 0000 就是0.

原码、反码、补码的出现是为了方便计算机表示、计算负数参与的加减法运算。因此，原码，反码，补码是机器存储一个具体数字的编码方式。

#### 原码:

在数值前直接加一符号位的表示法，对于8位二进制来说：

[+7]原= 0 0000111 [-7]原= 1 0000111

#### 反码:

正数的反码与原码相同;负数的反码,符号位为“1”,数值部分按位取反。

[+7]反= 0 0000111 [-7]反= 1 1111000

#### 补码:

正数的补码和原码相同;负数的补码则是符号位为“1”,数值部分按位取反后再在末位(最低位)加1，也就是“反码+1”。

[+7]补= 0 0000111 [-7]补= 1 1111001

**其中正整数的原码、反码和补码都一样;**

**负数部分：**

**原码和反码的相互转换：符号位不变，数值位按位取反;**

**原码和补码的相互转换：符号位不变，数值位按位取反,末位再加1;**

**已知补码，求原码的负数的补码：符号位和数值位都取反，末位再加1。**

#### 那为什么会有反码和补码呢？

- 计算机没有减法器，只有加法器，所以只能做加法
- 可以用负数代替减法

#### 原因：

8位二进制（有符号）的取值范围是-128~127的原因：在计算机中0是由0000 0000存储的，对于正数0000 0001~0111 1111(1~127).对于负数1000 0001~1111 1111（-1~-127）.那么唯独只剩1000 0000（指-0）我们就把1000 0000作为-128.用1000 0000作为-128而不是128的原因是：

如果作为+128，+128的表示方法为01000 0000（原码反码补码均是），位数明显超过了8.所以要舍去一位，最高位代表的符号位是必选的。其他数值位则从低到高选取后7位，则成为0000 0000与1000 0000 并不符。

如果作为-128，-128的表示方法是11000 0000（原码），10111 1111（反码），11000 0000（补码），同样的要舍去以为那么舍去后的原码反码补码分别为：1000 0000，1111 1111，1000 0000.所以用1000 0000（-0）来代表-128.（但实际上-128是11000 0000）.

-128的源码反码补码为1000 0000，1111 1111，1000 0000实际上是根据上面的运算得出来的。**其实-128只有补码**，原码反码代表的是-0的原码反码。但是真正做运算时某某1000 0000来做的。例如用-128+1：

-128的补码：1000 0000

1的补码： 0000 0001

运算结果 1000 0001（补码）

1000 0001是-127的反码，所以在正常情况下运算是正确的，加减运算时要避免溢出。












