[{"categories":["运维"],"content":"官方文档：Docker环境可道云网盘的安装示例 | Kodcloud Documentation 安装Docker环境 安装并启动docker服务, 新版本docker会自动安装docker-compose-plugin curl -fsSL https://get.docker.com | bash -s docker systemctl enable docker \u0026\u0026 systemctl start docker docker compose 用法, 在通过docker compose up启动后, 可以使用docker compose ls查看配置文件位置 若docker compose命令不存在，可手动安装二进制文件docker-compose并在后续命令中替换。 curl -SL https://github.com/docker/compose/releases/download/v2.23.3/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose http方式快速启动 首先创建一个目录作为项目目录，后面所有命令都在这个目录下执行 mkdir /kodbox \u0026\u0026 cd /kodbox 创建文件来设置数据库环境变量vim db.env MYSQL_PASSWORD= MYSQL_DATABASE=kodbox MYSQL_USER=kodbox 创建docker-compose.yml 文件，在其中配置映射端口、持久化目录 version:'3.5'services:db:image:mariadb:10.6restart:alwayscommand:--transaction-isolation=READ-COMMITTED --log-bin=binlog --binlog-format=ROWvolumes:- \"./db:/var/lib/mysql\"#./db是数据库持久化目录，可以修改# - \"./etc/mysql/conf.d:/etc/mysql/conf.d\" #增加自定义mysql配置environment:- MYSQL_ROOT_PASSWORD=- MARIADB_AUTO_UPGRADE=1- MARIADB_DISABLE_UPGRADE_BACKUP=1env_file:- db.envapp:image:kodcloud/kodboxrestart:alwaysports:- 80:80#左边80是使用端口，可以修改volumes:- \"./site:/var/www/html\"#./site是站点目录位置，可以修改environment:- MYSQL_HOST=db- REDIS_HOST=redisenv_file:- db.envdepends_on:- db- redisredis:image:redis:alpinerestart:always 增加自定义mysql配置： mkdir -p ./etc/mysql/conf.d \u0026\u0026 vim ./etc/mysql/conf.d/custom.cnf 进入项目目录，执行docker compose up -d启动命令，会自动拉取容器并运行 列出docker容器，可以看到3个容器正在运行 如果需要停止服务 docker compose down 安装要点 1、MYSQL_ROOT_PASSWORD需要自己填 2、安装过程中 app 容器第一次安装事件比较长，不要中途停止容器 3、MYSQL_PASSWORD这个是环境变量，不知道是不是必填，自己测试一下 ","date":"2023-12-29","objectID":"/docker%E5%AE%89%E8%A3%85kodbox%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8/:0:0","tags":["docker","kodbox","文件管理"],"title":"Docker安装Kodbox快速启动","uri":"/docker%E5%AE%89%E8%A3%85kodbox%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8/"},{"categories":["数据库"],"content":"Specified key was too long; max key length is 3072 bytes showvariableslike'innodb_page_size'; 16384 = 16KB * 1024 果断翻译了一下mysql8的官方文档，得出结论： 需要修改长度的字段做了索引； innodb引擎的每个索引列长度限制为767字节（bytes），所有组成索引列的长度和不能大于3072字节。为什么限制为3072 ？ 这个和InnoDB的页大小有关。 我们知道InnoDB一个page的默认大小是16k。由于是B+树组织，要求叶子节点上一个page至少要包含两条记录所以一个记录最多不能超过8k。又由于InnoDB的聚簇索引结构，一个二级索引要包含主键索引，因此每个单个索引不能超过 4 k（极端情况，聚集索引和某个二级索引都达到这个限制）。由于需要预留和辅助空间，扣掉后不能超过 3500 ，取个“整数”就是(1024*3)。由此推算将页大小改为8K，4K的时候索引长度限制也应该相应减小。 问题所在的表的字符集是 utf8mb4 时，一个字符将占用 4 个字节。这意味着索引前缀最大长度为 3072 字节时，只能容纳 3072 / 4 = 768 个字符。因此只要将上面建表语句索引字段的前缀长度设为768或者修改索引字段，让其小于3072字节。 索引前缀长度还和 InnoDB 的 page size 有关。“innodb_page_size”选项默认是 16KB 的时候，最长索引前缀长度是 3072 字节，如果是 8KB 的时候，最长索引前缀长度是 1536 字节；4KB 的时候，最长索引前缀长度是 768 字节。 总结：读取数据的整个流程中，最浪费时间的是磁盘寻道，查找数据所属扇区位置的过程（机械运动）。又因为内存最小的存储单位是页，这样最快的存储方式，1个内存页的数据，正好在1个扇区内，一次性查询完成。所以限制了3072字节为1个内存页。 综上可知： 当Mysql数据库引擎为innodb时，page_size大小为16KB（16384）、utf8mb4字符集时，建立索引的字段长度不能超过 768个字符，超过就报错 如何计算索引长度 所有的索引字段，如果没有设置 Not Null，则需要加一个字节(这也是我们为什么建议建表时不要有 Null 字段的原因之一)。 对于定长字段，int 类型占四个字节、date 占三个字节、char(n) 占 N 个字符。 对于变成字段 varchar(n)，则是 N 个字符 + 两个字节。 不同的字符集，一个字符占用的字节数不同。latin1编码的，一个字符占用一个字节，gbk编码的，一个字符占用两个字节，utf8编码的，一个字符占用三个字节。 索引长度 char()、varchar() 索引长度的计算公式： Character Set：utf8mb4=4,utf8=3,gbk=2,latin1=1) * 列长度 + 1(允许 Null) + 2(变长列) 基于以上原则，我们建张表来验证下： CREATETABLE`tb_item`(`id`bigintNOTNULLCOMMENT'书籍id，同时也是书籍编号',`title`varchar(100)NOTNULLCOMMENT'书籍名称',`sell_point`varchar(500)DEFAULTNULLCOMMENT'书籍卖点',`price`bigintNOTNULLCOMMENT'书籍价格，单位为：分',`num`intNOTNULLCOMMENT'库存数量',`barcode`varchar(30)DEFAULTNULLCOMMENT'书籍条形码',`image`varchar(500)DEFAULTNULLCOMMENT'书籍图片',`cid`bigintNOTNULLCOMMENT'所属类目，叶子类目',`status`tinyintNOTNULLDEFAULT'1'COMMENT'书籍状态，1-正常，2-下架，3-删除',`created`datetimeNOTNULLCOMMENT'创建时间',`updated`datetimeNOTNULLCOMMENT'更新时间',`upload_id`bigintDEFAULTNULL,PRIMARYKEY(`id`),KEY`cid`(`cid`),KEY`status`(`status`),KEY`updated`(`updated`),KEY`tb_item_title_price_num`(`title`,`price`,`num`))ENGINE=InnoDBDEFAULTCHARSET=utf8COMMENT='书籍表'; 在这张表上我们建立了联合索引 tb_item_title_price_num ，由三个字段组成，分别是变长字段 varchar，定长字段 price 以及 num。 我们先来执行如下这条语句： explain select * from tb_item where title = '编译原理' and price = 45 and num = 23232; 我们看到 key 是 tb_item_title_price_num，同时索引长度 key_len 为 314 ，证明是使用到了联合索引 tb_item_title_price_num 的三个完整字段的。 这个 314 的具体计算方式为： 字符集我们建表时用的为 utf8 编码，所以 title 字段的索引长度是 3 * 100 + 0 + 2 = 302，price 字段的索引长度是 8，num 字段的索引长度是 4。 因此 tb_item_title_price_num 索引总共长度是 302 + 8 + 4 = 314。 为了验证我们的计算方式，接下来我们再执行如下语句，使得索引部分失效。 explain select * from tb_item where title = '编译原理' and num = 23232 这条语句因为我们跳过了 price 字段，所以联合索引中只会有 title 字段生效，剩余部分都会失效，如果我们计算方式没有问题的话，那么此时执行计划中的 key_len 应该为 302。 果然，我们看到 key_len 已经变成了 302，这意味着索引部分失效了，只有 title 字段索引起了作用，同时 Extra 为 Using index condition，说明使用了索引，但是需要回表查询数据。 简单总结一下，在 MySQL 中，索引长度不仅取决于我们建表时设置的字段长度，还和具体的字符集编码以及字段是否允许为 Null 等多个条件相关，字段长度只能作为索引长度的预估项，而不是准确值。 MySQL各版本中对索引大小限制（InnoDB引擎） 1.联合索引 MySQL 3.23：最大联合索引长度为1000字节。 MySQL 4.0.x/4.1.x/5.0.x：最大联合索引长度为1000字节。 MySQL 5.1.x：最大联合索引长度为3072字节（InnoDB存储引擎），或1000字节（MyISAM存储引擎）。 MySQL 5.5.x/5.6.x/5.7.x：最大联合索引长度为3072字节（InnoDB存储引擎），或1000字节（MyISAM存储引擎）。 MySQL 8.0.x：最大联合索引长度为3072字节（InnoDB和MyISAM存储引擎）。 2.单列索引 MySQL 5.6 及之前版本： InnoDB 存储引擎中单列索引的大小限制为767字节。这个限制是由于InnoDB存储引擎默认使用UTF-8字符集，而UTF-8编码中一个字符 可能占用3个字节的存储空间，所以InnoDB将限制单列索引不能超过255个字符（因为255*3=765）。 MySQL 5.7：InnoDB 存储引擎中单列索引的大小限制已经被扩展到3072字节。这个改变主要是为了适应更长的JSON列索引。 MySQL 8.0：InnoDB 存储引擎中单列索引的大小限制依然是3072字节。 ","date":"2023-12-26","objectID":"/specified-key-was-too-long/:0:0","tags":[],"title":"Specified key was too long; max key length is 3072 bytes","uri":"/specified-key-was-too-long/"},{"categories":["前端"],"content":"快速入门 数据类型与变量 实际上，JavaScript允许对任意数据类型做比较： false == 0; // true false === 0; // false 要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是 == 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是 === 比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： NaN === NaN; // false 唯一能判断NaN的方法是通过isNaN()函数： isNaN(NaN); // true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： Math.abs(1 / 3 - (1 - 2 / 3)) \u003c 0.0000001; // true BigInt 要精确表示比253还大的整数，可以使用内置的BigInt类型，它的表示方法是在整数后加一个n，例如9223372036854775808n，也可以使用BigInt()把Number和字符串转换成BigInt： var bi1 = 9223372036854775807n; var bi2 = BigInt(12345); var bi3 = BigInt(\"0x7fffffffffffffff\"); console.log(bi1 === bi2); // false console.log(bi1 === bi3); // true console.log(bi1 + bi2); false true 9223372036854788152 null和undefined null表示一个“空”的值，它和0以及空字符串''不同，0是一个数值，''表示长度为0的字符串，而null表示“空”。 在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 true or false JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true for(var i in arr) for(var i of arr) var inArray = ['a','dfg','sdvfd','ryt','234']; for(var i in inArray){ console.log(i); console.log(inArray[i]); } 0 a 1 dfg 2 sdvfd 3 ryt 4 234 var inArray = ['a','dfg','sdvfd','ryt','234']; for(var i of inArray){ console.log(i); } a dfg sdvfd ryt 234 函数 函数的定义 function abs(x) { if (x \u003e= 0) { return x; } else { return -x; } } 由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。 var abs = function (x) { if (x \u003e= 0) { return x; } else { return -x; } }; 在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。 上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 function foo(x) { console.log('x = ' + x); // 10 for (var i=0; i\u003carguments.length; i++) { console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30 } } foo(10, 20, 30); // x = 10 arg 0 = 10 arg 1 = 20 arg 2 = 30 rest参数 由于JavaScript函数允许接收任意个参数，于是我们就不得不用arguments来获取所有参数： function foo(a, b) { var i, rest = []; if (arguments.length \u003e 2) { for (i = 2; i\u003carguments.length; i++) { rest.push(arguments[i]); } } console.log('a = ' + a); console.log('b = ' + b); console.log(rest); } 为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？ ES6标准引入了rest参数，上面的函数可以改写为： function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest); } foo(1, 2, 3, 4, 5); // 结果: // a = 1 // b = 2 // Array [ 3, 4, 5 ] foo(1); // 结果: // a = 1 // b = undefined // Array [] rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。 因为rest参数是ES6新标准，所以你需要测试一下浏览器是否支持。 变量提升 JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部： 'use strict'; function foo() { var x = 'Hello, ' + y; console.log(x); var y = 'Bob'; } foo(); 虽然是strict模式，但语句var x = 'Hello, ' + y;并不报错，原因是变量y在稍后申明了。但是console.log显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。 对于上述foo()函数，JavaScript引擎看到的代码相当于： function foo() { var y; // 提升变量y的申明，此时y为undefined var x = 'Hello, ' + y; console.log(x); y = 'Bob'; } 由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量。 全局作用域 不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性： 'use strict'; var course = 'Learn JavaScript'; alert(course); // 'Learn JavaScript' alert(window.course); // 'Learn JavaScript' 因此，直接访问全局变量course和访问window.course是完全一样的。 你可能猜到了，由于函数定义有两种方式，以变量方式var foo = function () {}定义的函数实际上也是一个全局变量，因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象： 'use strict'; function foo() { alert('foo'); } foo(); // 直接调用foo() window.foo(); // 通过window.foo()调用 名字空间 全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如： // 唯一的全局变量MYA","date":"2023-12-25","objectID":"/javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%82%B9/:0:1","tags":[],"title":"JavaScript基础语法","uri":"/javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%82%B9/"},{"categories":["运维"],"content":"基础操作设置 修改name,code同步修改，操作不便 版本在16.6之下 工具栏 Tools -\u003e 常规选项 general Options -\u003e Dialog 下 Name to Code mirroring 取消勾选 版本是16.6以及之上 工具栏 Tools -\u003e 常规选项 general Options -\u003e Respository 下 Display 取消 Name to Code mirroring 勾选 工具栏 Tools -\u003e Modeal Options -\u003e Naming Convention -\u003e Synchronize code ","date":"2023-12-21","objectID":"/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/:0:1","tags":["PDM"],"title":"SQL生成PDM文件","uri":"/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/"},{"categories":["运维"],"content":"SQL逆向生成PDM 第一步：File \u003e Reverse Engineer \u003e Database 第二步：设置DBMS参数 第三步：选择sql文件 ","date":"2023-12-21","objectID":"/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/:0:2","tags":["PDM"],"title":"SQL生成PDM文件","uri":"/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/"},{"categories":["运维"],"content":"生成的PDM将coments同步至name字段 Open PDM–Tools–Execute Commands–Run Script 脚本语法参考 Microsoft VBScript 脚本语法 脚本1 Option Explicit ValidationMode = True InteractiveMode = im_Batch Dim mdl Set mdl = ActiveModel If (mdl Is Nothing) Then MsgBox \"There is no current Model\" ElseIf Not mdl.IsKindOf(PdPDM.cls_Model) Then MsgBox \"The current model is not an Physical Data model.\" Else ProcessFolder mdl End If Private sub ProcessFolder(folder) Dim Tab for each Tab in folder.tables if not tab.isShortcut then tab.name=tab.comment Dim col for each col in tab.columns col.name=col.comment next end if next end sub 脚本2 '------------------------------------------------------------ ' '脚本功能： ' PowerDesigner中****完成后，将数据库中comment脚本 ' 赋值到PDM的name '执行方法： ' Open PDM--Tools--Execute Commands--Run Script ' '------------------------------------------------------------ Option Explicit ValidationMode = True InteractiveMode = im_Batch Dim mdl 'the current model 'get the current active model Set mdl = ActiveModel If (mdl Is Nothing) Then MsgBox \"There is no current Model\" ElseIf Not mdl.IsKindOf(PdPDM.cls_Model) Then MsgBox \"The current model is not an Physical Data model.\" Else ProcessFolder mdl End If '------------------------------------------------------------ 'This routine copy name into code for each table, each column 'and each view of the current folder '------------------------------------------------------------ Private sub ProcessFolder(folder) Dim Tab 'running table for each Tab in folder.tables if not tab.isShortcut then if len(tab.comment) \u003c\u003e 0 then tab.name = tab.comment end if On Error Resume Next Dim col 'running column Dim b for each col in tab.columns b = Split(col.comment,\";\") if len(b(0)) \u003c\u003e0 then col.name = b(0) end if if ubound(b) \u003e0 then col.comment = b(1) else col.comment = \"\" end if On Error Resume Next next end if next end sub '------------------------------------------------------------ kingdee脚本 '------------------------------------------------------------ ' '脚本功能： ' PowerDesigner中****完成后，将数据库中comment脚本 ' 赋值到PDM的name '执行方法： ' Open PDM--Tools--Execute Commands--Run Script ' '------------------------------------------------------------ Option Explicit ValidationMode = True InteractiveMode = im_Batch Dim mdl 'the current model 'get the current active model Set mdl = ActiveModel If (mdl Is Nothing) Then MsgBox \"There is no current Model\" ElseIf Not mdl.IsKindOf(PdPDM.cls_Model) Then MsgBox \"The current model is not an Physical Data model.\" Else ProcessFolder mdl End If '------------------------------------------------------------ 'This routine copy name into code for each table, each column 'and each view of the current folder '------------------------------------------------------------ Private sub ProcessFolder(folder) Dim Tab 'running table for each Tab in folder.tables if not tab.isShortcut then if len(tab.comment) \u003c\u003e 0 then tab.name = tab.comment end if On Error Resume Next Dim col 'running column Dim b Dim dataType for each col in tab.columns b = Split(col.comment,\";\") if len(b(0)) \u003c\u003e0 then col.name = b(0) end if if ubound(b) \u003e0 then col.comment = b(1) else col.comment = \"\" end if dataType = col.DataType if InStr(dataType,\"bpchar(1)\") then col.DataType = \"char(1)\" col.DefaultValue = \"''\" col.Mandatory = true elseif InStr(dataType,\"timestamp\") then col.DataType = \"datetime\" col.Mandatory = false elseif InStr(dataType,\"int8\") then col.DataType = \"bigint\" col.DefaultValue = 0 col.Mandatory = true elseif InStr(dataType,\"varchar\") then col.DefaultValue = \"''\" col.Mandatory = true end if On Error Resume Next next end if next end sub '------------------------------------------------------------ ","date":"2023-12-21","objectID":"/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/:0:3","tags":["PDM"],"title":"SQL生成PDM文件","uri":"/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/"},{"categories":["Java后端"],"content":"Nashorn探索背景 ​ 通过合理的设计，将应用程序中所有动态变量都配置化，可以最大程度上让程序变得灵活。而灵活的配置，既可以减少开发成本，又能提高交付的效率。 提到业务规则的可配置化技术，自然是首推规则引擎了，像drools，easy rule 都是比较优秀的开源规则引擎，他们可以通过特定的语法，将if esle等判断逻辑从代码中独立出来，甚至可以热更新规则，非常的成熟好用。 ​ 只不过，有些时候，我们可能并不需要规则引擎的所有完整的功能，也不想引入一堆依赖的包，我们只是想要做一些简单的逻辑配置工作，这个时候，Nashorn脚本引擎就可以纳入考虑的范围了。 ","date":"2023-11-23","objectID":"/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:1","tags":["Nashorn脚本"],"title":"Nashorn脚本引擎框架","uri":"/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"Nashorn简介 ​ Nashorn 最初是在 JDK 8 中引入的，用于取代 Rhino 脚本引擎。当其发布时，Nashorn 是 ECMAScript-262 5.1 的完整实现，增强了 Java 和 JavaScript 的兼容性。 ​ 借助 Nashorn，开发人员可以从 JavaScript 调用 Java 代码，也可以从 Java 代码调用 JavaScript 函数。Nashorn 可以作为 Java 应用程序的嵌入式解释器，提供使用 Nashorn 命令行工具 jjs 从命令行运行 JavaScript 的能力。当在 Java 中对 JavaScript 代码求值时，Nashorn 实现了javax.script API。 ","date":"2023-11-23","objectID":"/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:2","tags":["Nashorn脚本"],"title":"Nashorn脚本引擎框架","uri":"/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"Nashorn语法一览： ​ Nashorn使用的都是原生的java和js语法，并没有什么上手门槛，需要注意的是，js语法并不支持ES6。下面我们简单的看一下如何使用它。 hello js in JVM ​ Nashorn是JDK中自带的包，并不需要引入额外的依赖，只不过要jdk1.8的版本才支持。它通过在JVM上以原生方式运行动态JavaScript代码的方式来扩展java的功能。 首先，我们来感受一下在jvm运行js的骚操作： ScriptEngine scriptEngine = new ScriptEngineManager().getEngineByName(\"nashorn\"); scriptEngine.eval(\"print('hello js in jvm')\"); ​ 这里可以直接写js代码，也可以读取特定的文件中的js代码，也就是说，这里的js脚本，我们是可以在前端灵活配置的，这样就达到了我们随心所欲配置规则的目的了。 在JVM在中调用js函数 Nashorn支持调用js的函数，我们先在脚本中定义函数，再到JVM var sayHi = function(name) { print('hello js,my name is ' + name); return \"result from js\"; }; 调用方法： ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\"); engine.eval(new FileReader(\"script.js\")); Invocable invocable = (Invocable) engine; Object result = invocable.invokeFunction(\"sayHi\", \"JAVA\"); System.out.println(result); //此处为调用控制台返回值： //hello js,my name is JAVA //result from js 在js中调用java 反过来，也可以在js中调用java的方法也很简单： 先定义静态方法 static String sayHiByJava(String name) { System.out.format(\"hello java,my name is %s\", name); return \"result from java\"; } 注意，调用时，需要先使用Java.type引入java class，类似于java中import var MyJavaClass = Java.type('com.lx.soil.demos.leetcode.Solution'); var result = MyJavaClass.sayHiByJava('js'); print(result); //此处为调用控制台返回值： //hello java,my name is js //result from java ","date":"2023-11-23","objectID":"/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:3","tags":["Nashorn脚本"],"title":"Nashorn脚本引擎框架","uri":"/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"使用Nashorn的几种安全机制： 既然是可以支持动态传入脚本来运行js代码，而且可以调用java中的类，那么安全问题就是我们所必须要注意的了，在安心使用Nashorn前，下面两个点是必须要解决的： 首先是防止任意代码执行的漏洞 防止代码有逻辑错误死循环导致占用大量资源 好在，现在有两个比较靠谱的方案来解决这些问题： 使用ClassFilter限制js引擎可以访问的类 1.在jdk1.8中引入了ClassFilter来限制可以访问的类，只要限制了可以访问的类，那么代码任意执行的漏洞就可以解决了，但是这个还不完美，因为还有第二个问题没解决。 import javax.script.ScriptEngine; import jdk.nashorn.api.scripting.ClassFilter; import jdk.nashorn.api.scripting.NashornScriptEngineFactory; public class MyClassFilterTest { class MyCF implements ClassFilter { @Override public boolean exposeToScripts(String s) { if (s.compareTo(\"java.io.File\") == 0) return false; return true; } } public void testClassFilter() { final String script = \"print(java.lang.System.getProperty(\\\"java.home\\\"));\" + \"print(\\\"Create file variable\\\");\" + \"var File = Java.type(\\\"java.io.File\\\");\"; NashornScriptEngineFactory factory = new NashornScriptEngineFactory(); ScriptEngine engine = factory.getScriptEngine( new MyClassFilterTest.MyCF()); try { engine.eval(script); } catch (Exception e) { System.out.println(\"Exception caught: \" + e.toString()); } } public static void main(String[] args) { MyClassFilterTest myApp = new MyClassFilterTest(); myApp.testClassFilter(); } } 执行完则会报错： C:\\Java\\jre8 Create file variable Exception caught: java.lang.RuntimeException: java.lang.ClassNotFoundException: java.io.File Nashorn沙箱 事实上，Nashorn本身就考虑了安全问题，实现了一套沙箱机制(SandBox),用法如下： NashornSandbox sandbox = NashornSandboxes.create(); sandbox.allow(File.class); sandbox.eval(\"var File = Java.type('java.io.File'); File;\") 限制nashorn引擎的资源使用也有考虑： NashornSandbox sandbox = NashornSandboxes.create(); sandbox.setMaxCPUTime(100); sandbox.setMaxMemory(50*1024); sandbox.allowNoBraces(false); sandbox.setMaxPreparedStatements(30); // because preparing scripts for execution is expensive sandbox.setExecutor(Executors.newSingleThreadExecutor()); sandbox.eval(\"var o={}, i=0; while (true) {o[i++]='abc';};\"); ","date":"2023-11-23","objectID":"/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:4","tags":["Nashorn脚本"],"title":"Nashorn脚本引擎框架","uri":"/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"Nashorn沙箱的实现原理浅析： java应用程序本身就是自带沙箱的，只不过一般都没有被启用，要启用沙箱，在启动的命令行要加如下参数： java -Djava.security.manager \u003cother args\u003e 沙箱启动后，安全管理器会使用两个默认的策略文件来确定沙箱启动参数。当然也可以通过命令指定： java -Djava.security.policy=\u003cURL\u003e 如果要求启动时只遵循一个策略文件，那么启动参数要加个等号，如下： java -Djava.security.policy==\u003cURL\u003e 关于java的安全沙箱，这里有一篇比较完整的介绍文章，有兴趣的同学可以看看。 java安全沙箱 写在最后 本来Nashorn是有计划支持ES6的，但是由于对ES6的支持太过困难，导致oracle放弃了这一想法（手动表示遗憾。。。），甚至打算弃用Nashorn，所以最后在我的项目中并没有使用Nashorn引擎，而是选用了抽象的方式去迂回实现我所需要的功能，但是，Nashorn确实给我提供了一种思路，一种能让我在终极可配置化的道路上走的更远的思路，一种能让我离\"write once， run forevre\"的终极目标更近一小步的思路。 ","date":"2023-11-23","objectID":"/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:5","tags":["Nashorn脚本"],"title":"Nashorn脚本引擎框架","uri":"/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"一:Rhino简介 Rhino是一个完全以Java编写的JavaScript引擎，目前由Mozilla基金会所管理。Rhino项目开始于1997年，当时，Netscape计划开发Java版本的Netscape Navigator，虽然该计划最终被放弃，但是Rhino引擎被遗留了下来。1998年4月，Mozilla基金会宣布开放源代码.引擎的命名源自于欧莱礼所出版的《JavaScript: The Definitive Guide》一书的封面动物.Rhino作为JDK脚本引擎对JavaScript支持部分包含到甲骨文JDK 1.6中，但将被Nashorn继承取代包含到OpenJDK 1.8中. ","date":"2023-11-02","objectID":"/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:1","tags":["Rhino脚本"],"title":"Rhino脚本引擎框架","uri":"/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"二:Rhino资料 下载地址: https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino/Download_Rhino 官网文档资料: https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino http://mozilla.github.io/rhino/javadoc/index.html 版本选用的版本: rhino1.7.6 JavaScript 引擎概念: “JavaScript 引擎”通常被称作一种 虚拟机。“虚拟机”是指软件驱动的给定的计算机系统的模拟器。有很多类型的虚拟机，它们根据自己在多大程度上精确地模拟或代替真实的物理机器来分类。例如，“系统虚拟机”提供了一个可以运行操作系统的完整仿真平台。Mac 用户很熟悉的 Parallels 就是一个允许你在 Mac 上运行 Windows系统虚拟机。另一方面，“进程虚拟机”不具备全部的功能，能运行一个程序或者进程。Wine 是一个允许你在 Linux 机器上运行 Windows 应用的进程虚拟机，但是并不在 Linux 中提供完整的 Windows 操作系统。JavaScript 虚拟机是一种进程虚拟机，专门设计来解释和执行的 JavaScript 代码。 ","date":"2023-11-02","objectID":"/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:2","tags":["Rhino脚本"],"title":"Rhino脚本引擎框架","uri":"/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"三:主要解决的问题 本文档主要介绍的Rhino的基本使,重点在介绍JavasScrip在Java中的嵌入开发时Java和JavaScript之间的相互调用. ","date":"2023-11-02","objectID":"/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:3","tags":["Rhino脚本"],"title":"Rhino脚本引擎框架","uri":"/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"四:Rhino的基本使用 1.引入 Rhino JavaScript 工具包 由于Rhino作为JDK脚本引擎对JavaScript支持部分包含到甲骨文JDK 1.6中,所以在JDK1.6及以上版本不需要单独的引入Jar包. JDK1.6以下版本需要引入以下jar包: js.jar 2.构造 JavaScript 的运行环境 Context对象中储存了脚本执行的全局环境信息. Context cx = Context.enter() 3.初始化标准对象 scope 变量类似于构造了一个全局对象，而在整个运行过程中 JavaScript 的变量都会作为该对象的一部分. Scriptable scope = cx.initStandardObjects(); 4.执行 JavaScript 脚本 执行脚本字符串 string，当脚本中需要使用其它变量时，会在作用域 scope 中寻找所需要的变量，如果发生异常的话则会报告 error 错误信息和所在的行号 num，正确执行结束后会返回一个 Object 对象的运行结果。如果脚本字符串中没有需要执行的表达式则会返回undefined. Object result = cx.evaluateString(scope, string, error, num, null); 静态方法Context.toString(Object result)返回该对象在JavaScript中的值. public final Object evaluateString(Scriptable scope, String source,String sourceName, int lineno, Object securityDomain) 参数解释: Scope : 运行的作用域,运行js时会在作用域 scope 中寻找所需要的变量. Source: 待运行的JS脚本字符串. SourceName: 定义源码的名称,出错的时候方便定位,可以为null. Lineno: 发生错误时显示的行号. securityDomain: 一个指定安全性的任意对象,如果不关心线程安全是,可以为null值. 5.结束上下文 结束上下文是每次使用 Rhino 结束后必须要做的工作，它将移除上下文和当前的线程并做垃圾回收。在每次进入上下文后都应该调用静态方法Context.exit()退出，因为在使用过程中可能会产生异常，所以通常在调用 Context.enter() 进入上下文之后，将退出操作放入对应的 finally 块中. Context.exit(); 6.在Java代码中加载外部JS文件 在Java代码中加载外部JS文件,有两种方式,Context实例提供两个方法: 方式一: public static void testLoadJSFile() { Context context = Context.enter(); LineNumberReader reader = null; try { Scriptable scope = context.initStandardObjects(); String filename = System.getProperty(\"user.dir\") + File.separator + \"testLoadJs.js\"; reader = new LineNumberReader(new FileReader(filename)); String temp = null; StringBuffer sb = new StringBuffer(); while ((temp = reader.readLine()) != null) { sb.append(temp).append(\"\\n\"); } context.evaluateString(scope, sb.toString(), null, 1, null); Object result = context.evaluateString(scope, \"countNumber(10010);\", \"mysource\", 1, null); System.out.println(Context.toString(result)); } catch (Exception e) { e.printStackTrace(); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } Context.exit(); } } 方式二: public static void testLoadJSFile2() { Context context = Context.enter(); FileReader fileReader = null; try { Scriptable scope = context.initStandardObjects(); String filename = System.getProperty(\"user.dir\") + File.separator + \"testLoadJs.js\"; fileReader = new FileReader(filename); context.evaluateReader(scope, fileReader, null, 1, null); Object result = context.evaluateString(scope, \"countNumber(10010);\", \"mysource\", 1, null); System.out.println(Context.toString(result)); } catch (Exception e) { e.printStackTrace(); } finally { if (fileReader != null) { try { fileReader.close(); } catch (IOException e) { e.printStackTrace(); } } Context.exit(); } } ","date":"2023-11-02","objectID":"/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:4","tags":["Rhino脚本"],"title":"Rhino脚本引擎框架","uri":"/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"五:Java 和 JavaScript 对象相互调用 1.在JavaScrip中调用Java对象 A.在JS调用Java对象(在JS代码中声明Java对象) public static void testCallJavaInScript() { Context context = Context.enter(); Scriptable scope = context.initStandardObjects(); try { context.evaluateString(scope, \"java.lang.System.out.println('你好Yves!');\", null, 1, null); } catch (Exception e) { e.printStackTrace(); } finally { Context.exit(); } } B.在JS调用Java对象(在java代码中声明Java对象) public static void testCallJavaInScript2() { Context context = Context.enter(); Scriptable scope = context.initStandardObjects(); // 1.将java对象放置JS的作用域中 Student students = new Student(); students.setAge(23); students.setName(\"Yves\"); Object jsObj = Context.javaToJS(students, scope); ScriptableObject.putProperty(scope, \"student\", jsObj); // 2.在JS中调用放置在JS作用域中的Java对象. try { Object result1 = context.evaluateString(scope, \"student.showInfo()\", null, 1, null); Object result2 = context.evaluateString(scope, \"student.showInfo('study')\", null, 1, null); System.out.println(Context.toString(result1)); System.out.println(Context.toString(result2)); } catch (Exception e) { e.printStackTrace(); } finally { Context.exit(); } } 2.在Java中调用JavaScript脚本 在 Java 中若要取得 JavaScript 脚本的运行结果非常的简单. evaluateReader(Scriptable scope, Reader in,String sourceName, int lineno,Object securityDomain); evaluateString(Scriptable scope, String source,String sourceName, int lineno,Object securityDomain); 这两个方法返回的结果都是JavaScript 脚本运行后的结果,如果没有运行的脚本,则返回的是undefined; 有时候在项目开发中我们或许常常会希望获得一些额外的信息，比如运行过程中的一些临时信息，无法作为最终结果返回时下面就是获取运行时的一些临时信息的方式: A.在 Java 中调用 JavaScript 脚本中的变量 public static void testCallScriptInJava() { Context context = Context.enter(); try { Scriptable scope = context.initStandardObjects(); String jsStr = \"var name = 'Yves';\"; context.evaluateString(scope, jsStr, null, 1, null); Object jsObject = scope.get(\"name\", scope); if (jsObject == Scriptable.NOT_FOUND) { System.out.println(\"name is not defined.\"); } else { System.out.println(\"name is \" + Context.toString(jsObject)); } } catch (Exception e) { } finally { Context.exit(); } } B.在Java中调用Script中的函数 public static void testCallScriptInJava2() { Context context = Context.enter(); try { Scriptable scope = context.initStandardObjects(); String jsStr = \"function showHello(name) {return 'hello ' + name +'!';}\"; context.evaluateString(scope, jsStr, null, 1, null); Object functionObject = scope.get(\"showHello\", scope); if (!(functionObject instanceof Function)) { System.out.println(\"showHello is undefined or not a function.\"); } else { Object args[] = { \"Yves\" }; Function test = (Function) functionObject; Object result = test.call(context, scope, scope, args); System.out.println(Context.toString(result)); } } catch (Exception e) { } finally { Context.exit(); } } ","date":"2023-11-02","objectID":"/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:5","tags":["Rhino脚本"],"title":"Rhino脚本引擎框架","uri":"/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Git"],"content":"使用 Git 作为代码版本管理，早已是现在开发工程师必备的技能。可大多数工程师还是只会最基本的保存、拉取、推送，遇到一些commit管理的问题就束手无策，或者用一些不优雅的方式解决。 本文分享我在开发工作中实践过的实用命令。这些都能够大大提高工作效率，还能解决不少疑难场景。下面会介绍命令，列出应用场景，手摸手教学使用，让同学们看完即学会。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:0:0","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"stash ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:1:0","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"描述 官方解释：当您想记录工作目录和索引的当前状态，但又想返回一个干净的工作目录时，请使用git stash。该命令将保存本地修改，并恢复工作目录以匹配头部提交。 stash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:1:1","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"应用场景 我猜你心里一定在想：为什么要变干净？ 应用场景：某一天你正在 feature 分支开发新需求，突然产品经理跑过来说线上有bug，必须马上修复。而此时你的功能开发到一半，于是你急忙想切到 master 分支，然后你就会看到以下报错： 因为当前有文件更改了，需要提交commit保持工作区干净才能切分支。由于情况紧急，你只有急忙 commit 上去，commit 信息也随便写了个“暂存代码”，于是该分支提交记录就留了一条黑历史…(真人真事，看过这种提交) ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:1:2","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"命令使用 如果你学会 stash，就不用那么狼狈了。你只需要： git stash 就这么简单，代码就被存起来了。 当你修复完线上问题，切回 feature 分支，想恢复代码也只需要： git stash apply ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:1:3","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"相关命令 # 保存当前未commit的代码 git stash # 保存当前未commit的代码并添加备注 git stash save \"备注的内容\" # 列出stash的所有记录 git stash list # 删除stash的所有记录 git stash clear # 应用最近一次的stash git stash apply # 应用最近一次的stash，随后删除该记录 git stash pop # 删除最近的一次stash git stash drop 当有多条 stash，可以指定操作stash，首先使用stash list 列出所有记录： $ git stash list stash@{0}: WIP on ... stash@{1}: WIP on ... stash@{2}: On ... 应用第二条记录： $ git stash apply stash@{1} pop，drop 同理。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:1:4","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"vscode 集成 stash 代码 填写备注内容，也可以不填直接Enter 在STASHES菜单中可以看到保存的stash 先点击stash记录旁的小箭头，再点击 apply 或者 pop 都可恢复 stash ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:1:5","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"reset –soft ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:2:0","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"描述 完全不接触索引文件或工作树（但会像所有模式一样，将头部重置为）。这使您的所有更改的文件更改为“要提交的更改”。 回退你已提交的 commit，并将 commit 的修改内容放回到暂存区。 一般我们在使用 reset 命令时，git reset --hard会被提及的比较多，它能让 commit 记录强制回溯到某一个节点。而git reset --soft的作用正如其名，--soft(柔软的) 除了回溯节点外，还会保留节点的修改内容。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:2:1","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"应用场景 回溯节点，为什么要保留修改内容？ 应用场景1：有时候手滑不小心把不该提交的内容 commit 了，这时想改回来，只能再 commit 一次，又多一条“黑历史”。 应用场景2：规范些的团队，一般对于 commit 的内容要求职责明确，颗粒度要细，便于后续出现问题排查。本来属于两块不同功能的修改，一起 commit 上去，这种就属于不规范。这次恰好又手滑了，一次性 commit 上去。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:2:2","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"命令使用 学会reset --soft之后，你只需要： # 恢复最近一次 commit git reset --soft HEAD^ reset --soft相当于后悔药，给你重新改过的机会。对于上面的场景，就可以再次修改重新提交，保持干净的 commit 记录。 以上说的是还未 push 的commit。对于已经 push 的 commit，也可以使用该命令，不过再次 push 时，由于远程分支和本地分支有差异，需要强制推送git push -f来覆盖被 reset 的 commit。 还有一点需要注意，在reset --soft指定 commit 号时，会将该 commit 到最近一次 commit 的所有修改内容全部恢复，而不是只针对该 commit。 举个例子： commit 记录有 c、b、a。 reset 到 a。 git reset --soft 1a900ac29eba73ce817bf959f82ffcb0bfa38f75 此时的 HEAD 到了 a，而 b、c 的修改内容都回到了暂存区。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:2:3","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"cherry-pick ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:3:0","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"描述 给定一个或多个现有提交，应用每个提交引入的更改，为每个提交记录一个新的提交。这需要您的工作树清洁（没有从头提交的修改）。 将已经提交的 commit，复制出新的 commit 应用到分支里 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:3:1","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"应用场景 commit 都提交了，为什么还要复制新的出来？ 应用场景1：有时候版本的一些优化需求开发到一半，可能其中某一个开发完的需求要临时上，或者某些原因导致待开发的需求卡住了已开发完成的需求上线。这时候就需要把 commit 抽出来，单独处理。 应用场景2：有时候开发分支中的代码记录被污染了，导致开发分支合到线上分支有问题，这时就需要拉一条干净的开发分支，再从旧的开发分支中，把 commit 复制到新分支。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:3:2","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"命令使用 复制单个 现在有一条feature分支，commit 记录如下： 需要把 b 复制到另一个分支，首先把 commitHash 复制下来，然后切到 master 分支。 当前 master 最新的记录是 a，使用cherry-pick把 b 应用到当前分支。 完成后看下最新的 log，b 已经应用到 master，作为最新的 commit 了。可以看到 commitHash 和之前的不一样，但是提交时间还是保留之前的。 复制多个 以上是单个 commit 的复制，下面再来看看 cherry-pick 多个 commit 要如何操作。 一次转移多个提交： git cherry-pick commit1 commit2 上面的命令将 commit1 和 commit2 两个提交应用到当前分支。 多个连续的commit，也可区间复制： git cherry-pick commit1^..commit2 上面的命令将 commit1 到 commit2 这个区间的 commit 都应用到当前分支（包含commit1、commit2），commit1 是最早的提交。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:3:3","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"cherry-pick 代码冲突 在cherry-pick多个commit时，可能会遇到代码冲突，这时cherry-pick会停下来，让用户决定如何继续操作。下面看看怎么解决这种场景。 还是 feature 分支，现在需要把 c、d、e 都复制到 master 分支上。先把起点c和终点e的 commitHash 记下来。 切到 master 分支，使用区间的cherry-pick。可以看到 c 被成功复制，当进行到 d 时，发现代码冲突，cherry-pick中断了。这时需要解决代码冲突，重新提交到暂存区。 然后使用cherry-pick --continue让cherry-pick继续进行下去。最后 e 也被复制进来，整个流程就完成了。 以上是完整的流程，但有时候可能需要在代码冲突后，放弃或者退出流程： 放弃 cherry-pick： git cherry-pick --abort 回到操作前的样子，就像什么都没发生过。 退出 cherry-pick： git cherry-pick --quit 不回到操作前的样子。即保留已经cherry-pick成功的 commit，并退出cherry-pick流程。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:3:4","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"revert ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:4:0","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"描述 给定一个或多个现有提交，恢复相关提交引入的更改，并记录一些这些更改的新提交。这就要求你的工作树是干净的（没有来自头部的修改）。 将现有的提交还原，恢复提交的内容，并生成一条还原记录。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:4:1","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"应用场景 应用场景：有一天测试突然跟你说，你开发上线的功能有问题，需要马上撤回，否则会影响到系统使用。这时可能会想到用 reset 回退，可是你看了看分支上最新的提交还有其他同事的代码，用 reset 会把这部分代码也撤回了。由于情况紧急，又想不到好方法，还是任性的使用 reset，然后再让同事把他的代码合一遍（同事听到想打人），于是你的技术形象在同事眼里一落千丈。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:4:2","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"命令使用 revert 普通提交 学会 revert 之后，立马就可以拯救这种尴尬的情况。 现在 master 记录如下： git revert 21dcd937fe555f58841b17466a99118deb489212 revert 掉自己提交的 commit。 因为 revert 会生成一条新的提交记录，这时会让你编辑提交信息，编辑完后 :wq 保存退出就好了。 再来看下最新的 log，生成了一条 revert 记录，虽然自己之前的提交记录还是会保留着，但你修改的代码内容已经被撤回了。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:4:3","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"revert 合并提交 在 git 的 commit 记录里，还有一种类型是合并提交，想要 revert 合并提交，使用上会有些不一样。 现在的 master 分支里多了条合并提交。 使用刚刚同样的 revert 方法，会发现命令行报错了。为什么会这样？在官方文档中有解释。 通常无法 revert 合并，因为您不知道合并的哪一侧应被视为主线。此选项指定主线的父编号（从1开始），并允许 revert 反转相对于指定父编号的更改 我的理解是因为合并提交是两条分支的交集节点，而 git 不知道需要撤销的哪一条分支，需要添加参数 -m 指定主线分支，保留主线分支的代码，另一条则被撤销。 -m 后面要跟一个 parent number 标识出\"主线\"，一般使用 1 保留主分支代码。 git revert -m 1 \u003ccommitHash\u003e ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:4:4","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"revert 合并提交后，再次合并分支会失效 还是上面的场景，在 master 分支 revert 合并提交后，然后切到 feature 分支修复好 bug，再合并到 master 分支时，会发现之前被 revert 的修改内容没有重新合并进来。 因为使用 revert 后， feature 分支的 commit 还是会保留在 master 分支的记录中，当你再次合并进去时，git 判断有相同的 commitHash，就忽略了相关 commit 修改的内容。 这时就需要 revert 掉之前 revert 的合并提交，有点拗口，接下来看操作吧。 现在 master 的记录是这样的。 再次使用 revert，之前被 revert 的修改内容就又回来了。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:4:5","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"reflog ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:5:0","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"描述 此命令管理重录中记录的信息。 如果说reset --soft是后悔药，那 reflog 就是强力后悔药。它记录了所有的 commit 操作记录，便于错误操作后找回记录。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:5:1","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"应用场景 应用场景：某天你眼花，发现自己在其他人分支提交了代码还推到远程分支，这时因为分支只有你的最新提交，就想着使用reset --hard，结果紧张不小心记错了 commitHash，reset 过头，把同事的 commit 搞没了。没办法，reset --hard是强制回退的，找不到 commitHash 了，只能让同事从本地分支再推一次（同事瞬间拳头就硬了，怎么又是你）。于是，你的技术形象又一落千丈。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:5:2","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"命令使用 分支记录如上，想要 reset 到 b。 误操作 reset 过头，b 没了，最新的只剩下 a。 这时用git reflog查看历史记录，把错误提交的那次 commitHash 记下。 再次 reset 回去，就会发现 b 回来了。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:5:3","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"设置 Git 短命令 对我这种喜欢敲命令而不用图形化工具的爱好者来说，设置短命令可以很好的提高效率。下面介绍两种设置短命令的方式。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:6:0","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"方式一 git config --global alias.ps push ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:6:1","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"方式二 打开全局配置文件 vim ~/.gitconfig 写入内容 [alias] co = checkout ps = push pl = pull mer = merge --no-ff cp = cherry-pick ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:6:2","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"使用 # 等同于 git cherry-pick \u003ccommitHash\u003e git cp \u003ccommitHash\u003e ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:6:3","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"总结 本文主要分享了5个在开发中实用的 Git 命令和设置短命令的方式。 stash：存储临时代码。 reset --soft：软回溯，回退 commit 的同时保留修改内容。 cherry-pick：复制 commit。 revert：撤销 commit 的修改内容。 reflog：记录了 commit 的历史操作。 ","date":"2023-10-27","objectID":"/git%E8%BF%9B%E9%98%B6/:7:0","tags":["Git进阶"],"title":"Git进阶","uri":"/git%E8%BF%9B%E9%98%B6/"},{"categories":["数据库\""],"content":"初识事务 ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:0:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"为什么需要事务？ 这里又要掏出那个烂大街的银行转账案例了，以A、B两个账户的转账为例，假设现在要从A账户向B账户中转入1000员，当进行转账时，需要先从银行账户A中取出钱，然后再存入银行账户B中，SQL样本如下： //第一步：A账户余额减少减少1000updatebalancesetmoney=money-500wherename=‘A’;//第二步：B账户余额增加1000updatebalancesetmoney=money+500wherename=‘B’; 如果在完成了第1步的时候突然宕机了，A的钱减少了而B的钱没有增加，那A岂不是白白丢了1000元，这时候就需要用到我们的事务了，开启事务后SQL样本如下： //第一步：开始事务starttransaction;//第二步：A账户余额减少减少1000updatebalancesetmoney=money-500wherename=‘A’;//第三步：B账户余额增加1000updatebalancesetmoney=money+500wherename=‘B’;//第四步：提交事务commit; ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:1:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"什么是事务 事务（Transaction）是访问和更新数据库的程序执行单元；事务中可能包含一个或多个sql语句，这些语句要么都执行成功，要么全部执行失败。 ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:2:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"事务的四大特性（ACID） 原子性（Atomicity，或称不可分割性） 「一个事务必须被视为一个不可分割的最小工作单元，整个事务中所有的操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性」 一致性（Consistency） 「数据库总是从一个一致性的状态转换到另外一个一致性的状态，在事务开始之前和之后，数据库的完整性约束没有被破坏。在前面的例子中，事务结束前后A、B账户总额始终保持不变」 隔离性（Isolation） 「隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。」 持久性（Durability） 「持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。」 ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:3:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"事务的隔离级别 在前文中我们介绍了隔离性，但实际上隔离性比想象的要复杂的多。在SQL标准中定义了四种隔离级别，每一种隔离级别都规定了一个事务所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的，较低级别的隔离通常可以执行跟高的并发，系统的开销也更低 ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:4:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"未提交读（READ UNCOMMITTED） 在这个隔离级别下，事务的修改即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，这也被称之为脏读。这个级别会带来很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但是却会带来很多问题，除非真的有非常必要的理由，在实际应用中一般很少使用。 ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:4:1","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"提交读（REDA COMMITED） 大多数数据系统的默认隔离级别都是REDA COMMITED（MySql不是），REDA COMMITED满足前面提到的隔离性的简单定义：一个事务开始时，只能看到已经提交的事务所做的修改。换句话说，一个事物从开始直到提交前，所做的修改对其他事务不可见。这个级别有时候也叫做不可重复读，因为执行两次相同的查询可能会得到不同的结果。 ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:4:2","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"可重复读（REPEATABLE READ） REPEATABLE READ解决了脏读以及不可重复度的问题。该级别保证了同一个事务多次读取同样记录的结果是一致的。但是理论上，可重复度还是无法解决另外一个幻读的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，就会产生幻行。 不可重复读跟幻读的区别在于，「前者是数据发生了变化，后者是数据的行数发生了变化」。 ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:4:3","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"可串行化（SERIALIZABLE） SERIALIZABLE是最高的隔离级别，它通过强制事务串行执行，避免前面说的幻读。简单来说SERIALIZABLE会在读取的每一行数据上都加锁，所以可能会导致大量的超时和锁争用的问题。实际应用中也很少使用这个隔离级别，只有在非常需要确保数据一致性而且可以接受没有并发的情况下，才考虑此级别。 ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:4:4","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"保存点 我们可以在事务执行的过程中定义保存点，在回滚时直接指定回滚到指定的保存点而不是事务开始之初，有点像我们玩游戏的时候可以存档而不是每次都要重新再来 定义保存点的语法如下： SAVEPOINT 保存点名称; 当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词WORK和SAVEPOINT是可有可无的）： ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称; MySQL中的事务跟原理 ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:5:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"MySQL中的事务 「MySQL中不是所有的存储引擎都支持事务」，例如MyISAM就不支持事务，实际上支持事务的只有InnoDB跟NDB Cluster，「本文关于事务的分析都是基于InnoDB」 「MySQL默认采用的是自动提交的方式」，也就是说如果不是显示的开始一个事务，则系统会自动向数据库提交结果。在当前连接中，还可以通过设置AUTOCONNIT变量来启用或者禁用自动提交模式。 开启自动提交功能 SET AUTOCOMMIT = 1; MySQL中默认情况下的自动提交功能是已经开启的。 关闭自动提交功能。 SET AUTOCOMMIT = 0; 关闭自动提交功能后，只用当执行COMMIT命令后，MySQL才将数据表中的资料提交到数据库中。如果执行ROLLBACK命令，数据将会被回滚。如果不提交事务，而终止MySQL会话，数据库将会自动执行回滚操作。 「MySQL的默认隔离级别是可重复读（REPEATABLE READ）」。 ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:6:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"事务的实现原理 我们要探究MySQL中事务的实现原理，实际上就是要弄明天它的ACID特性是如何实现的，在这里有必要先说明的是，「ACID中的一致性是事务的最终目标，前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性」。所以我们要分析的就是MySQL的原子性、持久性和隔离性的实现原理，在分析事务的实现原理之前我们需要补充一些InnoDB的相关知识 InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正**「处理数据的过程是发生在内存中的」，「所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上」。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，InnoDB采取的方式是：「将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 *16* KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。」** 我们还需要对MySQL中的日志有一定了解。MySQL的日志有很多种，如二进制日志（bin log）、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：「redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。」 InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了**「缓存(Buffer Pool)」，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：「当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。」** InnoDB存储引擎文件主要可以分为两类，表空间文件及重做日志文件（redo log file）,表空间文件又可以细分为两类，共享表空间跟独立表空间。「undo log位于共享表空间中的undo段中」，每个表空间都被划分成了若干个页面，「凡是页面的读写都在buffer pool中进行，这意味着undo log也需要先写入到buffer pool，所以undo log的生成也需要持久化，也就是说undo log的生成需要记录对应的redo log」。(注意：不是所有的undo log的生成都会产生对应的redo log，对于操作临时表生成的undo log并不会生成对应的undo log，因为修改临时表而产生的undo日志只需要在系统运行过程中有效，如果系统奔溃了，那么在重启时也不需要恢复这些undo日志所在的页面，所以在写针对临时表的Undo页面时，并不需要记录相应的redo日志。) ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:7:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"持久性实现原理 ​ 通过前面的补充知识我们知道InnoDB引入了Buffer Pool来优化读写的性能，但是虽然Buffer Pool优化了性能，但同时也带来了新的问题：「如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证」。 ​ 基于此，redo log就诞生了，「redo log是物理日志，记录的是数据库中数据库中物理页的情况」，redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。在概念上，innodb通过**「force log at commit」**机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。 ​ 看到这里可能有的小伙伴又会有疑问了，既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因： （1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。 （2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。 这里我以文章开头的例子进行说明redo log为何能保证持久性： //第一步：开始事务starttransaction;//第二步：A账户余额减少减少1000updatebalancesetmoney=money-500wherename=‘A’;//第三步：B账户余额增加1000updatebalancesetmoney=money+500wherename=‘B’;//第四步：提交事务commit; redo ❝ 这里需要对redo log的刷盘补充一点内容： MySQL支持用户自定义在commit时如何将log buffer中的日志刷log file中。这种控制通过变量 innodb_flush_log_at_trx_commit 的值来决定。该变量有3种值：0、1、2，「默认为1」。但注意，这个变量只是控制commit动作是否刷新log buffer到磁盘。 当设置为1的时候，事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()函数刷到log file on disk中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。 当设置为0的时候，事务提交时不会将log buffer中日志写入到os buffer（内核缓冲区），而是每秒写入os buffer并调用fsync()写入到log file on disk中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。 当设置为2的时候，每次提交都仅写入到os buffer，然后是每秒调用fsync()将os buffer中的日志写入到log file on disk。 「可以看到设置为0或者2时，都有可能丢失1s的数据」 ❞ ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:7:1","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"原子性实现原理 前面提到了，所谓原子性就是指整个事务是一个不可分隔的整体，组成事务的一组SQL要么全部成功，要么全部失败，要达到这个目的就意味着当某一个SQL执行失败时，我们要能够撤销掉其它SQL的执行结果，在MySQL中这是依赖undo log(回滚日志)来实现。 undo log属于**「逻辑日志」（前面提到的redo log属于物理日志，记录的是数据页的情况），我们可以这么认为，「当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。」** 但执行发生异常时，会根据undo log中的记录进行回滚。undo log主要分为两种 insert undo log update undo log 「insert undo log是指在insert 操作中产生的undo log」，因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。 「而update undo log记录的是对*delete 和update*操作产生的undo log」，该undo log可能需要提供MVCC机制，因此不能再事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。 ❝ 补充：purge线程两个主要作用是：清理undo页和清除page里面带有Delete_Bit标识的数据行。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种\"假删除\",只是做了个标记，真正的删除工作需要后台purge线程去完成。 ❞ 这里我们就来看看insert undo log的结构，如下： insert undo 在上图中，undo type记录的是undo log的类型，对于insert undo log，该值始终为11（TRX_UNDO_INSERT_REC），undo no在一个事务中是从0开始递增的，也就是说只要事务没提交，每生成一条undo日志，那么该条日志的undo no就增1。table id记录undo log所对应的表对象。如果记录中的主键只包含一个列，那么在类型为TRX_UNDO_INSERT_REC的undo日志中只需要把该列占用的存储空间大小和真实值记录下来，如果记录中的主键包含多个列（复合主键），那么每个列占用的存储空间大小和对应的真实值都需要记录下来（图中的len就代表列占用的存储空间大小，value就代表列的真实值），「在回滚时只需要根据主键找到对应的列然后删除即可」。end of record记录了下一条undo log在页面中开始的地址，start of record记录了本条undo log在页面中开始的地址。 对undo log有一定了解后，我们再回头看看文章开头的例子，分析下为什么undo log能保证原子性 // 第一步：开始事务 start transaction; // 第二步：A账户余额减少减少1000 update balance set money = money -500 where name= ‘A’; // 第三步：B账户余额增加1000 update balance set money = money +500 where name= ‘B’; // 第四步：提交事务 commit; undo redo 考虑到排版，这里我只画了一条语句的流程图，第二条也是一样的，每次更新或者插入前，先记录undo，再修改内存中数据，再记录redo。 ","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:7:2","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库\""],"content":"隔离性实现原理 我们知道，一个事务中的读操作是不会影响到另外一个事务的，所以在讨论隔离性我们主要分为两种情况 一个事务中的写操作，对另外一个事务中写操作的影响 一个事务中的写操作，对另外一个事务中读操作的影响 写操作之间的隔离是通过锁来实现的，MySQL中的锁机制要详细来讲是很复杂的，要讲明白整个锁需要从索引开始介绍，限于笔者能力及文章篇幅，本文只对MySQL中的锁机制做一个简单的介绍 MySQL中的锁机制（InnoDB） 读锁跟写锁 读锁又称为共享锁`，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，「都能访问到数据，但是只能读不能修改。」 写锁又称为排他锁`，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。 行锁跟表锁 表锁在操作数据时会锁定整张表，并发性能较差； 行锁则只锁定需要操作的数据，并发性能好。 但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。 意向锁 意向锁分为两种，意向读锁（IS）跟意向写锁（IX） 意向锁是表级别的锁 为什么需要意向锁呢？思考一个问题：如果我们想对某个表加一个表锁，那么在加锁之前我们需要去检查表中的每一行记录是否已经被单独加了行锁，这样的话岂不是意味着我们需要去遍历表中所有的记录依次进行检查，遍历是不可能的，这辈子都不可能遍历的，基于效率的考虑，我们可以在每次给行记录加锁时先给当前表加一个意向锁，如果我们要对行加读锁（S）的话，那么就先给表加一个意向读锁（IS），如果要对行加写锁（X）的话，那么先给表加一个意向写锁（IX），这样当我们需要给整个表加锁的时候就可以通过先判断表上是否已经存在了意向锁来决定是否可以上锁了，避免遍历，提高了效率。 意向锁跟普通的读锁写锁间的兼容性如下： IS IX S X IS 兼容 兼容 兼容 不兼容 IX 兼容 兼容 不兼容 不兼容 S 兼容 不兼容 兼容 不兼容 X 不兼容 不兼容 不兼容 不兼容 注：IS（意向读锁/意向共享锁）， IX（意向写锁/意向排他锁）， S（读锁/共享锁），X（写锁/排他锁） 从上图中可以看出，意向锁之间都是兼容的，这是因为意向锁的作用仅仅是来快速判断是否可以直接上表锁。 「接下来介绍的这几种锁都属于行锁」，为了更好的理解这几种锁，我们先创建一个表 CREATETABLE`user`(`id`int(11)NOTNULLAUTO_INCREMENT,`name`varchar(10)NOTNULL,PRIMARYKEY(`id`),)ENGINE=InnoDBAUTO_INCREMENT=7DEFAULTCHARSET=utf8; 其中id为主键，没有建其余的索引，插入如下数据 INSERTINTO`test`.`user`(`id`,`name`)VALUES(1,'a张大胆');INSERTINTO`test`.`user`(`id`,`name`)VALUES(3,'b王翠花');INSERTINTO`test`.`user`(`id`,`name`)VALUES(6,'c范统');INSERTINTO`test`.`user`(`id`,`name`)VALUES(8,'d朱逸群');INSERTINTO`test`.`user`(`id`,`name`)VALUES(15,'e董格求'); Record Lock（记录锁） 锁定单条记录 也分为S锁跟X锁 如果我们对id为3的记录添加一个行锁，对应如下（图中每一列代表数据库中的一行记录）： 行锁 Gap Lock（间隙锁） 锁定一个范围，但是不包含记录本身 间隙锁的主要作用在于防止幻读的发生，虽然也有S锁跟X锁的区分，但是它们的作用都是相同的，而且如果你对一条记录加了间隙锁（不论是共享间隙锁还是独占间隙锁），并不会限制其他事务对这条记录加记录锁或者继续加间隙锁，再强调一遍，间隙锁的作用仅仅是为了防止幻读的发生。 假设我们要对id为6的记录添加间隙锁，那么此时锁定的区域如下所示 其中虚线框代表的是要锁定的间隙，其实就是当前需要加间隙锁的记录跟上一条记录之间的范围，但是间隙锁不会锁定当前记录，如图所示，id=6的记录并没有被加锁。（图中虚线框表锁间隙，没有插入真实的记录） 间隙锁 Next-Key Lock（Gap Lock+Record Lock） 假设我们要对id为6的记录添加Next-Key Lock，那么此时锁定的区域如下所示 next key lock 跟间隙锁最大的区别在于，Next-Key Lock除了锁定间隙之外还要锁定当前记录 ❝ 通过锁实现了写、写操作之间的隔离性，实际上我们也可以通过加锁来实现读、写之间的隔离性，但是这样带来一个问题，读、写需要串行执行这样会大大降低效率，所以MySQL中实现读写之间的隔离性是通过MVCC+锁来实现的，对于读采用快照都，对于写使用加锁！ ❞ MVCC（多版本并发控制） 版本链 在介绍MVCC之前我们需要对MySQL中的行记录格式有一定了解，其实除了我们在数据库中定义的列之外，每一行中还包含了几个隐藏列，分别是 row_id：行记录的唯一标志 transaction_id：事务ID roll_pointer：回滚指针 「row_id是行记录的唯一标志，这一列不是必须的。」 MySQL会优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。也就是说只有在表中既没有定义主键，也没有申明唯一索引的情况MySQL才会添加这个隐藏列。 「transaction_id代表的是事务的ID」。当一个事务对某个表执行了增、删、改操作，那么InnoDB存储引擎就会给它分配一个独一无二的事务id，分配方式如下： 对于只读事务来说，只有在它第一次对某个用户创建的**「临时表执行增、删、改操作」**时才会为这个事务分配一个事务id，否则的话是不分配事务id的。 对于读写事务来说，只有在它**「第一次对某个表（包括用户创建的临时表）执行增、删、改操作」**时才会为这个事务分配一个事务id，否则的话也是不分配事务id的。 有的时候虽然我们开启了一个读写事务，但是在这个事务中全是查询语句，并没有执行增、删、改的语句，那也就意味着这个事务并不会被分配一个事务id。 「roll_pointer表示回滚指针，指向该记录对应的undo log」。前文已经提到过了，undo log记录了对应记录在修改前的状态，通过roll_pointer我们就可以找到对应的undo log，然后根据undo log进行回滚。 ❝ 在之前介绍undo log的时候我们只介绍了insert undo log的数据格式，实际上除了insert undo log还有update undo log，而update undo log中也包含roll_pointer跟transaction_id。update undo log中的roll_pointer指针其实就是保存的被更新的记录中的roll_pointer指针 ❞ 「除了这些隐藏列以外，实际上每条记录的记录头信息中还会存储一个标志位，标志该记录是否删除。」 我们以实际的例子来说明上面三个隐藏列的作用，还是以之前的表为例，现在对其执行如下SQL： #开启事务STARTTRANSACTION;#插入一条数据INSERTINTO`test`.`user`(`id`,`name`)VALUES(16,'e杜子騰');#更新插入的数据UPDATE`test`.`user`SETname=\"史珍香\"WHEREid=16;#删除数据DELETEfrom`test`.`user`WHEREid=16; 我们通过画图来看看上面这段SQL在执行的过程中都做了什么 SQL执行流程图 从上图中我们可以看到，每对记录进行一次增、删、改时，都会生成一条对应的undo log，并且被修改后的记录中的roll pointer指针指向了这条undo log，同时如果不是新增操作，那么生成的undo log中也会保存一个roll pointer，其值是从被修改的数据中复制过来了，在我们上边的例子中update undo log的roll pointer就复制了insert进去的数据中的roll pointer指针的值。 另外我们会发现，根据当前记录中的roll pointer指针，我们可以找到一个有undo log组成的链表，这个undo log链表其实就是这条记录的版本链。 ReadView（快照） 对于使用READ UNCOMMITTED隔离级别的事务来说，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了； 对于使用SERIALIZABLE隔离级别的事务来说，MySQL规定使用加锁的方式来访问记录； 对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是：「需要判断一下版本链中的哪个版本是当前","date":"2023-09-27","objectID":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:7:3","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["前端"],"content":"问题描述 部署WEB项目后，开启了强制HTTPS，产生如下错误： hubu8.github.io/:1 Mixed Content: The page at 'https://hubu8.github.io/friend/' was loaded over HTTPS, but requested an insecure image 'http://www.ruoyi.vip/images/ruoyi_vue.png'. This request has been blocked; the content must be served over HTTPS. ","date":"2023-09-13","objectID":"/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/:0:1","tags":["https"],"title":"https站点无法使用http资源","uri":"/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/"},{"categories":["前端"],"content":"问题分析 报错的原因就是当前页面是https协议加载的，但是这个页面发起了一个http的ajax请求，这种做法是非法的。HTTPS页面里动态的引入HTTP资源，比如引入一个js文件，会被直接block掉的.在HTTPS页面里通过AJAX的方式请求HTTP资源，也会被直接block掉的。 ","date":"2023-09-13","objectID":"/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/:0:2","tags":["https"],"title":"https站点无法使用http资源","uri":"/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/"},{"categories":["前端"],"content":"解决办法 可以在相应的页面的里加上这句代码，意思是自动将http的不安全请求升级为https \u003cmeta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\"\u003e ","date":"2023-09-13","objectID":"/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/:0:3","tags":["https"],"title":"https站点无法使用http资源","uri":"/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/"},{"categories":["Java后端"],"content":"1. 环境准备 ","date":"2023-09-13","objectID":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/:1:0","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/"},{"categories":["Java后端"],"content":"1.1 邮件服务 SpringBoot邮件服务的搭建流程为： 引入邮件服务依赖 配置邮件发送邮箱服务器、账户、密码等信息 使用SpringBoot内置javaMailSender工具实现邮件发送方法 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-mail\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-thymeleaf\u003c/artifactId\u003e \u003c/dependency\u003e spring.mail.host=smtp.163.com（host） spring.mail.username=邮箱地址 spring.mail.password=邮箱密码 spring.mail.port=25 spring.mail.default-encoding=UTF-8 spring.mail.properties.mail.smtp.socketFactoryClass=javax.net.ssl.SSLSocketFactory spring.mail.properties.mail.smtp.debug=true ","date":"2023-09-13","objectID":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/:1:1","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/"},{"categories":["Java后端"],"content":"1.2 Thymeleaf环境 Thymeleaf的使用流程可以简单概括为： 引入Thymeleaf依赖信息 配置文件中设置Thymeleaf基础属性 resource/templates下定义Thymeleaf使用的html文件 定义接口服务指向Thymeleaf模板文件，并将属性数据传参 Thymeleaf文件中使用相关语法展示后端传参内容 ","date":"2023-09-13","objectID":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/:1:2","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/"},{"categories":["Java后端"],"content":"2. 模板邮件实现 ","date":"2023-09-13","objectID":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/:2:0","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/"},{"categories":["Java后端"],"content":"2.1 Thymeleaf 定义邮件模板首先使用Thymeleaf定义一个静态的html文件，并利用Thymeleaf与服务接口变量的绑定特性，动态的改变邮件模板中的参数内容。 如定义一个html邮件模板文件： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e【东源学院】尊敬的东源学院用户：\u003c/p\u003e \u003cp\u003e我们收到了一项请求，要求通过您的电子邮件\u003cspan th:text=\"${email}\"\u003e您的账户，您的【东源学院】验证码为：\u003c/span\u003e\u003c/p\u003e \u003ch2 style=\"text-align: center;\" th:text=\"${code}\"\u003e\u003c/h2\u003e \u003cp\u003e如果您并未请求此验证码，则可能是他人正在尝试访问以下 【东源学院】 帐号：\u003cspan th:text=\"${email}\"。\u003e请勿将此验证码转发给或提供给任何人。\u003c/span\u003e\u003c/p\u003e \u003cp\u003e验证码有效时间为5分钟\u003c/p\u003e \u003cdiv style=\"color: #ff1a0e\"\u003e一起努力创造辉煌\u003c/div\u003e \u003chr\u003e \u003cp\u003e此致\u003c/p\u003e \u003cp\u003e东源科技团队敬上\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 其中th:text=\"${email}\"是利用了Thymeleaf模板引擎的特性，获取服务返回的参数信息，并展示到html页面中。 ","date":"2023-09-13","objectID":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/:2:1","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/"},{"categories":["Java后端"],"content":"2.1 TemplateEngine 为了使用定义的邮件模板，并将整个html文件内容作为html的格式邮件发送，这时就需要用到 org.thymeleaf.TemplateEngine包中的TemplateEngine类。 可以按照如下方式获取模板文件中的html内容，并填充内容： @Autowired private JavaMailSender javaMailSender; @Autowired private TemplateEngine templateEngine; @Override public boolean sendEmail(String email, String templateName, Map\u003cString, Object\u003e param) { MimeMessage mimeMessage = javaMailSender.createMimeMessage(); MimeMessageHelper helper = null; try { helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject(\"欢迎使用东源学院\"); helper.setFrom(\"posttimer@163.com\"); helper.setTo(email); // helper.setCc(\"37xxxxx37@qq.com\"); // helper.setBcc(\"14xxxxx098@qq.com\"); helper.setSentDate(new Date()); // 这里引入的是Template的Context Context context = new Context(); // 设置模板中的变量 context.setVariable(\"email\", email); context.setVariable(\"code\",param.get(\"code\")); // 第一个参数为模板的名称 String process = templateEngine.process(templateName, context); // 第二个参数true表示这是一个html文本 helper.setText(process,true); javaMailSender.send(mimeMessage); return true; } catch (MessagingException e) { e.printStackTrace(); return false; } } //具体代码见：https://gitee.com/hubu8/edu_dongyuan/blob/master/service/service_msm/src/main/java/buzz/hubu/msmservice/service/impl/MsmServiceImpl.java //此仓库为私有仓库，代码仅供参考 ","date":"2023-09-13","objectID":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/:2:2","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/"},{"categories":["Java后端"],"content":"3.模板升级 thymeleaf模板进数据库 @Override public boolean sendEmailByTemplate(String funcNo, String email, Map\u003cString, Object\u003e param) { QueryWrapper\u003cEmailTemplate\u003e emailTemplateQueryWrapper = new QueryWrapper\u003c\u003e(); emailTemplateQueryWrapper.eq(\"func_no\", funcNo); EmailTemplate emailTemplate = emailTemplateMapper.selectOne(emailTemplateQueryWrapper); if (emailTemplate != null) { MimeMessage mimeMessage = javaMailSender.createMimeMessage(); MimeMessageHelper helper = null; helper = new MimeMessageHelper(mimeMessage, null); try { helper.setSubject((String) param.get(\"subject\")); helper.setFrom(\"posttimer@163.com\"); helper.setTo(email); helper.setSentDate(new Date()); String template = emailTemplate.getEmailTemplate(); //parameterList:'[{\\\"name\\\": \\\"邮件\\\", \\\"fields\\\": \\\"email\\\", \\\"initValue\\\": \\\"2650523664@qq.com\\\"}, {\\\"name\\\": \\\"验证码\\\", \\\"fields\\\": \\\"code\\\", \\\"initValue\\\": \\\"152368\\\"}]' //解析参数 List\u003cFieldsDTO\u003e fieldsDTOS = JSON.parseArray(emailTemplate.getParameterList(), FieldsDTO.class); Map\u003cString, Object\u003e resultMap = new HashMap\u003c\u003e(); fieldsDTOS.forEach(i -\u003e { String fields = i.getFields(); Object initValue = i.getInitValue(); if (param.containsKey(fields)) { initValue = param.get(fields); } resultMap.put(fields, initValue); }); Context context = new Context(); context.setVariables(resultMap); TemplateEngine engine = new TemplateEngine(); String process = engine.process(template, context); helper.setText(process, true); javaMailSender.send(mimeMessage); return true; } catch (Exception e) { return false; } } return false; } // https://gitee.com/-/ide/project/hubu8/edu_dongyuan/edit/dev-v1.0.0/-/service/service_msm/src/main/java/buzz/hubu/msmservice/service/impl/MsmServiceImpl.java ","date":"2023-09-13","objectID":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/:3:0","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/"},{"categories":["Java后端"],"content":"4.其他实现思路 ","date":"2023-09-13","objectID":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/:4:0","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/"},{"categories":["Java后端"],"content":"Velocity模板引擎 ","date":"2023-09-13","objectID":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/:4:1","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/"},{"categories":["Java后端"],"content":"freemarker 模板引擎","date":"2023-09-13","objectID":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/:4:2","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6templateengine/"},{"categories":["java"],"content":"写在最前面 测试代码展示YYYY与yyyy的区别： public class Test { public static void main(String[] args) { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String dateStr = \"2023-12-31 23:59:59\"; try { Date date = sdf.parse(dateStr); String yearLowCase = sdf.format(date); System.out.println(\"LowYearCase: \" + yearLowCase); SimpleDateFormat sdf2 = new SimpleDateFormat(\"YYYY-MM-dd HH:mm:ss\"); String yearUpperCase = sdf2.format(date); System.out.println(\"UpperYearCase: \" + yearUpperCase); } catch (ParseException e) { throw new RuntimeException(e); } } } 输出结果： LowYearCase: 2023-12-31 23:59:59 UpperYearCase: 2024-12-31 23:59:59 很明显，使用YYYY时，2023年变成了2024年，在正常情况下可能没问题，但是在跨年的时候大概率就会有问题了。 ","date":"2023-09-12","objectID":"/date-formatting%E4%B8%ADyyyy%E4%B8%8Eyyyy%E7%9A%84%E5%8C%BA%E5%88%AB/:0:1","tags":["时间格式化"],"title":"Date Formatting中YYYY与yyyy的区别","uri":"/date-formatting%E4%B8%ADyyyy%E4%B8%8Eyyyy%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["java"],"content":"原因 与小写的yyyy不同，大写的YYYY表示一个基于周的年份。它是根据周计算的年份，而不是基于日历的年份。通常情况下，两者的结果是相同的，但在跨年的第一周或最后一周可能会有差异。 区别： yyyy使用的是日历年，我们应该使用日历年这种方式 YYYY使用的是当前周所在的年份（Week of Year） 大部分情况下这两种方式的值是一样的 避免这个问题的方法也十分简单，要有公用的格式类，所有使用日期格式的地方都引用这个类，这个类中就定义好yyyy-MM-dd想给的格式即可，这样就不会出现有人手误给大家埋雷了。 ","date":"2023-09-12","objectID":"/date-formatting%E4%B8%ADyyyy%E4%B8%8Eyyyy%E7%9A%84%E5%8C%BA%E5%88%AB/:0:2","tags":["时间格式化"],"title":"Date Formatting中YYYY与yyyy的区别","uri":"/date-formatting%E4%B8%ADyyyy%E4%B8%8Eyyyy%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["数据库"],"content":"for update定义 ​ for update是一种行级锁，又叫排它锁，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行．如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。行锁永远是独占方式锁。 只有当出现如下之一的条件，才会释放共享更新锁： 1.执行提交（COMMIT）语句 2.退出数据库（LOG　OFF） 3.程序停止运行 ","date":"2023-09-12","objectID":"/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/:0:1","tags":["for update"],"title":"for update的作用与用法","uri":"/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/"},{"categories":["数据库"],"content":"概念和用法 通常情况下，select语句是不会对数据加锁，妨碍影响其他的DML和DDL操作。同时，在多版本一致读机制的支持下，select语句也不会被其他类型语句所阻碍。 而select … for update 语句是我们经常使用手工加锁语句。在数据库中执行select … for update ,大家会发现会对数据库中的表或某些行数据进行锁表，在mysql中，如果查询条件带有主键、索引，会锁行数据，如果没有，会锁表。 由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table Lock (将整个资料表单给锁住)。 【举例说明】假设有张表user ，里面有 id 和 name 两列，id是主键。 例1: (明确指定主键，并且数据真实存在，row lock) SELECT*FROMuserWHEREid=3FORUPDATE;SELECT*FROMuserWHEREid=3andname='Tom'FORUPDATE; 例2: (明确指定主键，但数据不存在，无lock) SELECT*FROMuserWHEREid=0FORUPDATE; 例3: (主键不明确，table lock) SELECT*FROMuserWHEREid\u003c\u003e3FORUPDATE;SELECT*FROMuserWHEREidLIKE'%3%'FORUPDATE; 例4: (无主键，table lock) SELECT*FROMuserWHEREname=‘Tom’FORUPDATE; 注意： 1.FOR UPDATE仅适用于InnoDB，且必须在事务处理模块(BEGIN/COMMIT)中才能生效。 2.要测试锁定的状况，可以利用MySQL的Command Mode(命令模式) ，开两个视窗来做测试。 3.Myisam 只支持表级锁，InnerDB支持行级锁 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改。是表级锁时，不管是否查询到记录，都会锁定表。 4.有普通索引或者唯一索引的情况下，也会进行行锁，情况与走主键一样 ","date":"2023-09-12","objectID":"/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/:0:2","tags":["for update"],"title":"for update的作用与用法","uri":"/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/"},{"categories":["数据库"],"content":"什么时候需要使用for update？ 借助for update语句，我们可以在应用程序的层面手工实现数据加锁保护操作。就是那些需要业务层面数据独占时，可以考虑使用for update。 场景上，比如火车票订票，在屏幕上显示有票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。 ","date":"2023-09-12","objectID":"/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/:0:3","tags":["for update"],"title":"for update的作用与用法","uri":"/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/"},{"categories":["数据库"],"content":"for update悲观锁 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它解锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。就像for update，再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。 乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。 ","date":"2023-09-12","objectID":"/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/:0:4","tags":["for update"],"title":"for update的作用与用法","uri":"/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/"},{"categories":["运维"],"content":"1.复制下面命令至文件并保存 #!/bin/bash sudo systemctl stop docker.socket #删除原有docker sudo yum remove docker docker-ce docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine echo \"=======删除 docker 完成=======\" #删除镜像、容器、配置文件等内容 sudo rm -rf /var/lib/docker sudo rm -rf /etc/systemd/system/docker.service.d sudo rm -rf /var/run/docker echo \"=======删除 docker 完成=======\" #安装 docker sudo curl -sSL https://get.daocloud.io/docker | sh #启动 docker systemctl start docker docker -v echo \"=======安装 docker 完成=======\" #设置 docker仓库为国内仓库 touch /etc/docker/daemon.json cat \u003e /etc/docker/daemon.json \u003c\u003cEOF { \"registry-mirrors\": [\"https://nrbewqda.mirror.aliyuncs.com\",\"https://dmmxhzvq.mirror.aliyuncs.com\",\"https://registry.docker-cn.com\"] } EOF #启动 docker systemctl daemon-reload systemctl restart docker echo \"=======开始安装 docker-compose 完成=======\" #安装 docker-compose sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version echo \"=======安装 docker-compose 完成=======\" 2.给文件添加执行权限 chmod +x install-docker.sh ","date":"2023-05-29","objectID":"/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85docker%E5%92%8Cdocker-compose/:0:0","tags":["docker"],"title":"一键安装docker和docker Compose","uri":"/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85docker%E5%92%8Cdocker-compose/"},{"categories":["Java后端"],"content":"ThreadLocal特点 ThreadLocal是一个线程内部的变量，只在本线程中使用，隔离其他线程 ThreadLocal内部维护了一个ThreadLocalMap Thread内部引用了ThreadLocalMap ThreadLocalMap可以保存键值对，但是一个ThreadLocal只能保存一个值，并且各个线程数据互不干扰 ThreadLocalMap存储时的key永远为当前的ThreadLocal ThreadLocalMap存储时的key是弱引用的 ThreadLocalMap 每个ThreadLocal只能存储一个数据，如果需要存储多个值的话，可以定义多个ThreadLocal。ThreadLocal在内部维护了一个ThreadLocalMap用来存储这些值。 ThreadLocalMap并没有去实现Map接口，它定义了一个Entry数组，每个Entry以\u003ckey,value\u003e的形式来保存值，其中key为当前ThreadLocal本身，value为要保存的值。 ","date":"2023-05-24","objectID":"/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/:0:1","tags":["ThreadLocal"],"title":"ThreadLocal多值应用","uri":"/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/"},{"categories":["Java后端"],"content":"应用 public class UploadContext { private boolean isCompress; private String suffix; private static final ThreadLocal\u003cUploadContext\u003e current; static { current = new ThreadLocal\u003c\u003e(); } public boolean isCompress() { return isCompress; } public void setCompress(boolean compress) { isCompress = compress; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; } public static UploadContext getOrCreate(){ UploadContext uploadContext = current.get(); if(uploadContext == null){ uploadContext = new UploadContext(); current.set(uploadContext); } return uploadContext; } } ","date":"2023-05-24","objectID":"/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/:0:2","tags":["ThreadLocal"],"title":"ThreadLocal多值应用","uri":"/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/"},{"categories":["Java后端"],"content":"如何使用 String suffix = UploadContext.getOrCreate().getSuffix(); ","date":"2023-05-24","objectID":"/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/:0:3","tags":["ThreadLocal"],"title":"ThreadLocal多值应用","uri":"/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/"},{"categories":["Java后端"],"content":"代码解释 一个上下文变量类，里面包含上下文业务需要的参数； 静态成员变量（所有对象共享一个本地线程变量）为ThreadLocal，getOrCreate返回的是上下文变量对象（本地线程变量值），变量对象包含参数的get与set方法， ","date":"2023-05-24","objectID":"/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/:0:4","tags":["ThreadLocal"],"title":"ThreadLocal多值应用","uri":"/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/"},{"categories":["运维"],"content":"问题背景 在一个上线项目中，系统需要定时备份数据，如果系统部署方式为服务器本地环境部署或者数据库与系统应用在同一个环境内，可以通过程序调用mysqldump来备份程序，核心代码如下： /** * Cannot run program \"mysqldump\": CreateProcess error=2, 系统找不到指定的文件。 * 确保代码运行环境和MySQL在一个环境，目前还未找到好的方法 * @param username 用户名 * @param password 密码 * @param dbName 数据库名 * @param backupDir 备份路径 * @param sqlName 文件名 */ public void backUpDataBase(String username,String password,String dbName,String backupDir,String sqlName){ String backupSql = StringUtils.format(\"mysqldump -u{} -p{} {} \u003e {}/{}`date +%Y%m%d%H%M%S`.sql\", username, password, dbName, backupDir, sqlName); logger.info(StringUtils.format(\"{} 待执行的shell命令:{}\", DateUtils.getTime(),backupSql)); File folder = new File(backupDir); if (!folder.exists() \u0026\u0026 !folder.isDirectory()) { folder.mkdirs(); logger.info(StringUtils.format(\"{} 没有当前备份目录%s,已经自动创建\",DateUtils.getTime())); } try { Runtime.getRuntime().exec(backupSql); } catch (IOException e) { logger.error(StringUtils.format(\"{} 备份脚本执行失败，请检查\",DateUtils.getTime())); throw new RuntimeException(e); } } 但是现在普遍的部署方式为docker部署服务和底层组件，此时如果容器处在同一个网络，网络是通的，但是并不能互相免密登录（因为容器环境的不同，生态并没有完整linux完善），所以就需要一种定时备份数据的程序。 ","date":"2023-05-11","objectID":"/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/:0:1","tags":["mysql数据备份"],"title":"Docker之mysql数据备份","uri":"/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"},{"categories":["运维"],"content":"环境简介 主应用程序和MySQL容器部署在不同容器但是属于同一个网络，此时服务器系统没有mysql环境，所以也就没有mysqldump备份命令，此时数据库的备份方案只能在mysql容器上部署。 ","date":"2023-05-11","objectID":"/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/:0:2","tags":["mysql数据备份"],"title":"Docker之mysql数据备份","uri":"/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"},{"categories":["运维"],"content":"方案简介 1、MySQL容器挂载出一个目录作为数据备份输出目录，这样服务器系统可以访问； 2、主系统程序部署一个定时任务，通过定时任务把备份数据备份到其他地方（例如通过邮件发送给系统管理员）； 3、主系统程序需要访问到备份数据，那么就需要MySQL容器和主系统程序挂载在主机的同一个目录； ","date":"2023-05-11","objectID":"/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/:0:3","tags":["mysql数据备份"],"title":"Docker之mysql数据备份","uri":"/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"},{"categories":["运维"],"content":"技术落地 1、MySQL容器目录挂载 ruoyi-mysql:container_name:ruoyi-mysqlimage:mysql:5.7build:context:./mysqlports:- \"3306:3306\"volumes:- ./mysql/conf:/etc/mysql/conf.d- ./mysql/logs:/logs- ./mysql/data:/var/lib/mysql- ./mysql/backup:/opt/backupcommand:['mysqld','--innodb-buffer-pool-size=80M','--character-set-server=utf8mb4','--collation-server=utf8mb4_unicode_ci','--default-time-zone=+8:00','--lower-case-table-names=1'] 2、服务器备份脚本 #!/bin/bash # -v ./mysql/backup:/opt/backup # 此文件同放在与backup同级 dockerMysqlName=ruoyi-mysql mysqlUser=root mysqlPassword=password mysqlHost=localhost mysqlPort=3306 dateBackup=$(date +%Y-%m-%d_%H_%M_%S) dir=./backup/${dateBackup} # 宿主机新建目录，通过挂载会自动添加到容器 这里是每次的log文件 if [ ! -d ${dir} ]; then mkdir ${dir} echo \"*****************\u003e 开始备份 ${dateBackup}数据\u003c*****************\" \u003e\u003e ${dir}/backup.log echo \"创建文件夹 ${dir}成功\" \u003e\u003e ${dir}/backup.log else echo \"-----------------\u003e 开始备份 ${dateBackup}数据\u003c-----------------\" \u003e\u003e ${dir}/backup.log echo \"创建文件夹 ${dir}失败，文件夹已存在\" \u003e\u003e ${dir}/backup.log fi # 需要备份的数据库名 dbNames=(ry-cloud ry-dev ry-config) for dbName in ${dbNames[@]} do echo \"-----------------\u003e 备份 ${dbName}数据库 start\u003c-----------------\" \u003e\u003e ${dir}/backup.log docker exec -i ${dockerMysqlName} sh -c \"mkdir -p /opt/backup/${dateBackup}/table\" docker exec -i ${dockerMysqlName} sh -c \"mkdir -p /opt/backup/${dateBackup}/data\" echo \" 1、 ---------\u003e 备份 ${dbName}数据库 表结构 \u003c--------- \" \u003e\u003e ${dir}/backup.log docker exec -i ${dockerMysqlName} sh -c \"mysqldump --opt -u${mysqlUser}-p${mysqlPassword}-h${mysqlHost}-P${mysqlPort}${dbName}1\u003e\u003e /opt/backup/${dateBackup}/table/${dbName}-dbschema.sql 2\u003e\u003e /opt/backup/${dateBackup}/table/error.log\" echo \" 2、 ---------\u003e 备份 ${dbName}数据库 数据 \u003c--------- \" \u003e\u003e ${dir}/backup.log docker exec -i ${dockerMysqlName} sh -c \"mysqldump -t -u${mysqlUser}-p${mysqlPassword}-h${mysqlHost}-P${mysqlPort}${dbName}1\u003e\u003e /opt/backup/${dateBackup}/data/${dbName}-dbdata.sql 2\u003e\u003e /opt/backup/${dateBackup}/data/error.log\" echo \"-----------------\u003e 备份 ${dbName}数据库 end\u003c-----------------\" \u003e\u003e ${dir}/backup.log done echo \"-----------------\u003e 压缩今日备份数据目录：${dir}\u003c-----------------\" \u003e\u003e ${dir}/backup.log tar -czvf ${dir}.tar.gz ${dir} echo \"----------------\u003e 删除过期文件 \u003c---------------------------\" \u003e\u003e ${dir}/backup.log # 判断文件夹数量是否大于7，防止程序意外停止，删除所有备份 dirCount=`ls -l ./backup/|grep \"^d\"|wc -l` if [ ${dirCount} -gt 7 ] then # 删除超过七天的带\"_\"的目录 find ./backup/ -type d -mtime +6 -name \"*_*\" -exec rm -rf {} \\; echo -e \"删除过期文件成功\" \u003e\u003e ${dir}/backup.log else echo \"删除过期文件失败，文件数量小于 7 \" \u003e\u003e ${dir}/backup.log fi echo -e \"*****************\u003e 完成备份 ${dateBackup}数据\u003c*****************\\n\\n\" \u003e\u003e ${dir}/backup.log cat ${dir}/backup.log\u003e\u003e./backup/backup.log 同时可以通过定时任务实现定时执行 3、文件异地备份 最后通过系统程序挂载到文件共享目录，通过系统定时任务发送邮件；这部分代码参考hutools的Email功能 @Override public void send(EmailVO emailVo, EmailConfig emailConfig){ if(emailConfig.getId() == null){ throw new EmailConfigException(\"请先配置，再操作\"); } // 封装 MailAccount account = new MailAccount(); // 设置用户 String user = emailConfig.getFromUser().split(\"@\")[0]; account.setHost(emailConfig.getHost()); account.setPort(Integer.parseInt(emailConfig.getPort())); account.setAuth(true); try { // 对称解密 account.setPass(EncryptUtils.desDecrypt(emailConfig.getPass())); } catch (Exception e) { throw new CheckedException(e.getMessage()); } // ssl方式发送 account.setSslEnable(true); // 使用STARTTLS安全连接 account.setStarttlsEnable(true); account.setUser(user); account.setFrom(emailConfig.getFromUser()); String content = emailVo.getContent(); // 发送 try { int size = emailVo.getTos().size(); Mail mail = Mail.create(account); mail.setTos(emailVo.getTos().toArray(new String[size])) .setTitle(emailVo.getSubject()) .setContent(content) .setHtml(true); List\u003cDataSource\u003e attachments = emailVo.getAttachments(); if(attachments != null \u0026\u0026 attachments.size() \u003e 0){ mail.setAttachments(attachments.toArray(new DataSource[]{})); } List\u003cFile\u003e files = emailVo.getFiles(); if(files != null \u0026\u0026 files.size() \u003e 0){ mail.setFiles(files.toArray(new File[]{})); } mail //关闭session .setUseGlobalSession(false) .send(); }catc","date":"2023-05-11","objectID":"/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/:0:4","tags":["mysql数据备份"],"title":"Docker之mysql数据备份","uri":"/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"},{"categories":["运维"],"content":"0、网上最常见的**行为 通过Dockerfile中的CMD命令： FROMmysql:5.7#设置免密登录ENV MYSQL_ALLOW_EMPTY_PASSWORD yes#将所需文件放到容器中COPY setup.sh /mysql/setup.shCOPY schema.sql /mysql/schema.sqlCOPY privileges.sql /mysql/privileges.sql#设置容器启动时执行的命令CMD [\"sh\", \"/mysql/setup.sh\"] 通过把需要执行的脚本复制到容器镜像中，然后通过CMD命令把脚本执行，从设计角度没问题，但是此时会出现一个问题那就是执行顺序，当前dockerfile文件中的CMD命令会把原来镜像的MySQL启动命令覆盖，所以最后的结果是容器一启动，就执行sh脚本，此时数据库都没有启动，直接报错。 既然如此那就在CMD命令前面加上数据库启动脚本？发现依旧存在其他问题个人可以去尝试一下 ","date":"2023-04-15","objectID":"/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/:0:1","tags":["docker","mysql初始化"],"title":"Docker启动mysql之初始化数据库","uri":"/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["运维"],"content":"1、docker-entrypoint-initdb.d 官方是这样介绍的： Initializing a fresh instance When a container is started for the first time, a new database with the specified name will be created and initialized with the provided configuration variables. Furthermore, it will execute files with extensions .sh, .sql and .sql.gz that are found in /docker-entrypoint-initdb.d. Files will be executed in alphabetical order. You can easily populate your mysql services by mounting a SQL dump into that directory and provide custom images with contributed data. SQL files will be imported by default to the database specified by the MYSQL_DATABASE variable. 大致意思： 当容器首次启动时，将创建一个具有指定名称的新数据库，并使用提供的配置变量进行初始化。此外，它将执行扩展名为“.sh”、“.sql”和“.sql.gz”的文件，这些文件位于“/docker entrypoint initdb.d”中。文件将按字母顺序执行。您可以通过[将SQL转储装载到该目录中]来轻松地填充“mysql”服务(https://docs.docker.com/engine/tutorials/dockervolumes/#mount-主机-文件即数据卷）并提供自定义图像有贡献的数据。默认情况下，SQL文件将导入到由“MYSQL_database”变量指定的数据库中。 ","date":"2023-04-15","objectID":"/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/:0:2","tags":["docker","mysql初始化"],"title":"Docker启动mysql之初始化数据库","uri":"/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["运维"],"content":"2、开始使用 2.1、dockerfile FROMmysql:5.7#设置免密登录ENV MYSQL_ALLOW_EMPTY_PASSWORD yes#将所需文件放到容器中COPY schema.sql /docker-entrypoint-initdb.d/1schema.sqlCOPY privileges.sql /docker-entrypoint-initdb.d/2privileges.sql 2.2、数据库初始化文件 -- 创建数据库 createdatabase`nest_cms_api`defaultcharactersetutf8collateutf8_general_ci;usenest_cms_api;-- 建表 /* Navicat Premium Data Transfer Source Server : Local-MySQL Source Server Type : MySQL Source Server Version : 80025 Source Host : localhost:3306 Source Schema : nest_cms_api Target Server Type : MySQL Target Server Version : 80025 File Encoding : 65001 Date: 22/10/2021 11:16:32 */SETNAMESutf8mb4;SETFOREIGN_KEY_CHECKS=0;-- ---------------------------- -- Table structure for about -- ---------------------------- DROPTABLEIFEXISTS`about`;CREATETABLE`about`(`id`char(36)NOTNULL,`name`varchar(255)NOTNULL,`content`mediumtext,`status`tinyintNOTNULL,`createdAt`datetimeNOTNULL,`updatedAt`datetimeNOTNULL,`banner`varchar(255)NOTNULL,`route`varchar(255)NOTNULL,`description`varchar(255)NOTNULL,`category`varchar(255)NOTNULL,PRIMARYKEY(`id`))ENGINE=InnoDBDEFAULTCHARSET=utf8mb4;-- ---------------------------- -- Records of about -- ---------------------------- BEGIN;INSERTINTO`about`VALUES('47fd5dd0-d34e-41c5-9375-fbdfc21b405a','联系我们','\u003cp\u003e\u0026nbsp;\u003c/p\u003e\u003cfigure class=\\\"image\\\"\u003e\u003cimg src=\\\"http://localhost:3000/uploads/31570b02b5d4cacc55c3c5a07095b1fc1634348290965.jpg\\\"\u003e\u003c/figure\u003e\u003cp\u003eOpera桌面浏览器首创了许多新功能，从而帮助用户提高上网效率，促进创新和网络开发。例如，在Opera浏览器的第一个公开发行版本里，Opera就实现了在一个窗口里同时打开多个文档——这就是普遍流行的“标签式浏览”的前身。又如，2001年Opera首创了“鼠标手势”，极大地改变了许多人网上冲浪的方式。\u003c/p\u003e\u003cp\u003eOpera还有很多创新是围绕着如何帮助用户提高工作效率，如浏览器内置的笔记功能，便于用户快速浏览常用网址的“快速拨号”功能，以及能同步各种浏览信息的OperaLink功能等等。在Opera即将推出的10.0版本中，又加入了可以通过压缩页面为窄带用户带来宽带浏览速度的OperaTurbo加速技术。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e标签式浏览\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e标签式浏览是现代几乎所有浏览器支持的方式，在打开一个网页时新的网页会在同一个窗口内打开并在靠近窗口顶部的位置出现该网页的选项卡标签，点击这些标签就可以在不同的网页间方便切换，而不必打开一个新的浏览器窗口。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e快速拨号\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e快速拨号就是可以帮助用户将自己最常访问的多个网站，依次设入“拨号面板”中，而这些网站是以缩略图形式展现出来直观明了。然后，每次启动Opera时，便可以通过这个面板，快速打开相应的网站。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e鼠标手势\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e就是用鼠标做出一些动作以控制软件完成某些操作，就好比人们见面时打的手势一样。一般是按住鼠标右键，并在网页的空白处划出某种特定的轨迹，然后即可实现预先定制的前进、后退、刷新、关闭窗口等常用操作。\u003c/p\u003e\u003cfigure class=\\\"image\\\"\u003e\u003cimg src=\\\"http://localhost:3000/uploads/1570b02b5d4cacc55c3c5a07095b1fc71634348542377.jpg\\\"\u003e\u003c/figure\u003e\u003cp\u003e\u003cstrong\u003eOperaLink\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eOperaLink不仅仅是一个简单的书签同步功能，用户使用它将可以共享自己桌面浏览器和手机浏览器的所有书签、快速拨号、笔记和其它一些个性化设置，让用户时刻享受简单、轻松、便捷的互联网生活。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eOpera Turbo\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eOpera Turbo技术源于Opera大力推行的“One Web”理念，它也标志Opera帮助人们随时随地更轻松快速上网的构想向前迈进了一大步。Opera正在通过不断开发新技术创建更好的网络体验，并逐渐打破阻碍，实现全球互联网的一体化进程。Opera Turbo是存在于Opera 10和Opera Mobile中独创的压缩技术。Opera Turbo在窄带环境下网页浏览速度比同类浏览器快8倍。Opera Turbo功能始于2009年9月1日的Opera 10，但Opera的网页压缩技术最早在Opera mini中已经应用。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eOpera unite\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003ca href=\\\"https://baike.baidu.com/item/Opera%20Unite\\\"\u003eOpera Unite\u003c/a\u003e是一种全新的在线协作技术，它基于Opera浏览器中简单而精密的服务器程序实现共享数据和服务等功能。Opera Unite颠覆了互联网传统的“客户端─服务器”计算模式，使得每一台电脑既成为客户端也成为服务器，电脑之间可以直接通过网络进行点对点互动和信息共享，再也不需要通过第三方服务器中转。而且，Opera Unite为我们提供了文件共享、媒体播放器、相片册、聊天室、冰箱门（虚拟出来的一个冰箱门，访客和用户自己可以随意在冰箱门上贴便条）等服务，甚至能够将用户的电脑扮演成网络服务器。Opera Unite提出了一种Mashup“云计算”和“点对点（P2P）”概念的新的计算模式。它的优势就在于借助个人电脑平台来分销高昂的云计算服务器开支以及服务器运行时的压力等；它的诞生，就如同AJAX一样——源自传统，却是颠覆性的。Unite 扩展始现于Opera 10.10 正式版，Opera 12终止服务。\u003c/p\u003e',1,'2021-10-15 17:03:31','2021-10-16 09:50:09','public/uploads/b02b5d4cacc55c3c5a07095b1fc796261634348910770.jpg','contact-us','快速拨号就是可以帮助用户将自己最常访问的多个网站，依次设入“拨号面板”中，而这些网站是以缩略图形式展现出来直观明了。然后，每次启动Opera时，便可以通过这个面板，快速打开相应的网站。','contact');INSERTINTO`about`VALUES('4aa124a1-35f3-4c05-a5ce-46b9a581cf48','关于我们','\u003cfigure class=\\\"image\\\"\u003e\u003cimg src=\\\"http://localhost:3000/uploads/70b02b5d4cacc55c3c5a07095b1fc7961634348703334.jpg\\\"\u003e\u003c/figure\u003e\u003cp\u003eOpera浏览器，是一款挪威Opera Software ASA公司制作的支持多页面标签式浏览的网络浏览器，是跨平台浏览器可以在Windows、Mac和Linux三个操作系统平台上运行。Opera浏览器创始于1995年4月。2019.1.31日最新版本58.0(58.0.3135.53)。\u003c/p\u003e\u003cp\u003eOpera浏览器因为它的快速、小巧和比其他浏览器更佳的标准兼容性获得了国际上的最终用户和业界媒体的承认，并在网上受到很多人的推崇。OperaSoftware开发的Opera浏览器是一款适用于各种平台、操作系统和嵌入式网络产品的高品质、多平台产品，opera浏览器不同于其他浏览器的特点有：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eOpera支持多种操作系统，\u003c/strong\u003e如\u003ca href=\\\"https://baike.baidu.com/item/Windows\\","date":"2023-04-15","objectID":"/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/:0:3","tags":["docker","mysql初始化"],"title":"Docker启动mysql之初始化数据库","uri":"/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["前端"],"content":"0、最终实现效果 ","date":"2023-04-07","objectID":"/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:1","tags":["Echarts"],"title":"Echarts之liquidFill球状图封装","uri":"/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"1、组件代码 1.1、Vue代码 \u003ctemplate\u003e \u003cdiv class=\"content content-item item\" :style=\"'float: left;background-image: url(' + static_color.bgImage+')'\"\u003e \u003cdiv class=\"statistics-item-1\"\u003e 本月总数 \u003cp\u003e {{ option.num }} \u003cspan\u003e笔\u003c/span\u003e \u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"echarts\" :id=\"option.id\"\u003e\u003c/div\u003e \u003cdiv class=\"statistics-item-2\" :style=\"'color: ' + static_color.color\"\u003e 好评数 \u003cspan :style=\"'color: ' + static_color.color\"\u003e {{ option.total }}笔 \u003c/span\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import * as echarts from 'echarts' import 'echarts-liquidfill' export default { name: 'thematicModelBizMonitor-8-si', props:{ option:{ type: Object }, static_color:{ type: Object } }, mounted() { this.initEcharts() }, methods: { initEcharts() { const echartsDom = document.getElementById(this.option.id) let liquidEchart = echarts.getInstanceByDom(echartsDom) if (liquidEchart == null) { liquidEchart = echarts.init(echartsDom) } liquidEchart.setOption(this.getOption()) }, getOption(){ const data = this.option.num/this.option.total; const option = { // backgroundColor: 'white', series: [ { type: 'liquidFill', radius: '80%', data: [data, data-0.111], backgroundStyle: { color: { type: 'radial', x: 0.5, y: 0.5, r: 0.5, colorStops: this.static_color.background_colorStops, globalCoord: false } }, outline: { borderDistance: 0, itemStyle: { borderWidth: 0, borderColor: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: this.static_color.outline_colorStops, globalCoord: false } } }, // color: ['rgba(37,237,240, 1)', 'rgba(37,200,220, 1)'], color: [ { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: this.static_color.line_colorStops, globalCoord: false } ], label: { normal: { formatter: '' } } } ] } return option; } } } \u003c/script\u003e \u003cstyle scoped\u003e .content { width: 100%; height: 350px; box-sizing: content-box; text-align: center; position: relative; display: block; } .content-item { width: 50%; height: 100%; position: relative; } .item{ top: 0; background-position: 50% 150px; background-repeat: no-repeat; background-size: 300px 150px; } .echarts { width: 250px; height: 250px; margin: auto; display: block; /*//position: absolute;*/ } .statistics-item-1 { position: absolute; z-index: 1; display: block; align-items: center; font-size: 16px; line-height: 16px; font-weight: 550; color: rgb(0, 240, 224); margin: 0 auto; margin-top: 50px; /*//width: 250px;*/ /*//margin: auto;*/ width: 100%; padding: 20px 0; font-family: PingFang SC; p { margin-bottom: 0; font-size: 30px; line-height: 50px; font-family: YouSheBiaoTiHei; font-weight: 400; display: flex; align-items: center; color: #ffffff; margin: auto; width: fit-content; span { padding-top: 10px; font-size: 20px; line-height: 20px; font-family: YouSheBiaoTiHei; font-weight: 400; color: #ffffff; margin-left: 9px; } } } .statistics-item-2 { position: absolute; align-items: center; font-size: 16px; line-height: 16px; color: #00f8ff; /*//margin-left: 36%;*/ font-weight: 550; width: 100%; span { margin-bottom: 0; font-size: 20px; line-height: 20px; font-family: YouSheBiaoTiHei; font-weight: 400; /*display: flex;*/ margin-left: 10px; align-items: center; color: #ffffff; } } \u003c/style\u003e 1.2、js常量类 export const color_blue = { color: \"rgb(0,240,224)\", bgImage: require(\"@/assets/images/pay/liquidfill/wave_bg_blue.png\"), background_colorStops: [ { offset: 0, color: 'rgba(0,240,224, 0)' }, { offset: 0.9, color: 'rgba(0,240,224, 0)' }, { offset: 1, color: 'rgba(0,240,224, 0.6)' } ], outline_colorStops: [ { offset: 0, color: 'rgba(50,115,256, 1)' }, { offset: 0.5, color: 'rgba(50,115,233, .75)' }, { offset: 1, color: 'rgba(50,115,233, 1)' } ], line_colorStops: [ { offset: 0, color: 'rgba(2,145,157, 0.6)' }, { offset: 0.5, color: 'rgba(2,145,157, 0.3)' }, { offset: 1, color: 'rgba(2,145,157, 0.1)' } ] }; export const color_green = { color: \"rgb(89,201,100)\", bgImage: require(\"@/assets/images/pay/liquidfill/wave_bg_green.png\"), background_colorStops: [ { offset: 0, color: 'rgba(89,201,100, 0)' }, { offset: 0.9, color: 'rgba(89,201,100, 0)' }, { offset: 1, color:","date":"2023-04-07","objectID":"/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:2","tags":["Echarts"],"title":"Echarts之liquidFill球状图封装","uri":"/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"2、如何使用 \u003ctemplate\u003e \u003cdiv class=\"grid-content bg-purple\"\u003e \u003cliquidfill-echart :option=\"liquidOption\" :static_color=\"color1\" /\u003e \u003cliquidfill-echart :option=\"liquidOption2\" :static_color=\"color2\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import LiquidfillEchart from \"@/components/3DEcharts/liquidfill/liquidfillEchart.vue\"; import { color_blue,color_green } from \"@/components/3DEcharts/liquidfill/liquidConst\" export default { name: 'staticpay', components: { LiquidfillEchart}, data() { return { liquidOption:{ id: \"liquid\", num: 100, total: 200, }, liquidOption2:{ id: \"liquid2\", num: 100, total: 200, }, color1: color_blue, color2: color_green, } }, mounted() { console.log(cubeConst.colors) }, methods: { } } \u003c/script\u003e ","date":"2023-04-07","objectID":"/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:3","tags":["Echarts"],"title":"Echarts之liquidFill球状图封装","uri":"/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"0、最终实现效果 ","date":"2023-04-07","objectID":"/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:1","tags":["Echarts"],"title":"Echarts之3D柱之圆形柱状图封装","uri":"/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"1、组件代码 1.1、Vue代码 \u003ctemplate\u003e \u003cdiv :id=\"id\" class=\"cylinder-3d\"\u003e\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { get3DOptions } from \"./options.js\"; import * as echarts from 'echarts' export default { name: \"outputMea\", props:{ // id 容器id,可以不传 id: { type: String, default: 'myChart' + Math.ceil(Math.random() * 10) }, // x轴数据 xData: { type: Array, default: () =\u003e { return [] } }, // y轴数据 yData: { type: Array, default: () =\u003e { return [] } }, }, mounted() { this.init(); }, methods:{ init() { let echartsDom = document.getElementById(this.id); //日总产量 let output_3DBarCharts = echarts.init(echartsDom); let option = get3DOptions({xData: this.xData,yData: this.yData}); output_3DBarCharts.setOption(option); this.fetchSize(echartsDom) var that = this window.addEventListener(\"resize\", function () { that.fetchSize(echartsDom) output_3DBarCharts.resize(); },true); }, fetchSize(echartsDom){ let offsetWidth = echartsDom.parentNode.offsetWidth let offsetHeight = echartsDom.parentNode.offsetHeight echartsDom.style.width = offsetWidth+\"px\"; echartsDom.style.height = offsetHeight+\"px\"; debugger } } } \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .cylinder-3d{ width: 100%; height: 100%; margin: 0 20px; background: no-repeat 46px 93.5%; background-size: calc(100% - 60px) auto; } // #output_3DBarCharts{ // width: calc(100% - 40px); // height: calc(100% - 98px); // margin: 0 20px; // background: url(\"../../assets/bigData/3dBarBg.png\") no-repeat 46px 93.5%; // background-size: calc(100% - 60px) auto; // } \u003c/style\u003e 1.2、js工具类 import * as echarts from 'echarts' /*3D柱形图*/ const get3DOptions = (op = {}) =\u003e { var options = { grid: { left: 60, right: 20, top: 50, bottom: 40 }, legend: { show: true, icon: 'circle', orient: 'horizontal', top: '90.5%', right: 'center', itemWidth: 16.5, itemHeight: 6, textStyle: { color: '#C9C8CD', fontSize: 14 } }, xAxis: [{ data: op.xData || [], axisLabel: { show: true, textStyle: { color: '#aaaaaa', fontSize: 12 }, margin: 30, //刻度标签与轴线之间的距离。 }, axisLine: { show: false //不显示x轴 }, axisTick: { show: false //不显示刻度 }, boundaryGap: true, splitLine: { show: false, width: 1, lineStyle: { type: \"solid\", color: \"#03202E\" } } }], yAxis: [{ show: true, axisLabel: { interval: 'auto', show: true, textStyle: { fontSize: 14, color: '#fff', }, }, splitLine: { show: false, lineStyle: { color: 'rgba(49,176,255,0.05)', }, }, axisTick: { show: false, }, axisLine: { show: true, lineStyle: { color: 'rgba(49,176,255,0.5)', }, }, }], series: [ {//柱底圆片 name: \"\", type: \"pictorialBar\", symbolSize: [20, 8],//调整截面形状 symbolOffset: [0, 4], z: 12, itemStyle: { normal: { color: '#183E96', } }, data: op.yData || [] }, //柱体 { name: '', type: 'bar', barWidth: 20, barGap: '0%', itemStyle: { color: () =\u003e { return new echarts.graphic.LinearGradient(0, 0, 0, 1, [ { offset: 0, color: '#01AEF6'}, { offset: 1, color: 'rgba(16,36,95,0.6)' }, ]) }, opacity:1 }, data: op.yData || [] }, //柱顶圆片 { name: \"\", type: \"pictorialBar\", symbolSize: [20, 8],//调整截面形状 symbolOffset: [0, -5], z: 12, symbolPosition: \"end\", label: { show: true, position: 'top', textStyle: { color: '#fff' } }, itemStyle: { normal: { color: '#17E1FF', } }, data: op.yData || [] } ] } return options; }; export { get3DOptions } ","date":"2023-04-07","objectID":"/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:2","tags":["Echarts"],"title":"Echarts之3D柱之圆形柱状图封装","uri":"/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"2、如何使用 \u003ctemplate\u003e \u003cdiv class=\"grid-content bg-purple\"\u003e \u003cecharts-cylinder3d :id=\"'thematicModelBizMonitor13Si'\" :yData=\"yData1\" :xData=\"xData1\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import EchartsCylinder3d from '@/components/3DEcharts/cylinder/3D_cylinder.vue' export default { name: 'staticpay', components: { LiquidfillEchart}, data() { return { yData1: [25,36,47,58,34], xData1: [\"测试1\",\"测试2\",\"测试3\",\"测试4\",\"测试5\"], }, mounted() { console.log(cubeConst.colors) }, methods: { } } \u003c/script\u003e ","date":"2023-04-07","objectID":"/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:3","tags":["Echarts"],"title":"Echarts之3D柱之圆形柱状图封装","uri":"/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"0、最终实现效果 ","date":"2023-04-07","objectID":"/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/:0:1","tags":["Echarts"],"title":"Echarts之3D柱状图组件封装","uri":"/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"1、组件代码 1.1、Vue组件代码 \u003ctemplate\u003e \u003cdiv :id=\"id\" style=\"width: 100%;height: 100%;padding: 10px;\"\u003e\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import * as echarts from 'echarts' import chartUtils from './chartUtils' import cubeConst from './3dcubeConst' export default { name: 'echarts-bar-3d', props: { // id 容器id,可以不传 id: { type: String, default: 'myChart' + Math.ceil(Math.random() * 10) }, // x轴数据 xData: { type: Array, default: () =\u003e { return [] } }, // y轴数据 yData: { type: Array, default: () =\u003e { return [] } }, lineData: { type: Array, default: () =\u003e { return [] } }, // 颜色 colors: { type: Array, default: () =\u003e { return [] } }, // 显示模式 mode: { type: String, // vertical 垂直 // horizontal 水平 default: 'vertical' }, coverYAxis: { type: Object, default: () =\u003e { return {} } }, coverXAxis: { type: Object, default: () =\u003e { return {} } }, coverTooltip: { type: Object, default: () =\u003e { return {} } }, extraSeries: { type: Array, default: () =\u003e { return [] } }, extraYAxis: { type: Array, default: () =\u003e { return [] } }, extraOption: { type: Object, default: () =\u003e { return {} } } }, watch: { yData: function(val) { if ( val \u0026\u0026 val.length \u003e 0 \u0026\u0026 this.xData \u0026\u0026 this.xData.length \u003e 0 \u0026\u0026 this.colors \u0026\u0026 this.colors.length \u003e 0 ) { console.log(\"135\") this.initChart() }else{ console.log(\"125\") } } }, mounted(){ this.initChart(); }, methods: { initChart() { console.log(cubeConst) // 注册自定义3D柱状图 chartUtils.registerShapes() const isVertical = this.mode == 'vertical' // 数据转换 const yData = isVertical ? chartUtils.transferData(this.yData) : this.yData console.log(this.colors) // 根据数据生成series系列 let series = chartUtils.generateSeries(yData, this.colors, this.mode) console.log(series) const option = { animation: false, grid: { show: true, left: 20, right: 40, top: '10%', bottom: '10%', containLabel: true }, tooltip: { show: true, trigger: 'axis', axisPointer: { type: 'shadow' }, textStyle: { color: '#04a19e' }, backgroundColor: 'rgba(0,0,0,0.5)', borderColor: 'rgba(0,0,0,0.3)', formatter: params =\u003e { let result = '\u003cdiv style=\"line-height:1;font-size: var(--cdp-dashboard-text-size);\"\u003e' + params[0].name + '\u003cbr/\u003e' for (let i = 0; i \u003c params.length; i++) { let value = params[i].value if (isVertical \u0026\u0026 i \u003e 0) { value -= params[i - 1].value } result += '\u003cdiv style=\"margin: 10px 0 0;\"\u003e' + params[i].marker + `\u003cspan style=\"font-size: var(--cdp-dashboard-text-size);text-align: left;margin-left:2px;margin-right: 20px;color: #04a19e\"\u003e${params[i].seriesName}\u003c/span\u003e` + `\u003cspan style=\"font-size: var(--cdp-dashboard-text-size);float: right;font-weight: bold;color: #04a19e\"\u003e ${value}${this.coverTooltip.unit || ''}\u003c/span\u003e` + '\u003c/div\u003e' } return result + '\u003c/div\u003e' }, ...this.coverTooltip }, xAxis: { data: this.xData, axisLine: { // 坐标轴线 // show: true, lineStyle: { color: 'rgba(0, 168, 168, 1)', shadowBlur: 10, shadowOffsetX: 10, shadowOffsetY: -10, shadowColor: 'rgb(0,9,9)', } }, axisTick: { // 坐标轴刻度 show: false }, axisLabel: { fontSize: cubeConst.fontSize, interval: 0, color: 'rgba(0, 168, 168, 1)' }, ...this.coverXAxis }, yAxis: [ { type: 'value', name: '', splitNumber: 6, nameTextStyle: { fontSize: cubeConst.fontSize, color: 'rgba(0, 168, 168, 1)' }, axisLine: { show: true, lineStyle: { color: 'rgba(0, 168, 168, 1)' } }, splitLine: { show: true, lineStyle: { color: 'rgba(0, 168, 168, 1)' } }, // 坐标轴刻度 axisTick: { show: false }, axisLabel: { fontSize: cubeConst.fontSize, color: 'rgba(0, 168, 168, 1)' }, boundaryGap: ['20%', '20%'], ...this.coverYAxis }, ...this.extraYAxis ], series: [...series, ...this.extraSeries] } let cubeEchart = document.getElementById(this.id) let offsetWidth = cubeEchart.parentNode.offsetWidth cubeEchart.style.width = offsetWidth+\"px\"; let myChart = echarts.init(cubeEchart) myChart.on('click', event =\u003e { this.$emit('clickbar', event) }) // 绘制图表 // const option2 = this.deepMerge(option, this.extraOption) myChart.setOption(option) function mychartsResize() { offsetWidth = cubeEchart.parentNode.offsetWidth debugger cubeEchart.style.width = offsetWidth+\"px\"; myChart.resize() } window.","date":"2023-04-07","objectID":"/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/:0:2","tags":["Echarts"],"title":"Echarts之3D柱状图组件封装","uri":"/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"2、使用 \u003ctemplate\u003e \u003cdiv class=\"grid-content bg-purple\"\u003e \u003cecharts-bar-3d :id=\"'thematicModelBizMonitor11Si'\" :mode=\"'horizontal'\" :yData=\"yData\" :coverYAxis=\"{ name: '/笔', min: 0 }\" :colors=\"colors\" :xData=\"xData\" :coverXAxis=\"coverXAxis\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import EchartsBar3d from '@/components/3DEcharts/cdp_cube/3D_cube.vue' import cubeConst from \"@/components/3DEcharts/cdp_cube/3dcubeConst\" export default { name: 'staticpay', components: { EchartsBar3d}, data() { return { // 制图数据 yData: [[\"数据项1\",25,36,47,58,34],[\"数据项2\",15,26,37,48,24]], xData: [\"测试1\",\"测试2\",\"测试3\",\"测试4\",\"测试5\"], colors: cubeConst.colors, coverXAxis: { axisLabel: { formatter: function(value) { if (value) { if (value.trim().length \u003e 5) { let res = '' // 行（不超过5） for (let i = 0; i \u003c 5; i++) { // 每次+5 for (let j = 0; j \u003c value.length; j += 5) { // 还有字的时候取字，没有字的时候补空 if (i + j \u003c value.length) { res += value.charAt(i + j) } else { res += ' ' } } res += '\\n' } return res } return value.split('').join('\\n') } } } } } }, mounted() { console.log(cubeConst.colors) }, methods: { } } \u003c/script\u003e ps:以上组件代码持续优化中，敬请关注 ","date":"2023-04-07","objectID":"/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/:0:3","tags":["Echarts"],"title":"Echarts之3D柱状图组件封装","uri":"/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"1、直接在组件中写rules \u003c :rules=’ rules’\u003e 2、在data中写入方法 rules { name: [ { type: 'string', required: true, message: \"名称必填\", trigger: 'blur' }, { max: 30, message: \"名称长度不能超过30位\" }] } 其中name为prop名 type：类型 required：是否必选项（此栏是否为空） message：报错信息 trigger：触发方式 ​ blur ：失去焦点时进行验证 常用：对 input 输入框的验证 ​ change ：当值发生变化时进行验证 常用：下拉框select，日期选择框date-picker，复选框checkbox，单选框radio 3、也可以直接用pattern进行匹配验证: name: [ { pattern: 验证条件, required: true, message: \"提示信息\", trigger: \"blur\" }] rules: { //验证非空和长度 name: [ { required: true, message: \"站点名称不能为空\", trigger: \"blur\" }, { min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' } ], [] } vue常用检验 前端Vue中常用rules校验规则: 1、是否合法IP地址: pattern:/^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5]).(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5]).(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5]).(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$/, 2.是否手机号码或者固话 pattern:/^((0\\d{2,3}-\\d{7,8})|(1[34578]\\d{9}))$/, 3.是否身份证号码 pattern:/(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)/, 4.是否邮箱 pattern:/^([a-zA-Z0-9]+[-_.]?)+@[a-zA-Z0-9]+.[a-z]+$/, 5.整数填写 pattern:/^-?[1-9]\\d*$/, 6.正整数填写 pattern:/^[1-9]\\d*$/, 7.小写字母 pattern:/^[a-z]+$/, 8.大写字母 pattern:/^[A-Z]+$/, 9.大小写混合 pattern:/^[A-Za-z]+$/, 10.多个8位数字格式(yyyyMMdd)并以逗号隔开 pattern:/^\\d{8}(,\\d{8})*$/, 11.数字加英文，不包含特殊字符 pattern:/^[a-zA-Z0-9]+$/, 12.前两位是数字后一位是英文 pattern:/^\\d{2}[a-zA-Z]+$/, 13.密码校验（6-20位英文字母、数字或者符号（除空格），且字母、数字和标点符号至少包含两种） pattern:/^(?![\\d]+$)(?![a-zA-Z]+$)(?![^\\da-zA-Z]+$)([^\\u4e00-\\u9fa5\\s]){6,20}$/, 14.中文校验 pattern:/^[\\u0391-\\uFFE5A-Za-z]+$/, ","date":"2023-03-20","objectID":"/vue%E4%B8%AD%E7%9A%84%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C/:0:0","tags":["vue"],"title":"Vue中的表单校验","uri":"/vue%E4%B8%AD%E7%9A%84%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C/"},{"categories":["前端"],"content":"一、什么是promise，及其作用 什么是： Promise是ES6中的一个内置对象，实际是一个构造函数 特点： ①三种状态：pending（进行中）、resolved（已完成）、rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都不能改变这个状态。 ②两种状态的转化：其一，从pending（进行中）到resolved（已完成）。其二，从pending（进行中）到rejected（已失败）。只有这两种形式的转变。 ③Promise构造函数的原型对象上，有then()和catch()等方法，then()第一个参数接收resolved()传来的数据，catch()第一个参数接收rejected()传来的数据 作用： ①通常用来解决异步调用问题 ②解决多层回调嵌套的方案 ③提高代码可读性、更便于维护 二、promise的使用 function getJSON() { return new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e { let json = Math.random() * 2 if (json \u003e 1) { resolve(json) } else { reject(json) } }, 2000) }) } const makeRequest = () =\u003e getJSON() .then(data =\u003e { console.log('data==\u003e', data) return 'done' }) .catch(err =\u003e { console.log('err==\u003e', err) }) makeRequest() 三、什么是Async/Await，及其作用 什么是： ①async/await是ES8新特性 ②async/await是写异步代码的新方式，以前的方法有回调函数和Promise ③async/await是基于Promise实现的，它不能用于普通的回调函数 ④async/await与Promise一样，是非阻塞的 ⑤async/await使得异步代码看起来像同步代码，这正是它的魔力所在 四、Async/Await的使用 function getJSON() { return new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e { let json = Math.random() * 2 if (json \u003e 1) { resolve(json) } else { reject(json) } }, 2000) }) } const makeRequest = async () =\u003e { const value = await getJSON() console.log(value) return value } makeRequest() 五、Async/await 比 Promise 更优越的表现 1、简洁干净：使用 async/await 能省去写多少行代码 2、错误处理：async/wait 能用相同的结构和好用的经典 try/catch 处理同步和异步错误，错误堆栈能指出包含错误的函数。 3、调试：async/await 的一个极大优势是它更容易调试，使用 async/await 则无需过多箭头函数，并且能像正常的同步调用一样直接跨过 await 调用。 六、总结 Async/await进一步优化了Promise.then()的缺点，使代码更简洁，所以在项目中尽量使用Async/await ","date":"2023-03-15","objectID":"/promise%E4%B8%8Easyncawait%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["Promise"],"title":"Promise与Async/Await的区别","uri":"/promise%E4%B8%8Easyncawait%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Tools"],"content":"Excel撤销单元格保护 单元格保护 1、打开Excel表格，点击上方工具栏的【审阅】，再选择【保护工作表】或者【保护工作簿】 2、出现对话框后，输入想要设定的限制密码即可，也可以根据限制需要在下面勾选相应的选项。 不知道密码 1、改变excel文件后缀名，将xlsx改为zip或者rar，并解压： 2、修改xl/worksheets下的所有xml文件，逐个打开将sheetProtection标签删除 一个sheet.xml文件就代表一个工作空间，一个excel可以包含多个工作空间，所以包含有多个，如果只需要接触特定工作空间的单元格保护，工作空间顺序是和xml文件顺序一致的，可按需修改 3、将去除sheetProtection标签的文件保存，重新压缩为一个压缩文件，修改文件后缀名为xlsx: 工作空间太多？ 面对重复繁杂的程序化工作，我选择编程，面对文件操作我选择python，通过程序化方式将解除单元格保护的步骤写为一个python程序，最后编译为exe文件直接在电脑上运行 仓库地址：removeProtection 程序截图： ","date":"2023-03-05","objectID":"/excel%E5%8E%BB%E9%99%A4%E5%8D%95%E5%85%83%E6%A0%BC%E4%BF%9D%E6%8A%A4/:0:1","tags":["Excel"],"title":"Excel去除单元格保护","uri":"/excel%E5%8E%BB%E9%99%A4%E5%8D%95%E5%85%83%E6%A0%BC%E4%BF%9D%E6%8A%A4/"},{"categories":["hugo"],"content":"为什么要配置自动发布 基于前面的方案中，一次更新过程如下： 在本地写好md文章 用hugo发布到public/目录下 复制到本地仓库(也可以将git本地仓库配置到public/目录下，但因为我同时也在用git管理md，这么做会将两个项目的git纠缠在一起，不够清爽，违背我的审美) 再推到远程仓库 这样做的弊端是： 本地必须管理两个git仓库，一个是hugo-md源码库，另一个是生成的静态网页库，增加了更新文章的复杂度； 发布必须先发一个本地，然后手动上传，也增加了出错的风险。 一个理想的状态是，我只负责写文，和将好的md提交到git备份，然后就可以坐等网站内容更新了。github官方提供的GitHub Action正可以满足这个需求。 这样的需求下，整个Github Action只需要做两件事： 编译，生成静态文件 部署，把静态文件移动到合适的位置 比如放到某个云服务器上 或者放到 Github Pages 然后我们再通过git push来触发Github Action就可以了。 ","date":"2023-02-12","objectID":"/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/:0:1","tags":[],"title":"github action实现自动编译发布githubPages","uri":"/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/"},{"categories":["hugo"],"content":"准备 需要我们在github上准备两个仓库： 一个是存放博客源码的私有仓库 另一个是Github Pages公开库 ","date":"2023-02-12","objectID":"/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/:0:2","tags":[],"title":"github action实现自动编译发布githubPages","uri":"/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/"},{"categories":["hugo"],"content":"主要流程 配置私有库的Github Action 配置合适的token ","date":"2023-02-12","objectID":"/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/:0:3","tags":[],"title":"github action实现自动编译发布githubPages","uri":"/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/"},{"categories":["hugo"],"content":"具体实现 配置私有库的Github Action 在hugo博客根目录下，创建放置Github Action配置文件的目录 .github/workflows； 在 .github/workflows目录下，创建一个yml文件，这就是Github Action需要的一个工作流的配置，如果需要多个工作流可以创建多个yml文件； Hugo的官方文档Build Hugo With GitHub Action 中也推荐采用GitHub Actions作为持续集成部署方案，并提供了yml文件示例: name:github pageson:push:branches:- main # Set a branch to deploypull_request:jobs:deploy:runs-on:ubuntu-22.04steps:- uses:actions/checkout@v3with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:'latest'# extended: true- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3if:github.ref == 'refs/heads/main'with:github_token:${{ secrets.GITHUB_TOKEN }}publish_dir:./public 整个 Action 一个包含 4 个步骤： 拉取代码 准备 hugo 环境 使用 hugo 编译生成静态文件 把生成的静态文件发布到 Github Pages 可以根据自己的情况修改配置参数，最好和本地配置一致，可以避免版本不同造成的问题。我改了以下几处： jobs.build-deploy.runs-on改为ubuntu-20.04（为了和本地版本一致） jobs.build-deploy.steps.uses.with.hugo-version改为 “0.88.1” （为了和本地版本一致） token改用personal_token（github_token不支持外部库，我们采用的两个仓库的方案不能使用github_token） 增加cname配置自己的自定义域名 最终我的yml配置文件是这样的： name:build and deploy to pageson:push:branches:- masterjobs:build-deploy:# runs-on: ubuntu-20.04runs-on:ubuntu-20.04steps:- name:Check out sourceuses:actions/checkout@v2with:submodules:recursive # Fetch Hugo themes (true OR recursive)- name:Setup hugouses:peaceiris/actions-hugo@v2with:# hugo-version: \"latest\" # 可以修改为你使用的 Hugo 版本hugo-version:\"0.99.1\"#extended:true# 设置是否需要 extended 版本- name:Buildrun:hugo- name:Deployuses:peaceiris/actions-gh-pages@v3with:personal_token:${{ secrets.PERSONAL_TOKEN }}# 另外还支持 deploy_token 和 github_tokenexternal_repository:hubu8/hubu8.github.io# 修改为你的 GitHub Pages 仓库publish_dir:./public# keep_files: falsepublish_branch:master# 如果使用自定义域名，还需要添加下面一行配置# cname: www.goodfun.me 设置参数PERSONAL_TOKEN GITHUB_TOKEN 是一个特殊访问令牌,您可以使用它代表 GitHub Actions 进行身份验证 在用户设置中最下面找到Developer setting，在token中增加自己的token 随后点击generate token按钮之后会出现token,此时需要复制下来，后面会用到，不然重新打开界面是看不到的。 设置Action的serects ","date":"2023-02-12","objectID":"/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/:0:4","tags":[],"title":"github action实现自动编译发布githubPages","uri":"/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/"},{"categories":["java面试"],"content":"​ Java面向对象有哪些特征，如何应用 ​ 面向对象编程是利用类和对象编程的一种思想。万物可归类，类是对于世界事物的高度抽象 ，不同的事物之间有不同的关系 ，一个类自身与外界的封装关系，一个父类和子类的继承关系， 一个类和多个类的多态关系。万物皆对象，对象是具体的世界事物，面向对象的三大特征封装，继承，多态。封装，封装说明一个类行为和属性与其他类的关系，低耦合，高内聚；继承是父类和子类的关系，多态说的是类与类的关系。 ​ 封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。属性的封装：使用者只能通过事先定制好的方法来访问数据，可以方便地加入逻辑控制，限制对属性的 不合理操作；方法的封装：使用者按照既定的方式调用方法，不必关心方法的内部实现，便于使用； 便于修改，增强 代码的可维护性； ​ 继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。在本质上是特殊~一般的关系，即常说的is-a关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性 ，当实现类用extends关键字继承了基类（父类）后，实现类就具备了这些相同的属性。继承的类叫做子类（派生类或者超类），被继承的类叫做父类（或者基类）。比如从猫类、狗类、虎类中可以抽象出一个动物类，具有和猫、狗、虎类的共同特性（吃、跑、叫等）。Java通过extends关键字来实现继承，父类中通过private定义的变量和方法不会被继承，不能在子类中直接操作父类通过private定义的变量以及方法。继承避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围，在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。 ​ 相比于封装和继承，Java多态是三大特性中比较难的一个，封装和继承最后归结于多态， 多态指的是类和类的关系，两个类由继承关系，存在有方法的重写，故而可以在调用时有父类引用指向子类对象。多态必备三个要素：继承，重写，父类引用指向子类对象。 HashMap原理是什么，在jdk1.7和1.8中有什么区别 HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍 HashMap 的结构。 JAVA7 实现 大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色 的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 loadFactor：负载因子，默认为 0.75。 threshold：扩容的阈值，等于 capacity * loadFactor **JAVA8实现 ** Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。 根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决 于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 ArrayList和LinkedList有什么区别 ArrayList和LinkedList都实现了List接口，他们有以下的不同点： ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。 LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 也可以参考ArrayList vs. LinkedList。 因为 Array 是基于索引 (index) 的数据结构，它使用索引在数组中搜索和读取数据是很快的。 Array 获取数据的时间复杂度是 O(1), 但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。 相对于 ArrayList ， LinkedList 插入是更快的。因为 LinkedList 不像 ArrayList 一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是 ArrayList 最坏的一种情况，时间复杂度是 O(n) ，而 LinkedList 中插入或删除的时间复杂度仅为 O(1) 。 ArrayList 在插入数据时还需要更新索引（除了插入数组的尾部）。 类似于插入数据，删除数据时， LinkedList 也优于 ArrayList 。 LinkedList 需要更多的内存，因为 ArrayList 的每个索引的位置是实际的数据，而 LinkedList 中的每个节点中存储的是实际的数据和前后节点的位置 ( 一个 LinkedList 实例存储了两个值： Node first 和 Node last 分别表示链表的其实节点和尾节点，每个 Node 实例存储了三个值： E item,Node next,Node pre) 。 什么场景下更适宜使用 LinkedList，而不用ArrayList 你的应用不会随机访问数据 。因为如果你需要LinkedList中的第n个元素的时候，你需要从第一个元素顺序数到第n个数据，然后读取数据。 你的应用更多的插入和删除元素，更少的读取数据 。因为插入和删除元素不涉及重排数据，所以它要比ArrayList要快。 换句话说，ArrayList的实现用的是数组，LinkedList是基于链表，ArrayList适合查找，LinkedList适合增删 以上就是关于 ArrayList和LinkedList的差别。你需要一个不同步的基于索引的数据访问时，请尽量使用ArrayList。ArrayList很快，也很容易使用。但是要记得要给定一个合适的初始大小，尽可能的减少更改数组的大小。 高并发中的集合有哪些问题 **第一代线程安全集合类 ** Vector、Hashtable 是怎么保证线程安排的： 使用synchronized修饰方法* 缺点：效率低下 第二代线程非安全集合类 ArrayList、HashMap 线程不安全，但是性能好，用来替代Vector、Hashtable 使用ArrayList、HashMap，需要线程安全怎么办呢？ 使用 Collections.synchronizedList(list); Collections.synchronizedMap(m); 底层使用synchronized代码块锁 虽然也是锁住了所有的代码，但是锁在方法里边，并所在方法外边性能可以理解为稍有提高吧。毕竟进方法本身就要分配资源的 第三代线程安全集合类 在大量并发情况下如何提高集合的效率和安全呢？ java.util.concurrent.* ConcurrentHashMap： CopyOnWriteArrayList ： CopyOnWriteArraySet： 注意 不是CopyOnWriteHashSet* 底层大都采用Lock锁（1.8的ConcurrentHashMap不使用Lock锁），保证安全的同时，性能也很高。 jdk1.8的新特性有哪些 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:0:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"一、接口的默认方法 Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下： 代码如下: interface Formula { double calculate(int a); default double sqrt(int a) { return Math.sqrt(a); } } Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 代码如下: Formula formula = new Formula() { @Override public double calculate(int a) { return sqrt(a * 100); } }; formula.calculate(100); // 100.0 formula.sqrt(16); // 4.0 文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。 译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:0:1","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"二、Lambda 表达式 首先看看在老版本的Java中是如何排列字符串的： 代码如下: List names = Arrays.asList(“peterF”, “anna”, “mike”, “xenia”); Collections.sort(names, new Comparator() { @Override public int compare(String a, String b) { return b.compareTo(a); } }); 只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式： 代码如下: Collections.sort(names, (String a, String b) -\u003e { return b.compareTo(a); }); 看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短： 代码如下: Collections.sort(names, (String a, String b) -\u003e b.compareTo(a)); 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点： 代码如下: Collections.sort(names, (a, b) -\u003e b.compareTo(a)); Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来： ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:0:2","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"三、函数式接口 Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。 示例如下： 代码如下: @FunctionalInterface interface Converter\u003cF, T\u003e { T convert(F from); } Converter\u003cString, Integer\u003e converter = (from) -\u003e Integer.valueOf(from); Integer converted = converter.convert(“123”); System.out.println(converted); // 123 需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。 译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:0:3","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"四、方法与构造函数引用 前一节中的代码还可以通过静态方法引用来表示： 代码如下: Converter\u003cString, Integer\u003e converter = Integer::valueOf; Integer converted = converter.convert(“123”); System.out.println(converted); // 123 Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法： 代码如下: converter = something::startsWith; String converted = converter.convert(“Java”); System.out.println(converted); // “J” 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： 代码如下: class Person { String firstName; String lastName; Person() {} Person(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } } 接下来我们指定一个用来创建Person对象的对象工厂接口： 代码如下: interface PersonFactory{ P create(String firstName, String lastName); } 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂： 代码如下: PersonFactory personFactory = Person::new; Person person = personFactory.create(“Peter”, “Parker”); 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:0:4","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"五、Lambda 作用域 在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:0:5","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"六、访问局部变量 我们可以直接在lambda表达式中访问外层的局部变量： 代码如下: final int num = 1; Converter\u003cInteger, String\u003e stringConverter = (from) -\u003e String.valueOf(from + num); stringConverter.convert(2); // 3 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确： 代码如下: int num = 1; Converter\u003cInteger, String\u003e stringConverter = (from) -\u003e String.valueOf(from + num); stringConverter.convert(2); // 3 不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译： 代码如下: int num = 1; Converter\u003cInteger, String\u003e stringConverter = (from) -\u003e String.valueOf(from + num); num = 3; 在lambda表达式中试图修改num同样是不允许的。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:0:6","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"七、访问对象字段与静态变量 和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的： 代码如下: class Lambda4 { static int outerStaticNum; int outerNum; void testScopes() { Converter\u003cInteger, String\u003e stringConverter1 = (from) -\u003e { outerNum = 23; return String.valueOf(from); }; Converter\u003cInteger, String\u003e stringConverter2 = (from) -\u003e { outerStaticNum = 72; return String.valueOf(from); }; } } ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:0:7","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"八、访问接口的默认方法 还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。 Lambda表达式中是无法访问到默认方法的，以下代码将无法编译： 代码如下: Formula formula = (a) -\u003e sqrt( a * 100); Built-in Functional Interfaces JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。 Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 Predicate****接口 Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）： 代码如下: Predicate predicate = (s) -\u003e s.length() \u003e 0; predicate.test(“foo”); // true predicate.negate().test(“foo”); // false Predicate nonNull = Objects::nonNull; Predicate isNull = Objects::isNull; Predicate isEmpty = String::isEmpty; Predicate isNotEmpty = isEmpty.negate(); Function 接口 Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）： 代码如下: Function\u003cString, Integer\u003e toInteger = Integer::valueOf; Function\u003cString, String\u003e backToString = toInteger.andThen(String::valueOf); backToString.apply(“123”); // “123” Supplier 接口 Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数 代码如下: Supplier personSupplier = Person::new; personSupplier.get(); // new Person Consumer 接口 Consumer 接口表示执行在单个参数上的操作。 代码如下: Consumer greeter = (p) -\u003e System.out.println(“Hello, \" + p.firstName); greeter.accept(new Person(“Luke”, “Skywalker”)); Comparator 接口 Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法： 代码如下: Comparator comparator = (p1, p2) -\u003e p1.firstName.compareTo(p2.firstName); Person p1 = new Person(“John”, “Doe”); Person p2 = new Person(“Alice”, “Wonderland”); comparator.compare(p1, p2); // \u003e 0 comparator.reversed().compare(p1, p2); // \u003c 0 Optional 接口 Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么： Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。 代码如下: Optional optional = Optional.of(“bam”); optional.isPresent(); // true optional.get(); // “bam” optional.orElse(“fallback”); // “bam” optional.ifPresent((s) -\u003e System.out.println(s.charAt(0))); // “b” Stream 接口 java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。 首先看看Stream是怎么用，首先创建实例代码的用到的数据List： 代码如下: List stringCollection = new ArrayList\u003c\u003e(); stringCollection.add(“ddd2”); stringCollection.add(“aaa2”); stringCollection.add(“bbb1”); stringCollection.add(“aaa1”); stringCollection.add(“bbb3”); stringCollection.add(“ccc”); stringCollection.add(“bbb2”); stringCollection.add(“ddd1”); Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作： Filter 过滤 过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。 代码如下: stringCollection .stream() .filter((s) -\u003e s.startsWith(“a”)) .forEach(System.out::println); // “aaa2”, “aaa1” Sort 排序 排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。 代码如下: stringCollection .stream() .sorted() .filter((s) -\u003e s.startsWith(“a”)) .forEach(System.out::println); // “aaa1”, “aaa2” 需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的： 代码如下: System.out.println(stringCollection); // ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1 Map 映射 中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。 代码如下: stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -\u003e b.compareTo(a)) .forEach(System.out::println); // “DDD2”, “DDD1”, “CCC”, “BBB3”, “BBB2”, “AAA2”, “AAA1” Match 匹配 Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。 代码如下: boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -\u003e s.startsWith(“a”)); System.out.println(anyStartsWithA); // true boolean allStartsWithA = stringCollection .stream() .allMatch((s) -\u003e s.startsWith(“a”)); System.out.println(allStartsWithA); // false boolean n","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:0:8","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"九、Date API Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分： Clock 时钟 Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。 代码如下: Clock clock = Clock.systemDefaultZone(); long millis = clock.millis(); Instant instant = clock.instant(); Date legacyDate = Date.from(instant); // legacy java.util.Date Timezones 时区 在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。 代码如下: System.out.println(ZoneId.getAvailableZoneIds()); // prints all available timezone ids ZoneId zone1 = ZoneId.of(“Europe/Berlin”); ZoneId zone2 = ZoneId.of(“Brazil/East”); System.out.println(zone1.getRules()); System.out.println(zone2.getRules()); // ZoneRules[currentStandardOffset=+01:00] // ZoneRules[currentStandardOffset=-03:00] LocalTime 本地时间 LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差： 代码如下: LocalTime now1 = LocalTime.now(zone1); LocalTime now2 = LocalTime.now(zone2); System.out.println(now1.isBefore(now2)); // false long hoursBetween = ChronoUnit.HOURS.between(now1, now2); long minutesBetween = ChronoUnit.MINUTES.between(now1, now2); System.out.println(hoursBetween); // -3 System.out.println(minutesBetween); // -239 LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。 代码如下: LocalTime late = LocalTime.of(23, 59, 59); System.out.println(late); // 23:59:59 DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN); LocalTime leetTime = LocalTime.parse(“13:37”, germanFormatter); System.out.println(leetTime); // 13:37 LocalDate 本地日期 LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。 代码如下: LocalDate today = LocalDate.now(); LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS); LocalDate yesterday = tomorrow.minusDays(2); LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4); DayOfWeek dayOfWeek = independenceDay.getDayOfWeek(); System.out.println(dayOfWeek); // FRIDAY 从字符串解析一个LocalDate类型和解析LocalTime一样简单： 代码如下: DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN); LocalDate xmas = LocalDate.parse(“24.12.2014”, germanFormatter); System.out.println(xmas); // 2014-12-24 LocalDateTime 本地日期时间 LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。 代码如下: LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59); DayOfWeek dayOfWeek = sylvester.getDayOfWeek(); System.out.println(dayOfWeek); // WEDNESDAY Month month = sylvester.getMonth(); System.out.println(month); // DECEMBER long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY); System.out.println(minuteOfDay); // 1439 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。 代码如下: Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant(); Date legacyDate = Date.from(instant); System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式： 代码如下: DateTimeFormatter formatter = DateTimeFormatter .ofPattern(“MMM dd, yyyy - HH:mm”); LocalDateTime parsed = LocalDateTime.parse(“Nov 03, 2014 - 07:13”, formatter); String string = formatter.format(parsed); System.out.println(string); // Nov 03, 2014 - 07:13 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:0:9","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"十、Annotation 注解 在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。 首先定义一个包装类Hints注解用来放置一组具体的Hint注解： 代码如下: @interface Hints { Hint[] value(); } @Repeatable(Hints.class) @interface Hint { String value(); } Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。 例 1: 使用包装类当容器来存多个注解（老方法） 代码如下: @Hints({@Hint(“hint1”), @Hint(“hint2”)}) class Person {} 例 2：使用多重注解（新方法） 代码如下: @Hint(“hint1”) @Hint(“hint2”) class Person {} 第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息： 代码如下: Hint hint = Person.class.getAnnotation(Hint.class); System.out.println(hint); // null Hints hints1 = Person.class.getAnnotation(Hints.class); System.out.println(hints1.value().length); // 2 Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class); System.out.println(hints2.length); // 2 即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。 另外Java 8的注解还增加到两种新的target上了： 代码如下: @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE}) @interface MyAnnotation {} 关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。 Java中重写和重载有哪些区别 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态 性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为 重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方 法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 方法重载的规则： 1.方法名一致，参数列表中参数的顺序，类型，个数不同。 2.重载与方法的返回值无关，存在于父类和子类，同类中。 3.可以抛出不同的异常，可以有不同修饰符 方法重写的规则： 1.参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。 2.构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，但是能够被再次 声明。 3.访问权限不能比父类中被重写的方法的访问权限更低。 4.重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是 否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则 可以。 接口和抽象类有哪些区别 不同： 抽象类： 1.抽象类中可以定义构造器 2.可以有抽象方法和具体方法 3.接口中的成员全都是 public 的 4.抽象类中可以定义成员变量 5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法 6.抽象类中可以包含静态方法 7.一个类只能继承一个抽象类 接口： 1.接口中不能定义构造器 2.方法全部都是抽象方法 3.抽象类中的成员可以是 private、默认、protected、public 4.接口中定义的成员变量实际上都是常量 5.接口中不能有静态方法 6.一个类可以实现多个接口 相同： 1.不能够实例化 2.可以将抽象类和接口类型作为引用类型 3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要 被声明为抽象类 怎样声明一个类不会被继承，什么场景下会用 如果一个类被final修饰，此类不可以有子类，不能被其它类继承，如果一个中的所有方法都没有重写的需要，当前类没有子类也罢，就可以使用final修饰类。 Java中==和equals有哪些区别 equals 和== 最大的区别是一个是方法一个是运算符。 ==：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象 的地址值是否相等。 equals()：用来比较方法两个对象的内容是否相等。 注意：equals 方法不能用于基本数据类型的变量，如果没有对 equals 方法进行重写，则比较的是引用类型的变 量所指向的对象的地址。 String、StringBuffer、StringBuilder区别及使用场景 Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们都可以储存和操作字符串，区别 如下。 1）String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。初学者可能会有这样的误解： String str = “abc”； str = “bcd”; 如上，字符串 str 明明是可以改变的呀！其实不然，str 仅仅是一个引用对象，它指向一个字符串对象“abc”。第 二行代码的含义是让 str 重新指向了一个新的字符串“bcd”对象，而“abc”对象并没有任何改变，只不过该对象已 经成为一个不可及对象罢了。 2）StringBuffer/StringBuilder 表示的字符串对象可以直接进行修改。 3）StringBuilder 是 Java5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的， 因为它的所有方法都没有被 synchronized 修饰，因此它的效率理论上也比 StringBuffer 要高。 Java代理的几种实现方式 第一种:静态代理,只能静态的代理某些类或者某些方法,不推荐使用,功能比较弱,但是编码简单 第二种:动态代理,包含Proxy代理和CGLIB动态代理 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:0:10","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Proxy代理是JDK内置的动态代理 ​ 特点:面向接口的,不需要导入三方依赖的动态代理,可以对多个不同的接口进行增强,通过反射读取注解时,只能读取到接口上的注解 ​ 原理:面向接口,只能对实现类在实现接口中定义的方法进行增强 定义接口和实现 package com.proxy; public interface UserService { public String getName(int id); public Integer getAge(int id); } package com.proxy; public class UserServiceImpl implements UserService { @Override public String getName(int id) { System.out.println(\"------getName------\"); return \"riemann\"; } @Override public Integer getAge(int id) { System.out.println(\"------getAge------\"); return 26; } } package com.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class MyInvocationHandler implements InvocationHandler { public Object target; MyInvocationHandler() { super(); } MyInvocationHandler(Object target) { super(); this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (\"getName\".equals(method.getName())) { System.out.println(\"++++++before \" + method.getName() + \"++++++\"); Object result = method.invoke(target, args); System.out.println(\"++++++after \" + method.getName() + \"++++++\"); return result; } else { Object result = method.invoke(target, args); return result; } } } package com.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Main1 { public static void main(String[] args) { UserService userService = new UserServiceImpl(); InvocationHandler invocationHandler = new MyInvocationHandler(userService); UserService userServiceProxy = (UserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(), userService.getClass().getInterfaces(),invocationHandler); System.out.println(userServiceProxy.getName(1)); System.out.println(userServiceProxy.getAge(1)); } } ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:1:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"CGLIB动态代理 ​ 特点:面向父类的动态代理,需要导入第三方依赖 ​ 原理:面向父类,底层通过子类继承父类并重写方法的形式实现增强 Proxy和CGLIB是非常重要的代理模式,是springAOP底层实现的主要两种方式 CGLIB的核心类： net.sf.cglib.proxy.Enhancer – 主要的增强类 net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现 net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用： Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。 net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法 public Object intercept(Object object, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable; 第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快。 package com.proxy.cglib; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class CglibProxy implements MethodInterceptor { @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\"++++++before \" + methodProxy.getSuperName() + \"++++++\"); System.out.println(method.getName()); Object o1 = methodProxy.invokeSuper(o, args); System.out.println(\"++++++before \" + methodProxy.getSuperName() + \"++++++\"); return o1; } } package com.proxy.cglib; import com.test3.service.UserService; import com.test3.service.impl.UserServiceImpl; import net.sf.cglib.proxy.Enhancer; public class Main2 { public static void main(String[] args) { CglibProxy cglibProxy = new CglibProxy(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(UserServiceImpl.class); enhancer.setCallback(cglibProxy); UserService o = (UserService)enhancer.create(); o.getName(1); o.getAge(1); } } hashcode和equals如何使用 equals()源自于java.lang.Object,该方法用来简单验证两个对象的相等性。Object类中定义的默认实现只检查两个对象的对象引用，以验证它们的相等性。 通过重写该方法,可以自定义验证对象相等新的规则,如果你使用ORM处理一些对象的话，你要确保在hashCode()和equals()对象中使用getter和setter而不是直接引用成员变量 hashCode()源自于java.lang.Object ,该方法用于获取给定对象的唯一的整数(散列码)。当这个对象需要存储在哈希表这样的数据结构时，这个整数用于确定桶的位置。默认情况下，对象的hashCode()方法返回对象所在内存地址的整数表示。hashCode()是HashTable、HashMap和HashSet使用的。默认的，Object类的hashCode()方法返回这个对象存储的内存地址的编号。 hash散列算法,使得在hash表中查找一个记录速度变O(1). 每个记录都有自己的hashcode,散列算法按照hashcode把记录放置在合适的位置. 在查找一个记录,首先先通过hashcode快速定位记录的位置.然后再通过equals来比较是否相等。如果hashcode没找到，则不equal，元素不存在于哈希表中；即使找到了，也只需执行hashcode相同的几个元素的equal，如果不equal，还是不存在哈希表中。 HashMap和HashTable的区别及底层实现 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:2:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"HashMap和HashTable对比 HashTable线程同步，HashMap非线程同步。 HashTable不允许\u003c键,值\u003e有空值，HashMap允许\u003c键,值\u003e有空值。 HashTable使用Enumeration，HashMap使用Iterator。 HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小是16，增长方式是2的指数倍。 5.HashMap jdk1.8之前list + 链表 jdk1.8之后list + 链表,当链表长度到8时，转化为红黑树 6.HashMap链表插入节点的方式 在Java1.7中，插入链表节点使用头插法。Java1.8中变成了尾插法 7.Java1.8的hash()中，将hash值高位（前16位）参与到取模的运算中，使得计算结果的不确定性增强，降低发生哈希碰撞的概率 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:3:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"HashMap扩容优化: 扩容以后,1.7对元素进行rehash算法,计算原来每个元素在扩容之后的哈希表中的位置,1.8借助2倍扩容机制,元素不需要进行重新计算位置 JDK 1.8 在扩容时并没有像 JDK 1.7 那样，重新计算每个元素的哈希值，而是通过高位运算**（e.hash \u0026 oldCap）**来确定元素是否需要移动，比如 key1 的信息如下： 使用 e.hash \u0026 oldCap 得到的结果，高一位为 0，当结果为 0 时表示元素在扩容时位置不会发生任何变化，而 key 2 信息如下 高一位为 1，当结果为 1 时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度**hashmap,**不必像1.7一样全部重新计算位置 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:4:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"为什么hashmap扩容的时候是两倍？ 查看源代码 在存入元素时,放入元素位置有一个 (n-1)\u0026hash 的一个算法,和hash\u0026(newCap-1),这里用到了一个\u0026位运算符 当HashMap的容量是16时，它的二进制是10000，(n-1)的二进制是01111，与hash值得计算结果如下 下面就来看一下HashMap的容量不是2的n次幂的情况，当容量为10时，二进制为01010，(n-1)的二进制是01001，向里面添加同样的元素，结果为 可以看出，有三个不同的元素进过\u0026运算得出了同样的结果，严重的hash碰撞了 只有当n的值是2的N次幂的时候，进行\u0026位运算的时候，才可以只看后几位，而不需要全部进行计算 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:5:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"hashmap线程安全的方式？ HashMap不是线程安全的,往往在写程序时需要通过一些方法来回避.其实JDK原生的提供了2种方法让HashMap支持线程安全. 方法一:通过Collections.synchronizedMap()返回一个新的Map,这个新的map就是线程安全的. 这个要求大家习惯基于接口编程,因为返回的并不是HashMap,而是一个Map的实现. 方法二:重新改写了HashMap,具体的可以查看java.util.concurrent.ConcurrentHashMap. 这个方法比方法一有了很大的改进. 方法一特点: 通过Collections.synchronizedMap()来封装所有不安全的HashMap的方法,就连toString, hashCode都进行了封装. 封装的关键点有2处,1)使用了经典的synchronized来进行互斥, 2)使用了代理模式new了一个新的类,这个类同样实现了Map接口.在Hashmap上面,synchronized锁住的是对象,所以第一个申请的得到锁,其他线程将进入阻塞,等待唤醒. 优点:代码实现十分简单,一看就懂.缺点:从锁的角度来看,方法一直接使用了锁住方法,基本上是锁住了尽可能大的代码块.性能会比较差. 方法二特点: 重新写了HashMap,比较大的改变有如下几点.使用了新的锁机制,把HashMap进行了拆分,拆分成了多个独立的块,这样在高并发的情况下减少了锁冲突的可能,使用的是NonfairSync. 这个特性调用CAS指令来确保原子性与互斥性.当如果多个线程恰好操作到同一个segment上面,那么只会有一个线程得到运行. 优点:需要互斥的代码段比较少,性能会比较好. ConcurrentHashMap把整个Map切分成了多个块,发生锁碰撞的几率大大降低,性能会比较好. 缺点:代码繁琐 Java异常处理方式 Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对 象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、 catch、throw、throws 和 finally。 在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。 throw和throws的区别： （1）位置不同： throw：方法内部 throws: 方法的签名处，方法的声明处 （2）内容不同： throw+异常对象（检查异常，运行时异常） throws+异常的类型（可以多个类型，用，拼接） （3）作用不同： throw：异常出现的源头，制造异常。 throws:在方法的声明处，告诉方法的调用者，这个方法中可能会出现我声明的这些异常。然后调用者对这个异常进行处理： 要么自己处理要么再继续向外抛出异常 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:6:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"1.throws声明异常 通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下 去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。注意 非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。 ​ 一个方法出现编译时异常，就需要 try-catch/ throws 处理，否则会导致编译错误 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:7:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"2.throw抛出异常 如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。 throw关键字作用是在方法内部抛出一个Throwable类型的异常。任何Java代码都可以通过throw语句抛出异常。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:8:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"3.trycatch捕获异常 程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。如何选择异常类型 可以根据下图来选择是捕获异常，声明异常还是抛出异常 自定义异常在生产中如何应用 Java虽然提供了丰富的异常处理类，但是在项目中还会经常使用自定义异常，其主要原因是Java提供的异常类在某些情况下还是不能满足实际需球。例如以下情况： 1、系统中有些错误是符合Java语法，但不符合业务逻辑。 2、在分层的软件结构中，通常是在表现层统一对系统其他层次的异常进行捕获处理。 如何实现一个IOC容器? ​ IOC(Inversion of Control),意思是控制反转，不是什么技术，而是一种设计思想，IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。 ​ 在传统的程序设计中，我们直接在对象内部通过new进行对象创建，是程序主动去创建依赖对象，而IOC是有专门的容器来进行对象的创建，即IOC容器来控制对象的创建。 ​ 在传统的应用程序中，我们是在对象中主动控制去直接获取依赖对象，这个是正转，反转是由容器来帮忙创建及注入依赖对象，在这个过程过程中，由容器帮我们查找级注入依赖对象，对象只是被动的接受依赖对象。 ​ 1、先准备一个基本的容器对象，包含一些map结构的集合，用来方便后续过程中存储具体的对象 ​ 2、进行配置文件的读取工作或者注解的解析工作，将需要创建的bean对象都封装成BeanDefinition对象存储在容器中 ​ 3、容器将封装好的BeanDefinition对象通过反射的方式进行实例化，完成对象的实例化工作 ​ 4、进行对象的初始化操作，也就是给类中的对应属性值就行设置，也就是进行依赖注入，完成整个对象的创建，变成一个完整的bean对象，存储在容器的某个map结构中 ​ 5、通过容器对象来获取对象，进行对象的获取和逻辑处理工作 ​ 6、提供销毁操作，当对象不用或者容器关闭的时候，将无用的对象进行销毁 说说你对Spring 的理解？ 官网地址：https://spring.io/projects/spring-framework#overview 压缩包下载地址：https://repo.spring.io/release/org/springframework/spring/ 源码地址：https://github.com/spring-projects/spring-framework Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment, with support for Groovy and Kotlin as alternative languages on the JVM, and with the flexibility to create many kinds of architectures depending on an application’s needs. As of Spring Framework 5.1, Spring requires JDK 8+ (Java SE 8+) and provides out-of-the-box support for JDK 11 LTS. Java SE 8 update 60 is suggested as the minimum patch release for Java 8, but it is generally recommended to use a recent patch release. Spring supports a wide range of application scenarios. In a large enterprise, applications often exist for a long time and have to run on a JDK and application server whose upgrade cycle is beyond developer control. Others may run as a single jar with the server embedded, possibly in a cloud environment. Yet others may be standalone applications (such as batch or integration workloads) that do not need a server. Spring is open source. It has a large and active community that provides continuous feedback based on a diverse range of real-world use cases. This has helped Spring to successfully evolve over a very long time. Spring 使创建 Java 企业应用程序变得更加容易。它提供了在企业环境中接受 Java 语言所需的一切,，并支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并可根据应用程序的需要灵活地创建多种体系结构。 从 Spring Framework 5.0 开始，Spring 需要 JDK 8(Java SE 8+)，并且已经为 JDK 9 提供了现成的支持。 Spring支持各种应用场景， 在大型企业中, 应用程序通常需要运行很长时间，而且必须运行在 jdk 和应用服务器上，这种场景开发人员无法控制其升级周期。 其他可能作为一个单独的jar嵌入到服务器去运行，也有可能在云环境中。还有一些可能是不需要服务器的独立应用程序(如批处理或集成的工作任务)。 Spring 是开源的。它拥有一个庞大而且活跃的社区，提供不同范围的，真实用户的持续反馈。这也帮助Spring不断地改进,不断发展。 你觉得Spring的核心是什么？ ​ spring是一个开源框架。 ​ spring是为了简化企业开发而生的，使得开发变得更加优雅和简洁。 ​ spring是一个IOC和AOP的容器框架。 ​ IOC：控制反转 ​ AOP：面向切面编程 ​ 容器：包含并管理应用对象的生命周期，就好比用桶装水一样，spring就是桶，而对象就是水 说一下使用spring的优势？ ​ 1、Spring通过DI、AOP和消除样板式代码来简化企业级Java开发 ​ 2、Spring框架之外还存在一个构建在核心框架之上的庞大生态圈，它将Spring扩展到不同的领域，如Web服务、REST、移动开发以及NoSQL ​ 3、低侵入式设计，代码的污染极低 ​ 4、独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once,Run Anywhere的承诺 ​ 5、Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦 ​ 6、Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式处理，从而提供了更好的复用 ​ 7、Spring的ORM和DAO提供了与第三方持久层框架的的良好整合，并简化了底层的数据库访问 ​ 8、Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部 Spring是如何简化开发的？ ​ 基于POJO的轻量级和最小侵入性编程 ​ 通过依赖注入和面向接口实现松耦合 ​ 基于切面和惯例进行声明式编程 ​ 通过切面和模板减少样板式代码 说说你对Aop的理解？ ​ AOP全称叫做 Aspect Oriented Programming 面向切面编程。它是为解耦而生的，解耦是程序员编码开发过程中一直追求的境界，AOP在业务类的隔离上，绝对是做到了解耦，在这里面有几个核心的概念： 切面（Aspect）: 指关注点模块化，这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。 在Spring AOP中，切面可以使用通用类基于模式的方式（schema-based approach）或者在普通类中以@Aspect注解（@AspectJ 注解方式）来实现。 连接点（Join point）: 在程序执行过程中某个特定的点，例如某个方法调用的时间点或者处理异常的时间点。在Spring AOP中，一个连接点总是代表一个方法的执行。 通知（Advice）: 在切面的某个特定的连接点上执行的动作。通知有多种类型，包括“around”, “before” and “after”等等。通知的类型将在后面的章节进行讨论。 许多AOP框架，包括Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链。 切点（Pointcut）: 匹配连接点的断言。通知和切点表达式相关联，并在满足这个切点的连接点上运行（例如，当执行某个特定名称的方法时）。切点表达式如何和连接点匹配是AOP的核心：Spring默认使用AspectJ切点语义。 引入（Intro","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:9:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":" 双亲委派机制 双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 双亲委派的好处 每一个类都只会被加载一次，避免了重复加载 每一个类都会被尽可能的加载（从引导类加载器往下，每个加载器都可能会根据优先次序尝试加载它） 有效避免了某些恶意类的加载（比如自定义了Java.lang.Object类，一般而言在双亲委派模型下会加载系统的Object类而不是自定义的Object类） 另外，可以多讲一下，如何破坏双亲委派模型 双亲委派模型的第一次“被破坏”是重写自定义加载器的loadClass(),jdk不推荐。一般都只是重写findClass()，这样可以保持双亲委派机制.而loadClass方法加载规则由自己定义，就可以随心所欲的加载类 双亲委派模型的第二次“被破坏”是ServiceLoader和Thread.setContextClassLoader()。即线程上下文类加载器（contextClassLoader）。双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢？线程上下文类加载器就出现了。 SPI。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。 线程上下文类加载器默认情况下就是AppClassLoader，那为什么不直接通过getSystemClassLoader()获取类加载器来加载classpath路径下的类的呢？其实是可行的，但这种直接使用getSystemClassLoader()方法获取AppClassLoader加载类有一个缺点，那就是代码部署到不同服务时会出现问题，如把代码部署到Java Web应用服务或者EJB之类的服务将会出问题，因为这些服务使用的线程上下文类加载器并非AppClassLoader，而是Java Web应用服自家的类加载器，类加载器不同。，所以我们应用该少用getSystemClassLoader()。总之不同的服务使用的可能默认ClassLoader是不同的，但使用线程上下文类加载器总能获取到与当前程序执行相同的ClassLoader，从而避免不必要的问题 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。 GC如何判断对象可以被回收？ 引用计数法（已被淘汰的算法） 每一个对象有一个引用属性，新增一个引用时加一，引用释放时减一，计数为0的时候可以回收。 但是这种计算方法，有一个致命的问题，无法解决循环引用的问题 可达性分析算法（根引用） 从GcRoot开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GcRoot没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就可以判定回收。 那么GcRoot有哪些？ 虚拟机栈中引用的对象 方法区中静态属性引用的对象。 方法区中常量引用的对象 本地方法栈中（即一般说的native方法）引用的对象 此外，不同的引用类型的回收机制是不一样的 强引用：通过关键字new的对象就是强引用对象，强引用指向的对象任何时候都不会被回收，宁愿OOM也不会回收。 软引用：如果一个对象持有软引用，那么当JVM堆空间不足时，会被回收。一个类的软引用可以通过java.lang.ref.SoftReference持有。 弱引用：如果一个对象持有弱引用，那么在GC时，只要发现弱引用对象，就会被回收。一个类的弱引用可以通过java.lang.ref.WeakReference持有。 虚引用：几乎和没有一样，随时可以被回收。通过PhantomReference持有。 如何回收内存对象，有哪些回收算法？ 1.标记-清除（Mark-Sweep）算法 分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它的主要不足有两个： 效率问题，标记和清除两个过程的效率都不高。 空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法 为了解决效率问题，一种称为复制（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 复制算法的代价是将内存缩小为了原来的一半，减少了实际可用的内存。现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。 标记-整理算法 复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。根据老年代的特点，有人提出了另外一种标记-整理（Mark-Compact）算法，标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法 当前商业虚拟机的垃圾收集都采用分代收集（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清理或者标记—整理算法来进行回收。 jvm有哪些垃圾回收器，实际中如何选择？ 图中展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，则说明它们可以搭配使用。虚拟机所处的区域则表示它是属于新生代还是老年代收集器。 新生代收集器（全部的都是复制算法）：Serial、ParNew、Parallel Scavenge 老年代收集器：CMS（标记-清理）、Serial Old（标记-整理）、Parallel Old（标记整理） 整堆收集器： G1（一个Region中是标记-清除算法，2个Region之间是复制算法） 同时，先解释几个名词： 1，并行（Parallel）：多个垃圾收集线程并行工作，此时用户线程处于等待状态 2，并发（Concurrent）：用户线程和垃圾收集线程同时执行 3，吞吐量：运行用户代码时间／（运行用户代码时间＋垃圾回收时间） 1.Serial收集器是最基本的、发展历史最悠久的收集器。 **特点：**单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。 应用场景：适用于Client模式下的虚拟机。 Serial / Serial Old收集器运行示意图 2.ParNew收集器其实就是Serial收集器的多线程版本。 除了使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、S","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:10:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"大前提： 先读缓存，如果缓存没有，才从数据库读取。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:10:1","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"(1)先更新数据库，再更新缓存 这套方案，大家是普遍反对的。为什么呢？有如下两点原因。 原因一（线程安全角度） 同时有请求A和请求B进行更新操作，那么会出现 （1）线程A更新了数据库 （2）线程B更新了数据库 （3）线程B更新了缓存 （4）线程A更新了缓存 这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。 原因二（业务场景角度） 有如下两点： （1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。 （2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。 接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:10:2","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"(2)先删缓存，再更新数据库 该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形: （1）请求A进行写操作，删除缓存 （2）请求B查询发现缓存不存在 （3）请求B去数据库查询得到旧值 （4）请求B将旧值写入缓存 （5）请求A将新值写入数据库 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。 那么，如何解决呢？采用延时双删策略 （1）先淘汰缓存 （2）再写数据库（这两步和原来一样） （3）休眠1秒，再次淘汰缓存 这么做，可以将1秒内所造成的缓存脏数据，再次删除。 那么，这个1秒怎么确定的，具体该休眠多久呢？ 针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。 如果你用了mysql的读写分离架构怎么办？ ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。 （1）请求A进行写操作，删除缓存 （2）请求A将数据写入数据库了， （3）请求B查询缓存发现，缓存没有值 （4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值 （5）请求B将旧值写入缓存 （6）数据库完成主从同步，从库变为新值 上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。 采用这种同步淘汰策略，吞吐量降低怎么办？ ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。 第二次删除,如果删除失败怎么办？ 这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库： （1）请求A进行写操作，删除缓存 （2）请求B查询发现缓存不存在 （3）请求B去数据库查询得到旧值 （4）请求B将旧值写入缓存 （5）请求A将新值写入数据库 （6）请求A试图去删除，请求B写入对的缓存值，结果失败了。 ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。 如何解决呢？ ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:10:3","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"(3)先更新数据库，再删缓存 首先，先说一下。老外提出了一个缓存更新套路，名为《Cache-Aside pattern》。其中就指出 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。 命中：应用程序从cache中取数据，取到后返回。 更新：先把数据存到数据库中，成功后，再让缓存失效。 另外，知名社交网站facebook也在论文《Scaling Memcache at Facebook》中提出，他们用的也是先更新数据库，再删缓存的策略。 这种情况不存在并发问题么？ 不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生 （1）缓存刚好失效 （2）请求A查询数据库，得一个旧值 （3）请求B将新值写入数据库 （4）请求B删除缓存 （5）请求A将查到的旧值写入缓存 ok，如果发生上述情况，确实是会发生脏数据。 然而，发生这种情况的概率又有多少呢？ 发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。 假设，有人非要抬杠，有强迫症，一定要解决怎么办？ 如何解决上述并发问题？ 首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。 还有其他造成不一致的原因么？ 有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。 如何解决？ 提供一个保障的重试机制即可，这里给出两套方案。 方案一： 如下图所示 流程如下所示 （1）更新数据库数据； （2）缓存因为种种问题删除失败 （3）将需要删除的key发送至消息队列 （4）自己消费消息，获得需要删除的key （5）继续重试删除操作，直到成功 然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。 方案二： 流程如下图所示： （1）更新数据库数据 （2）数据库会将操作信息写入binlog日志当中 （3）订阅程序提取出所需要的数据以及key （4）另起一段非业务代码，获得该信息 （5）尝试删除缓存操作，发现删除失败 （6）将这些信息发送至消息队列 （7）重新从消息队列中获得该数据，重试操作。 **备注说明：**上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。 分布式微服务项目你是如何设计的？ 我一般设计成两层：业务层和能力层（中台），业务层接受用户请求，然后通过调用能力层来完成业务逻辑。 认证 (Authentication) 和授权 (Authorization)的区别是什么？ Authentication（认证） 是验证您的身份的凭据（例如用户名/用户ID和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。 Authorization（授权） 发生在 Authentication（认证） 之后。授权，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。 这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。 Cookie 和 Session 有什么区别？如何使用Session进行身份验证？ Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。 Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。 那么，如何使用Session进行身份验证？ 很多时候我们都是通过 SessionID 来实现特定的用户，SessionID 一般会选择存放在 Redis 中。举个例子：用户成功登陆系统，然后返回给客户端具有 SessionID 的 Cookie，当用户向后端发起请求的时候会把 SessionID 带上，这样后端就知道你的身份状态了。关于这种认证方式更详细的过程如下： 用户向服务器发送用户名和密码用于登陆系统。 服务器验证通过后，服务器为用户创建一个 Session，并将 Session信息存储 起来。 服务器向用户返回一个 SessionID，写入用户的 Cookie。 当用户保持登录状态时，Cookie 将与每个后续请求一起被发送出去。 服务器可以将存储在 Cookie 上的 Session ID 与存储在内存中或者数据库中的 Session 信息进行比较，以验证用户的身份，返回给用户客户端响应信息的时候会附带用户当前的状态。 使用 Session 的时候需要注意下面几个点： 依赖Session的关键业务一定要确保客户端开启了Cookie。 注意Session的过期时间 为什么Cookie 无法防止CSRF攻击，而token可以？ **CSRF（Cross Site Request Forgery）**一般被翻译为 跨站请求伪造 。那么什么是 跨站请求伪造 呢？说简单用你的身份去发送一些对你不友好的请求。举个简单的例子： 小壮登录了某网上银行，他来到了网上银行的帖子区，看到一个帖子下面有一个链接写着“科学理财，年盈利率过万”，小壮好奇的点开了这个链接，结果发现自己的账户少了10000元。这是这么回事呢？原来黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。 \u003ca src=http://www.mybank.com/Transfer?bankId=11\u0026money=10000\u003e科学理财，年盈利率过万\u003c/\u003e 进行Session 认证的时候，我们一般使用 Cookie 来存储 SessionId,当我们登陆后后端生成一个SessionId放在Cookie中返回给客户端，服务端通过Redis或者其他存储工具记录保存着这个Sessionid，客户端登录以后每次请求都会带上这个SessionId，服务端通过这个SessionId来标示你这个人。如果别人通过 cookie拿到了 SessionId 后就可以代替你的身份访问系统了。 Session 认证中 Cookie 中的 SessionId是由浏览器发送到服务端的，借助这个特性，攻击者就可以通过让用户误点攻击链接，达到攻击效果。 但是，我们使用 token 的话就不会存在这个问题，在我们登录成功获得 token 之后，一般会选择存放在 local storage 中。然后我们在前端通过某些方式会给每个发到后端的请求加上这个 token,这样就不会出现 CSRF 漏洞的问题。因为，即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 token 的，所以这个请求将是非法的。 什么是 Token?什么是 JWT?如何基于Token进行身份验证？ 我们知道 Session 信息需要保存一份在服务器端。这种方式会带来一些麻烦，比如需要我们保证保存 Session 信息服务器的可用性、不适合移动端（依赖Cookie）等等。 有没有一种不需要自己存放 Session 信息就能实现身份验证的方式呢？使用 Token 即可！JWT （JSON Web Token） 就是这种方式的实现，通过这种方式服务器端就不需要保存 Session 数据了，只用在客户端保存服务端返回给客户的 Token 就可以了，扩展性得到提升。 JWT 本质上就一段签名的 JSON 格式的数据。由于它是带有签名的，因此接收者便可以验证它的真实性。 下面是 RFC 7519 对 JWT 做的较为正式的定义。 JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JW","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:10:4","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Redis 持久化 Redis 提供了不同级别的持久化方式: RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储. AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大. 如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式. 你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整. 最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始: ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:11:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"RDB的优点 RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集. RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复. RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能. 与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些. ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:12:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"RDB的缺点 如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你.虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据. RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度. ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:13:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"AOF 优点 使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据. AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题. Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。 AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:14:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"AOF 缺点 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:15:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"4.X版本的整合策略 在AOF重写策略上做了优化 在重写AOF文件时，4.x版本以前是把内存数据集的操作指令落地，而新版本是把内存的数据集以rdb的形式落地 这样重写后的AOF依然追加的是日志，但是，在恢复的时候是先rdb再增量的日志，性能更优秀 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:16:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"扩展知识 异步线程知识点 计算机组成原理 fork copy on write 系统IO pagecache fsync redis的过期键有哪些删除策略 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:17:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"过期精度 在 Redis 2.4 及以前版本，过期期时间可能不是十分准确，有0-1秒的误差。 从 Redis 2.6 起，过期时间误差缩小到0-1毫秒。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:18:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"过期和持久 Keys的过期时间使用Unix时间戳存储(从Redis 2.6开始以毫秒为单位)。这意味着即使Redis实例不可用，时间也是一直在流逝的。 要想过期的工作处理好，计算机必须采用稳定的时间。 如果你将RDB文件在两台时钟不同步的电脑间同步，有趣的事会发生（所有的 keys装载时就会过期）。 即使正在运行的实例也会检查计算机的时钟，例如如果你设置了一个key的有效期是1000秒，然后设置你的计算机时间为未来2000秒，这时key会立即失效，而不是等1000秒之后。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:19:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Redis如何淘汰过期的keys Redis keys过期有两种方式：被动和主动方式。 当一些客户端尝试访问它时，key会被发现并主动的过期。 当然，这样是不够的，因为有些过期的keys，永远不会访问他们。 无论如何，这些keys应该过期，所以定时随机测试设置keys的过期时间。所有这些过期的keys将会从密钥空间删除。 具体就是Redis每秒10次做的事情： 测试随机的20个keys进行相关过期检测。 删除所有已经过期的keys。 如果有多于25%的keys过期，重复步奏1. 这是一个平凡的概率算法，基本上的假设是，我们的样本是这个密钥控件，并且我们不断重复过期检测，直到过期的keys的百分百低于25%,这意味着，在任何给定的时刻，最多会清除1/4的过期keys。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:20:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"在复制AOF文件时如何处理过期 为了获得正确的行为而不牺牲一致性，当一个key过期，DEL将会随着AOF文字一起合成到所有附加的slaves。在master实例中，这种方法是集中的，并且不存在一致性错误的机会。 然而，当slaves连接到master时，不会独立过期keys（会等到master执行DEL命令），他们任然会在数据集里面存在，所以当slave当选为master时淘汰keys会独立执行，然后成为master。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:21:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"﻿扩展 绝对时间点过期 相对时间点过期 时钟轮算法 redis线程模型有哪些，单线程为什么快 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:22:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"IO模型维度的特征 IO模型使用了多路复用器，在linux系统中使用的是EPOLL 类似netty的BOSS,WORKER使用一个EventLoopGroup(threads=1) 单线程的Reactor模型，每次循环取socket中的命令然后逐一操作，可以保证socket中的指令是按顺序的，不保证不同的socket也就是客户端的命令的顺序性 命令操作在单线程中顺序操作，没有多线程的困扰不需要锁的复杂度，在操作数据上相对来说是原子性质的 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:23:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"架构设计模型 自身的内存存储数据，读写操作不设计磁盘IO redis除了提供了Value具备类型还为每种类型实现了一些操作命令 实现了计算向数据移动，而非数据想计算移动，这样在IO的成本上有一定的优势 且在数据结构类型上，丰富了一些统计类属性，读写操作中，写操作会O(1)负载度更新length类属性，使得读操作也是O(1)的 缓存雪崩、缓存穿透、缓存击穿在实际中如何处理 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:24:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"缓存穿透 缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:25:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"解决方案 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:25:1","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"缓存击穿 对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。 缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:26:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"解决方案 缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:26:1","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"缓存雪崩 缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:27:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"解决方案 1.使用互斥锁(mutex key) 业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。 SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在redis2.6.1之前版本未实现setnx的过期时间 2.“提前\"使用互斥锁(mutex key)： 在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。 3.“永远不过期”： 这里的“永远不过期”包含两层意思： (1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。 (2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期 从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:27:1","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"总结 穿透：缓存不存在，数据库不存在，高并发，少量key 击穿：缓存不存在，数据库存在，高并发，少量key 雪崩：缓存不存在，数据库存在，高并发，大量key ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:28:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"语义有些许差异，但是，都可以使用限流的互斥锁，保障数据库的稳定 redis事务是怎么实现的 MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证： 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 EXEC 命令负责触发并执行事务中的所有命令： 如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。 另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。 当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。 然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。 如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。 使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。 从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:29:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"事务中的错误 使用事务时可能会遇上以下两种错误： 事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。 命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。 对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。 不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。 在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。 至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:30:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"为什么 Redis 不支持回滚（roll back） 如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。 以下是这种做法的优点： Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。 有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。 redis集群方案有哪些 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:31:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"常见集群分类 主从复制集群 分片集群 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:32:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"redis有那些： 主从复制集群，手动切换 带有哨兵的HA的主从复制集群 客户端实现路由索引的分片集群 使用中间件代理层的分片集群 redis自身实现的cluster分片集群 redis主从复制的原理是什么 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:33:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"主从复制机制 当一个 master 实例和一个 slave 实例连接正常时， master 会发送一连串的命令流来保持对 slave 的更新，以便于将自身数据集的改变复制给 slave ， ：包括客户端的写入、key 的过期或被逐出等等。 当 master 和 slave 之间的连接断开之后，因为网络问题、或者是主从意识到连接超时， slave 重新连接上 master 并会尝试进行部分重同步：这意味着它会尝试只获取在断开连接期间内丢失的命令流。 当无法进行部分重同步时， slave 会请求进行全量重同步。这会涉及到一个更复杂的过程，例如 master 需要创建所有数据的快照，将之发送给 slave ，之后在数据集更改时持续发送命令流到 slave 。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:34:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"主从复制的关注点 Redis 使用异步复制，slave 和 master 之间异步地确认处理的数据量 一个 master 可以拥有多个 slave slave 可以接受其他 slave 的连接。除了多个 slave 可以连接到同一个 master 之外， slave 之间也可以像层叠状的结构（cascading-like structure）连接到其他 slave 。自 Redis 4.0 起，所有的 sub-slave 将会从 master 收到完全一样的复制流。 Redis 复制在 master 侧是非阻塞的。这意味着 master 在一个或多个 slave 进行初次同步或者是部分重同步时，可以继续处理查询请求。 复制在 slave 侧大部分也是非阻塞的。当 slave 进行初次同步时，它可以使用旧数据集处理查询请求，假设你在 redis.conf 中配置了让 Redis 这样做的话。否则，你可以配置如果复制流断开， Redis slave 会返回一个 error 给客户端。但是，在初次同步之后，旧数据集必须被删除，同时加载新的数据集。 slave 在这个短暂的时间窗口内（如果数据集很大，会持续较长时间），会阻塞到来的连接请求。自 Redis 4.0 开始，可以配置 Redis 使删除旧数据集的操作在另一个不同的线程中进行，但是，加载新数据集的操作依然需要在主线程中进行并且会阻塞 slave 。 复制既可以被用在可伸缩性，以便只读查询可以有多个 slave 进行（例如 O(N) 复杂度的慢操作可以被下放到 slave ），或者仅用于数据安全。 可以使用复制来避免 master 将全部数据集写入磁盘造成的开销：一种典型的技术是配置你的 master Redis.conf 以避免对磁盘进行持久化，然后连接一个 slave ，其配置为不定期保存或是启用 AOF。但是，这个设置必须小心处理，因为重新启动的 master 程序将从一个空数据集开始：如果一个 slave 试图与它同步，那么这个 slave 也会被清空。 任何时候数据安全性都是很重要的，所以如果 master 使用复制功能的同时未配置持久化，那么自动重启进程这项应该被禁用。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:35:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Redis 复制功能是如何工作的 每一个 Redis master 都有一个 replication ID ：这是一个较大的伪随机字符串，标记了一个给定的数据集。每个 master 也持有一个偏移量，master 将自己产生的复制流发送给 slave 时，发送多少个字节的数据，自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集时，它可以以此更新 slave 的状态。复制偏移量即使在没有一个 slave 连接到 master 时，也会自增，所以基本上每一对给定的 Replication ID, offset 都会标识一个 master 数据集的确切版本。 当 slave 连接到 master 时，它们使用 PSYNC 命令来发送它们记录的旧的 master replication ID 和它们至今为止处理的偏移量。通过这种方式， master 能够仅发送 slave 所需的增量部分。但是如果 master 的缓冲区中没有足够的命令积压缓冲记录，或者如果 slave 引用了不再知道的历史记录（replication ID），则会转而进行一个全量重同步：在这种情况下， slave 会得到一个完整的数据集副本，从头开始。 下面是一个全量同步的工作细节： master 开启一个后台保存进程，以便于生产一个 RDB 文件。同时它开始缓冲所有从客户端接收到的新的写入命令。当后台保存完成时， master 将数据集文件传输给 slave， slave将之保存在磁盘上，然后加载文件到内存。再然后 master 会发送所有缓冲的命令发给 slave。这个过程以指令流的形式完成并且和 Redis 协议本身的格式相同。 你可以用 telnet 自己进行尝试。在服务器正在做一些工作的同时连接到 Redis 端口并发出 SYNC 命令。你将会看到一个批量传输，并且之后每一个 master 接收到的命令都将在 telnet 回话中被重新发出。事实上 SYNC 是一个旧协议，在新的 Redis 实例中已经不再被使用，但是其仍然向后兼容：但它不允许部分重同步，所以现在 PSYNC 被用来替代 SYNC。 之前说过，当主从之间的连接因为一些原因崩溃之后， slave 能够自动重连。如果 master 收到了多个 slave 要求同步的请求，它会执行一个单独的后台保存，以便于为多个 slave 服务。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:36:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"无需磁盘参与的复制 正常情况下，一个全量重同步要求在磁盘上创建一个 RDB 文件，然后将它从磁盘加载进内存，然后 slave以此进行数据同步。 如果磁盘性能很低的话，这对 master 是一个压力很大的操作。Redis 2.8.18 是第一个支持无磁盘复制的版本。在此设置中，子进程直接发送 RDB 文件给 slave，无需使用磁盘作为中间储存介质。 redis缓存如何回收 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:37:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"回收策略 noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外） allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。 volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 allkeys-random: 回收随机的键使得新添加的数据有空间存放。 volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键 allkeys-lfu：从所有键中驱逐使用频率最少的键 如果没有键满足回收的前提条件的话，策略volatile-lru, volatile-random以及volatile-ttl就和noeviction 差不多了。 选择正确的回收策略是非常重要的，这取决于你的应用的访问模式，不过你可以在运行时进行相关的策略调整，并且监控缓存命中率和没命中的次数，通过RedisINFO命令输出以便调优。 一般的经验规则: 使用allkeys-lru策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。. 使用allkeys-random：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。 使用volatile-ttl：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。 allkeys-lru 和 volatile-random策略对于当你想要单一的实例实现缓存及持久化一些键时很有用。不过一般运行两个实例是解决这个问题的更好方法。 为了键设置过期时间也是需要消耗内存的，所以使用allkeys-lru这种策略更加高效，因为没有必要为键取设置过期时间当内存有压力时。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:38:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"回收进程如何工作 理解回收进程如何工作是非常重要的: 一个客户端运行了新的命令，添加了新的数据。 Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。 一个新的命令被执行，等等。 所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。 如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。 RabbitMQ的架构设计是什么样的 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:39:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"是AMQP的实现，相关概念语义 Broker:它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输 Exchange：消息交换机,它指定消息按什么规则,路由到哪个队列。 Queue:消息的载体,每个消息都会被投到一个或多个队列。 Binding:绑定，它的作用就是把exchange和queue按照路由规则绑定起来. Routing Key:路由关键字,exchange根据这个关键字进行消息投递。 vhost:虚拟主机,一个broker里可以有多个vhost，用作不同用户的权限分离。 Producer:消息生产者,就是投递消息的程序. Consumer:消息消费者,就是接受消息的程序. Channel:消息通道,在客户端的每个连接里,可建立多个channel. ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:40:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"核心概念 在mq领域中，producer将msg发送到queue，然后consumer通过消费queue完成P.C解耦 kafka是由producer决定msg发送到那个queue rabbitmq是由Exchange决定msg应该怎么样发送到目标queue，这就是binding及对应的策略 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:40:1","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Exchange Direct Exchange:直接匹配,通过Exchange名称+RountingKey来发送与接收消息. Fanout Exchange:广播订阅,向所有的消费者发布消息,但是只有消费者将队列绑定到该路由器才能收到消息,忽略Routing Key. Topic Exchange：主题匹配订阅,这里的主题指的是RoutingKey,RoutingKey可以采用通配符,如:*或#，RoutingKey命名采用.来分隔多个词,只有消息这将队列绑定到该路由器且指定RoutingKey符合匹配规则时才能收到消息; Headers Exchange:消息头订阅,消息发布前,为消息定义一个或多个键值对的消息头,然后消费者接收消息同时需要定义类似的键值对请求头:(如:x-mactch=all或者x_match=any)，只有请求头与消息头匹配,才能接收消息,忽略RoutingKey. 默认的exchange:如果用空字符串去声明一个exchange，那么系统就会使用”amq.direct”这个exchange，我们创建一个queue时,默认的都会有一个和新建queue同名的routingKey绑定到这个默认的exchange上去 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:40:2","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"复杂与精简 在众多的MQ中间件中，首先学习Rabbitmq的时候，就理解他是一个单机的mq组件，为了系统的解耦，可以自己在业务层面做AKF 其在内卷能力做的非常出色，这得益于AMQP，也就是消息的传递形式、复杂度有exchange和queue的binding实现，这，对于P.C有很大的帮助 RabbitMQ如何确保消息发送和消息接收 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:41:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"消息发送确认 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:42:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"1 ConfirmCallback方法 ConfirmCallback 是一个回调接口，消息发送到 Broker 后触发回调，确认消息是否到达 Broker 服务器，也就是只确认是否正确到达 Exchange 中。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:42:1","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"2 ReturnCallback方法 通过实现 ReturnCallback 接口，启动消息失败返回，此接口是在交换器路由不到队列时触发回调，该方法可以不使用，因为交换器和队列是在代码里绑定的，如果消息成功投递到 Broker 后几乎不存在绑定队列失败，除非你代码写错了。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:42:2","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"消息接收确认 RabbitMQ 消息确认机制（ACK）默认是自动确认的，自动确认会在消息发送给消费者后立即确认，但存在丢失消息的可能，如果消费端消费逻辑抛出异常，假如你用回滚了也只是保证了数据的一致性，但是消息还是丢了，也就是消费端没有处理成功这条消息，那么就相当于丢失了消息。 消息确认模式有： AcknowledgeMode.NONE：自动确认。 AcknowledgeMode.AUTO：根据情况确认。 AcknowledgeMode.MANUAL：手动确认。 消费者收到消息后，手动调用 Basic.Ack 或 Basic.Nack 或 Basic.Reject 后，RabbitMQ 收到这些消息后，才认为本次投递完成。 Basic.Ack 命令：用于确认当前消息。 Basic.Nack 命令：用于否定当前消息（注意：这是AMQP 0-9-1的RabbitMQ扩展） 。 Basic.Reject 命令：用于拒绝当前消息。 Nack,Reject后都有能力要求是否requeue消息或者进入死信队列 RabbitMQ事务消息原理是什么 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:43:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"事务V.S确认 确认是对一件事的确认 事务是对批量的确认 增删改查中，事务是对于增删改的保证 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:44:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"发送方事务 开启事务，发送多条数据，事务提交或回滚是原子的，要么都提交，要么都回滚 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:45:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"消费方事务 消费方是读取行为，那么事务体现在哪里呢 rabbitmq的消费行为会触发queue中msg的是否删除、是否重新放回队列等行为，类增删改 所以，消费方的ack是要手动提交的，且最终确定以事务的提交和回滚决定 RabbitMQ死信队列、延时队列分别是什么 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:46:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"死信队列 DLX（Dead Letter Exchange），死信交换器。 当队列中的消息被拒绝、或者过期会变成死信，死信可以被重新发布到另一个交换器，这个交换器就是DLX，与DLX绑定的队列称为死信队列。 造成死信的原因： 信息被拒绝 信息超时 超过了队列的最大长度 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:47:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"过期消息： 在 rabbitmq 中存在2种方可设置消息的过期时间，第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这2种方法，那么以过期时间小的那个数值为准。当消息达到过期时间还没有被消费，那么那个消息就成为了一个 死信 消息。 队列设置：在队列申明的时候使用 x-message-ttl 参数，单位为 毫秒 单个消息设置：是设置消息属性的 expiration 参数的值，单位为 毫秒 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:47:1","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"延迟队列 延迟队列存储的是延迟消息 延迟消息指的是，当消息被发发布出去之后，并不立即投递给消费者，而是在指定时间之后投递。如： 在订单系统中，订单有30秒的付款时间，在订单超时之后在投递给消费者处理超时订单。 rabbitMq没有直接支持延迟队列，可以通过死信队列实现。 在死信队列中，可以为普通交换器绑定多个消息队列，假设绑定过期时间为5分钟，10分钟和30分钟，3个消息队列，然后为每个消息队列设置DLX，为每个DLX关联一个死信队列。 当消息过期之后，被转存到对应的死信队列中，然后投递给指定的消费者消费。 简述kafka架构设计是什么样 语义概念 1 broker Kafka 集群包含一个或多个服务器，服务器节点称为broker。 broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。 如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。 如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。 2 Topic 每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处） 类似于数据库的表名 3 Partition topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。 4 Producer 生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。 5 Consumer 消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。 6 Consumer Group 每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会复制-给consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。 7 Leader 每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。 8 Follower Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。 9 Offset kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka KAFKA天生是分布式的，满足AKF的XYZ轴特点，扩展性，可靠性，高性能是没得说 而且，kafka具备自己的特色，比如动态ISR集合，是在强一致性，过半一致性之外的另一个实现手段 Kafka消息丢失的场景有哪些 生产者在生产过程中的消息丢失 broker在故障后的消息丢失 消费者在消费过程中的消息丢失 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:48:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ACK机制 ack有3个可选值，分别是1，0，-1。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:49:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ack=0：生产者在生产过程中的消息丢失 简单来说就是，producer发送一次就不再发送了，不管是否发送成功。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:50:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ack=1：broker在故障后的消息丢失 简单来说就是，producer只要收到一个分区副本成功写入的通知就认为推送消息成功了。这里有一个地方需要注意，这个副本必须是leader副本。只有leader副本成功写入了，producer才会认为消息发送成功。 注意，ack的默认值就是1。这个默认值其实就是吞吐量与可靠性的一个折中方案。生产上我们可以根据实际情况进行调整，比如如果你要追求高吞吐量，那么就要放弃可靠性。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:51:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ack=-1：生产侧和存储侧不会丢失数据 简单来说就是，producer只有收到分区内所有副本的成功写入的通知才认为推送消息成功了。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:52:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Offset机制 kafka消费者的三种消费语义 at-most-once：最多一次，可能丢数据 at-least-once：最少一次，可能重复消费数据 exact-once message：精确一次 Kafka是pull？push？以及优劣势分析 Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。 Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息。 一些消息系统比如Scribe和Apache Flume采用了push模式，将消息推送到下游的consumer。 这样做有好处也有坏处：由broker决定消息推送的速率，对于不同消费速率的consumer就不太好处理了。 消息系统都致力于让consumer以最大的速率最快速的消费消息，但不幸的是，push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。 最终Kafka还是选取了传统的pull模式。 Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。 Push模式必须在不知道下游consumer消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。 如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。 Pull模式下，consumer就可以根据自己的消费能力去决定这些策略。 Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到达。 为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达(当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发 Kafka中zk的作用是什么 Zookeeper是分布式协调，注意它不是数据库 kafka中使用了zookeeper的分布式锁和分布式配置及统一命名的分布式协调解决方案 在kafka的broker集群中的controller的选择，是通过zk的临时节点争抢获得的 brokerID等如果自增的话也是通过zk的节点version实现的全局唯一 kafka中broker中的状态数据也是存储在zk中，不过这里要注意，zk不是数据库，所以存储的属于元数据 而，新旧版本变化中，就把曾经的offset从zk中迁移出了zk Kafka中高性能如何保障 首先，性能的最大瓶颈依然是IO，这个是不能逾越的鸿沟 虽然，broker在持久化数据的时候已经最大努力的使用了磁盘的顺序读写 更进一步的性能优化是零拷贝的使用，也就是从磁盘日志到消费者客户端的数据传递，因为kafka是mq，对于msg不具备加工处理，所以得以实现 然后就是大多数分布式系统一样，总要做tradeoff，在速度与可用性/可靠性中挣扎 ACK的0，1，-1级别就是在性能和可靠中权衡 kafka的rebalance机制是什么 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:53:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"消费者分区分配策略 Range 范围分区(默认的) RoundRobin 轮询分区 Sticky策略 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:54:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"触发 Rebalance 的时机 Rebalance 的触发条件有3个。 组成员个数发生变化。例如有新的 consumer 实例加入该消费组或者离开组。 订阅的 Topic 个数发生变化。 订阅 Topic 的分区数发生变化。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:55:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Coordinator协调过程 消费者如何发现协调者 消费者如何确定分配策略 如果需要再均衡分配策略的影响 zk的数据模型和节点类型有哪些 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:56:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ZooKeeper数据模型 ZooKeeper的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用树形层次结构，ZooKeeper树中的每个节点被称为—Znode。 和文件系统的目录树一样，ZooKeeper树中的每个节点可以拥有子节点。但也有不同之处： Znode兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子Znode。用户对Znode具有增、删、改、查等操作（权限允许的情况下） Znode具有原子性操作，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作 Znode存储数据大小有限制。ZooKeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。ZooKeeper的服务器和客户端都被设计为严格检查并限制每个Znode的数据大小至多1M，当时常规使用中应该远小于此值 Znode通过路径引用，如同Unix中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。字符串\"/zookeeper\"用以保存管理信息，比如关键配额信息。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:57:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"节点类型 Znode有两种，分别为临时节点和永久节点。 节点的类型在创建时即被确定，并且不能改变。 临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话结束，临时节点将被自动删除，当然可以也可以手动删除。临时节点不允许拥有子节点。 永久节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。 Znode还有一个序列化的特性，如果创建的时候指定的话，该Znode的名字后面会自动追加一个不断增加的序列号。序列号对于此节点的父节点来说是唯一的，这样便会记录每个子节点创建的先后顺序。它的格式为“%10d”(10位数字，没有数值的数位用0补充，例如“0000000001”) 在ZooKeeper中，每个数据节点都是有生命周期的，其生命周期的长短取决于数据节点的节点类型。 1、持久节点（PERSISTENT） 该数据节点别创建后，就会一直存在于ZooKeeper服务器上，直到有删除操作来主动删除该节点。 2、持久顺序节点（PERSISTENT_SEQUENTIAL） 持久顺序节点的基本特性和持久节点是一致的，额外的特性表现在顺序性上。在ZooKeeper中，每个父节点都会为它的第一级子节点维护一份顺序，用于记录每个子节点创建的先后顺序。 3、临时节点（EPHEMERAL） 临时节点的生命周期和客户端的回话绑定在一起，如果客户端会话失效，那么这个节点就会被自动地清理掉。 ZooKeeper规定了不能基于临时节点来创建子节点，即临时节点只能作为叶子节点。 4、临时顺序节点（EPHEMERAL_SEQUENTIAL） Zookeeper watch机制是什么 ZooKeeper是用来协调（同步）分布式进程的服务，提供了一个简单高性能的协调内核，用户可以在此之上构建更多复杂的分布式协调功能。 多个分布式进程通过ZooKeeper提供的API来操作共享的ZooKeeper内存数据对象ZNode来达成某种一致的行为或结果，这种模式本质上是基于状态共享的并发模型，与Java的多线程并发模型一致，他们的线程或进程都是”共享式内存通信“。 Java没有直接提供某种响应式通知接口来监控某个对象状态的变化，只能要么浪费CPU时间毫无响应式的轮询重试，或基于Java提供的某种主动通知（Notif）机制（内置队列）来响应状态变化，但这种机制是需要循环阻塞调用。 而ZooKeeper实现这些分布式进程的状态（ZNode的Data、Children）共享时，基于性能的考虑采用了类似的异步非阻塞的主动通知模式即Watch机制，使得分布式进程之间的“共享状态通信”更加实时高效，其实这也是ZooKeeper的主要任务决定的—协调。Consul虽然也实现了Watch机制，但它是阻塞的长轮询。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:58:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ZooKeeper的Watch特性 Watch是一次性的，每次都需要重新注册，并且客户端在会话异常结束时不会收到任何通知，而快速重连接时仍不影响接收通知。 Watch的回调执行都是顺序执行的，并且客户端在没有收到关注数据的变化事件通知之前是不会看到最新的数据，另外需要注意不要在Watch回调逻辑中阻塞整个客户端的Watch回调 Watch是轻量级的，WatchEvent是最小的通信单元，结构上只包含通知状态、事件类型和节点路径。ZooKeeper服务端只会通知客户端发生了什么，并不会告诉具体内容。 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:59:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Zookeeper状态 Disconnected：客户端是断开连接的状态，不能连接服务集合中的任意一个 SyncConnected：客户端是连接状态，连接其中的一个服务 AuthFailed：鉴权失败 ConnectedReadOnly：客户端连接只读的服务器 SaslAuthenticated：SASL认证 Expired：服务器已经过期了该客户端的Session ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:60:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Zookeeper事件类型 None：无 NodeCreated：节点创建 NodeDeleted：节点删除 NodeDataChanged：节点数据改变 NodeChildrenChanged：子节点改变（添加/删除） ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:61:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Watcher使用的注意事项 Watcher是一次触发器，假如需要持续监听数据变更，需要在每次获取时设置Watcher 会话过期：当客户端会话过期时，该客户端注册的Watcher会失效 事件丢失：在接收通知和注册监视点之间，可能会丢失事件,但Zookeeper的状态变更和数据变化，都会记录在状态元数据信息和ZK数据节点上，所以能够获取最终一致的ZK信息状态 避免Watcher过多：服务器会对每一个注册Watcher事件的客户端发送通知，通知通过Socket连接的方式发送，当Watcher过多时，会产生一个尖峰的通知 zk的命名服务、配置管理、集群管理分别是什么 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:62:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"分布式协调 大于等于一的情况下，才会有协调，在协调的事务进行分类得到一些名词，语义能够接受就可以 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:63:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"命名服务 通过使用有序节点的特性做到协调命名规则 通过zk的事务ID递增，做到有序行命名规则 通过使用自己点做map映射，做到1:N的命名映射，比如DNS 顺序关系、映射关系 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:64:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"配置管理 配置、元数据、状态等语义可以通过ZK的节点1MB存储，或者通过zk的节点目录结构特性存储 并且通过watch机制，满足配置变化的全局通知能力 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:65:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"集群管理 通过zk的排他性，有序性 满足分布式锁、分布式选主、队列锁 串行化回调调度 分布式调度等 ","date":"2023-02-12","objectID":"/java%E9%9D%A2%E8%AF%95/:66:0","tags":[],"title":"Java面试","uri":"/java%E9%9D%A2%E8%AF%95/"},{"categories":["Java后端","ruoyi"],"content":"ruoyi框架分页原理 ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:0:0","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"分页实现 前端采用基于bootstrap的轻量级表格插件bootstrap-table(opens new window) 后端采用基于mybatis的轻量级分页插件pageHelper(opens new window) 提示 前后端分页实现流程 ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:1:0","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"#前端调用实现 1、前端定义分页流程 // 一般在查询参数中定义分页变量 queryParams: { pageNum: 1, pageSize: 10 }, // 页面添加分页组件，传入分页变量 \u003cpagination v-show=\"total\u003e0\" :total=\"total\" :page.sync=\"queryParams.pageNum\" :limit.sync=\"queryParams.pageSize\" @pagination=\"getList\" /\u003e // 调用后台方法，传入参数 获取结果 listUser(this.queryParams).then(response =\u003e { this.userList = response.rows; this.total = response.total; } ); ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:1:1","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"#后台逻辑实现 @PostMapping(\"/list\") @ResponseBody public TableDataInfo list(User user) { startPage(); // 此方法配合前端完成自动分页 List\u003cUser\u003e list = userService.selectUserList(user); return getDataTable(list); } 常见坑点1：selectPostById莫名其妙的分页。例如下面这段代码 startPage(); List\u003cUser\u003e list; if(user != null){ list = userService.selectUserList(user); } else { list = new ArrayList\u003cUser\u003e(); } Post post = postService.selectPostById(1L); return getDataTable(list); 原因分析：这种情况下由于user存在null的情况，就会导致pageHelper生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。 当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。 上面这个代码，应该写成下面这个样子才能保证安全。 List\u003cUser\u003e list; if(user != null){ startPage(); list = userService.selectUserList(user); } else { list = new ArrayList\u003cUser\u003e(); } Post post = postService.selectPostById(1L); return getDataTable(list); 常见坑点2：添加了startPage方法。也没有正常分页。例如下面这段代码 startPage(); Post post = postService.selectPostById(1L); List\u003cUser\u003e list = userService.selectUserList(user); return getDataTable(list); 原因分析：只对该语句以后的第一个查询（Select）语句得到的数据进行分页。 上面这个代码，应该写成下面这个样子才能正常分页。 Post post = postService.selectPostById(1L); startPage(); List\u003cUser\u003e list = userService.selectUserList(user); return getDataTable(list); 注意 如果改为其他数据库需修改配置application.yml文件中的属性helperDialect=你的数据库 ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:1:2","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"实现原理 1、所有的controller继承自BaseController,而在BaseController中实现了分页方法 public class BaseController { /** * 设置请求分页数据 */ protected void startPage() { PageUtils.startPage(); } } 2、在PageUtils中设置分页参数 public class PageUtils extends PageHelper { /** * 设置请求分页数据 */ public static void startPage() { PageDomain pageDomain = TableSupport.buildPageRequest(); Integer pageNum = pageDomain.getPageNum(); Integer pageSize = pageDomain.getPageSize(); String orderBy = SqlUtil.escapeOrderBySql(pageDomain.getOrderBy()); Boolean reasonable = pageDomain.getReasonable(); PageHelper.startPage(pageNum, pageSize, orderBy).setReasonable(reasonable); } /** * 清理分页的线程变量 */ public static void clearPage() { PageHelper.clearPage(); } } 3、TableSupport中获取对应的分页参数 public class TableSupport { /** * 当前记录起始索引 */ public static final String PAGE_NUM = \"pageNum\"; /** * 每页显示记录数 */ public static final String PAGE_SIZE = \"pageSize\"; /** * 排序列 */ public static final String ORDER_BY_COLUMN = \"orderByColumn\"; /** * 排序的方向 \"desc\" 或者 \"asc\". */ public static final String IS_ASC = \"isAsc\"; /** * 分页参数合理化 */ public static final String REASONABLE = \"reasonable\"; /** * 封装分页对象 */ public static PageDomain getPageDomain() { PageDomain pageDomain = new PageDomain(); //分页默认第一页 pageDomain.setPageNum(Convert.toInt(ServletUtils.getParameter(PAGE_NUM), 1)); //页大小10 pageDomain.setPageSize(Convert.toInt(ServletUtils.getParameter(PAGE_SIZE), 10)); //排序列 pageDomain.setOrderByColumn(ServletUtils.getParameter(ORDER_BY_COLUMN)); //升序降序 pageDomain.setIsAsc(ServletUtils.getParameter(IS_ASC)); //分页对象合理化 pageDomain.setReasonable(ServletUtils.getParameterToBool(REASONABLE)); return pageDomain; } public static PageDomain buildPageRequest() { return getPageDomain(); } } 4、解析PageHelper.startPage(pageNum, pageSize, orderBy).setReasonable(reasonable); pageNum：页数 pageSize：每页数据量 orderBy：排序 reasonable：分页合理化，对于不合理的分页参数自动处理，比如传递pageNum是小于0，会默认设置为1. 继续跟踪，连续点击startpage构造方法到达如下位置： /** * 开始分页 * * @param pageNum 页码 * @param pageSize 每页显示数量 * @param count 是否进行count查询 * @param reasonable 分页合理化,null时用默认配置 * @param pageSizeZero true且pageSize=0时返回全部结果，false时分页,null时用默认配置 */ public static \u003cE\u003e Page\u003cE\u003e startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero) { Page\u003cE\u003e page = new Page\u003cE\u003e(pageNum, pageSize, count); page.setReasonable(reasonable); page.setPageSizeZero(pageSizeZero); // 1、获取本地分页 Page\u003cE\u003e oldPage = getLocalPage(); if (oldPage != null \u0026\u0026 oldPage.isOrderByOnly()) { page.setOrderBy(oldPage.getOrderBy()); } // 2、设置本地分页 setLocalPage(page); return page; } 到达终点位置了，分别是：getLocalPage()和setLocalPage(page)，分别来看下： getLocalPage() 进入方法： /** * 获取 Page 参数 * * @return */ public static \u003cT\u003e Page\u003cT\u003e getLocalPage() { return LOCAL_PAGE.get(); } 看看常量LOCAL_PAGE是个什么路数？ protected static final ThreadLocal\u003cPage\u003e LOCAL_PAGE = new ThreadLocal\u003cPage\u003e(); 好家伙，是ThreadLocal，学过java基础的都知道吧，独属于每个线程的本地缓存对象。 当一个请求来的时候，会获取持有当前请求的线程的ThreadLocal，调用LOCAL_PAGE.get()，查看当前线程是否有未执行的分页配置。 setLocalPage(page) 此方法显而易见，设置线程的分页配置： protected static void setLocalPage(Page page) { LOCAL_PAGE.set(page); } ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:2:0","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"mybatis使用pageHelper分析 我们需要关注的就是mybatis在何时使用的这个ThreadLocal，也就是何时将分页餐数获取到的。 前面提到过，通过PageHelper的startPage()方法进行page缓存的设置，当程序执行sql接口mapper的方法时，就会被拦截器PageInterceptor拦截到。 PageHelper其实就是mybatis的分页插件，其实现原理就是通过拦截器的方式，pageHelper通PageInterceptor实现分页效果，我们只关注intercept方法： @Override public Object intercept(Invocation invocation) throws Throwable { try { Object[] args = invocation.getArgs(); MappedStatement ms = (MappedStatement) args[0]; Object parameter = args[1]; RowBounds rowBounds = (RowBounds) args[2]; ResultHandler resultHandler = (ResultHandler) args[3]; Executor executor = (Executor) invocation.getTarget(); CacheKey cacheKey; BoundSql boundSql; // 由于逻辑关系，只会进入一次 if (args.length == 4) { //4 个参数时 boundSql = ms.getBoundSql(parameter); cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql); } else { //6 个参数时 cacheKey = (CacheKey) args[4]; boundSql = (BoundSql) args[5]; } checkDialectExists(); //对 boundSql 的拦截处理 if (dialect instanceof BoundSqlInterceptor.Chain) { boundSql = ((BoundSqlInterceptor.Chain) dialect).doBoundSql(BoundSqlInterceptor.Type.ORIGINAL, boundSql, cacheKey); } List resultList; //调用方法判断是否需要进行分页，如果不需要，直接返回结果 if (!dialect.skip(ms, parameter, rowBounds)) { //判断是否需要进行 count 查询 if (dialect.beforeCount(ms, parameter, rowBounds)) { //查询总数 Long count = count(executor, ms, parameter, rowBounds, null, boundSql); //处理查询总数，返回 true 时继续分页查询，false 时直接返回 if (!dialect.afterCount(count, parameter, rowBounds)) { //当查询总数为 0 时，直接返回空的结果 return dialect.afterPage(new ArrayList(), parameter, rowBounds); } } resultList = ExecutorUtil.pageQuery(dialect, executor, ms, parameter, rowBounds, resultHandler, boundSql, cacheKey); } else { //rowBounds用参数值，不使用分页插件处理时，仍然支持默认的内存分页 resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql); } return dialect.afterPage(resultList, parameter, rowBounds); } finally { if(dialect != null){ dialect.afterAll(); } } } 如上所示是intecept的全部代码，我们下面只关注几个终点位置： ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:0","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"设置分页：dialect.skip(ms, parameter, rowBounds) 此处的skip方法进行设置分页参数，内部调用方法： Page page = pageParams.getPage(parameterObject, rowBounds); 继续跟踪getPage()，发现此方法的第一行就获取了ThreadLocal的值： Page page = PageHelper.getLocalPage(); ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:1","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"统计数量：dialect.beforeCount(ms, parameter, rowBounds) 我们都知道，分页需要获取记录总数，所以，这个拦截器会在分页前先进行count操作。 如果count为0，则直接返回，不进行分页： //处理查询总数，返回 true 时继续分页查询，false 时直接返回 if (!dialect.afterCount(count, parameter, rowBounds)) { //当查询总数为 0 时，直接返回空的结果 return dialect.afterPage(new ArrayList(), parameter, rowBounds); } afterPage其实是对分页结果的封装方法，即使不分页，也会执行，只不过返回空列表。 ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:2","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"分页：ExecutorUtil.pageQuery 在处理完count方法后，就是真正的进行分页了： resultList = ExecutorUtil.pageQuery(dialect, executor, ms, parameter, rowBounds, resultHandler, boundSql, cacheKey); 此方法在执行分页之前，会判断是否执行分页，依据就是前面我们通过ThreadLocal的获取的page。 当然，不分页的查询，以及新增和更新不会走到这个方法当中。 ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:3","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"非分页：executor.query 而是会走到下面的这个分支： resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql); 我们可以思考一下，如果ThreadLoad在使用后没有被清除，当执行非分页的方法时，那么就会将Limit拼接到sql后面。 为什么不分也得也会拼接？我们回头看下前面提到的dialect.skip(ms, parameter, rowBounds): 图片 如上所示，只要page被获取到了，那么这个sql，就会走前面提到的ExecutorUtil.pageQuery分页逻辑，最终导致出现不可预料的情况。 其实PageHelper对于分页后的ThreaLocal是有清除处理的。 ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:4","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"清除TheadLocal 在intercept方法的最后，会在sql方法执行完成后，清理page缓存： finally { if(dialect != null){ dialect.afterAll(); } } 看看这个afterAll()方法: @Override public void afterAll() { //这个方法即使不分页也会被执行，所以要判断 null AbstractHelperDialect delegate = autoDialect.getDelegate(); if (delegate != null) { delegate.afterAll(); autoDialect.clearDelegate(); } clearPage(); } 只关注 clearPage()： /** * 移除本地变量 */ public static void clearPage() { LOCAL_PAGE.remove(); } ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:5","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"小结 到此为止，关于PageHelper的使用方式就讲解完了。 整体看下来，似乎不会存在什么问题，但是我们可以考虑集中极端情况： 如果使用了startPage()，但是没有执行对应的sql，那么就表明，当前线程ThreadLocal被设置了分页参数，可是没有被使用，当下一个使用此线程的请求来时，就会出现问题。 如果程序在执行sql前，发生异常了，就没办法执行finally当中的clearPage()方法，也会造成线程的ThreadLocal被污染。 所以，官方给我们的建议，在使用PageHelper进行分页时，执行sql的代码要紧跟startPage()方法。 除此之外，我们可以手动调用clearPage()方法，在存在问题的方法之前。 需要注意：不要分页的方法前手动调用clearPage，将会导致你的分页出现问题。 ","date":"2023-01-30","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:4:0","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端"],"content":"对于大部分项目来说，为了运维方便和项目解耦，往往会将一些和代码无关的配置抽离出来，单独放在一个配置文件中进行维护。但这类配置文件中常常含有密码等比较敏感的信息。为了避免出现敏感信息泄露等问题，采用加密等手段来增强项目的安全性是比较有必要的。本篇文章将以jasypt这个应用较为广泛的第三方依赖来进行讲解，主要基于Springboot进行应用。 一、基于Springboot项目使用jasypt进行加解密 （一）引入依赖 jasypt对应Springboot项目有着良好的支持，可以省略我们对工具类的封装。使用jasypt需要在项目中引入如下依赖： \u003c!-- spring-boot项目的依赖 --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.github.ulisesbocchio\u003c/groupId\u003e \u003cartifactId\u003ejasypt-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.0.3\u003c/version\u003e \u003c/dependency\u003e （二）配置jasypt响应的加密配置 对于加密秘钥的话，最好是不要写在配置文件中，不然别人根据你的配置就可以轻而易举地进行反推，敏感信息的加密程度就大大降低了。 jasypt:encryptor:#默认加密算法:PBEWITHHMACSHA512ANDAES_256，sha512+AES算法，安全性更高，但是需要 Java JDK 1.9+#本服务使用jdk1.8，所以使用 PBEWithMD5AndDES md5+des算法#默认使用 com.ulisesbocchio.jasyptspringboot.encryptor.DefaultLazyEncryptor 进行加解密 ，PooledPBEStringEncryptor可以对其加密的内容进行解密algorithm:PBEWithMD5AndDES# 加密密钥，使用方式 spring.datasource.password=ENC(密文)，不要设置在配置文件中，建议使用环境变量或者启动参数: --jasypt.encryptor.password=123456#加密密钥可以放在yml配置文件里，也可以放在运行参数里password:123456#设置密文前缀和后缀property:prefix:ENC(suffix:)iv-generator-classname:org.jasypt.iv.RandomIvGenerator 除了上面的配置项之外，还有如下配置项可选 Key Required Default Value jasypt.encryptor.password True - jasypt.encryptor.algorithm False PBEWITHHMACSHA512ANDAES_256 jasypt.encryptor.key-obtention-iterations False 1000 jasypt.encryptor.pool-size False 1 jasypt.encryptor.provider-name False SunJCE jasypt.encryptor.provider-class-name False null jasypt.encryptor.salt-generator-classname False org.jasypt.salt.RandomSaltGenerator jasypt.encryptor.iv-generator-classname False org.jasypt.iv.RandomIvGenerator jasypt.encryptor.string-output-type False base64 jasypt.encryptor.proxy-property-sources False false jasypt.encryptor.skip-property-sources False empty list （三）在代码中进行测试 注意，在代码测试之前，需要保证springboot项目中有正常使用**@SpringBootApplication** 或者@EnableAutoConfiguration注解 我们可以项目中使用@Value注解来直接获取解密后的配置值 步骤零：加密工具类 package com.jindong.dailytest.utils; import org.jasypt.encryption.pbe.StandardPBEStringEncryptor; import org.jasypt.encryption.pbe.config.EnvironmentPBEConfig; import org.junit.Test; public class JasyptTest { @Test public void testEncrypt() throws Exception { //加密工具 StandardPBEStringEncryptor standardPBEStringEncryptor = new StandardPBEStringEncryptor(); EnvironmentPBEConfig config = new EnvironmentPBEConfig(); // 加密的算法，这个算法是默认的 config.setAlgorithm(\"PBEWithMD5AndDES\"); // 加密的密钥,要和配置文件一致或者项目启动参数 config.setPassword(\"\"); standardPBEStringEncryptor.setConfig(config); //需要加密的文本字符串 String plainText = \"202172\"; String encryptedText = standardPBEStringEncryptor.encrypt(plainText); System.out.println(encryptedText); } @Test public void testDe() throws Exception { //解密工具 StandardPBEStringEncryptor standardPBEStringEncryptor = new StandardPBEStringEncryptor(); EnvironmentPBEConfig config = new EnvironmentPBEConfig(); //加密算法 config.setAlgorithm(\"PBEWithMD5AndDES\"); //加密密钥 config.setPassword(\"\"); standardPBEStringEncryptor.setConfig(config); //需要解密的字符串 String encryptedText = \"\"; String plainText = standardPBEStringEncryptor.decrypt(encryptedText); System.out.println(plainText); } } 步骤一：在配置文件中新增一个加密的配置 注意，需要在密文外面使用我们前面定义的前缀和后缀进行包裹，这样jasypt才会识别到这个配置属于需要加密的配置。我们上面配置的jasypt.property.prefix和jasypt.property.suffix分别是ENC(和) （也是默认的前后缀）。至于加密后的值是怎么来的，后文会介绍一个工具类。 jasypt:encryptor:algorithm:PBEWithMD5AndDESiv-generator-classname:org.jasypt.iv.NoIvGeneratorspring:datasource:driver-class-name:com.mysql.cj.jdbc.Driverurl:jdbc:mysql://12.168.120.3:3307/hubu_test?serverTimezone=GMT%2B8\u0026useSSL=true\u0026serverTimezone=Asia/Shanghaiusername:rootpassword:ENC(sbvop4M65v0xqcPpJFbADQ==) 这里配置文件里面没有加加密密钥，放在启动参数里面，防止代码泄露，反解密出文本 步骤二：加入加密启动参数 在项目启动时加入加密启动参数-Djasypt.encryptor.password=test -Djasypt.encryptor.password=testtest -Djasypt.encryptor.property.prefix=ENCRYPT[ -Djasypt.encryptor.property.suffix:] ","date":"2022-12-28","objectID":"/jasypt%E5%AE%9E%E7%8E%B0springboot%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86/:0:0","tags":["Jasypt","参数加密"],"title":"Jasypt实现springboot参数加密","uri":"/jasypt%E5%AE%9E%E7%8E%B0springboot%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"PO（Persistant Object - 持久化对象） 该概念随着ORM产生，可以看成是与数据库中的表相映射的Java对象。通常就是对应数据库中某个表中的一条记录。PO仅仅用于表示数据，没有任何数据操作。通常遵守Java Bean的规范，拥有 getter/setter方法。 PO的生命周期：是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。 PO的作用：可以把数据表中一条记录作为一个对象处理，可以方便的转为其它对象。PO是有状态的，每个属性代表其当前的状态。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。 PO的特点 ： PO的属性是跟数据库表的字段一一对应的 PO对象需要实现序列化接口 一个POJO持久化后就是PO ","date":"2022-12-09","objectID":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:1","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"BO（Business Object - 业务对象） BO用于表示一个业务对象，它包括了业务逻辑，常常封装了对DAO和RPC等的调用，可以进行PO与VO/DTO之间的转换。 BO通常位于业务层，要区别于直接对外提供服务的服务层：BO提供了基本业务单元的基本业务操作，在设计上属于被服务层业务流程调用的对象，一个业务流程可能需要调用多个BO来完成。 ","date":"2022-12-09","objectID":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:2","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"DO（Domain Object - 领域对象） 领域对象就是从现实世界中抽象出来的有形或无形的业务实体。通常位于业务层中。 ","date":"2022-12-09","objectID":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:3","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"VO（Value Object/View Object - 值对象/视图对象） Value Object，值对象，也称为业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方（实际上跟DO有点类似）。 VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 VO通常用于业务层之间的数据传递，其仅仅包含数据。但应是抽象出的业务对象。根据业务的需要，其可以和表对应或者不。用new关键字创建，由GC进行回收。 View Object，视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来，对应整个界面的值 ","date":"2022-12-09","objectID":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:4","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"DTO（Data Transfer Object - 数据传输对象） DTO概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载。 DTO用于表示一个数据传输对象，通常用于不同服务或服务不同分层之间的数据传输。 DTO与VO与类似，但也有一些不同，这个不同主要是设计理念上的，比如API服务需要使用的是DTO，而用于展示层页面的使用的是VO。例如，为了展示方便，在VO的性别字段存的是男和女，而在DTO中存的是1或者2这样的代码。 ","date":"2022-12-09","objectID":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:5","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"DAO（Data Access Object - 数据访问对象） DAO是SUN公司的一个标准J2EE设计模式，这个模式中有个接口就是 DAO，负责持久层的操作并为业务层提供接口。此对象用于访问数据库。通常和PO结合使用。 DAO中包含了各种数据库的操作方法。通过它的方法结合PO对数据库进行CRUD的操作。 ","date":"2022-12-09","objectID":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:6","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"POJO（Plain Ordinary Java Object - 简单无规则Java对象） POJO表示一个简单Java对象。PO、VO、DTO都是典型的POJO。 ","date":"2022-12-09","objectID":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:7","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"无事务代码 @Override public int add(User user) { user.setId(idGenerator.nextId()); int insert = userMapper.insert(user); int i = 1/0; int insert1 = numMapper.insert(user); return insert; } 一个事务有两个数据库操作来完成，但是当第一个操作完成之后，系统发生了异常，就会造成数据不一致。 如下，两表同步数据，一个表有数据，另一个表没有 ","date":"2022-12-05","objectID":"/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/:0:1","tags":["事务"],"title":"Springboot事务代码实践","uri":"/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/"},{"categories":["Java后端"],"content":"编程式事务管理 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。 Service层实现类代码： @Resource TransactionTemplate transactionTemplate; @Override public int add(User user) { final int[] num = {0}; user.setId(idGenerator.nextId()); transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus status) { try { int insert = userMapper.insert(user); num[0] +=insert; // int i = 1/0; int insert1 = numMapper.insert(user); num[0] +=insert1; }catch (Exception e){ status.setRollbackOnly(); } } }); return num[0]; } 另一种实现事务编程方法： import org.springframework.transaction.PlatformTransactionManager; @Resource PlatformTransactionManager transactionManager; public int add(User user) { int num = 0; long l = idGenerator.nextId(); user.setId(l); TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); try { int insert = userMapper.insert(user); //int i = 1/0; int insert1 = numMapper.insert(user); num = insert1; transactionManager.commit(status); }catch (Exception e){ transactionManager.rollback(status); } return num; } 就编程式事务管理而言，Spring 更推荐使用 TransactionTemplate。 TransactionTemplate可以隐式调用commit，不需要在代码中显式调用，只需要事务代码块出现异常时回滚即可 TransactionManager需要显式调用commit和rollback操作；没有commit，数据库不会生成记录。 在编程式事务中，必须在每个业务操作中包含额外的事务管理代码，就导致代码看起来非常的臃肿，但对理解 Spring 的事务管理模型非常有帮助。 ","date":"2022-12-05","objectID":"/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/:0:2","tags":["事务"],"title":"Springboot事务代码实践","uri":"/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/"},{"categories":["Java后端"],"content":"声明式事务管理 ​ 声明式事务将事务管理代码从业务方法中抽离了出来，以声明式的方式来实现事务管理，对于开发者来说，声明式事务显然比编程式事务更易用、更好用。 ​ 当然了，要想实现事务管理和业务代码的抽离，就必须得用到 Spring 当中的AOP，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。 声明式事务虽然优于编程式事务，但也有不足，声明式事务管理的粒度是方法级别，而编程式事务是可以精确到代码块级别的。 REQUIRED 有则加入，内外同步 REQUIRES_NEW 内外分离 NESTED 外影响内，内不影响外 SUPPORTS 有事务就使用，无则非 MANDATORY 有则加入，无则抛异常 NOT_SUPPORTED 非事务，挂起当前事务 NEVER 在事务中抛异常 @Transactional(propagation = Propagation.REQUIRED) public int add(User user) { int num = 0; long l = idGenerator.nextId(); user.setId(l); int insert = userMapper.insert(user); int i = 1/0; int insert1 = numMapper.insert(user); num = insert1; return num; } java.lang.ArithmeticException: / by zero at com.jindong.dailytest.service.impl.UserServiceImpl.add(UserServiceImpl.java:78) ~[classes/:na] 业务代码处在同一个事务中，系统抛出异常后，业务代码都不成功 ","date":"2022-12-05","objectID":"/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/:0:3","tags":["事务"],"title":"Springboot事务代码实践","uri":"/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/"},{"categories":["Java后端"],"content":"事务是为了解决数据安全问题而存在的。 最经典的例子就是银行转账问题，A账户给B账户转账100元，A账户扣除100元后由于不可抗力因素导致程序中断，B账户没有收到那100元，A账户那100元凭空消失，肯定是不行的。A扣款和B收款操作要么同时成功，要么同时失败，这个时候就需要引入事务操作。 ","date":"2022-12-05","objectID":"/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/:0:1","tags":["事务"],"title":"Springboot事务概述","uri":"/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"},{"categories":["Java后端"],"content":"事务的四个特性： 原子性：一个事务是一个不可分割的工作单位。 一致性：事务必须是使数据库从一个一致性状态变到另一个一致性状态，一致性与原子性是密切相关的。 隔离性：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 ","date":"2022-12-05","objectID":"/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/:0:2","tags":["事务"],"title":"Springboot事务概述","uri":"/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"},{"categories":["Java后端"],"content":"事务管理方式 spring支持编程式事务管理和声明式事务管理两种方式。 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。 声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。 @Transactional注解： 它是声明式事务管理编程中使用的注解，放在接口实现类或接口实现方法上，并且只对public方法才起作用。只读的接口不需要事务管理，防止影响系统性能。 @Transactional 实质是使用了 JDBC 的事务来进行事务控制的，实现原理： 事务开始时，通过AOP机制，生成一个代理connection对象，并将其放入 DataSource 实例的某个与 DataSourceTransactionManager 相关的某处容器中。在接下来的整个事务中，客户代码都应该使用该 connection 连接数据库，执行所有数据库命令。[不使用该 connection 连接数据库执行的数据库命令，在本事务回滚的时候得不到回滚]（物理连接 connection 逻辑上新建一个会话session；DataSource 与 TransactionManager 配置相同的数据源） 事务结束时，回滚在第1步骤中得到的代理 connection 对象上执行的数据库命令，然后关闭该代理 connection 对象。（事务结束后，回滚操作不会对已执行完毕的SQL操作命令起作用） ","date":"2022-12-05","objectID":"/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/:0:3","tags":["事务"],"title":"Springboot事务概述","uri":"/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"},{"categories":["Java后端"],"content":"事务的隔离级别 当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。隔离级别越高，数据库的并发性能就越差。 第一种隔离级别：Read uncommitted(读未提交) 在该隔离级别下，所有事务都可以看到其它未提交事务的执行结果。即在该级别下，事务的修改即便没有提交，对其他事务也都是可见的，可能出现脏读、不可重复读、幻读。 第二种隔离级别：Read committed(读提交) 该隔离级别满足了隔离的简单定义，一个事务只能看见已经提交事务所做的改变。这是Oracle数据库默认的事务隔离级别。避免了脏读，可能出现不可重复读、幻读。 第三种隔离级别：Repeatable read(可重复读取) 可以确保同一个事务在多次读取同样的数据时，返回同样的结果。这是MySQL数据库默认的事务隔离级别。这样避免了不可重复读和脏读，但是有时可能会出现幻读。 第四种隔离级别：Serializable(可序化) 它通过强制事务排序，使事务一个一个的进行，事务之间不可能再存在相互冲突，从而解决幻读问题。 脏读、不可重复读、幻读： 1、脏读 脏读就是指当A事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，B事务也访问这个数据，然后使用了这个数据。这时候如果事务A回滚，那么B事务读到的数据是不被承认的。 2、不可重复读（重点在修改，体现在值不同） 指在A事务内，多次读同一数据。在A事务还没有结束时，B事务也访问该同一数据。那么，在A事务中的两次读数据之间，由于B事务的修改，那么A事务两次读到的的数据可能是不一样的。这样就发生了在A事务内两次读到的数据是不一样的。 3、幻读（重点在增加或删除，体现在记录数不同） 是指当事务不是独立执行时发生的一种现象，例如A事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，B事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作A事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 具体可看↓ 数据库事务隔离级别（脏读、幻读、不可重复读）_qq_41776884的博客-CSDN博客_脏读幻读不可重复读 一、脏读、幻读和不可重复读一、脏读、不可重复读、幻读1、脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。例如：张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。随后，事务A发生异常，而回滚了事务… https://blog.csdn.net/qq_41776884/article/details/81608777 ","date":"2022-12-05","objectID":"/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/:0:4","tags":["事务"],"title":"Springboot事务概述","uri":"/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"},{"categories":["Java后端"],"content":"事务的传播行为 事务的传播行为是针对嵌套事务而言的。具体可见↓ 【十六】Spring Boot之事务（事务传播机制、嵌套事务、事务隔离机制详解）_jy02268879的博客-CSDN博客_springboot 事务嵌套 一、事务传播机制：事务的传播行为是针对嵌套事务而言。示例：@Transactional(propagation = Propagation.REQUIRED)2.1.1REQUIREDspring默认的事务传播行为就是它。支持事务。如果业务方法执行时已经在一个事务中，则加入当前事务，否则重新开启一个事务。外层事务提交了，内层才会提交。内/外只要有报错，他俩会一起回滚。… https://blog.csdn.net/jy02268879/article/details/84322459 REQUIRED @Transactional(propagation = Propagation.REQUIRED) spring中的默认事务传播行为就是它。如果业务方法执行时已经在一个事务中，则加入当前事务， 否则重新开启一个事务。外层事务提交了，内层才会提交。内/外只要有报错，他俩会一起回滚。 只要内层方法报错抛出异常，即使外层有try-catch，该事务也会回滚。 因为内外层方法在同一个事务中，内层只要抛出了异常，这个事务就会被设置成rollback-only，即使外层try-catch内层的异常，该事务也会回滚。 REQUIRES_NEW @Transactional(propagation = Propagation.REQUIRES_NEW) 支持事务。每次都是创建一个新事物，如果当前已经在事务中了，会挂起当前事务。内层事务结束，内层就提交了，不用等着外层一起提交。 外层报错回滚，不影响内层。内层报错回滚，外层try-catch内层的异常，外层不会回滚。 内层报错回滚，然后又会抛出异常，外层如果没有捕获处理内层抛出来的这个异常，外层还是会回滚的。 NESTED @Transactional(propagation = Propagation.NESTED) 支持事务。如果当前事务存在，那么在嵌套的事务中执行，内层事务结束，要等着外层一起提交。如果当前事务不存在，则表现跟REQUIRED一样。 这个直接说，如果外层报错回滚，内层也会跟着回滚。 如果只是内层回滚，不影响外层。这个内层回滚不影响外层的特性是有前提的，否则内外都回滚。 内层是NESTED模式下，外层要try-catch内层的异常，外层才不会回滚。而内层是REQUIRED模式的话，即使外层try-catch内层异常，外层同样会回滚的。 SUPPORTS @Transactional(propagation = Propagation.SUPPORTS) 支持事务。当前有事务就支持使用当前事务，若当前不存在事务，以非事务的方式执行。内层事务结束，要等着外层一起提交。 MANDATORY @Transactional(propagation = Propagation.MANDATORY) 支持事务，如果业务方法执行时已经在一个事务中，则加入当前事务。否则抛出异常。内层事务结束，要等着外层一起提交。 NOT_SUPPORTED @Transactional(propagation = Propagation.NOT_SUPPORTED) 不支持事务，以非事务的方式执行，若当前存在事务，则把当前事务挂起，等方法执行完毕后，事务恢复进行。 若A是事务执行，B（NOT_SUPPORTED非事务执行）B在A尚未提交前再操作同一条记录，会产生死锁，A、B不可操作同一条记录。 NEVER @Transactional(propagation = Propagation.NEVER) 不支持事务。如果当前已经在一个事务中了，抛出异常。 ","date":"2022-12-05","objectID":"/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/:0:5","tags":["事务"],"title":"Springboot事务概述","uri":"/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"},{"categories":["java"],"content":"UidGenerator 0概述 UidGenerator是百度开源的Java语言实现，基于Snowflake算法的唯一ID生成器。 它是分布式的，并克服了雪花算法的并发限制。 单个实例的QPS能超过6000000。 需要的环境：JDK8+，MySQL（用于分配WorkerId） 但是百度对这些组成部分稍微调整了一下： 由上图可知，UidGenerator的时间部分只有28位，这就意味着UidGenerator默认只能承受8.5年（2^28-1/86400/365） 也可以根据你业务的需求，UidGenerator可以适当调整delta seconds、worker node id和sequence占用位数。 对于分布式的业务系统来说，SnowFlake算法的优缺点如下。 ► 优点： 1）毫秒数在高位，自增序列在低位，整个ID都是趋势递增的； 2）不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的； 3）可以根据自身业务特性分配bit位，非常灵活。 ► 缺点： 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。 UidGenerator改进后的SnowFlake算法 通过上节，我们知道了原版SnowFlake算法的基本构成。 具体是，原版SnowFlake算法核心组成： 原版SnowFlake算法各字段的具体意义是： 1）1位sign标识位； 2）41位时间戳； 3）10位workId（即5位数据中心id+5位工作机器id）； 4）12位自增序列。 而UidGenerator改进后的SnowFlake算法核心组成如下图： 简单来说，UidGenerator能保证“ 指定机器 \u0026 同一时刻 \u0026 某一并发序列 ”，是唯一，并据此生成一个64 bits的唯一ID（long），且默认采用上图字节分配方式。 与原版的snowflake算法不同，UidGenerator还支持自定义时间戳、工作机器id和序列号等各部分的位数，以应用于不同场景（详见源码实现）。 如上图所示，UidGenerator默认ID中各数据位的含义如下： 1）sign(1bit)： 固定1bit符号标识，即生成的UID为正数。 2）delta seconds (28 bits)： 当前时间，相对于时间基点\"2016-05-20\"的增量值，单位：秒，最多可支持约8.7年（注意：(a)这里的单位是秒，而不是毫秒！(b)注意这里的用词，是“最多”可支持8.7年，为什么是“最多”，后面会讲）。 3）worker id (22 bits)： 机器id，最多可支持约420w次机器启动。内置实现为在启动时由数据库分配，默认分配策略为用后即弃，后续可提供复用策略。 4）sequence (13 bits)： 每秒下的并发序列，13 bits可支持每秒8192个并发（注意下这个地方，默认支持qps最大为8192个）。 UidGenerator的具体代码实现分析 通过阅读UidGenerator的源码可知，UidGenerator的具体实现有两种选择，即 DefaultUidGenerator 和 CachedUidGenerator。我们分别来看看这两个具体代码实现的精妙之处。 DefaultUidGenerator DefaultUidGenerator 的源码很清楚的说明了几个生成ID的关键位的实现逻辑。 1）delta seconds（28 bits）： 这个值是指当前时间与epoch时间的时间差，且单位为秒。epoch时间就是指集成DefaultUidGenerator生成分布式ID服务第一次上线的时间，可配置，也一定要根据你的上线时间进行配置，因为默认的epoch时间可是2016-09-20，不配置的话，会浪费好几年的可用时间。 2）worker id（22bits）： 接下来说一下DefaultUidGenerator是如何给worker id赋值的，搭建DefaultUidGenerator的话，需要创建一个表。 3）sequence（13bits）： 核心代码如下，几个实现的关键点： a. synchronized保证线程安全； b. 如果时间有任何的回拨，那么直接抛出异常； c. 如果当前时间和上一次是同一秒时间，那么sequence自增。如果同一秒内自增值超过2^13-1，那么就会自旋等待下一秒（getNextSecond）； d. 如果是新的一秒，那么sequence重新从0开始。 （ 上述源码节选自：DefaultUidGenerator 类中的 nextId 方法） 4）小结： 通过DefaultUidGenerator的实现可知，它对时钟回拨的处理比较简单粗暴。另外如果使用UidGenerator的DefaultUidGenerator方式生成分布式ID，一定要根据你的业务的情况和特点，调整各个字段占用的位数： \u003c propertyname= “timeBits\"value= “29”/\u003e \u003c propertyname= “workerBits\"value= “21”/\u003e \u003c propertyname= “seqBits\"value= “13”/\u003e \u003c propertyname= “epochStr\"value= “2016-09-20”/\u003e CachedUidGenerator CachedUidGenerator是DefaultUidGenerator的重要改进实现。它的核心利用了RingBuffer，它本质上是一个数组，数组中每个项被称为slot。CachedUidGenerator设计了两个RingBuffer，一个保存唯一ID，一个保存flag。RingBuffer的尺寸是2^n，n必须是正整数。 以下是CachedUidGenerator中的RingBuffer原理示意图： 扩展知识：什么是RingBuffer？ Ring Buffer的概念，其实来自于Linux内核（Maybe），是为解决某些特殊情况下的竞争问题提供了一种免锁的方法。这种特殊的情况就是当生产者和消费者都只有一个，而在其它情况下使用它也是必须要加锁的。 环形缓冲区通常有一个读指针和一个写指针。读指针指向环形缓冲区中可读的数据，写指针指向环形缓冲区中可写的缓冲区。通过移动读指针和写指针就可以实现缓冲区的数据读取和写入。在通常情况下，环形缓冲区的读用户仅仅会影响读指针，而写用户仅仅会影响写指针。如果仅仅有一个读用户和一个写用户，那么不需要添加互斥保护机制就可以保证数据的正确性。如果有多个读写用户访问环形缓冲区，那么必须添加互斥保护机制来确保多个用户互斥访问环形缓冲区。 Tail指针、Cursor指针用于环形数组上读写slot： Tail指针 表示Producer生产的最大序号(此序号从0开始，持续递增)。Tail不能超过Cursor，即生产者不能覆盖未消费的slot。当Tail已赶上curosr，此时可通过rejectedPutBufferHandler指定PutRejectPolicy Cursor指针 表示Consumer消费到的最小序号(序号序列与Producer序列相同)。Cursor不能超过Tail，即不能消费未生产的slot。当Cursor已赶上tail，此时可通过rejectedTakeBufferHandler指定TakeRejectPolicy CachedUidGenerator采用了双RingBuffer，Uid-RingBuffer用于存储Uid、Flag-RingBuffer用于存储Uid状态(是否可填充、是否可消费) 由于数组元素在内存中是连续分配的，可最大程度利用CPU cache以提升性能。但同时会带来「伪共享」FalseSharing问题，为此在Tail、Cursor指针、Flag-RingBuffer中采用了CacheLine 补齐方式。 RingBuffer填充时机 初始化预填充 RingBuffer初始化时，预先填充满整个RingBuffer. 即时填充 Take消费时，即时检查剩余可用slot量(tail - cursor)，如小于设定阈值，则补全空闲slots。阈值可通过paddingFactor来进行配置，请参考Quick Start中CachedUidGenerator配置 周期填充 通过Schedule线程，定时补全空闲slots。可通过scheduleInterval配置，以应用定时填充功能，并指定Schedule时间间隔 更多具体的 CachedUidGenerator 的代码实现，有兴趣可以仔细读一读，也可以前往百度uid-generator工程的说明页看看具体的算法原理，这里就不再赘述。 简要的小结一下，CachedUidGenerator方式主要通过采取如下一些措施和方案规避了时钟回拨问题和增强唯一性： 1）自增列：CachedUidGenerator的workerId在实例每次重启时初始化，且就是数据库的自增ID，从而完美的实现每个实例获取到的workerId不会有任何冲突； 2）RingBuffer：CachedUidGenerator不再在每次取ID时都实时计算分布式ID，而是利用RingBuffer数据结构预先生成若干个分布式ID并保存； 小结一下 CachedUidGenerator通过缓存的方式预先生成一批唯一ID列表，可以解决唯一ID获取时候的耗时。但这种方式也有不好点，一方面需要耗费内存来缓存这部分数据，另外如果访问量不大的情况下，提前生成的UID中的时间戳可能是很早之前的","date":"2022-12-03","objectID":"/%E7%99%BE%E5%BA%A6uidgenerator%E9%9B%86%E6%88%90/:0:1","tags":["分布式ID","Snowflake","Long精度丢失"],"title":"springboot集成UidGenerator最佳指南","uri":"/%E7%99%BE%E5%BA%A6uidgenerator%E9%9B%86%E6%88%90/"},{"categories":["Tools"],"content":"虚拟机网络一般配置为net模式 要求：虚拟机网段与客户端网段不需要在同一网段内，所以没什么关系 上截图 ens33: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 12.168.120.3 netmask 255.255.255.0 broadcast 12.168.120.255 inet6 fe80::9e98:31b8:51e:9ffb prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:0c:29:8c:87:3f txqueuelen 1000 (Ethernet) RX packets 113 bytes 15203 (14.8 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 120 bytes 14794 (14.4 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u003cUP,LOOPBACK,RUNNING\u003e mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u003chost\u003e loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 1、虚拟机IP：12.168.120.3 网络掩码：255.255.255.0 网关：12.168.120.2 客户端只需要设置VMnet8虚拟网络参数 ","date":"2022-12-02","objectID":"/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/:0:0","tags":["网络","虚拟机"],"title":"虚拟机网络配置","uri":"/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"Docker compose  \u0026  Docker Swarm","date":"2022-11-29","objectID":"/docker%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92tips/","tags":["docker容器编排"],"title":"Docker容器编排TIPS","uri":"/docker%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92tips/"},{"categories":["运维"],"content":"一个系统采用微服务的方式编写，根据业务分割，将系统分为权限管理，内容管理，订单管理，视频管理，数据统计等服务，每个服务以Docker容器的方式运行，底层的redis,mysql等基础性的组件也以容器的方式启动，所有容器在同一主机的同一网络内，在同一个虚拟网络内，每个服务占用一个接口，因此，各个服务之间是相互可以通信的，在系统运行时只需要开放网关接口，所有请求通过网关转发到具体服务，所以在运行期，所有非网关端口对外不可见，在一定程度上也保证了系统安全。 但是在系统运行时，可能出现系统Bug,此时需要访问一些内部组件或服务来查找原因，但是端口又不可见，停止容器，重新启动容器加端口映射并不是明智之举，解决完问题又需要把端口关闭，此时就需要在系统中加一个nginx; 在网络中加一个或者多个nginx,把需要的端口映射出来，不需要外部访问时把nginx关闭，就做到了端口安全，当需要访问内部服务是，只需要开启有对应端口映射的nginx,就能达到动态开启端口与关闭端口的目的。 docker-compose.xml配置 version: '3' services: service-gateway: image: hubu8023/api_gateway:${TAG} container_name: service-gateway ports: - \"8222:8222\" restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-cms: image: hubu8023/service_cms:${TAG} container_name: service-cms restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-acl: image: hubu8023/service_acl:${TAG} container_name: service-acl restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-edu: image: hubu8023/service_edu:${TAG} container_name: service-edu restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-msm: image: hubu8023/service_msm:${TAG} container_name: service-msm restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-order: image: hubu8023/service_order:${TAG} container_name: service-order restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-oss: image: hubu8023/service_oss:${TAG} container_name: service-oss restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-sta: image: hubu8023/service_sta:${TAG} container_name: service-sta restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service_usercenter: image: hubu8023/service_usercenter:${TAG} container_name: service_usercenter restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-vod: image: hubu8023/service_vod:${TAG} container_name: service-vod restart: on-failure env_file: - .env nacos: image: nacos/nacos-server:1.1.3 container_name: nacos-stand # networks: # - sc-net environment: - PREFER_HOST_MODE=hostname - MODE=standalone volumes: - E:/test/edu_dongyuan/nacos-server/logs/:/home/nacos/logs # restart: on-failure mysql: image: hubu8023/edu_mysql container_name: mysql # command: --default-authentication-plugin=mysql_native_password # restart: always # environment: # MYSQL_ROOT_PASSWORD: 123456 volumes: - E:/test/edu_dongyuan/mysql01:/var/lib/mysql redis: hostname: redis image: redis container_name: redis restart: always volumes: - E:/test/edu_dongyuan/redis:/data nginx: image: hubu8023/proxy container_name: proxy_nginx ports: - \"8848:8848\" # nacos 注册中心 - \"3310:3310\" # mysql 数据库 - \"6380:6380\" # redis nginx Dockerfile FROM nginx ADD proxy.conf /etc/nginx/proxy.conf ADD proxy.sh /etc/nginx/proxy.sh ENTRYPOINT [\"sh\",\"/etc/nginx/proxy.sh\"] proxy.conf nginx监听需要动态关闭的端口 user nginx; worker_processes 10; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 50000; } stream { upstream mysql { server mysql:3306 max_fails=3 fail_timeout=30s; } server { listen 3310; proxy_connect_timeout 10s; proxy_timeout 120s; proxy_pass mysql; } upstream redis { server redis:6379 max_fails=3 fail_timeout=30s; } server { listen 6380; proxy_connect_timeout 10s; proxy_timeout 120s; proxy_pass redis; } upstream nacos { server nacos-stand:8848 max_fails=3 fail_timeout=30s; } server { listen 8848; proxy_connect_timeout 10s; proxy_timeout 120s; proxy_pass nacos; } } proxy.sh nginx启动之后copy配置文件，然后重启生效 #! /bin/bash cp /etc/nginx/proxy.conf /etc/nginx/nginx.conf /usr/bin/iperf3 -s -D cat /etc/nginx/nginx.conf nginx -g \"daemon off;\" ","date":"2022-11-29","objectID":"/docker%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92tips/:0:0","tags":["docker容器编排"],"title":"Docker容器编排TIPS","uri":"/docker%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92tips/"},{"categories":["java"],"content":"分布式ID生成算法Snowflake的原理与应用 ","date":"2022-11-29","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/:1:0","tags":["分布式ID","Snowflake","Long精度丢失"],"title":"分布式ID生成算法Snowflake的原理与应用","uri":"/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"UUID UUID(universally unique identifier) 长度是128 bit，也就是由32个16进制数值组成。其中 M 表示 version，N 表示 Variants xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx。例如：1e92d156-ffd6-4a38-9275-f66c31c31e13 UUID由以下几部分的组合： 当前日期和时间， 时钟序列。 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。 优点： 本地生成ID，不需要远程调用，时延低，适用于数据量小。 当数据量大的时候，UUID用作数据库主键会存在以下问题： UUID比较长，占用空间大，会间接导致数据库性能下降。 无序。会导致B+树索引在写的时候有过多的随机写操作、叶分裂等问题，导致数据库性能下降。 信息安全。UUID可能包含了MAC地址信息。 ","date":"2022-11-29","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/:1:1","tags":["分布式ID","Snowflake","Long精度丢失"],"title":"分布式ID生成算法Snowflake的原理与应用","uri":"/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"Snowflake 概述 SnowFlake算法生成id的结果是一个64bit大小的整数，它的结构如下图： 1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0 41位，用来记录时间戳（毫秒）。 41位可以表示2^41−1个数字，如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 2^41−1，减1是因为可表示的数值范围是从0开始算的，而不是1。 也就是说41位可以表示2^41−1个毫秒的值，转化成单位年则是(2^41−1)/(1000∗60∗60∗24∗365)=69年 10位，用来记录工作机器id。 可以部署在2^10=1024个节点，包括5位datacenterId和5位workerId 5位（bit）可以表示的最大正整数是2^5−1=31，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId 12位，序列号，用来记录同毫秒内产生的不同id。 12位（bit）可以表示的最大正整数是2^12−1=4095，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号 由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。 作用 SnowFlake可以保证： 所有生成的id按时间趋势递增 整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分） java实现 public class SnowFlake { /** * 起始的时间戳:这个时间戳自己随意获取，比如自己代码的时间戳 */ private final static long START_STMP = 1543903501000L; /** * 每一部分占用的位数 */ private final static long SEQUENCE_BIT = 12; //序列号占用的位数 private final static long MACHINE_BIT = 5; //机器标识占用的位数 private final static long DATACENTER_BIT = 5;//数据中心占用的位数 /** * 每一部分的最大值：先进行左移运算，再同-1进行异或运算；异或：相同位置相同结果为0，不同结果为1 */ /** 用位运算计算出最大支持的数据中心数量：31 */ private final static long MAX_DATACENTER_NUM = -1L ^ (-1L \u003c\u003c DATACENTER_BIT); /** 用位运算计算出最大支持的机器数量：31 */ private final static long MAX_MACHINE_NUM = -1L ^ (-1L \u003c\u003c MACHINE_BIT); /** 用位运算计算出12位能存储的最大正整数：4095 */ private final static long MAX_SEQUENCE = -1L ^ (-1L \u003c\u003c SEQUENCE_BIT); /** * 每一部分向左的位移 */ /** 机器标志较序列号的偏移量 */ private final static long MACHINE_LEFT = SEQUENCE_BIT; /** 数据中心较机器标志的偏移量 */ private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT; /** 时间戳较数据中心的偏移量 */ private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT; private static long datacenterId; //数据中心 private static long machineId; //机器标识 private static long sequence = 0L; //序列号 private static long lastStmp = -1L;//上一次时间戳 /** 此处无参构造私有，同时没有给出有参构造，在于避免以下两点问题： 1、私有化避免了通过new的方式进行调用，主要是解决了在for循环中通过new的方式调用产生的id不一定唯一问题问题，因为用于 记录上一次时间戳的lastStmp永远无法得到比对； 2、没有给出有参构造在第一点的基础上考虑了一套分布式系统产生的唯一序列号应该是基于相同的参数 */ private SnowFlake(){} /** * 产生下一个ID * * @return */ public static synchronized long nextId() { /** 获取当前时间戳 */ long currStmp = getNewstmp(); /** 如果当前时间戳小于上次时间戳则抛出异常 */ if (currStmp \u003c lastStmp) { throw new RuntimeException(\"Clock moved backwards. Refusing to generate id\"); } /** 相同毫秒内 */ if (currStmp == lastStmp) { //相同毫秒内，序列号自增 sequence = (sequence + 1) \u0026 MAX_SEQUENCE; //同一毫秒的序列数已经达到最大 if (sequence == 0L) { /** 获取下一时间的时间戳并赋值给当前时间戳 */ currStmp = getNextMill(); } } else { //不同毫秒内，序列号置为0 sequence = 0L; } /** 当前时间戳存档记录，用于下次产生id时对比是否为相同时间戳 */ lastStmp = currStmp; return (currStmp - START_STMP) \u003c\u003c TIMESTMP_LEFT //时间戳部分 | datacenterId \u003c\u003c DATACENTER_LEFT //数据中心部分 | machineId \u003c\u003c MACHINE_LEFT //机器标识部分 | sequence; //序列号部分 } private static long getNextMill() { long mill = getNewstmp(); while (mill \u003c= lastStmp) { mill = getNewstmp(); } return mill; } private static long getNewstmp() { return System.currentTimeMillis(); } } 缺点 雪花算法强依赖机器时钟，如果因为不可抗力或者人为因素导致机器时间出现倒退，则可能导致生成重复的ID。 以下是几种解决时钟回拨的思路： 回拨时间很短（\u003c=3ms）：Sleep对应的时间差值 回拨时间适中（\u003e3ms \u003c= 100ms）：本地缓存最近100ms内生成的所有最大ID值，当时间回拨处于该范围，通过本地缓存获取最大ID值并加一。 回拨时间较长（\u003e 100ms \u003c=5s）：抛出异常，利用业务端的重试机制，负载到其它正常的ID生成服务实例。 回拨时间很长（\u003e 5s）：通过注册中心下线服务实例，并通知人工干预。 注：时间值为参考值，具体如何设置看实际情况 public synchronized long nextId() { // long timestamp = this.timeGen(); //检查时钟回拨 timestamp = this.checkClockBackwards(timestamp); //同时间戳，那么时间戳加1 if (this.lastTimestamp == timestamp) { this.sequence = this.sequence + 1 \u0026 this.sequenceMask; if (this.sequence == 0) { timestamp = this.tilNextMillis(this.lastTimestamp); } } else if (this.sequence != 0) { this.sequence = 0; } this.lastTimestamp = timestamp; //构造ID return timestamp - this.epoch \u003c\u003c this.shiftTime | (long)(this.workerId \u003c\u003c this.shiftWorker) | (long)this.sequence; } private long checkClockBackwards(long timestamp) { if (timestamp \u003c this.lastTimestamp) { boolean fixedByWait = true; long offset = this.lastTimestamp - timestamp; //小于默认等待时间，那就一直等待，然后重新生成时间戳 if (offset \u003c= this.tolerantClockBackTimestamp \u0026\u0026 this.tolerantClockBackTimestamp \u003e 0L) { try { this.wait(t","date":"2022-11-29","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/:1:2","tags":["分布式ID","Snowflake","Long精度丢失"],"title":"分布式ID生成算法Snowflake的原理与应用","uri":"/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"},{"categories":["Java后端"],"content":"关于分布式文件的思考 ","date":"2022-11-27","objectID":"/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/:1:0","tags":["分布式文件"],"title":"关于分布式文件的思考","uri":"/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Java后端"],"content":"谈一谈Ruoy ruoyi框架在实现分布式文件系统时给了用户三种选择：本地存储，minio以及FastDFS。 在具体的使用中，只能指定一种存储方式，不能多源存储，在三种存储方式中，之后后面两种支持分布式系统。 @Primary:意思是在众多相同的bean中，优先使用用@Primary注解的bean。 ​ 在架构上，通过三个不同子类FastDfsSysFileServiceImpl.java、MinioSysFileServiceImpl.java、LocalSysFileServiceImpl.java实现同一个基类ISysFileService.java，默认LocalSysFileServiceImpl.java作为默认存储方式。 ​ 在依赖注入时，只注入默认的文件服务 @RestController public class SysFileController { private static final Logger log = LoggerFactory.getLogger(SysFileController.class); @Autowired private ISysFileService sysFileService; /** * 文件上传请求 */ @PostMapping(\"upload\") public R\u003cSysFile\u003e upload(MultipartFile file) { try { // 上传并返回访问地址 String url = sysFileService.uploadFile(file); SysFile sysFile = new SysFile(); sysFile.setName(FileUtils.getName(url)); sysFile.setUrl(url); return R.ok(sysFile); } catch (Exception e) { log.error(\"上传文件失败\", e); return R.fail(e.getMessage()); } } } 存在的缺点： 1、不能在controller层实现调用不同的文件服务，无法在调用层实现文件服务的切换； 2、切换数据源需要改代码； 3、不能多源存储，实现逻辑为一份文件实现多个数据源同时存储，可以存储在数据库的不同字段，以便系统容错 ","date":"2022-11-27","objectID":"/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/:1:1","tags":["分布式文件"],"title":"关于分布式文件的思考","uri":"/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Java后端"],"content":"1、实现文件服务工厂类","date":"2022-11-27","objectID":"/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/:1:2","tags":["分布式文件"],"title":"关于分布式文件的思考","uri":"/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Java后端","ruoyi"],"content":"分布式文件 ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:0:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#基本介绍 什么是分布式文件 分布式文件系统是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 为什么要使用分布式文件 分布式文件系统是面对互联网的需求而产生，互联网时代对海量数据如何存储？靠简单的增加硬盘的个数已经满足不了我们的要求，因为硬盘传输速度有限但是数据在急剧增长，另外我们还要要做好数据备份、数据安全等。 ruoyi-file目前支持三种存储方式，本地存储、MinIO存储、FastDfs存储，可以在ruoyi-file-dev.yml配置。 ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:1:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#本地存储 1、文件配置 # 本地文件上传 file:# 访问地址domain:http://127.0.0.1:9300# 本地存放的路径地址path:D:/ruoyi/uploadPath# 映射地址prefix:/statics 2、继承WebMvcConfigurer，重写addResourceHandlers，在registry里面配置访问路径和映射到的服务器本地路径。 package com.ruoyi.file.config; import java.io.File; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * 通用映射配置 * * @author ruoyi */ @Configuration public class ResourcesConfig implements WebMvcConfigurer { /** * 上传文件存储在本地的根路径 */ @Value(\"${file.path}\") private String localFilePath; /** * 资源映射路径 前缀 */ @Value(\"${file.prefix}\") public String localFilePrefix; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { /** 本地文件上传路径 */ registry.addResourceHandler(localFilePrefix + \"/**\") .addResourceLocations(\"file:\" + localFilePath + File.separator); } } 3、启动ruoyi-file应用，访问statics会被映射到本地项目D:/ruoyi/uploadPath下的目录里面。 ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:2:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#MinIO存储 ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:3:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#下载方式 Windows平台安装包下载 可以从https://min.io/download#/windows下载minio.exe可执行的文件。 Windows下载后新建一个目录存放minio文件，例如D:\\minioData，直接在cmd下运行minio.exe server D:\\minioData。 启动成功以后如下图，最后红色字提示修改access Key和Secret Key 提示 如果觉得官网下载慢，可以使用我分享的网盘地址: https://pan.baidu.com/s/1E9J52g6uW_VFWY34fHL6zA 提取码: vneh 打开控制台 minio`提供了一个可视化的管理控制平台，安装好之后，在浏览器中输入([http://localhost:9000/ (opens new window)](http://localhost:9000/))就可以访问了，默认的用户名和密码都是`minioadmin ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:3:1","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#如何使用 配置文件 # Minio配置minio:url:http://127.0.0.1:9000# 账号accessKey:minioadmin# 密码secretKey:minioadmin# MinIO桶名字bucketName:ruoyi 创建桶 在后台管理界面选择+号创建你的Create Bucket，可以理解为一个文件夹用来存放图片。桶创建成功之后就可以上传图片了。 上传图片 在后台管理界面选择+号上传你的Upload file，上传你自己的图片。在文件列表的右边就可以看到图片了。 ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:3:2","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#访问策略 设置* ReadOnly则所有用户通过文件路径即可访问，私有桶则不必设置访问策略。 启动ruoyi-file应用，在浏览器中打开(http://127.0.0.1:9000/ruoyi/ruoyi.png (opens new window))就可以访问图片了。 ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:3:3","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#FastDfs存储 文件存储、文件同步、文件上传、文件下载等，解决了文件大容量存储和高性能访问问题。 ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:4:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#下载方式 创建目录mkdir /home/fastdfs 1)、下载安装libfastcommon 1、下载libfastcommon v1.0.7 wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz 2、解压libfastcommon v1.0.7 tar -xvf V1.0.7.tar.gz` cd libfastcommon-1.0.7 3、编译、安装 ./make.sh ./make.sh install 4、创建软链接 ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so 2)、下载安装FastDFS 1、下载FastDFS wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz 2、解压FastDFS tar -xvf V5.05.tar.gz cd fastdfs-5.05 3、编译、安装 ./make.sh ./make.sh install 3)、配置 Tracker 服务 上述安装成功后，在/etc/目录下会有一个fdfs的目录，进入它。会看到三个.sample后缀的文件，这是作者给我们的示例文件， 我们需要把其中的tracker.conf.sample文件改为tracker.conf配置文件并修改它： cp tracker.conf.sample tracker.conf vi tracker.conf 编辑tracker.conf # 配置文件是否不生效，false 为生效 disabled=false # 提供服务的端口 port=22122 # Tracker 数据和日志目录地址 base_path=//home/data/fastdfs # HTTP 服务端口 http.server_port=80 创建tracker基础数据目录，即base_path对应的目录 mkdir -p /home/data/fastdfs 使用ln -s 建立软链接 ln -s /usr/bin/fdfs_trackerd /usr/local/bin ln -s /usr/bin/stop.sh /usr/local/bin ln -s /usr/bin/restart.sh /usr/local/bin 启动服务 service fdfs_trackerd start service fdfs_trackerd stop service fdfs_trackerd restart 查看监听 netstat -unltp|grep fdfs 如果看到22122端口正常被监听后，这时候说明Tracker服务启动成功啦！ tracker server目录及文件结构 Tracker服务启动成功后，会在base_path下创建data、logs两个目录。目录结构如下： ${base_path} |__data | |__storage_groups.dat：存储分组信息 | |__storage_servers.dat：存储服务器列表 |__logs | |__trackerd.log： tracker server 日志文件 4)、配置 Storage 服务 进入/etc/fdfs目录，复制FastDFS存储器样例配置文件storage.conf.sample，并重命名为storage.conf # cd /etc/fdfs # cp storage.conf.sample storage.conf # vi storage.conf 编辑storage.conf # 配置文件是否不生效，false 为生效 disabled=false # 指定此 storage server 所在 组(卷) group_name=group1 # storage server 服务端口 port=23000 # 心跳间隔时间，单位为秒 (这里是指主动向 tracker server 发送心跳) heart_beat_interval=30 # Storage 数据和日志目录地址(根目录必须存在，子目录会自动生成) base_path=/home/data/fastdfs/storage # 存放文件时 storage server 支持多个路径。这里配置存放文件的基路径数目，通常只配一个目录。 store_path_count=1 # 逐一配置 store_path_count 个路径，索引号基于 0。 # 如果不配置 store_path0，那它就和 base_path 对应的路径一样。 store_path0=/home/data/fastdfs/storage # FastDFS 存储文件时，采用了两级目录。这里配置存放文件的目录个数。 # 如果本参数只为 N（如： 256），那么 storage server 在初次运行时，会在 store_path 下自动创建 N * N 个存放文件的子目录。 subdir_count_per_path=256 # tracker_server 的列表 ，会主动连接 tracker_server # 有多个 tracker server 时，每个 tracker server 写一行 公网访问需要配置公网IP tracker_server=192.168.1.190:22122 # 允许系统同步的时间段 (默认是全天) 。一般用于避免高峰同步产生一些问题而设定。 sync_start_time=00:00 sync_end_time=23:59 创建storaged基础数据目录，即base_path对应的目录 mkdir -p /home/data/fastdfs/storage 使用ln -s 建立软链接 ln -s /usr/bin/fdfs_storaged /usr/local/bin 启动服务 service fdfs_storaged start service fdfs_storaged stop service fdfs_storaged restart 查看监听 netstat -unltp|grep fdfs 启动Storage前确保Tracker是启动的。初次启动成功，会在/home/data/fastdfs/storage目录下创建data、logs两个目录。 如果看到23000端口正常被监听后，这时候说明Storage服务启动成功啦！ 查看Storage和Tracker是否在通信 /usr/bin/fdfs_monitor /etc/fdfs/storage.conf ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:4:1","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#配置Nginx 1、下载安装Nginx和fastdfs-nginx-module 安装以下的开发库: yum install readline-devel pcre-devel openssl-devel -y 2、下载fastdfs-nginx-module-1.20.tar tar -xvf fastdfs-nginx-module-1.20.tar 3、编辑fastdfs-nginx-module-1.20/src/config文件修改 vi fastdfs-nginx-module-1.20/src/config ngx_module_incs=\"/usr/include/fastdfs /usr/include/fastcommon/\" CORE_INCS=\"$CORE_INCS/usr/include/fastdfs /usr/include/fastcommon/\" 4、配置nginx安装，加入fastdfs-nginx-module模块（需要先安装好nginx） ./configure --add-module=../fastdfs-nginx-module-master/src/ 5、编译、安装 make \u0026\u0026 make install 6、查看Nginx的模块 ./nginx -v 7、复制fastdfs-nginx-module源码中的配置文件到/etc/fdfs目录，并修改 cd /home/FastDFS/fastdfs-nginx-module-1.20/src cp mod_fastdfs.conf /etc/fdfs/ # 连接超时时间 connect_timeout=10 # Tracker Server tracker_server=192.168.1.190:22122 # StorageServer 默认端口 storage_server_port=23000 # 如果文件ID的uri中包含/group**，则要设置为true url_have_group_name = true # Storage 配置的store_path0路径，必须和storage.conf中的一致 store_path0=/home/data/fastdfs/storage 8、复制FastDFS的部分配置文件到/etc/fdfs目录 cd /home/FastDFS/fastdfs-5.11/conf cp http.conf /etc/fdfs/ cp mime.types /etc/fdfs/ 9、配置nginx，修改nginx.conf： location ~/group([0-9])/M00 { ngx_fastdfs_module; } 10、启动Nginx： ./nginx ngx_http_fastdfs_set pid=11256 ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:4:2","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#如何使用 1、配置文件 # FastDFS配置fdfs:domain:http://8.129.231.12soTimeout:3000connectTimeout:2000trackerList:8.129.231.12:22122 启动ruoyi-file应用，调用upload上传接口后会返回一个地址，在浏览器中打开http://8.129.231.12/group1/M00/00/00/xxxx.png就可以访问图片了。 ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:4:3","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#切换存储方式 目前默认采用的是本地存储，可以通过注解@Primary指定需要使用的文件接口。 @Primary：意思是在众多相同的bean中，优先使用用@Primary注解的bean。 1.在多数据源的时候，使用@Primary注解用于指定其中一个作为主数据源，即如果数据库操作没有指明使用哪个数据源的时候，默认使用主数据源，这个时候我们就使用到了@primary这个注解。 @Primary @Service public class LocalSysFileServiceImpl implements ISysFileService { ..... } 本地文件存储：LocalSysFileServiceImpl.java Minio 文件存储：MinioSysFileServiceImpl.java FastDFS文件存储：FastDfsSysFileServiceImpl.java ","date":"2022-11-27","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:5:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端"],"content":"SpringBoot 玩一玩代码混淆，防止反编译代码泄露 ","date":"2022-11-26","objectID":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:0:0","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["Java后端"],"content":"编译 简单就是把代码跑一哈，然后我们的代码 .java文件 就被编译成了 .class 文件 ","date":"2022-11-26","objectID":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:1:0","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["Java后端"],"content":"反编译 就是针对编译生成的 jar/war 包 里面的 .class 文件 逆向还原回来，可以看到你的代码写的啥。 比较常用的反编译工具 JD-GUI ，直接把编译好的jar丢进去，大部分都能反编译看到源码: 那如果不想给别人反编译看自己写的代码呢？ 怎么做？ ","date":"2022-11-26","objectID":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:2:0","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["Java后端"],"content":"混淆 该篇玩的代码混淆 ，是其中一种手段。 我给你看，但你反编译看到的不是真正的代码。 先看一张效果示例图 ： 开搞 ","date":"2022-11-26","objectID":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:3:0","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["Java后端"],"content":"正文 先看一下我们混淆一个项目代码，要做啥？ ","date":"2022-11-26","objectID":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:4:0","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["Java后端"],"content":"一共就两步 第一步， 在项目路径下，新增一份文件 proguard.cfg ： proguard.cfg #指定Java的版本 -target 1.8 #proguard会对代码进行优化压缩，他会删除从未使用的类或者类成员变量等 -dontshrink #是否关闭字节码级别的优化，如果不开启则设置如下配置 -dontoptimize #混淆时不生成大小写混合的类名，默认是可以大小写混合 -dontusemixedcaseclassnames # 对于类成员的命名的混淆采取唯一策略 -useuniqueclassmembernames #混淆时不生成大小写混合的类名，默认是可以大小写混合 -dontusemixedcaseclassnames #混淆类名之后，对使用Class.forName('className')之类的地方进行相应替代 -adaptclassstrings #对异常、注解信息予以保留 -keepattributes Exceptions,InnerClasses,Signature,Deprecated,SourceFile,LineNumberTable,*Annotation*,EnclosingMethod # 此选项将保存接口中的所有原始名称（不混淆）--\u003e -keepnames interface ** { *; } # 此选项将保存所有软件包中的所有原始接口文件（不进行混淆） #-keep interface * extends * { *; } #保留参数名，因为控制器，或者Mybatis等接口的参数如果混淆会导致无法接受参数，xml文件找不到参数 -keepparameternames # 保留枚举成员及方法 -keepclassmembers enum * { *; } # 不混淆所有类,保存原始定义的注释- -keepclassmembers class * { @org.springframework.context.annotation.Bean *; @org.springframework.beans.factory.annotation.Autowired *; @org.springframework.beans.factory.annotation.Value *; @org.springframework.stereotype.Service *; @org.springframework.stereotype.Component *; } #忽略warn消息 -ignorewarnings #忽略note消息 -dontnote #打印配置信息 -printconfiguration -keep public class com.example.myproguarddemo.MyproguarddemoApplication { public static void main(java.lang.String[]); } 注意点： 其余的看注释，可以配置哪些类不参与混淆，哪些枚举保留，哪些方法名不混淆等等。 第二步，在pom文件上 加入proguard 混淆插件 ： build标签里面改动加入一下配置 \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003ecom.github.wvengen\u003c/groupId\u003e \u003cartifactId\u003eproguard-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e2.6.0\u003c/version\u003e \u003cexecutions\u003e \u003c!-- 以下配置说明执行mvn的package命令时候，会执行proguard--\u003e \u003cexecution\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003eproguard\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003cconfiguration\u003e \u003c!-- 就是输入Jar的名称，我们要知道，代码混淆其实是将一个原始的jar，生成一个混淆后的jar，那么就会有输入输出。 --\u003e \u003cinjar\u003e${project.build.finalName}.jar\u003c/injar\u003e \u003c!-- 输出jar名称，输入输出jar同名的时候就是覆盖，也是比较常用的配置。 --\u003e \u003coutjar\u003e${project.build.finalName}.jar\u003c/outjar\u003e \u003c!-- 是否混淆 默认是true --\u003e \u003cobfuscate\u003etrue\u003c/obfuscate\u003e \u003c!-- 配置一个文件，通常叫做proguard.cfg,该文件主要是配置options选项，也就是说使用proguard.cfg那么options下的所有内容都可以移到proguard.cfg中 --\u003e \u003cproguardInclude\u003e${project.basedir}/proguard.cfg\u003c/proguardInclude\u003e \u003c!-- 额外的jar包，通常是项目编译所需要的jar --\u003e \u003clibs\u003e \u003clib\u003e${java.home}/lib/rt.jar\u003c/lib\u003e \u003clib\u003e${java.home}/lib/jce.jar\u003c/lib\u003e \u003clib\u003e${java.home}/lib/jsse.jar\u003c/lib\u003e \u003c/libs\u003e \u003c!-- 对输入jar进行过滤比如，如下配置就是对META-INFO文件不处理。 --\u003e \u003cinLibsFilter\u003e!META-INF/**,!META-INF/versions/9/**.class\u003c/inLibsFilter\u003e \u003c!-- 这是输出路径配置，但是要注意这个路径必须要包括injar标签填写的jar --\u003e \u003coutputDirectory\u003e${project.basedir}/target\u003c/outputDirectory\u003e \u003c!--这里特别重要，此处主要是配置混淆的一些细节选项，比如哪些类不需要混淆，哪些需要混淆--\u003e \u003coptions\u003e \u003c!-- 可以在此处写option标签配置，不过我上面使用了proguardInclude，故而我更喜欢在proguard.cfg中配置 --\u003e \u003c/options\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cgoals\u003e \u003cgoal\u003erepackage\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003cmainClass\u003ecom.example.myproguarddemo.MyproguarddemoApplication\u003c/mainClass\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 注意点： 然后可以看到： 然后点击package，正常执行编译打包流程就可以 ： 然后可以看到jar的生成： 看看效果： ","date":"2022-11-26","objectID":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:4:1","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["LowCode"],"content":"Umi4 集成阿里低代码框架lowcode-engine 携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第2天，点击查看活动详情 ","date":"2022-11-26","objectID":"/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/:0:0","tags":["Umi4","lowcode-engine"],"title":"Umi4 集成阿里低代码框架lowcode-engine","uri":"/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/"},{"categories":["LowCode"],"content":"前言 最近准备研究下阿里低代码框架lowcode-engine, 官方Demo是提供好的脚手架，由于我们的框架使用的是umi，官方文档提供了一些教程，在此记录下在umi4集成lowcode-engine. ","date":"2022-11-26","objectID":"/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/:1:0","tags":["Umi4","lowcode-engine"],"title":"Umi4 集成阿里低代码框架lowcode-engine","uri":"/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/"},{"categories":["LowCode"],"content":"实现 搭建umi4项目 1.通过官方文档的快速开始，我们可以快速创建出项目 先找个地方建个空目录 mkdir myapp \u0026\u0026 cd myapp 复制代码 通过官方工具创建项目, 这里我们采用pnpm包管理工具 $ pnpm dlx create-umi@latest ✔ Install the following package: create-umi? (Y/n) · true ✔ Pick Npm Client › pnpm ✔ Pick Npm Registry › taobao Write: .gitignore Write: .npmrc Write: .umirc.ts Copy: layouts/index.tsx Write: package.json Copy: pages/index.tsx Copy: pages/users.tsx Copy: pages/users/foo.tsx \u003e @ postinstall /private/tmp/sorrycc-vylwuW \u003e umi setup info - generate files 复制代码 创建完成后，安装依赖, 执行 pnpm dev就可以看到我们的项目启动起来了。 集成lowcode-engine 引入UMD包, 我们在 .umirc.ts中配置externals,styles和scripts externals: { 'react': 'var window.React', 'react-dom': 'var window.ReactDOM', 'prop-types': 'var window.PropTypes', '@alifd/next': 'var window.Next', '@alilc/lowcode-engine': 'var window.AliLowCodeEngine', '@alilc/lowcode-editor-core': 'var window.AliLowCodeEngine.common.editorCabin', '@alilc/lowcode-editor-skeleton': 'var window.AliLowCodeEngine.common.skeletonCabin', '@alilc/lowcode-designer': 'var window.AliLowCodeEngine.common.designerCabin', '@alilc/lowcode-engine-ext': 'var window.AliLowCodeEngineExt', '@ali/lowcode-engine': 'var window.AliLowCodeEngine', 'moment': 'var window.moment', 'lodash': 'var window._', }, styles: [ 'https://alifd.alicdn.com/npm/@alilc/lowcode-engine@latest/dist/css/engine-core.css', 'https://g.alicdn.com/code/lib/alifd__next/1.23.24/next.min.css', 'https://alifd.alicdn.com/npm/@alifd/theme-lowcode-light/0.2.0/next.min.css', 'https://alifd.alicdn.com/npm/@alilc/lowcode-engine-ext@latest/dist/css/engine-ext.css' ], scripts: [ { src: 'https://g.alicdn.com/code/lib/react/18.0.0/umd/react.development.js', defer: false, }, { src: 'https://g.alicdn.com/code/lib/react-dom/18.0.0/umd/react-dom.development.js', defer: false, }, { src: 'https://g.alicdn.com/code/lib/prop-types/15.7.2/prop-types.js', defer: false, }, { src: 'https://g.alicdn.com/platform/c/react15-polyfill/0.0.1/dist/index.js', defer: false, }, { src: 'https://g.alicdn.com/platform/c/lodash/4.6.1/lodash.min.js', defer: false, }, { src: 'https://g.alicdn.com/code/lib/moment.js/2.29.1/moment-with-locales.min.js', defer: false, }, { src: 'https://g.alicdn.com/code/lib/alifd__next/1.23.24/next.min.js', defer: false, }, { src: 'https://alifd.alicdn.com/npm/@alilc/lowcode-engine@latest/dist/js/engine-core.js', defer: false, }, { src: 'https://alifd.alicdn.com/npm/@alilc/lowcode-engine-ext@latest/dist/js/engine-ext.js', defer: false, } 我们使用lowcode-enginey引擎提供的init进行初始化，init() 内部会调用 ReactDOM.render() 函数，这样初始化有些弊端。一些内容没有办法与外部的 React 组件进行通信，也就没有办法在一些自定义的 plugin 中获取 redux 上的全局数据等内容，但也有好处，就是低代码引擎比较独立，后期可以拆出供多个项目使用。 我们参考官方提供的Demo的入口文件。在我们这里封装成一个LowcodeEditor组件。 import { init, plugins } from '@alilc/lowcode-engine'; import { useEffect } from 'react'; import registerPlugins from './plugin'; import './global.less'; export default function LowcodeEditor() { useEffect(() =\u003e { const preference = new Map(); preference.set('DataSourcePane', { importPlugins: [], dataSourceTypes: [ { type: 'fetch', }, { type: 'jsonp', }, ], }); (async function main() { await registerPlugins(); console.log('first-2') init( document.getElementById('engine-container')!, { // designMode: 'live', // locale: 'zh-CN', enableCondition: true, enableCanvasLock: true, // 默认绑定变量 supportVariableGlobally: true, // simulatorUrl 在当 engine-core.js 同一个父路径下时是不需要配置的！！！ // 这里因为用的是 alifd cdn，在不同 npm 包，engine-core.js 和 react-simulator-renderer.js 是不同路径 simulatorUrl: [ 'https://alifd.alicdn.com/npm/@alilc/lowcode-react-simulator-renderer@latest/dist/css/react-simulator-renderer.css', 'https://alifd.alicdn.com/npm/@alilc/lowcode-react-simulator-renderer@latest/dist/js/react-simulator-renderer.js', ], requestHandlersMap: { fetch: async () =\u003e {} } }, preference, ); })(); }, []); return \u003cdiv id='engine-container' style={{backgroundColor: 'red'}}\u003e\u003c/div\u003e; } 复制代码 这里只是入口组件的初始化，组件内部还有很多内容，我们重Deom中copy出来。比如plugin，assets.josn,schem.json等，这里不做过多的介绍，里面的内容好多，后续我们一边学习，一边慢慢拆解，分享。 使用LowcodeEditor组件，在我们需要的地方直接导入，使用就行 import yayJpg fr","date":"2022-11-26","objectID":"/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/:2:0","tags":["Umi4","lowcode-engine"],"title":"Umi4 集成阿里低代码框架lowcode-engine","uri":"/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/"},{"categories":["LowCode"],"content":"结束语 代码已上传到github,请查看mi4-lowcode-app。 ","date":"2022-11-26","objectID":"/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/:3:0","tags":["Umi4","lowcode-engine"],"title":"Umi4 集成阿里低代码框架lowcode-engine","uri":"/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/"},{"categories":["数据库"],"content":" (五)MySQL索引应用篇：建立索引的正确姿势与使用索引的最佳指南！ ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:0:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"引言 数据库索引，绝对是MySQL的核心功能之一，如果没有索引机制的数据库，那数据的检索效率绝对是令人无法接受的，毕竟没有索引的表数据，就如同一个普通的文本文件存储在磁盘中。在《索引上篇》中，我们对于MySQL提供的索引机制，从引入，到创建、使用、分类、管理….等进行了全面阐述，相信经过上一篇的讲解后，大家对MySQL索引机制建立了系统化的认知，而本篇则会以上篇为基础，对索引机制进一步加深掌握。 不过在上篇中虽对数据库索引机制有了完善认知，但还不够，因为上篇仅是单纯的认知阶段，能否真正的在实际项目中运用好索引机制，还需要具备丰富的经验以及一些原则与方法论，比如下述一些关于索引的问题： 索引虽然能给MySQL检索数据的效率带来质的飞跃，但加入索引未带来新问题吗？ 既然索引能够提升查询性能，那是不是为表中每个字段建立索引，性能会更好？ 一张数据表中，那些类型的字段不适合建立索引呢？又是因为什么原因呢？ 表中会存在大量的字段，但其中那些字段建立索引才能够最大的性能收益呢？ MySQL提供的索引种类也不少，一个字段上建立什么类型的索引才最好呢？ 当表中存在多个索引时，一条查询SQL有多条路径可走，此时走哪条索引最好？ ....... 对于这些问题，如果仅靠上篇索引的知识，相信是很难回答具体的，那在本篇中，则重点讲解索引应用相关的方式方法，例如各索引优劣分析、建立索引的原则、使用索引的指南以及索引失效与索引优化等内容。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:1:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"一、MySQL各索引的优劣分析 首先来聊聊索引机制带来的利害关系，有句古话曾说过：“凡事有利必有弊”，而MySQL的索引机制也不例外，引入索引机制后，能够给数据库带来的优势很明显： ①整个数据库中，数据表的查询速度直线提升，数据量越大时效果越明显。 ②通过创建唯一索引，可以确保数据表中的数据唯一性，无需额外建立唯一约束。 ③在使用分组和排序时，同样可以显著减少SQL查询的分组和排序的时间。 ④连表查询时，基于主外键字段上建立索引，可以带来十分明显的性能提升。 ⑤索引默认是B+Tree有序结构，基于索引字段做范围查询时，效率会明显提高。 ⑥从MySQL整体架构而言，减少了查询SQL的执行时间，提高了数据库整体吞吐量。 看着上面一条又一条的好处，似乎感觉索引好处很大啊，对于这点确实毋庸置疑，但只有好处吗？No，同时也会带来一系列弊端，如： ①建立索引会生成本地磁盘文件，需要额外的空间存储索引数据，磁盘占用率会变高。 ②写入数据时，需要额外维护索引结构，增、删、改数据时，都需要额外操作索引。 ③写入数据时维护索引需要额外的时间开销，执行写SQL时效率会降低，性能会下降。 当然，但对数据库整体来说，索引带来的优势会大于劣势。不过也正由于索引存在弊端，因此索引不是越多越好，合理建立索引才是最佳选择。 在上篇聊过，MySQL的索引也会分为多种类型，每个类型的索引多多少少都存在一些弊端，接下来聊聊其他类型的索引。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.1、主键索引存在的陷阱 相信大家数据库的表中，主键一般都是使用自增ID，但这是为什么呢？有人可能会回答自增ID不会重复，确保了主键唯一性。这样也确实没错，但不会重复的又不仅仅只有自增ID，比如我使用随机的UUID也不会重复，为何不使用UUID呢？这是由于索引存在一个陷阱！ 众所周知，一张表中大多数情况下，会将主键索引以聚簇的形式存在磁盘中，上篇文章也聊到过，聚簇索引在存储数据时，表数据和索引数据是一起存放的。同时，MySQL默认的索引结构是B+Tree，也就代表着索引节点的数据是有序的。 此时结合上面给出的一些信息，主键索引是聚簇索引，表数据和索引数据在一块、索引结构是有序的，那再反推前面给出的疑惑，为何不使用UUID呢？因为UUID是无序的，如果使用UUID作为主键，那么每当插入一条新数据，都有可能破坏原本的树结构，如下： 比如上图中的灰色节点，是一条新插入的数据，此时经过计算后，应该排第二个位置，那就代表着后面的三个节点需要移动，然后给灰色节点挪出一个位置存储，从而确保索引的有序性。 这里只是伪逻辑，目的是用于举例演示，实际上B+树索引结构不长这样，在《索引原理篇》会重新说一下这个点的。 由于主键索引是聚簇索引，因此上述案例中，当后续节点需要挪动时，也就代表着还需要挪动表数据，如果是偶尔需要移动还行，但如果主键字段值无序，那代表着几乎每次插入都有可能导致树结构要调整。 但使用自增ID就不会有这个问题，所有新插入的数据都会放到最后。 因此大家数据表的主键，最好选用带顺序性的值，否则有可能掉入主键索引的“陷阱”中。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:1","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.2、联合索引存在的矛盾 为了多条件查询时的效率更高，一般都会同时对多个字段建立联合索引，但之前也聊到过，联合索引存在一个致命的问题，比如在用户表中，通过id、name、age三个字段建立一个联合索引，此时来了一条查询SQL，如下： SELECT*FROM`zz_user`WHEREname=\"竹子\"ANDage=\"18\"; 而这条SQL语句是无法使用联合索引的，为什么呢？因为查询条件中，未包含联合索引的第一个字段，想要使用联合索引，那么查询条件中必须包含索引的第一个字段，如下： SELECT*FROM`zz_user`WHEREname=\"竹子\"ANDid=6; 上面这条SQL才是能命中多列索引的语句，因此在建立索引时也需要考虑这个问题，确保建立出的联合索引能够命中率够高。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:2","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.3、前缀索引存在的弊端 前缀索引的特点是短小精悍，我们可以利用一个字段的前N个字符创建索引，以这种形式创建的索引也被称之为前缀索引，相较于使用一个完整字段创建索引，前缀索引能够更加节省存储空间，当数据越多时，带来的优势越明显。 不过前缀索引虽然带来了节省空间的好处，但也正由于其索引节点中，未存储一个字段的完整值，所以MySQL也无法通过前缀索引来完成ORDER BY、GROUP BY等分组排序工作，同时也无法完成覆盖扫描等操作。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:3","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.4、全文索引存在的硬伤 之前做模糊查询时，通常都会使用like%语法，不过这种方式虽然能够实现效果，但随着表越来越大，数据越来越多时，其性能会出现明显下降，而全文索引的推出则能够完美解决该问题，可以利用全文索引代替like%语法实现模糊查询，它的性能会比like%快上N倍。 全文索引虽然可以实现模糊查询，但也存在一系列硬伤，一起来看看。 ①由于全文索引是基于分词实现的，所以对一个字段建立全文索引后，MySQL会对该字段做分词处理，这些分词结果也会被存储在全文索引中，因此全文索引的文件会额外的大！ ②由于全文索引对每个字段值都会做分词，因此当修改字段值后，分词是需要时间的，所以修改字段数据后不会立马自动更新全文索引，此时需要咱们写存储过程，并调用它手动更新全文索引中的数据。 ③除开上述两点外，全文索引最大的硬伤在于对中文支持不够友好，类似于英文可以直接通过符号、空格来分词，但中文呢？一个词语来形容就是博大精深，无法精准的对一段文字做分词，因此全文索引在检索中文时，存在些许精准度问题。 因此如果你项目规模较大，通常再引入ElasticSearch、Solr、MeiliSearch等搜索引擎是一个更佳的选择。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:4","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.5、唯一索引存在的快慢问题 唯一索引有个很大的好处，就是查询数据时会比普通索引效率更高，因为基于普通索引的字段查询数据，例如： SELECT*FROMTABLE_XXWHERECOLUMN_XX=\"XX\"; 假设COLUMN_XX字段上建立了一个普通索引，此时基于这个字段查询数据时，当查询到一条COLUMN_XX = \"XX\"的数据后，此时会继续走完整个索引树，因为可能会存在多条字段值相同的数据。 但如果COLUMN_XX字段上建立的是唯一索引，当找到一条数据后就会立马停下检索，因此本身建立唯一索引的字段值就具备唯一性。 因此唯一索引查询数据时，会比普通索引快上一截，但插入数据时就不同了，因为要确保数据不重复，所以插入前会检查一遍表中是否存在相同的数据。但普通索引则不需要考虑这个问题，因此普通索引的数据插入会快一些。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:5","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.6、哈希索引的致命问题 哈希索引，也就是数据结构为Hash类型的索引，不过估计大家接触的比较少，毕竟创建索引时都默认用的B+树结构。但要比起查询速度，哈希索引绝对是MySQL中当之无愧的魁首！因为采用哈希结构的索引，会以哈希表的形式存储索引字段值，当基于该字段查询数据时，只需要经过一次哈希计算就可获取到数据。 但哈希结构的致命问题在于无序，也就是无法基于哈希索引的字段做排序、分组等工作。 因此如果你确定一个表中，不会做排序这类的工作，那可以适当选用哈希结构作为索引的数据结构，它会给你带来意想不到的性能收益~ ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:6","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"二、建立索引的正确姿势 经过上述一系列分析后，简单讲明了每种索引类型存在的缺陷问题，但这跟我们本篇有啥关系呢？其实关系很大，因为只有当你了解了每种索引存在的劣势，才能更好的考虑并设计出合理的索引，而不是一股脑的盲目创建索引。 那么在创建索引时，咱们应当遵守那些原理原则，才能创建出合理的索引呢？ 在实际项目场景中，当SQL查询性能较慢时，我们常常会有一个疑惑：表中哪个字段建立一个索引能带来最大的性能收益呢？一般来说，判断字段是否要添加的索引的依据，是看这个字段是否被经常当做查询条件使用，但也不能光依靠这一个依据来判断，比如用户表中的性别字段，就会经常被用做查询条件，但如果对性别字段建立一个索引，那对查询的性能提升并不大，因为性别就两个值：男/女（不包含泰国在内），那对其建立索引，索引文件中就只会有两个索引节点，大致情况如下： 这种情况下，为性别建立一个索引，带来的性能收益显然不是太大。同时，上图中给出的案例，也不是索引真正的样子，如果表中存在主键索引或聚簇索引，对其他字段建立的索引，都是次级索引，也被称为辅助索引，其节点上的值，存储的并非一条完整的行数据，而是指向聚簇索引的索引字段值。 如果基于辅助索引查询数据，最终数据会以何种方式被检索出来，这里就牵扯到MySQL中的一个新概念，也就是SQL执行时的回表问题。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:3:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"2.1、索引查询时的回表问题 什么叫做回表呢？意思就是指一条SQL语句在MySQL内部，要经过两次查询过程才能获取到数据。这是跟索引机制有关的，先来看看索引在MySQL内部真正的面貌： 在上图用户表中，基于ID字段先建立了一个主键索引，然后又基于name字段建立了一个普通索引，此时MySQL默认会选用主键索引作为聚簇索引，将表数据和主键索引存在同一个文件中，也就是主键索引的每个索引节点，都直接对应着行数据。而基于name字段建立的索引，其索引节点存放的则是指向聚簇索引的ID值。 在这种情况下，假设有一条下述SQL，其内部查询过程是啥样的呢？ SELECT*FROM`zz_user`WHEREname=\"子竹\";复制代码 首先会走name字段的索引，然后找到对应的ID值，然后再基于查询到的ID值，再走ID字段的主键索引，最终得到一整条行数据并返回。 在这个案例中，一条查询SQL经历了两次查询才获取到数据，这个过程则被称之为回表。 回表动作会导致额外的查询开销，因此尽量可以基于主键做查询，如果实在需要使用非主键字段查询，那么尽量要写明查询的结果字段，而并非使用*。 当然，实际情况中建立联合索引，利用索引覆盖特性，从而避免使用辅助索引，这样也能够消除回表动作，但关于这点后面再聊，先来说说建立索引需要遵循的一些原则。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:3:1","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"2.2、建立索引时需要遵守的原则 前面说过一点，当建立索引仅考虑一个字段是否被经常用于查询是不够的，往往一个合适的索引需要更为细致与长远的思考，例如使用多个字段建立是否会更好？创建其他类型的索引性能是否会更佳？下面我们就一起来看看建立索引时，需要遵守的一些原则： ①经常频繁用作查询条件的字段应酌情考虑为其创建索引。 ②表的主外键或连表字段，必须建立索引，因为能很大程度提升连表查询的性能。 ③建立索引的字段，一般值的区分性要足够高，这样才能提高索引的检索效率。 ④建立索引的字段，值不应该过长，如果较长的字段要建立索引，可以选择前缀索引。 ⑤建立联合索引，应当遵循最左前缀原则，将多个字段之间按优先级顺序组合。 ⑥经常根据范围取值、排序、分组的字段应建立索引，因为索引有序，能加快排序时间。 ⑦对于唯一索引，如果确认不会利用该字段排序，那可以将结构改为Hash结构。 ⑧尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。 同时，除开上述一些建立索引的原则外，在建立索引时还需有些注意点： ❶值经常会增删改的字段，不合适建立索引，因为每次改变后需维护索引结构。 ❷一个字段存在大量的重复值时，不适合建立索引，比如之前举例的性别字段。 ❸索引不能参与计算，因此经常带函数查询的字段，并不适合建立索引。 ❹一张表中的索引数量并不是越多越好，一般控制在3，最多不能超过5。 ❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。 ❻当表的数据较少，不应当建立索引，因为数据量不大时，维护索引反而开销更大。 ❼索引的字段值无序时，不推荐建立索引，因为会造成页分裂，尤其是主键索引。 对于索引机制，在建立时应当参考上述给出的意见，这每一条原则都是从实际经验中总结出来的，前面八条不一定要全面思考，但后面七条注意点，一定要牢记，如若你的索引符合后面七条中的描述，那一定要更改索引。 对于每一条建议是为什么，在后面的《索引原理篇》讲完之后大家就会彻底理解，这里就不展开叙述了，接下来重点聊一下联合索引，以及它的最左前缀原则。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:3:2","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"2.3、联合索引的最左前缀原则 首先在讲最左前缀原则之前，先看看上述给出的一条原则： ⑧尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。 对于这一点是为什么呢？举个栗子理解，比如此时基于X、Y、Z字段建立了一个联合索引，实际上也相当于建立了三个索引：X、X、Y、X、Y、Z，因此只要查询中使用了这三组字段，都可以让联合索引生效。 但如若查询中这三个字段不以AND形式出现，而是单独作为查询条件出现，那单值索引性能会好一些，但三个不同的索引，维护的代价也会高一些。 其实联合索引的最左前缀原则，道理很简单的，就是组成联合索引的多个列，越靠左边优先级越高，同时也只有SQL查询条件中，包含了最左的字段，才能使用联合索引，例如： -- 基于上面的哪个X、Y、Z联合索引 SELECT*FROMtbWHEREY=\"...\"ANDZ=\"...\";复制代码 上面这条SQL就显然并不会使用联合索引，因为不符合最左前缀原则，最左侧的X字段未曾被使用。也正由于MySQL在使用联合索引时会遵循最左前缀原则，所以才在前面建立索引的建议中给出了一条： ❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。 因为将查询频率越高的字段放首位，就代表着查询时命中索引的几率越大。同时，MySQL的最左前缀原则，才匹配到范围查询时会停止匹配，比如\u003e、\u003c、between、like这类范围条件，并不会继续使用联合索引，举个栗子： SELECT*FROMtbWHEREX=\"...\"ANDY\u003e\"...\"ANDZ=\"...\";复制代码 当执行时，虽然上述SQL使用到X、Y、Z作为查询条件，但由于Y字段是\u003e范围查询，因此这里只能使用X索引，而不能使用X、Y或X、Y、Z索引。 对于一条查询SQL是否用到了索引，或者一条查询SQL到底用了那个索引，其实可以通过MySQL自带的explain工具分析（后续讲解）。 最后再来一个简单的栗子，加深一下对于联合索引的认知： select*fromuserwherename='竹子';select*fromuserwherename='竹子'andage=18;A.createindexindex_nameonuser(name);createindexindex_nameonuser(age);B.createindexindex_nameonuser(name,age);复制代码 比如上述这个案例中，对于这两条SQL选第一种方式创建索引，还是第二种呢？答案是B，因为两条sql完全能够利用到第二个创建的联合索引。 select*fromuserwherename='竹子'andage=18;select*fromuserwhereage=18andname='竹子';复制代码 同时选B建立联合索引后，如上两条SQL都会利用到上面创建的联合索引，SQL是否走索引查询跟where后的条件顺序无关，因为MySQL优化器会优化，对SQL查询条件进行重排序。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:3:3","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"三、索引失效与使用索引的正确姿势 相信这一点大家看了有些懵，啥叫使用索引的正确姿势？索引不是MySQL执行SQL时自动选择的吗？我们只能建立索引，怎么使用啊？其实这里是指我们编写SQL时，要注意的点，毕竟MySQL查询时到底使不使用索引，这完全取决于你编写的SQL。 但很多小伙伴在平时写SQL的时候，一般只追求实现业务功能，只要能够查询出相应的数据即可，压根不会过度考虑这条SQL应用到索引，那么这里就是给出一些经验之谈，讲清楚几点写SQL时的方法论。 其实索引本身是一把双刃剑，用的好能够给我们带来异乎寻常的查询效率，用的不好则反而会带来额外的磁盘占用及写入操作时的维护开销。因此大家一定要切记，既然选择建了索引，那一定要利用它，否则还不如干脆别建，既能节省磁盘空间，又能提升写入效率。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:4:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"3.1、索引失效的那些事儿 想要用好索引，那一定要先搞清楚那些情况会导致索引失效，弄明白这些事项之后，在写SQL的时候刻意避开，那你写出来的SQL十有八九是会用到索引的，那么在数据库中那些情况下会导致索引失效呢？下面一起来聊一聊，但单纯的讲概念会有种纸上谈兵的感觉，因此下面简单的举个案例，然后来说明索引失效的一些情况。 SELECT*FROM`zz_users`;+---------+-----------+----------+----------+---------------------+ |user_id|user_name|user_sex|password|register_time|+---------+-----------+----------+----------+---------------------+ |1|熊猫|女|6666|2022-08-1415:22:01||2|竹子|男|1234|2022-09-1416:17:44||3|子竹|男|4321|2022-09-1607:42:21|+---------+-----------+----------+----------+---------------------+ ALTERTABLE`zz_users`ADDPRIMARYKEY`p_user_id`(`user_id`);ALTERTABLE`zz_users`ADDKEY`unite_index`(`user_name`,`user_sex`,`password`);复制代码 此时对这张用户表，分别创建两个索引，第一个是基于user_id创建的主键索引，第二个是使用user_name、user_sex、password三个字段创建的联合索引。 但想要查看一条SQL是否使用了索引，需要用到一个自带的分析工具ExPlain，下面简单介绍一下。 3.1.1、执行分析工具 - ExPlain 这里就对explain工具做一个简单介绍，后续《SQL优化篇》会详细讲解这个工具，先来看看这个工具/命令的作用，当在一条SQL前加上explain命令，执行这条SQL后会列出所有的执行方案： EXPLAINSELECT*FROM`zz_users`;+----+-------------+----------+------+---------------+------+---------+------+------+-------+ |id|select_type|table|type|possible_keys|key|key_len|ref|rows|Extra|+----+-------------+----------+------+---------------+------+---------+------+------+-------+ |1|SIMPLE|zz_users|ALL|NULL|NULL|NULL|NULL|3||+----+-------------+----------+------+---------------+------+---------+------+------+-------+ 复制代码 id：这是执行计划的ID值，这个值越大，表示执行的优先级越高。 select_type ：当前查询语句的类型，有如下几个值： simple：简单查询。 primary：复杂查询的外层查询。 subquery：包含在查询语句中的子查询。 derived：包含在FROM中的子查询。 table：表示当前这个执行计划是基于那张表执行的。 type ：当前执行计划查询的类型，有几种情况： all：表示走了全表查询，未命中索引或索引失效。 system：表示要查询的表中仅有一条数据。 const：表示当前SQL语句的查询条件中，可以命中索引查询。 range：表示当前查询操作是查某个区间。 eq_ref：表示目前在做多表关联查询。 ref：表示目前使用了普通索引查询。 index：表示目前SQL使用了辅助索引查询。 possible_keys：执行SQL时，优化器可能会选择的索引（最后执行不一定用）。 key：查询语句执行时，用到的索引名字。 key_len：这里表示索引字段使用的字节数。 ref：这里显示使用了那种查询的类型。 rows：当前查询语句可能会扫描多少行数据才能检索出结果。 Extra ：这里是记录着额外的一些索引使用信息，有几种状态： using index：表示目前使用了覆盖索引查询（稍后讲）。 using where：表示使用了where子句查询，通常表示没使用索引。 using index condition：表示查询条件使用到了联合索引的前面几个字段。 using temporary：表示使用了临时表处理查询结果。 using filesort：表示以索引字段之外的方式进行排序，效率较低。 select tables optimized away：表示在索引字段上使用了聚合函数。 对于上述这么多的字段，其实目前不需要完全弄懂，本文只需要记住里面的type字段即可，all表示走全表扫描，const、ref...表示通过索引查询。 下面一起来聊一聊索引失效的一些场景。 3.1.2、查询中带有OR会导致索引失效 EXPLAINSELECT*FROM`zz_users`WHEREuser_id=1ORuser_name=\"熊猫\";复制代码 例如上述这条SQL，其中既包含了主键索引的字段，又包含了联合索引的第一个字段，按理来说是会走索引查询的对吗？但看看执行结果： 从结果中可看到type=ALL，显然并未使用索引来查询，也就代表着，虽然所有查询条件都包含了索引字段，但由于使用了OR，最终导致索引失效。 3.1.3、模糊查询中like以%开头导致索引失效 众所周知，使用like关键字做模糊查询时，是可以使用索引的，那来看看下述这条SQL： EXPLAINSELECT*FROM`zz_users`WHEREuser_nameLIKE\"%熊\";复制代码 在这条SQL中以联合索引中的第一个字段作为了查询条件，此时会使用索引吗？看看结果： 结果中显示依旧走了全表扫描，并未使用索引，但like不以%开头，实际上是不会导致索引失效的，例如： 在这里以%结尾，其实可以使用联合索引来检索数据，并不会导致索引失效。 3.1.4、字符类型查询时不带引号导致索引失效 -- 先插入一条user_name = 1111 的数据 INSERTINTO`zz_users`VALUES(4,\"1111\",\"男\",\"4321\",\"2022-09-17 23:48:29\");EXPLAINSELECT*FROM`zz_users`WHEREuser_name=111;复制代码 上述这条SQL按理来说是没有半点问题的，目前是符合联合索引的最左匹配原则的，但来看看结果： 从结果中很明显的可以看出，由于user_name是字符串类型的，因此查询时没带引号，竟然直接未使用索引，导致了索引失效（上面也放了对比图，大家可以仔细看看区别）。 3.1.5、索引字段参与计算导致索引失效 EXPLAINSELECT*FROM`zz_users`WHEREuser_id-1=1;复制代码 上面这条SQL看着估计有些懵，但实际上很简单，就是查询ID=2的数据，理论上因为查询条件中使用了主键字段，应该会使用主键索引，但结果呢？ 由于索引字段参与了计算，所以此时又导致了索引失效，因此大家要切记，千万不要让索引字段在SQL中参与计算，也包括使用一些聚合函数时也会导致索引失效，其根本原因就在于索引字段参与了计算导致的。 这里的运算也包括+、-、*、/、!.....等一系列涉及字段计算的逻辑。 3.1.6、字段被用于函数计算导致索引失效 EXPLAINSELECT*FROM`zz_users`WHERESUBSTRING(user_name,0,1)=\"竹子\";复制代码 上述中，我们使用SUBSTRING函数对user_name字段进行了截取，然后再用于条件查询，此时看看执行结果： 很显然，并未使用索引查询，这也是意料之中的事情，毕竟这一条和3.1.5的原因大致相同，索引字段参与计算导致失效。 3.1.7、违背最左前缀原则导致索引失效 EXPLAINSELECT*FROM`zz_users`WHERE`user_sex`=\"男\"AND`password`=\"1234\";复制代码 上述这条SQL中，显然用到了联合索引中的性别和密码字段，此时再看看结果： 由于违背了联合索引的最左前缀原则，因为没使用最左边的user_name字段，因此也导致索引失效，从而走了全表查询。 3.1.8、不同字段值对比导致索引失效 从一张表中查询出一些值，然后根据这些值去其他表中筛选数据，这个业务也是实际项目中较为常见的场景，下面为了简单实现，就简单用姓名和性别模拟一下字段对比的场景： EXPLAINSELECT*FROM`zz_users`WHEREuser_name=user_sex;复制代码 按理来说，因为user_name属于联合索引的第一个字段，所以上述这条SQL中规中矩，理论上会走索引的，但看看结果： 显然，这个场景也会导致索引无法使用，因此之后也要切记这点。 3.1.9、反向范围操作导致索引失效 一般来说，如果SQL属于正向范围查询，例如\u003e、\u003c、between、like、in...等操作时，索引是可以正常生效的，但如果SQL执行的是反向范围操作，例如NOT IN、NOT LI","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:4:1","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"3.2、使用索引的正确姿势 其实到这里，对于如何使用索引才是正确的呢？总结如下： ①查询SQL中尽量不要使用OR关键字，可以使用多SQL或子查询代替。 ②模糊查询尽量不要以%开头，如果实在要实现这个功能可以建立全文索引。 ③编写SQL时一定要注意字段的数据类型，否则MySQL的隐式转换会导致索引失效。 ④一定不要在编写SQL时让索引字段执行计算工作，尽量将计算工作放在客户端中完成。 ⑤对于索引字段尽量不要使用计算类函数，一定要使用时请记得将函数计算放在=后面。 ⑥多条件的查询SQL一定要使用联合索引中的第一个字段，否则会打破最左匹配原则。 ⑦对于需要对比多个字段的查询业务时，可以拆分为连表查询，使用临时表代替。 ⑧在SQL中不要使用反范围性的查询条件，大部分反范围性、不等性查询都会让索引失效。 ⑨....... 实际上无非就是根据前面给出的索引失效情况，尽量让自己编写的SQL不会导致索引失效即可，写出来的SQL能走索引查询，那就能在很大程度上提升数据检索的效率。 不过这些也属于SQL优化的内容，因此更多、更具体的SQL编写准则，会在之后的《SQL调优篇》详细讲解。 接下来再重点讲几个较重要的内容，既索引覆盖、索引下推、Multi-Range Read机制、索引跳跃式扫描机制。 3.2.1、索引覆盖 在之前聊到过，由于表中只能存在一个聚簇索引，一般都为主键索引，而建立的其他索引都为辅助索引，包括联合索引也例外，最终索引节点上存储的都是指向主键索引的值，拿前面的用户表为例： SELECT*FROM`zz_users`WHERE`user_name`=\"竹子\"AND`user_sex`=\"男\";复制代码 虽然这条SQL会走联合索引查询，但是基于联合索引查询出来的值仅是一个指向主键索引的ID，然后会拿着这个ID再去主键索引中查一遍，这个过程之前聊过，被称为回表过程。 那么回表问题无法解决吗？必须得经过两次查询才能得到数据吗？答案并非如此。 比如假设此时只需要user_name、user_sex、password这三个字段的信息，此时SQL语句可以更改为如下情况： SELECT`user_name`,`user_sex`,`password`FROM`zz_users`WHERE`user_name`=\"竹子\"AND`user_sex`=\"男\";复制代码 此时将SQL更改为查询所需的列后，就不会发生回表现象，Why？再这里很多小伙伴可能会疑惑，这是什么道理啊？因为此时所需的user_name、user_sex、password三个字段数据，在联合索引中完全包含，因此可以直接通过联合索引获取到数据。 但如果查询时用*，因为联合索引中不具备完整的一行数据，只能再次转向聚簇索引中获取完整的行数据，因此到这里大家应该也明白了为什么查询数据时，不能用*的原因，这是因为会导致索引覆盖失效，造成回表问题。 当然，再来提一点比较有意思的事情，先看SQL： EXPLAINSELECT`user_name`,`user_sex`FROM`zz_users`WHERE`password`=\"1234\"AND`user_sex`=\"男\";复制代码 比如上述这条SQL，显然是不符合联合索引的最左前缀匹配原则的，但来看看执行结果： 这个结果是不是很令你惊讶，通过EXPLAIN分析的结果显示，这条SQL竟然使用了索引，这是什么原因呢？也是因为索引覆盖。 一句话概述：就是要查询的列，在使用的索引中已经包含，被所使用的索引覆盖，这种情况称之为索引覆盖。 3.2.2、索引下推 索引下推是MySQL5.6版本以后引入的一种优化机制，还是以之前的用户表为例，先来看一条SQL语句： INSERTINTO`zz_users`VALUES(5,\"竹竹\",\"女\",\"8888\",\"2022-09-20 22:17:21\");SELECT*FROM`zz_users`WHERE`user_name`LIKE\"竹%\"AND`user_sex`=\"男\";复制代码 首先为了更加直观的讲清楚索引下推，因此先再向用户表中增加一条数据。然后再来看看后面的查询SQL，这条SQL会使用联合索引吗？答案是会的，但只能部分使用，因为联合索引的每个节点信息大致如下： { [\"熊猫\",\"女\",\"6666\"] : 1, [\"竹子\",\"男\",\"1234\"] : 2, [\"子竹\",\"男\",\"4321\"] : 3, [\"1111\",\"男\",\"4321\"] : 4, [\"竹竹\",\"女\",\"8888\"] : 5 } 复制代码 由于前面使用的是模糊查询，但%在结尾，因此可以使用竹这个字作为条件在联合索引中查询，整个查询过程如下： ①利用联合索引中的user_name字段找出「竹子、竹竹」两个索引节点。 ②返回索引节点存储的值「2、5」给Server层，然后去逐一做回表扫描。 ③在Server层中根据user_sex=\"男\"这个条件逐条判断，最终筛选到「竹子」这条数据。 有人或许会疑惑，为什么user_sex=\"男\"这个条件不在联合索引中处理呢？因为前面是模糊查询，所以拼接起来是这样的：竹x男，由于这个x是未知的，因此无法根据最左前缀原则去匹配数据，最终这里只能使用联合索引中user_name字段的一部分，后续的user_sex=\"男\"还需要回到Server层处理。 那什么又叫做索引下推呢？也就是将Server层筛选数据的工作，下推到引擎层处理。 以前面的案例来讲解，MySQL5.6加入索引下推机制后，其执行过程是什么样子的呢？ ①利用联合索引中的user_name字段找出「竹子、竹竹」两个索引节点。 ②根据user_sex=\"男\"这个条件在索引节点中逐个判断，从而得到「竹子」这个节点。 ③最终将「竹子」这个节点对应的「2」返回给Server层，然后聚簇索引中回表拿数据。 相较于没有索引下推之前，原本需要做「2、5」两次回表查询，但在拥有索引下推之后，仅需做「2」一次回表查询。 索引下推在MySQL5.6版本之后是默认开启的，可以通过命令set optimizer_switch='index_condition_pushdown=off|on';命令来手动管理。 3.2.3、MRR(Multi-Range Read)机制 Multi-Range Read简称为MRR机制，这也是和索引下推一同在MySQL5.6版本中引入的性能优化措施，那什么叫做MRR优化呢？ 一般来说，在实际业务中我们应当尽量通过索引覆盖的特性，减少回表操作以降低IO次数，但在很多时候往往又不得不做回表才能查询到数据，但回表显然会导致产生大量磁盘IO，同时更严重的一点是：还会产生大量的离散IO，下面举个例子来理解。 SELECT*FROM`zz_student_score`WHERE`score`BETWEEN0AND59;复制代码 上述这条SQL所做的工作很简单，就是在学生成绩表中查询所有成绩未及格的学生信息，假设成绩字段上存在一个普通索引，那思考一下，这条SQL的执行流程是什么样的呢？ ①先在成绩字段的索引上找到0分的节点，然后拿着ID去回表得到成绩零分的学生信息。 ②再次回到成绩索引，继续找到所有1分的节点，继续回表得到1分的学生信息。 ③再次回到成绩索引，继续找到所有2分的节点…… ④周而复始，不断重复这个过程，直到将0~59分的所有学生信息全部拿到为止。 那此时假设此时成绩0~5分的表数据，位于磁盘空间的page_01页上，而成绩为5~10分的数据，位于磁盘空间的page_02页上，成绩为10~15分的数据，又位于磁盘空间的page_01页上。此时回表查询时就会导致在page_01、page_02两页空间上来回切换，但0~5、10~15分的数据完全可以合并，然后读一次page_01就可以了，既能减少IO次数，同时还避免了离散IO。 而MRR机制就主要是解决这个问题的，针对于辅助索引的回表查询，减少离散IO，并且将随机IO转换为顺序IO，从而提高查询效率。 那MRR机制具体是怎么做的呢？MRR机制中，对于辅助索引中查询出的ID，会将其放到缓冲区的read_rnd_buffer中，然后等全部的索引检索工作完成后，或者缓冲区中的数据达到read_rnd_buffer_size大小时，此时MySQL会对缓冲区中的数据排序，从而得到一个有序的ID集合：rest_sort，最终再根据顺序IO去聚簇/主键索引中回表查询数据。 SET @@optimizer_switch='mrr=on|off,mrr_cost_based=on|off'; 可以通过上述这条命令开启或关闭MRR机制，MySQL5.6及以后的版本是默认开启的。 3.2.4、Index Skip Scan索引跳跃式扫描 在讲联合索引时，咱们提到过最左前缀匹配原则，也就是SQL的查询条件中必须要包含联合索引的第一个字段，这样才能命中联合索引查询，但实际上这条规则也并不是100%遵循的。因为在MySQL8.x版本中加入了一个新的优化机制，也就是索引跳跃式扫描，这种机制使得咱们即使查询条件中，没有使用联合索引的第一个字段，也依旧可以使用联合索引，看起来就像跳过了联合索引中的第一个字段一样，这也是跳跃扫描的名称由来。 但跳跃扫描究竟是怎么实现的呢？上个栗子快速理解一下。 比如此时通过(A、B、C)三个列建立了一个联合索引，此时有如下一条SQL： SELECT*FROM`tb_xx`WHEREB=`xxx`ANDC=`xxx`;复制代码 按理来说，这条SQL既不符合最左前缀原则，也不具备使用索引覆盖的条件，因此绝对是不会走联合索引查","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:4:2","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"四、索引应用篇总结 至此，MySQL索引应用篇，也就是索引中篇就结束了，相信大家认真看完本篇之后，对于索引的掌握性、熟练程度绝对会更上一层楼，因为本章中从索引的优劣分析，到建立索引的原则、索引失效的情景、使用索引的正确姿势、MySQL对于索引的优化机制等各方面，对索引进行了进一步阐述。 经历中、上两篇的阐述后，对于MySQL索引这个大体系已经建立出了完整的认知，下一篇就是《索引原理篇》啦，在中、上两篇中抛出了很多疑惑，都留在了索引原理篇中去分析，因为只有当你真正搞懂了索引的底层实现，才能更好的理解一些前面给出的建议、定论及概念。 当然，如果你认为我的文章对你有帮助，那可以动动发财的小手，点上一个免费的小赞赞~，点赞量足够多可加快《索引原理篇》的解锁进度，更文速度完全取决于诸位的点赞数量！当然，就算不给赞，《索引原理篇》也不会缺席噢！最后再给出两条关于索引的查询命令： show status like '%Handler_read%';查看当前会话的索引使用情况。 show global status like 'Handler_read%';：查询全局索引使用情况。 这两条命令在之后的《SQL调优篇》中会用到的，这些命令中的信息对于调优会有不小的参考价值，当然，对于详细的分析在后续的篇章中再详细讲解咯！ ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:5:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/%E7%B4%A2%E5%BC%95%E5%BA%94%E7%94%A8%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"(四)MySQL之索引初识篇：索引机制、索引分类、索引使用与管理综述 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:0:0","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"引言 由于MySQL是作为存储层部署在业务系统的最后端，所有的业务数据最终都要入库落盘，但随着一个项目在线上运行的时间越来越久，数据库中的数据量自然会越来越多，而数据体积出现增长后，当需要从表查询一些数据时，效率会越发低下。在正常情况下，表的查询性能和数据量是成反比的，也就是数据越多，查询越慢。 这是什么原因导致的呢？由于MySQL默认的查询方式导致的，举个例子~ SELECT*FROM`zz_student`;+------------+--------+------+--------+ |student_id|name|sex|height|+------------+--------+------+--------+ |1|竹子|男|185cm||2|熊猫|女|170cm||3|子竹|男|182cm||4|棕熊|男|187cm||5|黑豹|男|177cm||6|脑斧|男|178cm||7|兔纸|女|165cm|+------------+--------+------+--------+ SELECT*FROM`zz_student`WHEREname=\"脑斧\";复制代码 上面给出了一张学生表，其中有七位学生信息，而此时要查询姓名为「脑斧」的学生信息时，MySQL底层是如何检索数据的呢？会触发磁盘IO，对表中的数据进行逐条读取并判断，也就是说，在这里想要查找到符合要求的数据，至少要经过六次磁盘IO才能检索到目标（暂且先不考虑局部性读取原理与随机IO）。 那假设这个表中有1000W条数据呢？要查的目标数据位于表的900W行以后怎么办？岂不是要触发几百万次磁盘IO才能检索到数据啊，如果真的这样去干，其效率大家可想而知。 在这种情况下，又该如何去提升数据库的查询性能呢？因为查询往往都是一个业务系统中最频繁的操作，一般项目的写/读请求比例都遵循三七定律，也就是30%的请求会涉及到写库操作，另外70%则属于查库类型的操作。 在思考如何提升查询性能前，咱们不妨先回想一下小时候的场景，小时候由于刚接触汉字，很多字都不认识，所以通常每个人小时候都会拥有一本「新华字典」，但一本字典那么厚，我们是一页页去翻的吗？并不是，字典中有目录索引，我们可以根据音节、偏旁等方式查找不认识的字。 在「新华字典」中一页页翻找某个汉字，就类似于我们前面给出的全表扫描方式，效率特别特别低，而通过目录索引则能够在很短的时间内找到目标汉字。 既然字典中都存在目录索引页，能帮助小时候的我们快速检索汉字，那这个思想能否应用到数据库中来呢？答案是当然可以，并且MySQL也提供了索引机制，索引是数据库中的核心组件之一，一张表中建立了合适的索引后，往往在面对海量数据查询时，能够事半功倍，接下来一起聊一聊MySQL的索引。 索引机制会分为上、中、下三篇进行阐述，大致内容如下： 《上篇：索引初识篇》主要讲解索引的概述、分类、使用与管理等； 《中篇：索引应用篇》主要阐述索引优劣分析、建立索引的原则、索引失效的场景、如何正确的使用索引、索引优化机制等； 《下篇：索引原理篇》则主要讲述索引的底层实现、B+Tree、Hash数据结构、聚簇索引和非聚簇索引实现、索引查询原理、索引管理实现等； ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:1:0","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"一、MySQL索引机制概述 对于MySQL索引机制的作用，经过上述「新华字典」的案例后可得知：索引就是用来帮助表快速检索目标数据的。此时先来简单回顾一下MySQL中索引是如何使用的呢？首先需要创建索引，MySQL可以通过CREATE、ALTER、DDL三种方式创建一个索引。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:2:0","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"1.1、MySQL索引的创建方式 ①使用CREATE语句创建 CREATEINDEXindexNameONtableName(columnName(length)[ASC|DESC]);复制代码 这种创建方式可以给一张已存在的表结构添加索引，其中需要指定几个值： indexName：当前创建的索引，创建成功后叫啥名字。 tableName：要在哪张表上创建一个索引，这里指定表名。 columnName：要为表中的哪个字段创建索引，这里指定字段名。 length：如果字段存储的值过长，选用值的前多少个字符创建索引。 ASC|DESC：指定索引的排序方式，ASC是升序，DESC是降序，默认ASC。 当然，上述语句中的INDEX也可更改为KEY，作用都是创建一个普通索引，而对于其他的索引类型，这点在后续的索引分类中再聊。 ②使用ALTER语句创建 ALTERTABLEtableNameADDINDEXindexName(columnName(length)[ASC|DESC]);复制代码 这里的参数都相同，所以不再重复赘述。 ③建表时DDL语句中创建 CREATETABLEtableName(columnName1INT(8)NOTNULL,columnName2....,.....,INDEX[indexName](columnName(length)));复制代码 这种方式就比较适合在库表设计时，已经确定了索引项的情况下建立。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:2:1","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"1.2、查询、删除、指定索引 但不管通过哪种方式建立索引，本质上创建的索引都是相同的，当索引创建完成后，可通过SHOW INDEX FROM tableName;这条命令查询一个表中拥有的索引，如下： CREATETABLE`zz_user`(`user_id`int(8)NOTNULLAUTO_INCREMENT,`user_name`varchar(255)NULLDEFAULT\"\",`user_sex`varchar(255)NULLDEFAULT\"\",`user_phone`varchar(255)NULLDEFAULT\"\",PRIMARYKEY(`user_id`)USINGBTREE)ENGINE=InnoDBCHARACTERSET=utf8COLLATE=utf8_general_ciROW_FORMAT=Compact;复制代码 在上述的建表SQL中，为user_id创建了一个主键索引，然后来查一下当前表的索引信息： 简单的概述一下查询后，每个字段的含义： ①Table：当前索引属于那张表。 ②Non_unique：目前索引是否属于唯一索引，0代表是的，1代表不是。 ③Key_name：当前索引的名字。 ④Seq_in_index：如果当前是联合索引，目前字段在联合索引中排第几个。 ⑤Column_name：当前索引是位于哪个字段上建立的。 ⑥Collation：字段值以什么方式存储在索引中，A表示有序存储，NULL表无序。 ⑦Cardinality：当前索引的散列程度，也就是索引中存储了多少个不同的值。 ⑧Sub_part：当前索引使用了字段值的多少个字符建立，NULL表示全部。 ⑨Packed：表示索引在存储字段值时，以什么方式压缩，NULL表示未压缩， ⑩Null：当前作为索引字段的值中，是否存在NULL值，YES表示存在。 ⑪Index_type：当前索引的结构（BTREE, FULLTEXT, HASH, RTREE）。 ⑫Comment：创建索引时，是否对索引有备注信息。 这条命令在后续排除问题、性能调优时，会有不小的作用，比如可以通过分析其中的Cardinality字段值，如果该值少于数据的实际行数，那目前索引有可能失效（对于这些后续排查篇和SQL优化篇再聊）。 OK~，到这里了解了一下索引相关的创建、查询命令，接着再看看删除、强制使用命令。 在MySQL中并未提供修改索引的命令，也就说当你建错了索引，只能先删再重新建立一次，删除索引的语句如下： DROPINDEXindexNameONtableName;复制代码 当然，当建立了一条索引后，也可以强制性的为SELECT语句指定索引，如下： SELECT*FROMtable_nameFORCEINDEX(index_name)WHERE.....;复制代码 FORCE INDEX关键字可以为一条查询语句强制指定走哪个索引查询，但要牢记的是：如果当前的查询SQL压根不会走指定的索引字段，哪这种方式是行不通的，这个关键字的用法是：一条查询语句在有多个索引可以检索数据时，显式指定一个索引，减少优化器选择索引的耗时。 但要注意：如果你对于你整个业务系统十分熟悉，那可以这样干。但如果不熟悉的话，还是交给优化器来自行选择，否则会适得其反！ ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:2:2","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"1.3、数据库索引的本质 前面一直在聊创建、查看、删除、指定等一些索引的基本操作，但索引本质上在数据库中是什么呢？大家都知道，数据库是基于磁盘工作的，所有的数据都会放到磁盘上存储，而索引也是数据的一种，因此与表数据相同，最终创建出的索引也会在磁盘生成本地文件。 不过索引文件在磁盘中究竟以何种方式存储，这是由索引的数据结构来决定的。同时，由于索引机制最终是由存储引擎实现，因此不同存储引擎下的索引文件，其保存在本地的格式也并不相同。 在这里有一个点需要注意：建立索引的工作在表数据越少时越好，如果你想要给一张百万、千万条数据级别的表新创建一个索引，那创建的耗时也不短，这是为什么呢？ 因为刚刚聊过，索引本质上和表是一样的，都是磁盘中的文件，那也就代表着创建一个索引，并不像单纯的给一张表加个约束那么简单，而是会基于原有的表数据，重新在磁盘中创建新的本地索引文件。假设表中有一千万条数据，那创建索引时，就需要将索引字段上的1000W个值全部拷贝到本地索引文件中，同时做好排序并与表数据产生映射关系。 OK~，至此就对MySQL提供的索引机制做了简单回顾，下面再来说说数据库中“多样化”的索引类型。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:2:3","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"二、MySQL的索引分类 在前面我为什么用多样化去形容数据库索引呢？因为确实如此，先列一些大家都听说过的索引称呼：聚簇索引、非聚簇索引、唯一索引、主键索引、联合索引、全文索引、单列索引、多列索引、复合索引、普通索引、二级索引、辅助索引、次级索引、有序索引、B+Tree索引、R-Tree索引、T-Tree索引、Hash索引、空间索引、前缀索引…… 是不是看的眼花缭乱，这些都是MySQL中索引的一些称呼，一通看下来，估计大家看“索引”两个字都有点不认识了^_^ 但实际上MySQL中真的有这么多索引类型吗？其实并没有，上述列出的索引称呼中，有几个称呼对应的索引是同一个，有一部分只是逻辑上的索引，那索引究竟该如何分类呢？其实从不同的层面上来说，可以将索引划分为不同的类型，接下来重点聊一聊。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:0","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"2.1、数据结构层次 前面聊索引本质的时候提到过，索引建立后也会在磁盘生成索引文件，那每个具体的索引节点该如何在本地文件中存放呢？这点是由索引的数据结构来决定的。比如索引的底层结构是数组，那所有的索引节点都会以Node1→Node2→Node3→Node4....这样的形式，存储在磁盘同一块物理空间中，不过MySQL的索引不支持数组结构，或者说数组结构不适合作为索引结构，MySQL索引支持的数据结构如下： B+Tree类型：MySQL中最常用的索引结构，大部分引擎支持，有序。 Hash类型：大部分存储引擎都支持，字段值不重复的情况下查询最快，无序。 R-Tree类型：MyISAM引擎支持，也就是空间索引的默认结构类型。 T-Tree类型：NDB-Cluster引擎支持，主要用于MySQL-Cluster服务中。 在上述的几种索引结构中，B+树和哈希索引是最常见的索引结构，几乎大部分存储引擎都实现了，对于后续两种索引结构在某些情况下也较为常见，但除开列出的几种索引结构外，MySQL索引支持的数据结构还有R+、R*、QR、SS、X树等结构。 但为何后续的一些索引结构大家没听说过呢？这是因为索引到底支持什么数据结构，这是由存储引擎决定的，不同的存储引擎支持的索引结构也并不同，目前较为常用的引擎就是MyISAM、InnoDB，因此大家未曾听说后面列出的这些索引结构也是正常的。 当然，也正因为索引结构由存储引擎决定，而MySQL引擎层在《MySQL架构篇》中提到过，属于可拔插式引擎，所以如果你有能力自己实现一个引擎，那你甚至可以让引擎的索引机制支持任何数据结构。 在MySQL中创建索引时，其默认的数据结构就为B+Tree，如何更换索引的数据结构呢？如下： CREATEINDEXindexNameONtableName(columnName(length)[ASC|DESC])USINGHASH;复制代码 也就是在创建索引时，通过USING关键字显示指定索引的数据结构（必须要为当前引擎支持的结构）。 同时索引会被分为有序索引和无序索引，这是指索引文件中存储索引节点时，会不会按照字段值去排序。那一个索引到底是有序还是无序，就是依据数据结构决定的，例如B+Tree、R-Tree等树结构都是有序，而哈希结构则是无序的。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:1","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"2.2、字段数量层次 前面从索引的数据结构层次出发，可以将索引分为不同结构的类型，而从表字段的层次来看，索引又可以分为单列索引和多列索引，这两个称呼也比较好理解，单列索引是指索引是基于一个字段建立的，多列索引则是指由多个字段组合建立的索引。 单列索引也会分为很多类型，比如： 唯一索引：指索引中的索引节点值不允许重复，一般配合唯一约束使用。 主键索引：主键索引是一种特殊的唯一索引，和普通唯一索引的区别在于不允许有空值。 普通索引：通过KEY、INDEX关键字创建的索引就是这个类型，没啥限制，单纯的可以让查询快一点。 …..还有很多很多，只要是基于单个字段建立的索引都可以被称为单列索引。 多列索引的概念前面解释过了，不过它也有很多种叫法，例如： 组合索引、联合索引、复合索引、多值索引…. 但不管名称咋变，描述的含义都是相同的，即由多个字段组合建立的索引。 不过在使用多列索引时要注意：当建立多列索引后，一条SELECT语句，只有当查询条件中了包含了多列索引的第一个字段时，才能使用多列索引，下面举个栗子。 比如在用户表中，通过id、name、age三个字段建立一个多列索引，什么情况下会使用索引，什么时候不会呢？如下： -- 无法使用多列索引的SQL语句 SELECT*FROM`zz_user`WHEREname=\"竹子\"ANDage=\"18\";-- 能命中多列索引的SQL语句 SELECT*FROM`zz_user`WHEREname=\"竹子\"ANDid=6;复制代码 OK，到这里就根据字段数量的层面出发，简单讲明了单列和多列索引的概念，但无论是单列还是多列，都可以存在一个前缀索引的概念，啥叫前缀索引呢？还记得创建索引时指定的length字段吗？ length：如果字段存储的值过长，选用值的前多少个字符创建索引。 使用一个字段值中的前N个字符创建出的索引，就可以被称为前缀索引，前缀索引能够在很大程度上，节省索引文件的存储空间，也能很大程度上提升索引的性能，这是为什么呢？后面分析索引实现原理的时候细聊。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:2","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"2.3、功能逻辑层次 相信大家在面试时，如果问到了MySQL索引机制，相信一定会问如下这道面试题： 请回答一下你知道的MySQL索引类型。 这题的答案该怎么回答呢？其实主要就是指MySQL索引从逻辑上可以分为那些类型，以功能逻辑划分索引类型，这也是最常见的划分方式，从这个维度来看主要可划分为五种： 普通索引、唯一索引、主键索引、全文索引、空间索引 对于普通索引、唯一索引、主键索引都介绍过了，就不再过多阐述，但稍微提一嘴，在主键字段上建立的索引被称为主键索引，非主键字段上建立的索引一般被称为辅助索引或、二级索引或次级索引，接着重点聊一下全文索引和空间索引。 全文索引和空间索引都是MySQL5.7版本后开始支持的索引类型，不过这两种索引都只有MyISAM引擎支持，其他引擎要么我没用过，要么就由于自身实现的原因不支持，例如InnoDB。对于全文索引而言，其实在MySQL5.6版本中就有了，但当时并不支持汉字检索，到了5.7.6版本的时候才内嵌ngram全文解析器，才支持亚洲语种的分词，同时InnoDB引擎也开始支持全文索引，在5.7版本之前，只有MyISAM引擎支持。 全文索引 全文索引类似于ES、Solr搜索中间件中的分词器，或者说和之前常用的like+%模糊查询很类似，它只能创建在CHAR、VARCHAR、TEXT等这些文本类型字段上，而且使用全文索引查询时，条件字符数量必须大于3才生效。当然，还是举个栗子才有感觉： +------------+--------------------------------------------+------------------+ |article_id|article_name|special_column|+------------+--------------------------------------------+------------------+ |1|MySQL架构篇：自顶向下深入剖析MySQL整体架构|《全解MySQL》||2|MySQL执行篇：一条SQL语句从诞生至结束的历程|《全解MySQL》||3|MySQL设计篇：数据库六范式与反范式设计准则！|《全解MySQL》||4|MySQL索引篇：索引概述、分类及建立索引的原则|《全解MySQL》|+------------+--------------------------------------------+------------------+ 复制代码 比如现在用户想要搜索一篇文章，但是忘记文章全称了，只记得「诞生至结束」这个词汇，此时用户搜索这个词汇，走全文索引的情况下，照样能够定位到上表中的第二条记录。 当然，全文索引如何创建与使用，待会儿后面一起列出来。 空间索引 空间索引这玩意儿其实用的不多，至少大部分项目的业务中不会用到，想要弄清楚空间索引，那么首先得知道一个概念：GIS空间数据，GIS是什么意思呢？是地理信息系统，这是一门新的学科，基于了计算机、信息学、地理学等多科构建的，主要就是用于管理地理信息的数据结构，在国土、规划、出行、配送、地图等和地理有关的项目中，应用较为频繁。 地理空间数据主要包含矢量数据、3D模型、影像文件、坐标数据等，说简单点，空间数据也就是可以将地理信息以模型的方式，在地图上标注出来。在MySQL中总共支持GEOMETRY、POINT、LINESTRING、POLYGON四种空间数据类型，而空间索引则是基于这些类型的字段建立的，也就是可以帮助我们快捷检索空间数据。 不过对于空间索引，一般用的较少，大家了解即可。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:3","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"2.4、存储方式层次 上面聊完了三种不同层次的索引划分后，接着从存储方式的层面再聊聊，从存储方式来看，MySQL的索引主要可分为两大类： 聚簇索引：也被称为聚集索引、簇类索引 非聚簇索引：也叫非聚集索引、非簇类索引、二级索引、辅助索引、次级索引 重点说一说这两类索引存储方式的区别，在说之前先回忆一下数组和链表的区别： 数组是物理空间上的连续，存储的所有元素都会按序存放在同一块内存区域中。 链表是逻辑上的连续，存储的所有元素可能不在同一块内存，元素之间以指针连接。 为啥要说这个呢？因为聚簇索引和非聚簇索引的区别也大致是相同的： 聚簇索引：逻辑上连续且物理空间上的连续。 非聚簇索引：逻辑上的连续，物理空间上不连续。 当然，这里的连续和数组不同，因为索引大部分都是使用B+Tree结构存储，所以在磁盘中数据是以树结构存放的，所以连续并不是指索引节点，而是指索引数据和表数据，也就是说聚簇索引中，索引数据和表数据在磁盘中的位置是一起的，而非聚簇索引则是分开的，索引节点和表数据之间，用物理地址的方式维护两者的联系。 不过一张表中只能存在一个聚簇索引，一般都会选用主键作为聚簇索引，其他字段上建立的索引都属于非聚簇索引，或者称之为辅助索引、次级索引。但也不要走进一个误区，虽然MySQL默认会使用主键上建立的索引作为聚簇索引，但也可以指定其他字段上的索引为聚簇索引，一般聚簇索引要求索引必须是非空唯一索引才行。 其实就算表中没有定义主键，InnoDB中会选择一个唯一的非空索引作为聚簇索引，但如果非空唯一索引也不存在，InnoDB隐式定义一个主键来作为聚簇索引。 当然，主键或者说聚簇索引，一般适合采用带有自增性的顺序值。 对于聚簇、非聚簇索引的区别、两者的查找过程、隐式主键、为何主键适合自增值等这些问题，在后续的《索引原理篇》中会详细讲解。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:4","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"2.5、索引分类小结 至此，对于MySQL“多样化”的索引机制，一大堆索引名词，就已经梳理清楚啦！相信到这里为止，大家也对MySQL的索引机制有了系统化的认知，其实最开始给出的一大堆索引名词，只是从不同角度划分出来的，在上述中分别从数据结构、字段数量、功能逻辑以及存储方式多个层面进行了描述。当然，要牢记的是，以功能逻辑的层次来划分索引，这也是最常用的方式。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:5","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"三、MySQL其他索引的创建使用方式 前面的案例中，聊到了咱们有三种方式创建索引，在创建时可通过INDEX、KEY两个关键字创建，但这种方式建立的索引仅是普通索引，接着再来聊一聊MySQL数据库其他类型的索引该如何创建以及使用。 但不管是何种类型的索引，都可以通过前面聊到的三种方式创建。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:0","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"3.1、唯一索引的创建与使用 唯一索引在创建时，需要通过UNIQUE关键字创建：如下： -- 方式① CREATEUNIQUEINDEXindexNameONtableName(columnName(length));-- 方式② ALTERTABLEtableNameADDUNIQUEINDEXindexName(columnName);-- 方式③ CREATETABLEtableName(columnName1INT(8)NOTNULL,columnName2....,.....,UNIQUEINDEX[indexName](columnName(length)));复制代码 在已有的表基础上创建唯一索引时要注意，如果选用的字段，表中字段的值存在相同值时，这时唯一索引是无法创建的，比如： SELECT*FROM`zz_article`;+------------+--------------------------+-------------------+ |article_id|article_name|special_column|+------------+--------------------------+-------------------+ |1|MySQL架构篇：.......|《全解MySQL》||2|MySQL执行篇：.......|《全解MySQL》||3|MySQL设计篇：.......|《全解MySQL》||4|MySQL索引篇：.......|《全解MySQL》||5|MySQL索引篇：.......|《全解MySQL》|+------------+--------------------------+-------------------+ CREATEUNIQUEINDEXi_article_nameONzz_article(article_name);复制代码 比如上述文章表中，第4、5条数据是重复的，此时创建利用SQL语句创建唯一索引，就会抛出1062错误码： ERROR1062(23000):Duplicateentry'MySQL索引篇：.......'forkey'i_article_name'复制代码 在这种情况下，就只能先删除重复数据，然后才能创建唯一索引成功。 同时，当唯一索引创建成功后，它同时会对表具备唯一约束的作用，当再使用INSERT语句插入相同值时，会同样会抛出1062错误码： INSERTINTO`zz_article`VALUES(6,\"MySQL索引篇：.......\",\"《全解MySQL》\");1062-Duplicateentry'MySQL索引篇：.......'forkey'i_article_name'复制代码 这里会提示你插入的哪个值，已经在表中存在，因此无法插入当前这条数据。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:1","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"3.2、主键索引的创建与使用 前面聊到过，主键索引其实是一种特殊的唯一索引，但主键索引却并不是通过UNIQUE关键字创建的，而是通过PRIMARY关键字创建： -- 方式① ALTERTABLEtableNameADDPRIMARYKEYindexName(columnName);-- 方式② CREATETABLEtableName(columnName1INT(8)NOTNULL,columnName2....,.....,PRIMARYKEY[indexName](columnName(length)));复制代码 在这里要注意： 创建主键索引时，必须要将索引字段先设为主键，否则会抛1068错误码。 这里也不能使用CREATE语句创建索引，否则会提示1064语法错误。 同时创建索引时，关键字要换成KEY，并非INDEX，否则也会提示语法错误。 还是以之前的文章表为例，如下： -- 对非主键字段创建主键索引 ALTERTABLEzz_articleADDPRIMARYKEYi_special_column(special_column);-- 报错信息如下： 1068-Multipleprimarykeydefined-- 使用CREATE关键字创建主键索引 CREATEPRIMARYKEYi_article_idONzz_article(article_id);-- 报错信息如下： 1064-YouhaveanerrorinyourSQLsyntax;check....-- 使用INDEX关键字创建索引 ALTERTABLEzz_articleADDPRIMARYINDEXi_article_id(article_id);-- 报错信息如下： 1064-YouhaveanerrorinyourSQLsyntax;check....-- 创建主键索引正确的方式 ALTERTABLEzz_articleADDPRIMARYKEYi_article_id(article_id);复制代码 当然，一般主键索引都会在建表的DDL语句中创建，不会在表已经建立后再创建。 但似乎无论在讲普通索引，还是唯一索引、主键索引的时候，我们都没有讲如何使用这些创建好的索引查询数据，其实这一点无需咱们考虑，参考之前《SQL执行篇》中查询语句的执行流程，在一条SELECT语句来到MySQL时，会经历优化器优化的过程，而优化器则会自动帮咱们选择一个最合适的索引查询数据。当然，前提是查询条件中涉及到了索引字段才行。 前面也说过，你不想让优化器自动选择，也可以手动通过FORCE INDEX关键字强制指定。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:2","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"3.3、全文索引的创建与使用 全文索引和其他索引不同，首先如果你想要创建全文索引，那么MySQL版本必须要在5.7及以上，同时使用时也需要手动指定，一起来先看看如何创建全文索引，此时需要使用FULLTEXT关键字： -- 方式① ALTERTABLEtableNameADDFULLTEXTINDEXindexName(columnName);-- 方式② CREATEFULLTEXTINDEXindexNameONtableName(columnName);复制代码 不过在创建全文索引时，有三个注意点： 5.6版本的MySQL中，存储引擎必须为MyISAM才能创建。 创建全文索引的字段，其类型必须要为CHAR、VARCHAR、TEXT等文本类型。 如果想要创建出的全文索引支持中文，需要在最后指定解析器：with parser ngram。 此时还依旧是以文章表为例，为文章名称字段创建一个全文索引，命令如下： ALTERTABLEzz_articleADDFULLTEXTINDEXft_article_name(article_name)WITHPARSERNGRAM;复制代码 创建好全文索引后，当你想要使用全文索引时，优化器这时不能自动选择，因为全文索引有自己的语法，但在了解如何使用之前，得先清楚两个概念：最小搜索长度和最大搜索长度，先来看看全文索引的一些参数，可通过show variables like '%ft%';命令查询，如下： 多余的参数就不介绍了，重点讲一下其中的几个重要参数： ft_min_word_len：使用MyISAM引擎的表中，全文索引最小搜索长度。 ft_max_word_len：使用MyISAM引擎的表中，全文索引最大搜索长度。 ft_query_expansion_limit：MyISAM中使用with query expansion搜索的最大匹配数。 innodb_ft_min_token_size：InnoDB引擎的表中，全文索引最小搜索长度。 innodb_ft_max_token_size：InnoDB引擎的表中，全文索引最大搜索长度。 那么究竟做最小搜索长度、最大搜索长度的作用是什么呢？其实这个是一个限制，对于长度小于最小搜索长度和大于最大搜索长度的词语，都无法触发全文索引。也就是说，如果想要使用全文索引对一个词语进行搜索，那这个词语的长度必须在这两个值之间。 其实这两个值自己可以手动调整的，最小值可以手动调整为1，MyISAM引擎的最大值可以调整为3600，但InnoDB引擎最大似乎就是84。 OK~，了解全文索引中的一些概念后，接下来看看如何使用全文索引，全文索引中有两个专门用于检索的关键字，即MATCH(column)、AGAINST(关键字)，同时这两个检索函数也支持三种搜索模式： 自然语言模式(默认搜索模式) 布尔搜索模式 查询拓展搜索 MATCH()主要是负责指定要搜索的列，这里要指定创建全文索引的字段，AGAINST()则指定要搜索的关键字，也就是要搜索的词语，接下来简单的讲一下三种搜索模式。 自然语言模式 这种模式也是在使用全文索引时，默认的搜索模式，使用方法如下： +------------+--------------------------+-------------------+ |article_id|article_name|special_column|+------------+--------------------------+-------------------+ |1|MySQL架构篇：.......|《全解MySQL》||2|MySQL执行篇：.......|《全解MySQL》||3|MySQL设计篇：.......|《全解MySQL》||4|MySQL索引篇：.......|《全解MySQL》|+------------+--------------------------+-------------------+ SELECTCOUNT(article_id)AS'搜索结果数量'FROM`zz_article`WHEREMATCH(article_name)AGAINST('MySQL');-- 运行结果如下： +--------------+ |搜索结果数量|+--------------+ |4|+--------------+ 复制代码 一眼看过去，SQL就能看懂，毕竟都可以排版了一下SQL，不过多介绍了。唯一要注意的是，如果给定的关键词长度小于默认的最小搜索长度，那是无法使用全文索引的，比如下述这条SQL就不会触发： SELECTCOUNT(article_id)AS'搜索结果数量'FROM`zz_article`WHEREMATCH(article_name)AGAINST('M');复制代码 布尔搜索模式 布尔搜索模式有些特殊，因为在这种搜索模式中，还需要掌握特定的搜索语法： +：表示必须匹配的行数据必须要包含相应关键字。 -：和上面的+相反，表示匹配的数据不能包含相应的关键字。 \u003e：提升指定关键字的相关性，在查询结果中靠前显示。 \u003c：降低指定关键字的相关性，在查询结果中靠后显示。 ~：表示允许出现指定关键字，但出现时相关性为负。 *：表示以该关键字开头的词语，如A*，可以匹配A、AB、ABC.... \"\"：双引号中的关键字作为整体，检索时不允许再分词。 \"X Y\"@n ： \"\" 包含的多个词语之间的距离必须要在 n 之间，单位-字节，如： 竹子 熊猫@10：表示竹子和熊猫两个词语之间的距离要在10字节内。 ……. 举个几个例子使用一下，如下： -- 查询文章名中包含 [MySQL] 但不包含 [设计] 的数据 SELECT*FROM`zz_article`WHEREMATCH(article_name)AGAINST('+MySQL -设计'INBOOLEANMODE);-- 查询文章名中包含 [MySQL] 和 [篇] 的数据，但两者间的距离不能超过10字节 SELECT*FROM`zz_article`WHEREMATCH(article_name)AGAINST('\"MySQL 篇\"@10'INBOOLEANMODE);-- 查询文章名中包含[MySQL] 的数据， -- 但包含 [执行] 关键字的行相关性要高于包含 [索引] 关键字的行数据 SELECT*FROM`zz_article`WHEREMATCH(article_name)AGAINST('+MySQL +(\u003e执行 \u003c索引)'INBOOLEANMODE);-- 查询文章名中包含 [MySQL] 的数据，但包含 [设计] 时则将相关性降为负 SELECT*FROM`zz_article`WHEREMATCH(article_name)AGAINST('+MySQL ~设计'INBOOLEANMODE);-- 查询文章名中包含 [执行] 关键字的行数据 SELECT*FROM`zz_article`WHEREMATCH(article_name)AGAINST('执行*'INBOOLEANMODE);-- 查询文章名中必须要包含 [MySQL架构篇] 关键字的数据 SELECT*FROM`zz_article`WHEREMATCH(article_name)AGAINST('\"MySQL架构篇\"'INBOOLEANMODE);复制代码 同样的，上述的SQL语句应该都能看明白，最后的IN BOOLEAN MODE表示使用布尔搜索模式，除此外，大家唯一疑惑的就在于：相关性这个词，其实这个词也不难理解，就是检索数据后，数据的优先级顺序，当相关性越高，对应数据在结果中越靠前，当相关性为负，则相应的数据排到最后。 查询拓展搜索 查询拓展搜索其实是对自然语言搜索模式的拓展，比如举个例子： SELECTCOUNT(article_id)AS'搜索结果数量'FROM`zz_article`WHEREMATCH(article_name)AGAINST('MySQL'WITHQUERYEXPANSION);复制代码 在自然语言模式的查询语句基础上，最后面多加一个WITH QUERY EXPANSION表示使用查询拓展搜索，这种模式下会比自然语言模式多一次检索过程，比如上述的例子中： 首先会根据指定的关键字MySQL进行一次全文检索。 然后第二阶段还会对指定的关键进行分词，然后再进行一次全文检索。 之前介绍全文索引参数时，也列出来了一个名为ft_query_expansion_limit的参数，这个参数就是控制拓展搜索时的拓展行数的，最大可以调整到1000。但由于Query Expansion的全文检索可能带来许多非相关性的查询结果，因此在实际情况中要慎用！！！ 实际上，全文索引引入MySQL后，可以用它代替之前的like%模糊查询，效率会更高。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:3","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"3.4、空间索引的创建与使用 空间索引这玩意儿实际上很多项目不会用到，我用的次数也不多，但如果你要用到这个索引，那可以通过SPATIAL关键字创建，如下： ALTERTABLEtableNameADDSPATIALKEYindexName(columnName);复制代码 但在创建空间索引的时候，有几个注意点需要牢记： 目前MySQL常用引擎中，仅有MyISAM支持空间索引，所以表引擎必须要为它。 空间索引必须要建立在类型为GEOMETRY、POINT、LINESTRING、POLYGON的字段上。 这个用的较少，就不展开细聊了~ ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:4","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"3.5、联合索引的创建与使用 联合索引呢，实际上并不是一种逻辑索引分类，它是索引的一种特殊结构，前面给出的所有案例中，都仅仅是在单个字段的基础上建立索引，而联合索引的意思是可以使用多个字段建立索引。那该如何创建联合索引呢，不需要特殊的关键字，方法如下： CREATEINDEXindexNameONtableName(column1(length),column2...);ALTERTABLEtableNameADDINDEXindexName(column1(length),column2...);复制代码 你可以使用INDEX关键字，让多个列组成一个普通联合索引 也可以使用UNIQUE INDEX关键字，让多个列组成一个唯一联合索引 甚至还可以使用FULLTEXT INDEX关键字，让多个列组成一个全文联合索引 ……. 但是前面也提过，SELECT语句的查询条件中，必须包含组成联合索引的第一个字段，此时才会触发联合索引，否则是无法使用联合索引的。 ","date":"2022-11-26","objectID":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:5","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["Java后端"],"content":"思路：判断某字符串是否为空，为空的标准是str==null或str.length()==0 ","date":"2022-10-13","objectID":"/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/:0:0","tags":["java"],"title":"Java判断字符串String是否为空","uri":"/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/"},{"categories":["Java后端"],"content":"一.空字符串与null区别 1、类型 null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ; ““表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ; 2、内存分配 String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间； String str = “”; 表示声明一个字符串类型的引用，其值为\"“空字符串，这个str引用指向的是空字符串的内存空间； 在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）： 就如下： String str = new String(“yuge”) ; =左边的是存放在栈中（stack），=右边是存放在堆中（heap） 3、字符串对象与null的值不相等，且内存地址也不相等； 空字符串对象与null的值不相等，且内存地址也不相等； new String()创建一个字符串对象的默认值为”” （String类型成员变量的初始值为null） ","date":"2022-10-13","objectID":"/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/:0:1","tags":["java"],"title":"Java判断字符串String是否为空","uri":"/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/"},{"categories":["Java后端"],"content":"二.Java判断字符串常见方法 方法一: 最多人使用的一个方法, 直观, 方便, 但效率很低: if(str == null || str .equals(\"\")); 方法二: 比较字符串长度, 效率高, 是我知道的最好一个方法: if(str == null || str .length() == 0); 方法三: Java SE 6.0 才开始提供的方法, 效率和方法二几乎相等, 但出于兼容性考虑, 推荐使用方法二. if(str == null || str .isEmpty()); 方法四: 这是一种比较直观,简便的方法,而且效率也非常的高,与方法二、三的效率差不多: if (str == null || str == \"\"); 注意:str == null 是有必要存在的. 如果 String 类型为null, 而去进行 equals(String) 或 length() 等操作会抛出java.lang.NullPointerException. 并且str ==null 的顺序必须出现在前面，不然同样会抛出java.lang.NullPointerException. ","date":"2022-10-13","objectID":"/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/:0:2","tags":["java"],"title":"Java判断字符串String是否为空","uri":"/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/"},{"categories":["Java后端"],"content":"三、StringUtils的isBlank与isEmply 1.public static boolean isEmpty(String str) 判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0 2.public static boolean isNotEmpty(String str) 判断某字符串是否非空，等于 !isEmpty(String str) 3.public static boolean isBlank(String str) 判断某字符串是否为空或长度为0或由空白符(whitespace) 构成 4.public static boolean isNotBlank(String str) 判断某字符串是否不为空且长度不为0且不由空白符(whitespace) 构成，等于 !isBlank(String str) ","date":"2022-10-13","objectID":"/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/:0:3","tags":["java"],"title":"Java判断字符串String是否为空","uri":"/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/"},{"categories":["Java后端","ruoyi"],"content":"RuoYi-Cloud是一款基于Spring Boot、Spring Cloud \u0026 Alibaba、Vue、Element的前后端分离微服务极速后台开发框架。 RuoYi 官网地址：http://ruoyi.vip(opens new window) RuoYi 在线文档：http://doc.ruoyi.vip(opens new window) RuoYi 源码下载：https://gitee.com/y_project/RuoYi-Cloud(opens new window) RuoYi 在线提问：https://gitee.com/y_project/RuoYi-Cloud/issues(opens new window) RuoYi 博客：https://www.oschina.net/p/ruoyi(opens new window) RuoYi-Cloud 是一个 Java EE 企业级快速开发平台，基于经典技术组合（Spring Boot、Spring Cloud \u0026 Alibaba、Vue、Element），内置模块如：部门管理、角色用户、菜单及按钮授权、数据权限、系统参数、日志管理、代码生成等。在线定时任务配置；支持集群，支持多数据源。 ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6/:0:0","tags":["ruoyi"],"title":"Ruoyi","uri":"/ruoyi%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端","ruoyi"],"content":"导入导出 在实际开发中经常需要使用导入导出功能来加快数据的操作。在项目中可以使用注解来完成此项功能。 在需要被导入导出的实体类属性添加@Excel注解，目前支持参数如下： ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:0","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#注解参数说明 参数 类型 默认值 描述 sort int Integer.MAX_VALUE 导出时在excel中排序，值越小越靠前 name String 空 导出到Excel中的名字 dateFormat String 空 日期格式, 如: yyyy-MM-dd readConverterExp String 空 读取内容转表达式 (如: 0=男,1=女,2=未知) separator String , 分隔符，读取字符串组内容 scale int -1 BigDecimal 精度 默认:-1(默认不开启BigDecimal格式化) roundingMode int BigDecimal.ROUND_HALF_EVEN BigDecimal 舍入规则 默认:BigDecimal.ROUND_HALF_EVEN celltype Enum Type.STRING 导出类型（0数字 1字符串 2图片） height String 14 导出时在excel中每个列的高度 单位为字符 width String 16 导出时在excel中每个列的宽 单位为字符 suffix String 空 文字后缀,如% 90 变成90% defaultValue String 空 当值为空时,字段的默认值 prompt String 空 提示信息 combo String Null 设置只能选择不能输入的列内容 headerBackgroundColor Enum IndexedColors.GREY_50_PERCENT 导出列头背景色IndexedColors.XXXX headerColor Enum IndexedColors.WHITE 导出列头字体颜色IndexedColors.XXXX backgroundColor Enum IndexedColors.WHITE 导出单元格背景色IndexedColors.XXXX color Enum IndexedColors.BLACK 导出单元格字体颜色IndexedColors.XXXX targetAttr String 空 另一个类中的属性名称,支持多级获取,以小数点隔开 isStatistics boolean false 是否自动统计数据,在最后追加一行统计数据总和 type Enum Type.ALL 字段类型（0：导出导入；1：仅导出；2：仅导入） align Enum HorizontalAlignment.CENTER 导出对齐方式HorizontalAlignment.XXXX handler Class ExcelHandlerAdapter.class 自定义数据处理器 args String[] {} 自定义数据处理器参数 ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:1","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#导出实现流程 1、前端调用方法（参考如下） // 查询参数 queryParams queryParams: { pageNum: 1, pageSize: 10, userName: undefined }, /** 导出按钮操作 */ handleExport() { this.download('system/xxxx/export', { ...this.queryParams }, `post_${new Date().getTime()}.xlsx`) } 2、添加导出按钮事件 \u003cel-button type=\"warning\" icon=\"el-icon-download\" size=\"mini\" @click=\"handleExport\" \u003e导出\u003c/el-button\u003e 3、在实体变量上添加@Excel注解 @Excel(name = \"用户序号\", prompt = \"用户编号\") private Long userId; @Excel(name = \"用户名称\") private String userName; @Excel(name = \"用户性别\", readConverterExp = \"0=男,1=女,2=未知\") private String sex; @Excel(name = \"最后登陆时间\", width = 30, dateFormat = \"yyyy-MM-dd HH:mm:ss\") private Date loginDate; 4、在Controller添加导出方法 @Log(title = \"用户管理\", businessType = BusinessType.EXPORT) @PreAuthorize(hasPermi = \"system:user:export\") @PostMapping(\"/export\") public void export(HttpServletResponse response, SysUser user) throws IOException { List\u003cSysUser\u003e list = userService.selectUserList(user); ExcelUtil\u003cSysUser\u003e util = new ExcelUtil\u003cSysUser\u003e(SysUser.class); util.exportExcel(response, list, \"用户数据\"); } ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:2","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#导入实现流程 1、前端调用方法（参考如下） import { getToken } from \"@/utils/auth\"; // 用户导入参数 upload: { // 是否显示弹出层（用户导入） open: false, // 弹出层标题（用户导入） title: \"\", // 是否禁用上传 isUploading: false, // 是否更新已经存在的用户数据 updateSupport: 0, // 设置上传的请求头部 headers: { Authorization: \"Bearer \" + getToken() }, // 上传的地址 url: process.env.VUE_APP_BASE_API + \"/system/user/importData\" }, // 导入模板接口importTemplate import { importTemplate } from \"@/api/system/user\"; /** 导入按钮操作 */ handleImport() { this.upload.title = \"用户导入\"; this.upload.open = true; }, /** 下载模板操作 */ importTemplate() { importTemplate().then(response =\u003e { this.download(response.msg); }); }, // 文件上传中处理 handleFileUploadProgress(event, file, fileList) { this.upload.isUploading = true; }, // 文件上传成功处理 handleFileSuccess(response, file, fileList) { this.upload.open = false; this.upload.isUploading = false; this.$refs.upload.clearFiles(); this.$alert(response.msg, \"导入结果\", { dangerouslyUseHTMLString: true }); this.getList(); }, // 提交上传文件 submitFileForm() { this.$refs.upload.submit(); } 2、添加导入按钮事件 \u003cel-button type=\"info\" icon=\"el-icon-upload2\" size=\"mini\" @click=\"handleImport\" \u003e导入\u003c/el-button\u003e 3、添加导入前端代码 \u003c!-- 用户导入对话框 --\u003e \u003cel-dialog :title=\"upload.title\" :visible.sync=\"upload.open\" width=\"400px\"\u003e \u003cel-upload ref=\"upload\" :limit=\"1\" accept=\".xlsx, .xls\" :headers=\"upload.headers\" :action=\"upload.url + '?updateSupport=' + upload.updateSupport\" :disabled=\"upload.isUploading\" :on-progress=\"handleFileUploadProgress\" :on-success=\"handleFileSuccess\" :auto-upload=\"false\" drag \u003e \u003ci class=\"el-icon-upload\"\u003e\u003c/i\u003e \u003cdiv class=\"el-upload__text\"\u003e 将文件拖到此处，或 \u003cem\u003e点击上传\u003c/em\u003e \u003c/div\u003e \u003cdiv class=\"el-upload__tip\" slot=\"tip\"\u003e \u003cel-checkbox v-model=\"upload.updateSupport\" /\u003e是否更新已经存在的用户数据 \u003cel-link type=\"info\" style=\"font-size:12px\" @click=\"importTemplate\"\u003e下载模板\u003c/el-link\u003e \u003c/div\u003e \u003cdiv class=\"el-upload__tip\" style=\"color:red\" slot=\"tip\"\u003e提示：仅允许导入“xls”或“xlsx”格式文件！\u003c/div\u003e \u003c/el-upload\u003e \u003cdiv slot=\"footer\" class=\"dialog-footer\"\u003e \u003cel-button type=\"primary\" @click=\"submitFileForm\"\u003e确 定\u003c/el-button\u003e \u003cel-button @click=\"upload.open = false\"\u003e取 消\u003c/el-button\u003e \u003c/div\u003e \u003c/el-dialog\u003e 4、在实体变量上添加@Excel注解，默认为导出导入，也可以单独设置仅导入Type.IMPORT @Excel(name = \"用户序号\") private Long id; @Excel(name = \"部门编号\", type = Type.IMPORT) private Long deptId; @Excel(name = \"用户名称\") private String userName; /** 导出部门多个对象 */ @Excels({ @Excel(name = \"部门名称\", targetAttr = \"deptName\", type = Type.EXPORT), @Excel(name = \"部门负责人\", targetAttr = \"leader\", type = Type.EXPORT) }) private SysDept dept; /** 导出部门单个对象 */ @Excel(name = \"部门名称\", targetAttr = \"deptName\", type = Type.EXPORT) private SysDept dept; 5、在Controller添加导入方法，updateSupport属性为是否存在则覆盖（可选） @Log(title = \"用户管理\", businessType = BusinessType.IMPORT) @PostMapping(\"/importData\") public AjaxResult importData(MultipartFile file, boolean updateSupport) throws Exception { ExcelUtil\u003cSysUser\u003e util = new ExcelUtil\u003cSysUser\u003e(SysUser.class); List\u003cSysUser\u003e userList = util.importExcel(file.getInputStream()); LoginUser loginUser = tokenService.getLoginUser(ServletUtils.getRequest()); String operName = loginUser.getUsername(); String message = userService.importUser(userList, updateSupport, operName); return AjaxResult.success(message); } @GetMapping(\"/importTemplate\") public AjaxResult importTemplate() { ExcelUtil\u003cSysUser\u003e util = new ExcelUtil\u003cSysUser\u003e(SysUser.class); return util.importTemplateExcel(\"用户数据\"); } 提示 也可以直接到main运行此方法测试。 InputStream is = new FileInputStream(new File(\"D:\\\\test.xlsx\")); ExcelUtil\u003cEntity\u003e util = new ExcelUtil\u003cEntity\u003e(Entity.class); List\u003cEntity\u003e userList = util.importExcel(is); ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:3","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"自定义标题信息 有时候我们希望导出表格包含标题信息，我们可以这样做。 导出用户管理表格新增标题（用户列表） public AjaxResult export(SysUser user) { List\u003cSysUser\u003e list = userService.selectUserList(user); ExcelUtil\u003cSysUser\u003e util = new ExcelUtil\u003cSysUser\u003e(SysUser.class); return util.exportExcel(list, \"用户数据\", \"用户列表\"); } 导入表格包含标题处理方式，其中1表示标题占用行数，根据实际情况填写。 public AjaxResult importData(MultipartFile file, boolean updateSupport) throws Exception { ExcelUtil\u003cSysUser\u003e util = new ExcelUtil\u003cSysUser\u003e(SysUser.class); List\u003cSysUser\u003e userList = util.importExcel(file.getInputStream(), 1); String operName = SecurityUtils.getUsername(); String message = userService.importUser(userList, updateSupport, operName); return AjaxResult.success(message); } ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:4","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#自定义数据处理器 有时候我们希望数据展现为一个特殊的格式，或者需要对数据进行其它处理。Excel注解提供了自定义数据处理器以满足各种业务场景。而实现一个数据处理器也是非常简单的。如下： 1、在实体类用Excel注解handler属性指定自定义的数据处理器 public class User extends BaseEntity { @Excel(name = \"用户名称\", handler = MyDataHandler.class, args = { \"aaa\", \"bbb\" }) private String userName; } 2、编写数据处理器MyDataHandler继承ExcelHandlerAdapter，返回值为处理后的值。 public class MyDataHandler implements ExcelHandlerAdapter { @Override public Object format(Object value, String[] args) { // value 为单元格数据值 // args 为excel注解args参数组 return value; } } ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:5","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#自定义隐藏属性列 有时候我们希望对列信息根据业务去动态显示，那么我们可以进行如下处理。 示例：对用户进行条件判断，符合条件则隐藏属性。导出的文件则不会显示此列信息。 @PostMapping(\"/export\") public void export(HttpServletResponse response, SysUser user) { List\u003cSysUser\u003e list = userService.selectUserList(user); ExcelUtil\u003cSysUser\u003e util = new ExcelUtil\u003cSysUser\u003e(SysUser.class); if (条件A) { // 不显示用户ID（单个） util.hideColumn(\"userId\"); } else if (条件B) { // 不显示用户名称、用户手机（多个） util.hideColumn(\"userId\", \"phonenumber\"); } util.exportExcel(response, list, \"用户数据\"); } ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:6","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#导出对象的子列表 有时候对象里面还包含集合列表，例如用户管理包含多个角色需要导出，那么我们可以进行如下处理。 SysUser.java public class SysUser { @Excel(name = \"用户编号\", cellType = ColumnType.NUMERIC, width = 20, needMerge = true) private String userId; @Excel(name = \"用户名称\", width = 20, needMerge = true) private String userName; @Excel(name = \"邮箱\", width = 20, needMerge = true) private String email; @Excel(name = \"角色\") private List\u003cSysRole\u003e roles; public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public List\u003cSysRole\u003e getRoles() { return roles; } public void setRoles(List\u003cSysRole\u003e roles) { this.roles = roles; } } SysRole.java public class SysRole { @Excel(name = \"角色编号\", cellType = ColumnType.NUMERIC) private String roleId; @Excel(name = \"角色名称\") private String roleName; @Excel(name = \"角色字符\") private String roleKey; public String getRoleId() { return roleId; } public void setRoleId(String roleId) { this.roleId = roleId; } public String getRoleName() { return roleName; } public void setRoleName(String roleName) { this.roleName = roleName; } public String getRoleKey() { return roleKey; } public void setRoleKey(String roleKey) { this.roleKey = roleKey; } } 测试验证 public class Test { public static void main(String[] args) throws IOException { List\u003cSysUser\u003e userList = new ArrayList\u003cSysUser\u003e(); SysUser user1 = new SysUser(); List\u003cSysRole\u003e roles1 = new ArrayList\u003cSysRole\u003e(); SysRole role1 = new SysRole(); role1.setRoleId(\"1\"); role1.setRoleName(\"超级管理员\"); role1.setRoleKey(\"admin_key\"); SysRole role2 = new SysRole(); role2.setRoleId(\"2\"); role2.setRoleName(\"普通角色\"); role2.setRoleKey(\"common_key\"); SysRole role3 = new SysRole(); role3.setRoleId(\"3\"); role3.setRoleName(\"测试角色\"); role3.setRoleKey(\"test_key\"); SysRole role4 = new SysRole(); role4.setRoleId(\"4\"); role4.setRoleName(\"查询角色\"); role4.setRoleKey(\"query_key\"); roles1.add(role1); roles1.add(role2); roles1.add(role3); roles1.add(role4); user1.setUserId(\"1\"); user1.setUserName(\"admin\"); user1.setEmail(\"ry@qq.com\"); user1.setRoles(roles1); userList.add(user1); SysUser user2 = new SysUser(); List\u003cSysRole\u003e roles2 = new ArrayList\u003cSysRole\u003e(); SysRole role21 = new SysRole(); role21.setRoleId(\"4\"); role21.setRoleName(\"研发角色\"); role21.setRoleKey(\"yanfa_key\"); SysRole role22 = new SysRole(); role22.setRoleId(\"5\"); role22.setRoleName(\"销售角色\"); role22.setRoleKey(\"xiaoshou_key\"); roles2.add(role21); roles2.add(role22); user2.setUserId(\"2\"); user2.setUserName(\"ry\"); user2.setEmail(\"admin@qq.com\"); user2.setRoles(roles2); userList.add(user2); SysUser user3 = new SysUser(); List\u003cSysRole\u003e roles3 = new ArrayList\u003cSysRole\u003e(); SysRole role31 = new SysRole(); role31.setRoleId(\"4\"); role31.setRoleName(\"张三角色\"); role31.setRoleKey(\"zs_key\"); SysRole role32 = new SysRole(); role32.setRoleId(\"5\"); role32.setRoleName(\"李四角色\"); role32.setRoleKey(\"ls_key\"); roles3.add(role31); roles3.add(role32); user3.setUserId(\"3\"); user3.setUserName(\"test\"); user3.setEmail(\"test@qq.com\"); user3.setRoles(roles3); userList.add(user3); ExcelUtil\u003cSysUser\u003e util = new ExcelUtil\u003cSysUser\u003e(SysUser.class); AjaxResult ajax = util.exportExcel(userList, \"用户数据\", \"用户数据\"); System.out.println(ajax.toString()); } } 导出文件结果 ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:7","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#上传下载 首先创建一张上传文件的表，例如： droptableifexistssys_file_info;createtablesys_file_info(file_idint(11)notnullauto_incrementcomment'文件id',file_namevarchar(50)default''comment'文件名称',file_pathvarchar(255)default''comment'文件路径',primarykey(file_id))engine=innodbauto_increment=1defaultcharset=utf8comment='文件信息表'; ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:2:0","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#上传实现流程 1、代码生成sys_file_info表相关代码并复制到对应目录。 2、参考示例修改代码。 \u003cinput id=\"filePath\" name=\"filePath\" class=\"form-control\" type=\"file\"\u003e function submitHandler() { if ($.validate.form()) { uploadFile(); } } function uploadFile() { var formData = new FormData(); if ($('#filePath')[0].files[0] == null) { $.modal.alertWarning(\"请先选择文件路径\"); return false; } formData.append('fileName', $(\"#fileName\").val()); formData.append('file', $('#filePath')[0].files[0]); $.ajax({ url: prefix + \"/add\", type: 'post', cache: false, data: formData, processData: false, contentType: false, dataType: \"json\", success: function(result) { $.operate.successCallback(result); } }); } 3、在FileInfoController添加对应上传方法 @PostMapping(\"/add\") @ResponseBody public AjaxResult addSave(@RequestParam(\"file\") MultipartFile file, FileInfo fileInfo) throws IOException { // 上传文件路径 String filePath = RuoYiConfig.getUploadPath(); // 上传并返回新文件名称 String fileName = FileUploadUtils.upload(filePath, file); fileInfo.setFilePath(fileName); return toAjax(fileInfoService.insertFileInfo(fileInfo)); } 4、上传成功后需要预览可以对该属性格式化处理 { field : 'filePath', title: '文件预览', formatter: function(value, row, index) { return $.table.imageView(value); } }, 如需对文件格式控制，设置application.yml中的multipart属性 # 文件上传servlet:multipart:# 单个文件大小max-file-size:10MB# 设置总上传的文件大小max-request-size:20MB 注意：如果只是单纯的上传一张图片没有其他参数可以使用通用方法 /common/upload 请求处理方法 com.ruoyi.web.controller.common.CommonController ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:2:1","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#下载实现流程 1、参考示例代码。 function downloadFile(value){ window.location.href = ctx + \"common/download/resource?resource=\" + value; } 2、参考Controller下载方法 /** * 本地资源通用下载 */ @GetMapping(\"/common/download/resource\") public void resourceDownload(String resource, HttpServletRequest request, HttpServletResponse response) throws Exception { // 本地资源路径 String localPath = Global.getProfile(); // 数据库资源地址 String downloadPath = localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX); // 下载名称 String downloadName = StringUtils.substringAfterLast(downloadPath, \"/\"); response.setCharacterEncoding(\"utf-8\"); response.setContentType(\"multipart/form-data\"); response.setHeader(\"Content-Disposition\", \"attachment;fileName=\" + FileUtils.setFileDownloadHeader(request, downloadName)); FileUtils.writeBytes(downloadPath, response.getOutputStream()); } ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:2:2","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"使用ElementUI自带的action ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:0","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"Vue前端界面元素 \u003cel-upload ref=\"upload\" :limit=\"1\" accept=\".jpg, .png\" :action=\"upload.url\" :headers=\"upload.headers\" :file-list=\"upload.fileList\" :on-progress=\"handleFileUploadProgress\" :on-success=\"handleFileSuccess\" :auto-upload=\"true\"\u003e \u003cel-button slot=\"trigger\" size=\"small\" type=\"primary\"\u003e选取文件\u003c/el-button\u003e \u003cel-button style=\"margin-left: 10px;\" size=\"small\" type=\"success\" :loading=\"upload.isUploading\" @click=\"submitUpload\"\u003e上传到服务器\u003c/el-button\u003e \u003cdiv slot=\"tip\" class=\"el-upload__tip\"\u003e只能上传jpg/png文件，且不超过500kb\u003c/div\u003e \u003c/el-upload\u003e ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:1","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"引入获取token import { getToken } from \"@/utils/auth\"; ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:2","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"Data相关数据 // 上传参数 upload: { // 是否禁用上传 isUploading: false, // 设置上传的请求头部 headers: { Authorization: \"Bearer \" + getToken() }, // 上传的地址 url: process.env.VUE_APP_BASE_API + \"/common/upload\", // 上传的文件列表 fileList: [] }, ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:3","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"增加相关方法 handleAddFile() { this.upload.fileList = []; }, handleUpdateFile(row) { this.upload.fileList = [{ name: this.form.fileName, url: this.form.filePath }]; }, // 文件提交处理 submitUpload() { this.$refs.upload.submit(); }, // 文件上传中处理 handleFileUploadProgress(event, file, fileList) { this.upload.isUploading = true; }, // 文件上传成功处理 handleFileSuccess(response, file, fileList) { this.upload.isUploading = false; this.form.filePath = response.url; this.msgSuccess(response.msg); }, ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:4","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"后端远程调用文件服务 import com.ruoyi.common.core.constant.ServiceNameConstants; import com.ruoyi.common.core.domain.R; import com.ruoyi.pay.client.impl.RemoteFileFallbackFactory; import com.ruoyi.system.api.domain.SysFile; import com.ruoyi.system.api.factory.RemoteUserFallbackFactory; import com.ruoyi.system.api.model.LoginUser; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.multipart.MultipartFile; @FeignClient(contextId = \"sysFileService\", value = ServiceNameConstants.FILE_SERVICE, fallbackFactory = RemoteFileFallbackFactory.class) public interface RemoteFileService { /** * 通过上传文件 * * @param file 文件 * @return 结果 */ @GetMapping(value = \"/upload\",consumes = MediaType.MULTIPART_FORM_DATA_VALUE) public R\u003cSysFile\u003e upload(MultipartFile file); } ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:5","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"远程调用降级处理 import com.ruoyi.common.core.domain.R; import com.ruoyi.pay.client.RemoteFileService; import com.ruoyi.system.api.RemoteUserService; import com.ruoyi.system.api.domain.SysFile; import com.ruoyi.system.api.model.LoginUser; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.cloud.openfeign.FallbackFactory; import org.springframework.stereotype.Component; import org.springframework.web.multipart.MultipartFile; @Component public class RemoteFileFallbackFactory implements FallbackFactory\u003cRemoteFileService\u003e { private static final Logger log = LoggerFactory.getLogger(RemoteFileFallbackFactory.class); @Override public RemoteFileService create(Throwable throwable) { log.error(\"文件服务调用失败:{}\", throwable.getMessage()); return new RemoteFileService() { @Override public R\u003cSysFile\u003e upload(MultipartFile file) { return R.fail(\"上传文件失败:\" + throwable.getMessage()); } }; } } ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:6","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"后端Controller /** * 文件上传请求 */ @RequiresPermissions(\"system:qrcodes:add_code\") @Log(title = \"【请填写功能名称】\", businessType = BusinessType.INSERT) @PostMapping(\"/qrcode/upload\") public R\u003cSysFile\u003e upload(MultipartFile file){ R\u003cSysFile\u003e upload = remoteFileService.upload(file); return upload; } ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:7","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"后端debugger ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:8","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"前端请求 ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:9","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"使用自定义http-request ​ 不使用action定义文件上传接口，而是通过用户自定义方法实现对文件的上传，例如，更具不同的文件类型上传到不同的接口，相比较与以上方法灵活性更高。 ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:0","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"vue自定义http-request \u003cel-upload ref=\"upload_img\" :limit=\"1\" accept=\".jpg, .png\" :action=\"upload.url\" :headers=\"upload.headers\" :file-list=\"upload.fileList\" :on-progress=\"handleFileUploadProgress\" :on-success=\"handleFileSuccess\" :http-request=\"uploadSectionFile\" :auto-upload=\"true\"\u003e \u003cel-button slot=\"trigger\" size=\"small\" type=\"primary\"\u003e选取文件\u003c/el-button\u003e \u003cel-button style=\"margin-left: 10px;\" size=\"small\" type=\"success\" :loading=\"upload.isUploading\" @click=\"submitUpload\"\u003e上传到服务器\u003c/el-button\u003e \u003cdiv slot=\"tip\" class=\"el-upload__tip\"\u003e只能上传jpg/png文件，且不超过500kb\u003c/div\u003e \u003c/el-upload\u003e ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:1","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"自定义方法 uploadSectionFile(params){ // 自定义上传方法 console.log(params) var that = this var file = params.file //获取上传的文件 let formData = new FormData(); formData.append(\"file\",params.file) console.log(formData.get(\"file\")) var fileType = file.type //获取文件类型 var isImage = fileType.indexOf('image') != -1 // 判断是否是图片类型 var file_url = that.$refs.upload_img.uploadFiles[0].url; // console.log(file,fileType,isImage,file_url,that.$refs.upload_img); var isLt2M = file.size / 1024 / 1024 \u003c 10; if (!isLt2M) { // 判断大小 alert(\"上传图片的大小不能超过 2MB!\"); that.$refs.upload_img.uploadFiles = []; //不符合就清空已选择的图片 return; } if(!isImage){ // 文件格式 alert(\"请选择图片文件！\"); that.$refs.upload_img.uploadFiles = []; //不符合就清空已选择的图片 return; } that.uploadFile(file); }, uploadFile(file) { // 上传的函数 var that = this var formData = new FormData(); formData.append(\"file\", file); uploadQrcode(formData) .then(function (res) { console.log(res); if(res.code == 200){ //成功的话将数据插入data中 that.upload.fileList[0]=res.data; // that.file_list[0]=res.data.data.img; }else{ // 上传失败，清除已选择 内容 ，并提示失败原因 that.$refs.upload_img.uploadFiles = []; that.$alert('图片上传异常，原因：'+res.data.data, '', { showConfirmButton: false, callback: action =\u003e {} }); } }) } ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:2","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"定义API接口 export function uploadQrcode(formData) { return request({ url: '/pay/qrcodes/qrcode/upload', method: 'post', headers: { 'Content-Type': 'multipart/form-data', //设置请求头请求格式form }, data: formData, }) } ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:3","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"请求 ","date":"2022-10-05","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:4","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"在实际开发中，需要设置用户只能查看哪些部门的数据，这种情况一般称为数据权限。 例如对于销售，财务的数据，它们是非常敏感的，因此要求对数据权限进行控制， 对于基于集团性的应用系统而言，就更多需要控制好各自公司的数据了。如设置只能看本公司、或者本部门的数据，对于特殊的领导，可能需要跨部门的数据， 因此程序不能硬编码那个领导该访问哪些数据，需要进行后台的权限和数据权限的控制。 提示 默认系统管理员admin拥有所有数据权限（userId=1），默认角色拥有所有数据权限（如不需要数据权限不用设置数据权限操作） ","date":"2022-10-03","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/:0:0","tags":["ruoyi"],"title":"Ruoyi框架之数据权限","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/"},{"categories":["Java后端","ruoyi"],"content":"注解参数说明 参数 类型 默认值 描述 deptAlias String 空 部门表的别名 userAlias String 空 用户表的别名 ","date":"2022-10-03","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/:0:1","tags":["ruoyi"],"title":"Ruoyi框架之数据权限","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/"},{"categories":["Java后端","ruoyi"],"content":"数据权限使用 1、在（系统管理-角色管理）设置需要数据权限的角色 目前支持以下几种权限 全部数据权限 自定数据权限 部门数据权限 部门及以下数据权限 仅本人数据权限 2、在需要数据权限控制方法上添加@DataScope注解，其中d和u用来表示表的别名 部门数据权限注解 @DataScope(deptAlias = \"d\") public List\u003c...\u003e select(...) { return mapper.select(...); } 部门及用户权限注解 @DataScope(deptAlias = \"d\", userAlias = \"u\") public List\u003c...\u003e select(...) { return mapper.select(...); } 3、在mybatis查询底部标签添加数据范围过滤 \u003cselect id=\"select\" parameterType=\"...\" resultMap=\"...Result\"\u003e \u003cinclude refid=\"select...Vo\"/\u003e \u003c!-- 数据范围过滤 --\u003e ${params.dataScope} \u003c/select\u003e 例如：用户管理（未过滤数据权限的情况）： --left join 只是把部门名称带过来，没有数据权限 selectu.user_id,u.dept_id,u.login_name,u.user_name,u.email,u.phonenumber,u.password,u.sex,u.avatar,u.salt,u.status,u.del_flag,u.login_ip,u.login_date,u.create_by,u.create_time,u.remark,d.dept_namefromsys_useruleftjoinsys_deptdonu.dept_id=d.dept_idwhereu.del_flag='0' 例如：用户管理（已过滤数据权限的情况）： selectu.user_id,u.dept_id,u.login_name,u.user_name,u.email,u.phonenumber,u.password,u.sex,u.avatar,u.salt,u.status,u.del_flag,u.login_ip,u.login_date,u.create_by,u.create_time,u.remark,d.dept_namefromsys_useruleftjoinsys_deptdonu.dept_id=d.dept_idwhereu.del_flag='0'andu.dept_idin(selectdept_idfromsys_role_deptwhererole_id=2) 结果很明显，我们多了如下语句。通过角色部门表（sys_role_dept）完成了数据权限过滤 andu.dept_idin(selectdept_idfromsys_role_deptwhererole_id=2) 逻辑实现代码 com.ruoyi.framework.aspectj.DataScopeAspect package com.ruoyi.common.datascope.aspect; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; import com.ruoyi.common.core.utils.StringUtils; import com.ruoyi.common.core.web.domain.BaseEntity; import com.ruoyi.common.datascope.annotation.DataScope; import com.ruoyi.common.security.utils.SecurityUtils; import com.ruoyi.system.api.domain.SysRole; import com.ruoyi.system.api.domain.SysUser; import com.ruoyi.system.api.model.LoginUser; /** * 数据过滤处理 * * @author ruoyi */ @Aspect @Component public class DataScopeAspect { /** * 全部数据权限 */ public static final String DATA_SCOPE_ALL = \"1\"; /** * 自定数据权限 */ public static final String DATA_SCOPE_CUSTOM = \"2\"; /** * 部门数据权限 */ public static final String DATA_SCOPE_DEPT = \"3\"; /** * 部门及以下数据权限 */ public static final String DATA_SCOPE_DEPT_AND_CHILD = \"4\"; /** * 仅本人数据权限 */ public static final String DATA_SCOPE_SELF = \"5\"; /** * 数据权限过滤关键字 */ public static final String DATA_SCOPE = \"dataScope\"; @Before(\"@annotation(controllerDataScope)\") public void doBefore(JoinPoint point, DataScope controllerDataScope) throws Throwable { clearDataScope(point); handleDataScope(point, controllerDataScope); } protected void handleDataScope(final JoinPoint joinPoint, DataScope controllerDataScope) { // 获取当前的用户 LoginUser loginUser = SecurityUtils.getLoginUser(); if (StringUtils.isNotNull(loginUser)) { SysUser currentUser = loginUser.getSysUser(); // 如果是超级管理员，则不过滤数据 if (StringUtils.isNotNull(currentUser) \u0026\u0026 !currentUser.isAdmin()) { dataScopeFilter(joinPoint, currentUser, controllerDataScope.deptAlias(), controllerDataScope.userAlias()); } } } /** * 数据范围过滤 * * @param joinPoint 切点 * @param user 用户 * @param deptAlias 部门别名 * @param userAlias 用户别名 */ public static void dataScopeFilter(JoinPoint joinPoint, SysUser user, String deptAlias, String userAlias) { StringBuilder sqlString = new StringBuilder(); for (SysRole role : user.getRoles()) { String dataScope = role.getDataScope(); if (DATA_SCOPE_ALL.equals(dataScope)) { //全部数据权限 sqlString = new StringBuilder(); break; } else if (DATA_SCOPE_CUSTOM.equals(dataScope)) { //自定义数据权限 sqlString.append(StringUtils.format( \" OR {}.dept_id IN ( SELECT dept_id FROM sys_role_dept WHERE role_id = {} ) \", deptAlias, role.getRoleId())); } else if (DATA_SCOPE_DEPT.equals(dataScope)) { //部门数据权限 sqlString.append(StringUtils.format(\" OR {}.dept_id = {} \", deptAlias, user.getDeptId())); } else if (DATA_SCOPE_DEPT_AND_CHILD.equals(dataScope)) { //部门以及子部门数据权限 sqlString.append(StringUtils.format( \" OR {}.dept_id IN ( SELECT dept_id FROM sys_dept WHERE dept_id = {} or find_in_s","date":"2022-10-03","objectID":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/:0:2","tags":["ruoyi"],"title":"Ruoyi框架之数据权限","uri":"/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/"},{"categories":["Tools"],"content":"问题：idea微服务项目启动spring boot项目需要多次启动 如果微服务过多，启动的时候会点击多次，而且一旦某一个服务启动失败，无法看到启动失败的项目，在开发阶段增加开发人员的工作量；那么有没有一键启动所有项目的工具呢？ ","date":"2022-10-02","objectID":"/idea%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/:0:1","tags":["idea"],"title":"Idea批量运行微服务项目","uri":"/idea%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/"},{"categories":["Tools"],"content":"解决方案 IDEA本身就支持多项目一键启动，那么如何实现 1、在.idea文件夹下找到workspace.xml文件 2、在project标签添加配置 \u003ccomponent name=\"RunDashboard\"\u003e \u003coption name=\"configurationTypes\"\u003e \u003cset\u003e \u003coption value=\"SpringBootApplicationConfigurationType\" /\u003e \u003c/set\u003e \u003c/option\u003e \u003c/component\u003e 注意是在project标签内部： 3、批量启动项目 第一次启动可能会看不到这个界面，此时只需要随意启动一个spring boot服务，这个界面就出来了，下次启动项目就可以实现批量重启，并且可以看到启动失败的项目，快速定位问题 ","date":"2022-10-02","objectID":"/idea%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/:0:2","tags":["idea"],"title":"Idea批量运行微服务项目","uri":"/idea%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/"},{"categories":["hugo"],"content":"短代码支持使用ECharts库echarts在 Hugo 中进行数据可视化。 ECharts是一个帮助您生成交互式数据可视化的库。 ECharts 支持的基本图表类型包括折线系列、条形系列、散点系列、饼图、烛台系列、箱线图系列统计、地图系列、热图系列、线系列方向信息、关系图系列、树状图系列、旭日形系列，多维数据的平行系列，漏斗系列，量规系列。使用 ECharts 创建它们的组合非常容易。 只需将您的 ECharts 选项以JSON/ YAML/TOML格式插入短代码即可echarts。 格式echarts输入示例：JSON ","date":"2022-09-14","objectID":"/echarts%E7%A4%BA%E4%BE%8B/:0:0","tags":[],"title":"Echarts示例","uri":"/echarts%E7%A4%BA%E4%BE%8B/"},{"categories":["Java后端"],"content":"前端传回后端的数据结构 text:无实际用途，为第一个搜索值，没有包含全部，所以搜索条件大多不用，除非搜索条件固定且单一 searchFields:搜索框中键入的搜索条件 fieldNames:前后端预设的搜索key,即前后端约定的搜索条件 source:搜索控件的元数据，与本博客无关 ","date":"2022-09-13","objectID":"/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/:1:0","tags":["QFilter"],"title":"快速过滤器转QFilter","uri":"/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/"},{"categories":["Java后端"],"content":"searchFields ​ 它本身是一个ArrayList，每一个元素是一个LinkedHashMap，LinkedHashMap中包含两个键值对，第一个键值对为搜索字段映射（字段之间为或关系），第二个键值对为搜索值映射（值之间为匹配或关系），多个LinkedHashMap之间为and关系。 ​ fieldNames:前后端约定的搜索字段， ","date":"2022-09-13","objectID":"/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/:2:0","tags":["QFilter"],"title":"快速过滤器转QFilter","uri":"/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/"},{"categories":["Java后端"],"content":"数据关系转Filter /** * @param fastFilter 快速过滤条件 * @param fastFilterRelationMap 关键词标识与单据字段映射关系 * @return */ protected List\u003cQFilter\u003e buildFastFilters(FastFilter fastFilter, Map\u003cString, String\u003e fastFilterRelationMap) { List\u003cQFilter\u003e qFilters = new ArrayList\u003c\u003e(); if (fastFilter == null) { return qFilters; } List\u003cMap\u003cString, List\u003cObject\u003e\u003e\u003e fastFilterMap = fastFilter.getFastFilter(); for (Map\u003cString, List\u003cObject\u003e\u003e searchKeyMap : fastFilterMap) { //关键词对应标识 List\u003cObject\u003e fieldNameList = searchKeyMap.get(\"FieldName\"); //关键词值 List\u003cObject\u003e valueList = searchKeyMap.get(\"Value\"); fieldNameList.stream().map(fieldName -\u003e { String filterKey = fastFilterRelationMap.get(fieldName); return valueList.stream().map(v -\u003e new QFilter(filterKey, QFilter.like, \"%\" + v + \"%\")) .reduce((a, b) -\u003e a.or(b)).orElse(null); }).filter(filter -\u003e Optional.ofNullable(filter).isPresent()) .reduce((a, b) -\u003e a.or(b)) .ifPresent(qFilters::add); } return qFilters; } ","date":"2022-09-13","objectID":"/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/:3:0","tags":["QFilter"],"title":"快速过滤器转QFilter","uri":"/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/"},{"categories":["运维"],"content":"本文章实现最简单全面的Jenkins+docker+springboot 一键自动部署项目，步骤齐全，少走坑路。 环境：centos7+git(gitee) 简述实现步骤：在docker安装jenkins，配置jenkins基本信息，利用Dockerfile和shell脚本实现项目自动拉取打包并运行。 ","date":"2022-09-12","objectID":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:0:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"一、安装docker docker安装社区版本CE 1.确保 yum 包更新到最新。 yum update 2.卸载旧版本(如果安装过旧版本的话) yum remove docker docker-common docker-selinux docker-engine 3.安装需要的软件包 yum install -y yum-utils device-mapper-persistent-data lvm2 4.设置yum源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 5.安装docker yum install docker-ce #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0 yum install \u003c自己的版本\u003e # 例如：sudo yum install docker-ce-17.12.0.ce 6.启动和开机启动 systemctl start docker systemctl enable docker 7.验证安装是否成功 docker version ","date":"2022-09-12","objectID":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:1:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"二、安装Jenkins Jenkins中文官网： https://www.jenkins.io/zh/ 1.安装Jenkins docker 安装一切都是那么简单，注意检查8080是否已经占用！如果占用修改端口 docker run --name jenkins -u root --rm -d -p 8080:8080 -p 50000:50000 -v /var/jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock jenkinsci/blueocean 如果没改端口号的话 安装完成后访问地址-\u003e http://{部署Jenkins所在服务IP}:8080 此处会有几分钟的等待时间。 2.初始化Jenkins 2.1 解锁Jenkins 进入Jenkins容器：docker exec -it {Jenkins容器名} bash 例如 docker exec -it jenkins bash 查看密码：cat /var/lib/jenkins/secrets/initialAdminPassword 复制密码到输入框里面 图片 2.2 安装插件 选择第一个：安装推荐的插件 图片 2.3 创建管理员用户 此账户一定要记住哦 ","date":"2022-09-12","objectID":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:2:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"三、系统配置 1. 安装需要插件 进入【首页】–【系统管理】–【插件管理】–【可选插件】 搜索以下需要安装的插件，点击安装即可。 图片 安装Maven Integration 安装Publish Over SSH(如果不需要远程推送，不用安装) 如果使用Gitee 码云，安装插件Gitee（Git自带不用安装） 2. 配置Maven 进入【首页】–【系统管理】–【全局配置】，拉到最下面maven–maven安装 图片 ","date":"2022-09-12","objectID":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:3:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"四、创建任务 1. 新建任务 点击【新建任务】，输入任务名称，点击构建一个自由风格的软件项目 图片 2. 源码管理 点击【源码管理】–【Git】，输入仓库地址，添加凭证，选择好凭证即可。 图片 图片 3.构建触发器 点击【构建触发器】–【构建】–【增加构建步骤】–【调用顶层Maven目标】–【填写配置】–【保存】 图片 此处命令只是install，看是否能生成jar包 clean install -Dmaven.test.skip=true 图片 4. 保存 点击【保存】按钮即可 ","date":"2022-09-12","objectID":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:4:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"五、测试 该功能测试是否能正常打包 1. 构建 点击构建按钮 图片 2.查看日志 点击正在构建的任务，或者点击任务名称，进入详情页面，查看控制台输出，看是否能成功打成jar包。 该处日志第一次可能下载依赖jar包失败，再次点击构建即可成功。图片 图片 3. 查看项目位置 cd /var/jenkins_home/workspace ll 即可查看是否存在 ","date":"2022-09-12","objectID":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:5:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"六、运行项目 因为我们项目和jenkins在同一台服务器，所以我们用shell脚本运行项目，原理既是通过dockerfile 打包镜像，然后docker运行即可。 1. Dockerfile 在springboot项目根目录新建一个名为Dockerfile的文件，注意没有后缀名，其内容如下:（大致就是使用jdk8，把jar包添加到docker然后运行prd配置文件。详细可以查看其他教程） FROM jdk:8 VOLUME /tmp ADD target/zx-order-0.0.1-SNAPSHOT.jar app.jar EXPOSE 8888 ENTRYPOINT [\"Bash\",\"-DBash.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.jar\",\"--spring.profiles.active=prd\"] 2. 修改jenkins任务配置 图片 配置如下： 图片 -t：指定新镜像名 .：表示Dockfile在当前路径 cd /var/jenkins_home/workspace/zx-order-api docker stop zx-order || true docker rm zx-order || true docker rmi zx-order || true docker build -t zx-order . docker run -d -p 8888:8888 --name zx-order zx-order:latest 备注： 我上图用了docker logs -f 是为了方便看日志，真实不要用，因为会一直等待日志，构建任务会失败 加|| true 是如果命令执行失败也会继续实行，为了防止第一次没有该镜像报错 3. 保存 点击保存即可 4. 构建 查看jenkins控制台输出，输出如下，证明成功！ 图片 5. 验证 docker ps 查看是否有自己的容器 docker logs 自己的容器名 查看日志是否正确 浏览器访问项目试一试 ","date":"2022-09-12","objectID":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:6:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["Java后端"],"content":"1、简介 注解是一种能被添加到java源代码中的元数据，方法、类、参数和包都可以用注解来修饰。注解可以看作是一种特殊的标记，可以用在方法、类、参数和包上，程序在编译或者运行时可以检测到这些标记而进行一些特殊的处理。 ","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:1:0","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"2、元注解 元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解： @Target, @Retention, @Documented, @Inherited 下面我们看一下每个元注解的作用和相应分参数的使用说明。 ","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:2:0","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"2.1、@Target 表明该注解可以应用的java元素类型： Target类型 描述 ElementType.TYPE 应用于类、接口（包括注解类型）、枚举 ElementType.FIELD 应用于属性（包括枚举中的常量） ElementType.METHOD 应用于方法 ElementType.PARAMETER 应用于方法的形参 ElementType.CONSTRUCTOR 应用于构造函数 ElementType.LOCAL_VARIABLE 应用于局部变量 ElementType.ANNOTATION_TYPE 应用于注解类型 ElementType.PACKAGE 应用于包 ElementType.TYPE_PARAMETER 应用于类型变量 ElementType.TYPE_USE 应用于任何使用类型的语句中（例如声明语句、泛型和强制转换语句中的类型） ","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:2:1","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"2.2、@Retention 表明该注解的生命周期 生命周期类型 描述 RetentionPolicy.SOURCE 编译时被丢弃，不包含在类文件中 RetentionPolicy.CLASS JVM加载时被丢弃，包含在类文件中，默认值 RetentionPolicy.RUNTIME 由JVM 加载，包含在类文件中，在运行时可以被获取到 ","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:2:2","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"2.3、@Document 表明该注解标记的元素可以被Javadoc 或类似的工具文档化。 ","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:2:3","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"2.4、@Inherited 表明使用了@Inherited注解的注解，所标记的类的子类也会拥有这个注解。 ","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:2:4","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3、自定义注解 修饰符： 访问修饰符必须为public,不写默认为pubic； 关键字： 关键字为@interface； 注解名称： 注解名称为自定义注解的名称，使用时还会用到； 注解内容： 注解中内容，对注解的描述。 ","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:0","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3.1 自定义注解 @Documented @Inherited @Target({ ElementType.FIELD, ElementType.METHOD ,ElementType.TYPE}) //可以在字段、枚举的常量、方法 @Retention(RetentionPolicy.RUNTIME) public @interface Init { String value() default \"\"; } ","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:1","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3.2 数据模型使用注解 public class User { private String name; private String age; public String getName() { return name; } @Init(\"louis\") public User setName(String name) { this.name = name; return this; } public String getAge() { return age; } @Init(\"22\") public User setAge(String age) { this.age = age; return this; } } ","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:2","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3.3 定义一个“注解解析器” public class userFactory { public static User create() { User user = new User(); // 获取User类中所有的方法（getDeclaredMethods也行） Method[] methods = User.class.getMethods(); try { for (Method method : methods) { // 如果一个注解指定注解类型是存在于此元素上此方法返回true，否则返回false //参数 -- 对应于注解类型的Class对象 if (method.isAnnotationPresent(Init.class)) { //此方法返回该元素的注解在此元素的指定注释类型（如果存在），否则返回null Init init = method.getAnnotation(Init.class); // 如果Method代表了一个方法 那么调用它的invoke就相当于执行了它代表的这个方法,在这里就是给set方法赋值 method.invoke(user, init.value()); } } } catch (Exception e) { e.printStackTrace(); return null; } return user; } } ","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:3","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3.4 运行的代码 public static void main(String[] args) { User user = userFactory.create(); user.setAge(\"30\"); System.out.println(user.getName()); System.out.println(user.getAge()); } ","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:4","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3.5 结果","date":"2022-09-11","objectID":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:5","tags":["自定义注解"],"title":"自定义注解","uri":"/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["java后端"],"content":"什么是Jar 实现了特定功能，Java字节码文件的压缩包 本质上就是一个编译后的Java项目，打包城jar文件 log4j.jar 、mysql-connection-8.01.jar等 ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:1:0","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"自己创建jar包，让别人来用： 创建Java项目 创建实现了特定功能的类 将项目生成为jar包 将jar包发布出去，给别人使用 ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:2:0","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"创建项目和验证 ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:0","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"创建项目 创建项目名为dateUtil的project项目 或者： 项目 dateUtil 创建完成 ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:1","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"创建包和类 ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:2","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"相应的代码 package com.dongyuan.util; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /**日期转换工具类 * @author: XYT * @create-date: 2022/7/26 15:12 */ public class DateConvertUtil { /** 注释方法：/**+回车键 形参会被自动提取出来并加粗描黑。这就是为什么引用系统方法的时候，会有很多的说明 * 将字符串转为日期，默认格式为yyyy-MM-dd * @param strDate 字符串日期 * @return 返回转换的日期 */ public static Date getDate(String strDate){ //一个参数；对下方方法的一种封装;这种方式叫“语法糖”； return getDate(strDate,\"yyyy-MM-dd\"); //格式是默认的 getDate } /** * 将字符串转为日期类型 * @param strDate 字符串日期 * @param format 转换格式 * @return 返回转换的日期，转换失败返回null */ public static Date getDate(String strDate, String format){ //两个参数 SimpleDateFormat sdf=new SimpleDateFormat(format); //格式需要自己指定（设置） // try { //自动生成try-catch // return sdf.parse(strDate); // } catch (ParseException e) { // throw new RuntimeException(e); // } // } try { //课堂代码try-catch return sdf.parse(strDate); //注意：parse } catch (ParseException e) { e.printStackTrace(); //这里不一样 } return null; } /** * 将日期转为字符串，固定格式为yyyy-MM-dd * @param date 日期 * @return 返回转换的字符串 */ public static String getDate(Date date){ return getDate(date,\"yyyy-MM-dd\"); //格式是默认的 getDate } /** * 将日期转为字符串 * date 日期 * format 格式字符串 * 返回转换后的字符串 */ public static String getDate(Date date,String format){ //两个参数 SimpleDateFormat sdf=new SimpleDateFormat(format); //格式需要自己指定（设置） return sdf.format(date); //注意：format } } package com.dongyuan.util; /** * @author: XYT * @create-date: 2022/7/26 16:02 */ public class StringUtils { /** * 判断字符串是否为空 * @param str * @return */ public static boolean isNullOrEmpty(String str){ return str==null || str.isEmpty(); //注意 == } } ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:3","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"验证代码 package com.dongyuan.test; import com.aaa.util.DateConvertUtil; import java.util.Date; /** * @author: XYT * @create-date: 2022/7/26 16:08 */ public class Test { //测试 public static void main(String[] args) { //日期转为字符串 System.out.println(DateConvertUtil.getDate(new Date())); //日期转为固定格式的字符串 System.out.println(DateConvertUtil.getDate(new Date(),\"yyyy-MM-dd HH:mm:ss\")); } } ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:4","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"验证结果 ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:5","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"打包和引用 选择 File 中的 Project Structure。 ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:4:0","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"Project 左侧工具栏的功能 介绍 Project Structure 的工具栏及具体功能： ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:4:1","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"打 jar 包 复制生成的 jar 包到桌面，然后用解压工具打开： ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:4:2","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"导入生成的 jar 包 ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:4:3","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"验证 jar 包导入 / 应用的正确性 ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:4:4","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"maven项目如何使用jar包 ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:5:0","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"前言 maven作为包管理工具，好处不必多说 但是有些情况，比如需要引入第三方包，如快递鸟，支付宝，微信等jar包（当然有可能直接提供maven依赖） 如果直接下载到本地之后，怎么整合到自己的maven工程呢？ ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:5:1","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"下面列举五种方式 上传到maven中心仓库 https://oss.sonatype.org/ 愿意折腾可也搞搞，可以参考 如何发布Jar包到Maven中央仓库（确实比较麻烦） 如这是我手动上传到maven中央仓库的jar包 https://mvnrepository.com/search?q=chendahai 优点：可以直接在pom.xml中引入，打包部署没有问题 缺点：上传复杂，麻烦（创建工单，生成秘钥等等 搭建maven私服 手动在后台管理页面上传，之后pom.xml引入 上传方式查看 maven私服nexus上传第三方jar包以及下载 优点：下载速度快，maven聚合项目更适用，内部适用deploy即可，打包部署没有问题 缺点：相比第一种还要麻烦些，还占用本地服务器资源 传统方式java SE的套路 新建lib包，之后导入（eclipse直接build path）（idea麻烦些：File→project structure→libraries→+jar包） 优点：简单，不用做额外的配置 缺点：协作开发，多人都需做同样的操作，沟通也是一回事 pom文件scope的system属性 优点：配置后之后直接引入，maven reImport即可 缺点：没啥缺点，就是配置者得费些时间 案例 要引入如下dateUtil.jar 操作 自定义目录，这里在project的根目录新建lib文件夹，将jar放进去 pom.xml中引入 \u003cdependency\u003e \u003cgroupId\u003edingding\u003c/groupId\u003e \u003cartifactId\u003edingding\u003c/artifactId\u003e \u003cversion\u003e2.8\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/lib/dateUtil.jar\u003c/systemPath\u003e \u003c/dependency\u003e 注意： groupId：自定义 artifactId：自定义 version：自定义 scope：必须是system systemPath：jar包的路径（idea编写的时候会有提示的） 通过上述方式，在开发环境没有什么问题，不会存在什么包找不到等情况 但是，maven project部署一般打包发布，所以打包是需要额外配置的（上述的第一二中方式不需要做额外处理） 处理打包 打包的时候需要做如下配置，需要通过resource标签引入，位置build→resources→resource \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003elib\u003c/directory\u003e \u003ctargetPath\u003e/BOOT-INF/lib/\u003c/targetPath\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.jar\u003c/include\u003e \u003c/includes\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e directory：指定lib文件夹的位置，由于是相对工程根目录，所以直接写上lib即可 targetPath：打包到的文件夹位置，写上BOOT-INF/lib即可，或者是WEB-INF/lib。【斜杠（/）加不加都行，如果是mac的话写./】 includes：一般都是以jar结尾，就写**/*.jar 较为完整的pom.xml \u003cdependency\u003e \u003cgroupId\u003edingding\u003c/groupId\u003e \u003cartifactId\u003edingding\u003c/artifactId\u003e \u003cversion\u003e2.8\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/lib/taobao-sdk-java-auto_1479188381469-20190628.jar\u003c/systemPath\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003elib\u003c/directory\u003e \u003ctargetPath\u003e/BOOT-INF/lib/\u003c/targetPath\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.jar\u003c/include\u003e \u003c/includes\u003e \u003c/resource\u003e \u003c/resources\u003e ok，mvn package即可。 本地安装Jar包 在本地maven仓库安装本地jar包 maven install可以把指定的文件安装到本地maven仓库（使用maven指令前需要安装apache maven）。有三种install方式： （1）mvn install:install-file -Dfile= -DgroupId= -DartifactId= -Dversion= -Dpackaging= 指定jar包、groupid、artifactId和version，maven会自动生成相应的pom.xml文件。 （2）mvn install:install-file -Dfile= -DpomFile= 如果jar包是用maven打包生成的，可以直接指定jar包和pom.xml文件。 （3）mvn install:install-file -Dfile= 如果jar包是用maven打包生成的，maven 2.5版本会自动根据jar包生成pom.xml文件。 安装成功后，在.m2/repository文件夹里可以看到jar包和pom.xml文件。 添加依赖 \u003cdependency\u003e \u003cgroupId\u003edateUtil\u003c/groupId\u003e \u003cartifactId\u003edateUtil\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003c/dependency\u003e ","date":"2022-08-06","objectID":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:5:2","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["数据库"],"content":"​ 数据库连接是一种非常珍贵且有限的资源，尤其是在多用户的网络应用环境中更是如此。对于数据库连接管理的好坏会直接影响整个系统的性能： 建立与数据库的连接是一个耗时的操作，在页面响应中，如果每次用户请求都需要建立新的数据库连接，那么响应时间就会很长，会严重影响用户的体验‘； 数据库的连接个数是有限制的，如果管理不好用户经常建立连接却忘记释放连接，运行时间久了，数据库的连接资源就会耗尽，当有新用户需要访问数据库时，就需要等很长时间，直到有用户释放连接资源才能访问数据，这对系统的可用性有着严重的影响。 因此管理好数据库的连接资源对应用系统尤其是页面应用系统是非常重要的。 ​ 数据库连接池负责分配、管理并释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再建立一个新的连接，同时他还负责释放空闲时间超过最大空闲时间的数据库连接，避免因为没有释放数据库连接而引起数据库连接资源遗漏。 ​ 在J2EE中，服务器在启动时会创建一定数量的连接，并维持不少于次数目的连接池，当客户程序需要访问数据库时，就可以直接从池中获取与数据库的连接(获取一个空闲的连接)，而不用去创建一个新的连接，同时将该链接状态标记为忙状态。当使用完毕后再把该连接标记为空闲状态，这样其他用户就可以重复使用这个连接了。 ​ 如果当前没有空闲连接，那么服务器就会根据配置参数在池中创建一定数量的连接。 ​ 采用这种方法对数据库连接进行管理后可以大幅度缩短用户的响应时间，提高运行效率。 ​ 另一方面，为了提高数据库操作的性能，数据库连接池会释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。 ","date":"2021-11-03","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:0:0","tags":["连接池"],"title":"数据库连接池的工作原理","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":["java面试"],"content":"https://blog.csdn.net/xiahuale/article/details/82113929?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163452109116780271595133%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D\u0026request_id=163452109116780271595133\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-82113929.pc_search_all_es\u0026utm_term=%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\u0026spm=1018.2226.3001.4187 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class TestThread { static class MyRunable implements Runnable{ @Override public void run() { System.out.println(\"这是一个Runable线程，执行了run方法，没有返回值，不能抛出异常\"); } } static class MyCallable implements Callable\u003cString\u003e{ @Override public String call() throws Exception { return \"这是一个Callable线程，执行了call方法，有返回值，可以抛出异常。\"; } } static class MyThread extends Thread{ public void run(){ System.out.println(\"这是一个Thread类的子类，涉及运行机制问题，影响程序性能\"); } } public static void main(String[] args) throws ExecutionException, InterruptedException { MyRunable myRunable = new MyRunable(); Thread thread = new Thread(myRunable); thread.start(); MyCallable myCallable = new MyCallable(); FutureTask\u003cString\u003e stringFutureTask = new FutureTask\u003c\u003e(myCallable); Thread thread1 = new Thread(stringFutureTask); thread1.start(); String s = stringFutureTask.get(); System.out.println(s); MyThread myThread = new MyThread(); myThread.start(); } } 运行结果 这是一个Runable线程，执行了run方法，没有返回值，不能抛出异常 这是一个Callable线程，执行了call方法，有返回值，可以抛出异常。 这是一个Thread类的子类，涉及运行机制问题，影响程序性能 ","date":"2021-11-03","objectID":"/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:0","tags":["线程"],"title":"创建线程的三种方式","uri":"/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["java面试"],"content":"TCP(Transmission Control Protocol 传输控制协议)是一种面向连接(连接导向)的、可靠的、 基于IP的传输层协议。TCP在IP报文的协议号是6。TCP是一个超级麻烦的协议，而它又是互联网的基础，也是每个程序员必备的基本功。首先来看看OSI的七层模型: 我们需要知道TCP工作在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP 在第二层——Data Link层;在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数 据叫Segment。 同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行 封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封 装的过程。 在OSI七层模型中，每一层的作用和对应的协议如下： TCP是一个协议，那这个协议是如何定义的，它的数据格式是什么样子的呢?要进行更深层次的剖析，就 需要了解，甚至是熟记TCP协议中每个字段的含义。哦，来吧。 上面就是TCP协议头部的格式，由于它太重要了，是理解其它内容的基础，下面就将每个字段的信息都详 细的说明一下。 Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号;用于区别主机中的不同进程， 而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一 的确定一个TCP连接; Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据 字节在数据流中的序号;主要用来解决网络报乱序的问题; Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应 当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志(下面介绍)为1时该确认序列号的字 段才有效。主要用来解决不丢包的问题; Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit(最多能 表示15个32bit的的字，即4*15=60个字节的首部长度)，因此TCP最多有60字节的首部。然而，没有任选字段， 正常的长度是20字节; TCP Flags:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次 为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下： URG：此标志表示TCP包的紧急指针域(后面马上就要说到)有效，用来保证TCP连接不被中断，并且督促 中间层设备要尽快处理这些数据; ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中;有两个取值：0和1， 为1的时候表示应答域有效，反之为0; PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序， 而不是在缓冲区中排队; RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包; SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1， ACK=0;连接被响应的时候，SYN=1，ACK=1;这个标志的数据包经常被用来进行端口扫描。扫描者发送 一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口;但是由于这 种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全 的主机将会强制要求一个连接严格的进行TCP的三次握手; FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志 位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。 Window:窗口大小，也就是有名的滑动窗口，用来进行流量控制;这是一个复杂的问题，这篇博文中并不会进行 总结的; 好了，基本知识都已经准备好了，开始下一段的征程吧。 三次握手又是什么? TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号 并交换 TCP窗口大小信息。这就是面试中经常会被问到的TCP三次握手。只是了解TCP三次握手的 概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。 多么清晰的一张图，当然了，也不是我画的，我也只是引用过来说明问题了。 1.第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x;然后，客户端进入SYN_SEND状态，等待服务器的确认; 2.第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1);同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y;服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态; 3.第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。 那四次分手呢? 当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 1.第一次分手：主机1(可以使客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段;此时，主机1进入FIN_WAIT_1状态;这表示主机1没有数据要发送给主机2了; 2.第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1;主机1进入FIN_WAIT_2状态;主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了; 3.第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态; 4.第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态;主机2收到主机1的ACK报文段以后，就关闭连接;此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱;没事，我们继续总结。 为什么要三次握手? 既然总结了TCP的三次握手，那为什么非要三次呢?怎么觉得两次就可以完成了。那TCP为什么非要进行三次连接呢?在谢希仁的《计算机网络》中是这样说的： 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 在书中同时举了一个例子，如下： “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失， 而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一 个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新 的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server 发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认， 也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样， server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况， client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 这就很明白了，防止了服务器端的一直等待而浪费资源。 为什么要四次分手? 那四次分手又是为何呢?TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工 模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2， 它的数据已经全部发送完毕了;但是，这个时候主机1还是可以接受来自主机2的数据;当主机2返回ACK报文 段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的;当主机2也发送了FIN 报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此 就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示","date":"2021-08-30","objectID":"/tcp%E5%8D%8F%E8%AE%AE/:0:0","tags":["TCP"],"title":"TCP协议","uri":"/tcp%E5%8D%8F%E8%AE%AE/"},{"categories":["java后端"],"content":"JPA和Hibernate的关系 JPA（Java Persistence API），是Java EE 5的标准ORM接口，也是ejb3规范的一部分。 Hibernate是之前很流行的ORM框架，也是JPA的一个实现，其它还有Toplink之类的ROM框架。 JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。 Hibernate主要是通过三个组件来实现的： hibernate-core：Hibernate的核心实现，提供了Hibernate所有的核心功能。  hibernate-entitymanager：Hibernate实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。  hibernate-annotation：Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。 Entity @Entity说明这个class是实体类，并且使用默认的orm规则，即class名对应数据库表中表名，class字段名即表中的字段名。 （如果想改变这种默认的orm规则，就要使用@Table来改变class名与数据库中表名的映射规则，@Column来改变class中字段名与db中表的字段名的映射规则） 元数据属性说明： • name: 表名 下面的代码说明,Customer类对应数据库中的Customer表，其中name为可选，缺省类名即表名！ @Entity(name=”Customer”) public class Customer { ... } Table Table用来定义entity主表的name，catalog，schema等属性。 元数据属性说明： • name: 表名 • catalog: 对应关系数据库中的catalog • schema：对应关系数据库中的schema • UniqueConstraints:定义一个UniqueConstraint数组，指定需要建唯一约束的列 @Entity @Table() public class Customer { ... } SecondaryTable 一个entity class可以映射到多表，SecondaryTable用来定义单个从表的名字，主键名字等属性。 元数据属性说明： • name: 表名 • catalog: 对应关系数据库中的catalog • schema：对应关系数据库中的schema • pkJoin: 定义一个PrimaryKeyJoinColumn数组，指定从表的主键列 • UniqueConstraints: 定义一个UniqueConstraint数组，指定需要建唯一约束的列 下面的代码说明Customer类映射到两个表，主表名是CUSTOMER，从表名是CUST_DETAIL，从表的主键列和主表的主键列类型相同，列名为CUST_ID。 @Entity @Table() @SecondaryTable(,pkJoin=@PrimaryKeyJoinColumn()) public class Customer { ... } SecondaryTables 当一个entity class映射到一个主表和多个从表时，用SecondaryTables来定义各个从表的属性。 元数据属性说明： • value： 定义一个SecondaryTable数组，指定每个从表的属性。 @Table(name = \"CUSTOMER\") @SecondaryTables( value = { @SecondaryTable(name = \"CUST_NAME\", pkJoin = { @PrimaryKeyJoinColumn(name = \"STMO_ID\", referencedColumnName = \"id\") }), @SecondaryTable(name = \"CUST_ADDRESS\", pkJoin = { @PrimaryKeyJoinColumn(name = \"STMO_ID\", referencedColumnName = \"id\") }) }) public class Customer {} UniqueConstraint UniqueConstraint定义在Table或SecondaryTable元数据里，用来指定建表时需要建唯一约束的列。 元数据属性说明： • columnNames:定义一个字符串数组，指定要建唯一约束的列名。 @Entity @Table(, uniqueConstraints={@UniqueConstraint(columnNames={\"EMP_ID\", \"EMP_NAME\"})} ) public class Employee { ... } Column Column元数据定义了映射到数据库的列的所有属性：列名，是否唯一，是否允许为空，是否允许更新等。 元数据属性说明： • name:列名。 • unique: 是否唯一 • nullable: 是否允许为空 • insertable: 是否允许插入 • updatable: 是否允许更新 • columnDefinition: 定义建表时创建此列的DDL • secondaryTable: 从表名。如果此列不建在主表上（默认建在主表），该属性定义该列所在从表的名字。 public class Person { @Column(name = \"PERSONNAME\", unique = true, nullable = false, updatable = true) private String name; @Column(name = \"PHOTO\", columnDefinition = \"BLOB NOT NULL\", secondaryTable=\"PER_PHOTO\") private byte[] picture; OneToOne @OneToOne描述一个 一对一的关联 元数据属性说明： • fetch：表示抓取策略，默认为FetchType.LAZY • cascade：表示级联操作策略 @OneToOne(fetch=FetchType,cascade=CascadeType) ManyToOne @ManyToOne表示一个多对一的映射,该注解标注的属性通常是数据库表的外键. 元数据属性说明： • optional：是否允许该字段为null，该属性应该根据数据库表的外键约束来确定，默认为true • fetch：表示抓取策略，默认为FetchType.EAGER • cascade：表示默认的级联操作策略，可以指定为ALL，PERSIST，MERGE，REFRESH和REMOVE中的若干组合，默认为无级联操作 • targetEntity：表示该属性关联的实体类型。该属性通常不必指定，ORM框架根据属性类型自动判断targetEntity。 @ManyToOne(fetch=FetchType,cascade=CascadeType) OneToMany @OneToMany描述一个 一对多的关联,该属性应该为集体类型,在数据库中并没有实际字段。 元数据属性说明： • fetch：表示抓取策略,默认为FetchType.LAZY,因为关联的多个对象通常不必从数据库预先读取到内存 • cascade：表示级联操作策略,对于OneToMany类型的关联非常重要,通常该实体更新或删除时,其关联的实体也应当被更新或删除 例如： 实体User和Order是OneToMany的关系，则实体User被删除时，其关联的实体Order也应该被全部删除 @OneToMany(fetch=FetchType,cascade=CascadeType) ManyToMany @ManyToMany 描述一个多对多的关联.多对多关联上是两个一对多关联,但是在ManyToMany描述中,中间表是由ORM框架自动处理 元数据属性说明： • targetEntity:表示多对多关联的另一个实体类的全名,例如:package.Book.class • mappedBy:表示多对多关联的另一个实体类的对应集合属性名称 两个实体间相互关联的属性必须标记为@ManyToMany,并相互指定targetEntity属性, 需要注意的是,有且只有一个实体的@ManyToMany注解需要指定mappedBy属性,指向targetEntity的集合属性名称 利用ORM工具自动生成的表除了User和Book表外,还自动生成了一个User_Book表,用于实现多对多关联 JoinColumn 如果在entity class的field上定义了关系（one2one或one2many等），我们通过JoinColumn来定义关系的属性。JoinColumn的大部分属性和Column类似。 元数据属性说明： • name:列名。 • referencedColumnName:该列指向列的列名（建表时该列作为外键列指向关系另一端的指定列） • unique: 是否唯一 • nullable: 是否允许为空 • insertable: 是否允许插入 • updatable: 是否允许更新 • columnDefinitio","date":"2021-08-26","objectID":"/jpa/:0:0","tags":["JPA"],"title":"JPA","uri":"/jpa/"},{"categories":["java后端"],"content":"@JoinColumn @OneToOne注释只能确定实体与实体的关系是一对一的关系，不能指定数据库表中的保存的关联字段。所以此时要结合@JoinColumn标记来指定保存实体关系的配置。 @JoinColumn与本书上一章讲述的@Column注释类似，它的定义如下代码所示。 1. @Target({METHOD, FIELD}) 2. @Retention(RUNTIME) 3. String name() default \"\"; 4. String referencedColumnName() default \"\"; 5. boolean unique() default false; 6. boolean nullable() default true; 7. boolean insertable() default true; 8. boolean updatable() default true; 9. String columnDefinition() default \"\"; 10. String table() default \"\"; 11. } ","date":"2021-08-26","objectID":"/jpa/:1:0","tags":["JPA"],"title":"JPA","uri":"/jpa/"},{"categories":["java后端"],"content":"在使用@JoinColumn注释时，应注意以下几个问题： 1、 @JoinColumn与@Column标记一样，是用于注释表中的字段的。它的属性与@Column属性有很多相同之处，这里就不详细讲述。请读者参阅5.2.2小节中有关@Column属性的部分。 2、@JoinColumn与@Column相区别的是：@JoinColumn注释的是保存表与表之间关系的字段，它要标注在实体属性上。而@Column标注的是表中不包含表关系的字段。 3、与@Column标记一样，name属性是用来标识表中所对应的字段的名称。 例如customer表中存在字段addr_id，标识的代码如下所示。 1. @OneToOne 2. @JoinColumn(name = \"addr_id\") 3. public AddressEO getAddress() { 4. return address; 5. } 若此时，不设置name的值，则在默认情况下，name的取值遵循以下规则： name=关联表的名称+“_”+ 关联表主键的字段名 例如，CustomerEO实体中，如果不指定name的值，默认将对应name=address_id； 因为@JoinColumn注释在实体 AddressEO属性上，实体AddressEO对应的表名为“address”；表address的主键是“id”，所以此时对应的默认的字段名称为 “address_id”。 ","date":"2021-08-26","objectID":"/jpa/:2:0","tags":["JPA"],"title":"JPA","uri":"/jpa/"},{"categories":["java后端"],"content":"提示：  此规则只适用于与@OneToOne标记同时使用时。若与@ManyToOne或@ManyToMany标记同时使用时，将遵循其他的规则。 1、默认情况下，关联的实体的主键一般是用来做外键的。但如果此时不想主键作为外键，则需要设置referencedColumnName属性。 例如，将address表中增加一个字段“ref_id”，address表的建表SQL变为以下所示。 1. CREATE TABLE address ( id int(20) NOT NULL auto_increment, 3. ref_id int int(20) NOT NULL, 4. province varchar(50) , 5. city varchar(50) , 6. postcode varchar(50) , 7. detail varchar(50) , 8. PRIMARY KEY (id) 9. ) 此时，通过customer表中的“address_id”字段关联的是address表中的“ref_id”，而“ref_id”并不是address表中的主键，则实体中标注如代码下所示。 @OneToOne @JoinColumn(name = \"address_id\",referencedColumn) public AddressEO getAddress() { return address; } 属性referencedColumnName标注的是所关联表中的字段名，若不指定则使用的所关联表的主键字段名作为外键。 JoinColumn标记不仅能够与@OneToOne使用，也可以@ManyToOne或@ManyToMany标记同时使用，它们所表示的含义不同。 ","date":"2021-08-26","objectID":"/jpa/:3:0","tags":["JPA"],"title":"JPA","uri":"/jpa/"},{"categories":["数据库"],"content":"首先，mysql本身是没有提供全外连接的， MySql中多表查询只提供了内连接，左外连接与右外连接： table_reference {[INNER] JOIN | {LEFT|RIGHT} [OUTER] JOIN} table_reference ON conditional_expr 1】INNER JOIN ON内连接（只写join时默认为内连接） SELECT * FROM emp e JOIN dept d ON e.deptno=d.deptno; 2】外连接：在左外连接和右外连接时都会以一张表为基表，该表的内容会全部显示，然后加上两张表匹配的内容。如果基表的数据在另一张表没有记录。那么在相关联的结果集行中列显示为空值（NULL）。 2.1、左外连接：显示左表的全部记录 SELECT * FROM emp e LEFT JOIN dept d ON e.deptno=d.deptno; 2.2、右外连接：显示右表的全部记录 SELECT * FROM emp e RIGHT JOIN dept d ON e.deptno=d.deptno; ![右外连接](/java_images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RheWf b5naA==,size_16,color_FFFFFF,t_70) 2.3、全外连接：左表和右表都不做限制，所有的记录都显示，两表不足的地方用null 填充； 也就是： 左外连接=左表全部记录+相关联结果 右外连接=右表全部记录+相关联结果 全外连接=左表全部记录+右表全部记录+相关联结果=左外连接+右外连接-相关联结果（即去重复) 那么在MYSQL中谁可以做到呢？ UNION UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 故实现全外连接可以使用： SELECT * FROM emp e LEFT JOIN dept d ON e.deptno=d.deptno UNION SELECT * FROM emp e RIGHT JOIN dept d ON e.deptno=d.deptno; 注释：以上连接全为等值连接；Oracle中全外连接可以使用full join；请不要弄混。 ","date":"2021-08-26","objectID":"/%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5-oracle-mysql/:0:0","tags":["全外连接"],"title":"全外连接？Oracle!MySQL？","uri":"/%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5-oracle-mysql/"},{"categories":["java后端"],"content":"​ springboot依赖导入的时候需要从公网仓库拉取JAR包，同时为了自己代码的安全性，自己也会封装一部分JAR包上传到自己的私库或者内网服务器上 在项目中使用Maven管理jar包依赖，往往会出现以下状况： 1、国内访问maven默认远程中央镜像特别慢； 2、使用阿里的镜像替代远程中央镜像； 3、阿里云镜像中缺少部分jar包； 4、同时使用私有仓库和公有仓库； 针对以上情况，我们就需要让Maven支持多仓库配置。 单独仓库配置 当只配置一个仓库时，操作比较简单，直接在Maven的settings.xml文件中进行全局配置即可，以阿里云的镜像为例： \u003cmirrors\u003e \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e \u003c/mirrors\u003e 只用新增一个mirror配置即可。 要做到单一仓库，设置mirrorOf到*。 只用新增一个mirror配置即可。要做到单一仓库，设置mirrorOf到*。 mirrorOf中配置的星号，表示匹配所有的artifacts，也就是everything使用这里的代理地址。上面的mirrorOf配置了具体的名字，指的是repository的名字。 镜像配置说明： 1、id: 镜像的唯一标识； 2、name: 名称描述； 3、url: 地址； 4、mirrorOf: 指定镜像规则，什么情况下从镜像仓库拉取。 *: 匹配所有，所有内容都从镜像拉取； external:*: 除了本地缓存的所有从镜像仓库拉取； repo,repo1: repo或者repo1，这里的repo指的仓库ID； *,!repo1: 除了repo1的所有仓库； \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.3.1.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e \u003cgroupId\u003esol\u003c/groupId\u003e \u003cartifactId\u003eedrms\u003c/artifactId\u003e \u003cversion\u003e5.12.1.1\u003c/version\u003e \u003cname\u003eedrms\u003c/name\u003e \u003cdescription\u003eedrms core\u003c/description\u003e \u003cproperties\u003e \u003cjava.version\u003e1.8\u003c/java.version\u003e \u003ccom.hank.core.version\u003e3.3\u003c/com.hank.core.version\u003e \u003ccom.hank.common.version\u003e3.6\u003c/com.hank.common.version\u003e \u003ccom.hank.i18n.version\u003e3.0\u003c/com.hank.i18n.version\u003e \u003ccom.hank.es.version\u003e1.1\u003c/com.hank.es.version\u003e \u003celasticsearch.version\u003e6.7.1\u003c/elasticsearch.version\u003e \u003cspring4all.swagger.version\u003e1.9.0.RELEASE\u003c/spring4all.swagger.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.hank\u003c/groupId\u003e \u003cartifactId\u003ees-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e${com.hank.es.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.hank\u003c/groupId\u003e \u003cartifactId\u003ecore-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e${com.hank.core.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.hank\u003c/groupId\u003e \u003cartifactId\u003ecommon\u003c/artifactId\u003e \u003cversion\u003e${com.hank.common.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.hank\u003c/groupId\u003e \u003cartifactId\u003ei18n-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e${com.hank.i18n.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--mysql --\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.13\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.generator\u003c/groupId\u003e \u003cartifactId\u003emybatis-generator-core\u003c/artifactId\u003e \u003cversion\u003e1.3.5\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/net.sf.json-lib/json-lib --\u003e \u003cdependency\u003e \u003cgroupId\u003enet.sf.json-lib\u003c/groupId\u003e \u003cartifactId\u003ejson-lib\u003c/artifactId\u003e \u003cclassifier\u003ejdk15\u003c/classifier\u003e \u003cversion\u003e2.4\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.mybatis.generator\u003c/groupId\u003e \u003cartifactId\u003emybatis-generator-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e1.4.0\u003c/version\u003e \u003cconfiguration\u003e \u003c!--配置文件的位置--\u003e \u003cconfigurationFile\u003esrc/main/resources/generatorConfig.xml\u003c/configurationFile\u003e \u003coverwrite\u003etrue\u003c/overwrite\u003e \u003cverbose\u003etrue\u003c/verbose\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cskipTests\u003etrue\u003c/skipTests\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003crepositories\u003e \u003crepository\u003e \u003cid\u003epublic\u003c/id\u003e \u003cname\u003ePublic Repositories\u003c/name\u003e \u003curl\u003ehttp://192.168.251.93:8081/nexus/content/groups/public/\u003c/url\u003e \u003clayout\u003edefault\u003c/layout\u003e \u003creleases\u003e \u003cenabled\u003etrue\u003c/enabled\u003e \u003c/releases\u003e \u003csnapshots\u003e \u003cenabled\u003etrue\u003c/enabled\u003e \u003c/snapshots\u003e \u003c/repository\u003e \u003crepository\u003e \u003cid\u003ereleases\u003c/id\u003e \u003cname\u003eReleases\u003c/name\u003e \u003curl\u003ehttp://192.168.251.93:8081/nexus/content/repositories/releases/\u003c/url\u003e \u003clayout\u003edefaul","date":"2021-08-11","objectID":"/maven%E6%8B%89%E5%8F%96%E7%A7%81%E5%BA%93jar/:0:0","tags":["maven","jar"],"title":"Maven拉取私库JAR","uri":"/maven%E6%8B%89%E5%8F%96%E7%A7%81%E5%BA%93jar/"},{"categories":["Tools"],"content":"下载nmap https://nmap.org/download.html 安装完成后可能需要npcap的依赖，不懂为啥，安装了就对了https://nmap.org/npcap/ 查看version 使用 Nmap可以完成以下任务： 主机探测 端口扫描 版本检测 系统检测 支持探测脚本的编写 Nmap在实际中应用场合如下： 通过对设备或者防火墙的探测来审计它的安全性 探测目标主机所开放的端口 通过识别新的服务器审计网络的安全性 探测网络上的主机 端口扫描工具，即借助工具，试图了解所扫描IP提供的计算机网络服务类型（网络服务均与端口号相关），从而发现攻击弱点，常见服务对应端口号： 服务 端口号 HTTP 80 HTTPS 443 Telnet 23 FTP 21 SSH（安全登录）、SCP（文件传输）、端口重定向 22 SMTP 25 POP3 110 WebLogic 7001 TOMCAT 8080 WIN2003远程登录 3389 Oracle数据库 1521 MS SQL* SEVER数据库sever 1433 MySQL 数据库sever 3306 ","date":"2021-08-10","objectID":"/nmap/:0:0","tags":["Nmap"],"title":"Nmap","uri":"/nmap/"},{"categories":["Tools"],"content":"1、简单使用 nmap (*ip) nmap默认发送一个ARP的PING数据包，来探测目标主机1-10000范围内所开放的所有端口 命令语法： nmap \u003c*target ip address*\u003e nmap 192.168.1.1 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:14 中国标准时间 Nmap scan report for 10.168.9.50 Host is up (0.0051s latency). Not shown: 994 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 8000/tcp open http-alt 8002/tcp open teradataordbms 8008/tcp open http 9000/tcp open cslistener MAC Address: D4:5D:64:B8:DC:4E (Asustek Computer) Nmap done: 1 IP address (1 host up) scanned in 1.50 seconds ","date":"2021-08-10","objectID":"/nmap/:1:0","tags":["Nmap"],"title":"Nmap","uri":"/nmap/"},{"categories":["Tools"],"content":"2、nmap -vv (*ip) nmap简单扫描，并对结果返回详细的描述输出 nmap -vv (*ip) G:\\20H2_app\\hugo\\jindongBlog\u003enmap -vv 10.168.9.50 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:16 中国标准时间 Initiating ARP Ping Scan at 16:16 Scanning 10.168.9.50 [1 port] Completed ARP Ping Scan at 16:16, 0.13s elapsed (1 total hosts) Initiating Parallel DNS resolution of 1 host. at 16:16 Completed Parallel DNS resolution of 1 host. at 16:16, 0.02s elapsed Initiating SYN Stealth Scan at 16:16 Scanning 10.168.9.50 [1000 ports] Discovered open port 22/tcp on 10.168.9.50 Discovered open port 80/tcp on 10.168.9.50 Discovered open port 8002/tcp on 10.168.9.50 Discovered open port 8000/tcp on 10.168.9.50 Discovered open port 9000/tcp on 10.168.9.50 Discovered open port 8008/tcp on 10.168.9.50 Completed SYN Stealth Scan at 16:16, 0.74s elapsed (1000 total ports) Nmap scan report for 10.168.9.50 Host is up, received arp-response (0.0052s latency). Scanned at 2021-08-10 16:16:57 中国标准时间 for 1s Not shown: 994 closed tcp ports (reset) PORT STATE SERVICE REASON 22/tcp open ssh syn-ack ttl 64 80/tcp open http syn-ack ttl 63 8000/tcp open http-alt syn-ack ttl 62 8002/tcp open teradataordbms syn-ack ttl 62 8008/tcp open http syn-ack ttl 63 9000/tcp open cslistener syn-ack ttl 62 MAC Address: D4:5D:64:B8:DC:4E (Asustek Computer) Read data files from: C:\\Program Files (x86)\\Nmap Nmap done: 1 IP address (1 host up) scanned in 1.64 seconds Raw packets sent: 1001 (44.028KB) | Rcvd: 1001 (40.052KB) ","date":"2021-08-10","objectID":"/nmap/:2:0","tags":["Nmap"],"title":"Nmap","uri":"/nmap/"},{"categories":["Tools"],"content":"3、自定义端口 nmap -p10000-20000 (*ip) 命令语法：nmap -p(range) \u003ctarget IP\u003e 介绍：（range）为要扫描的端口范围，端口大小不能超过65535 例子：扫描目标主机的50-80号端口 nmap -p50-80 10.0.0.55 C:\\Users\\26505\u003enmap -p1-1000 127.0.0.1 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:27 中国标准时间 Nmap scan report for kubernetes.docker.internal (127.0.0.1) Host is up (0.00039s latency). Not shown: 995 closed tcp ports (reset) PORT STATE SERVICE 135/tcp open msrpc 137/tcp filtered netbios-ns 445/tcp open microsoft-ds 902/tcp open iss-realsecure 912/tcp open apex-mesh Nmap done: 1 IP address (1 host up) scanned in 2.05 seconds ","date":"2021-08-10","objectID":"/nmap/:3:0","tags":["Nmap"],"title":"Nmap","uri":"/nmap/"},{"categories":["Tools"],"content":"4、指定端口 nmap -p80,443 (*ip) 命令语法：nmap -p(port1,port2,…) \u003ctarget IP\u003e 介绍：port1,port2…为想要扫描的端口号 例子：扫描目标主机的80，443，801端口 nmap -p80,443,801 10.0.0.55 C:\\Users\\26505\u003enmap -p22,443 22.14.144.124 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:30 中国标准时间 Nmap scan report for 22.14.144.124 Host is up (0.063s latency). PORT STATE SERVICE 22/tcp filtered ssh 443/tcp open https Nmap done: 1 IP address (1 host up) scanned in 2.55 seconds ","date":"2021-08-10","objectID":"/nmap/:4:0","tags":["Nmap"],"title":"Nmap","uri":"/nmap/"},{"categories":["Tools"],"content":"5、nmap -sP (*ip) nmap可以利用类似windows/linux系统下的ping 方式进行扫描 命令语法： nmap -sP \u003ctarget ip\u003e 例子：nmap sP 10.1.112.89 C:\\Users\\26505\u003enmap -sP www.baidu.com Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:34 中国标准时间 Nmap scan report for www.baidu.com (180.101.49.11) Host is up (0.059s latency). Other addresses for www.baidu.com (not scanned): 180.101.49.12 Nmap done: 1 IP address (1 host up) scanned in 0.92 seconds ","date":"2021-08-10","objectID":"/nmap/:5:0","tags":["Nmap"],"title":"Nmap","uri":"/nmap/"},{"categories":["Tools"],"content":"6、nmap 路由跟踪 路由器追踪功能，能够帮助网络管理员了解网络通行情况，同时也是网络管理人员很好的辅助工具，通过路由器追踪可以轻松的查处从我们电脑所在地到目的地之间所经常的网络节点，并可以看到通过各个结点所花费的时间 命令语法： nmap –traceroute \u003ctarget IP\u003e 例子:namp –traceroute 8.8.8.8(geogle dns服务器ip) C:\\Users\\26505\u003enmap -traceroute 8.8.8.8 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:35 中国标准时间 Nmap scan report for dns.google (8.8.8.8) Host is up (0.081s latency). Not shown: 999 filtered tcp ports (no-response) PORT STATE SERVICE 53/tcp open domain TRACEROUTE (using port 53/tcp) HOP RTT ADDRESS 1 2.00 ms 192.168.191.225 2 ... 3 40.00 ms 172.19.2.29 4 ... 5 21.00 ms 221.228.22.29 6 ... 11 12 66.00 ms 108.170.241.1 13 70.00 ms 142.251.64.173 14 103.00 ms dns.google (8.8.8.8) Nmap done: 1 IP address (1 host up) scanned in 18.61 seconds ","date":"2021-08-10","objectID":"/nmap/:6:0","tags":["Nmap"],"title":"Nmap","uri":"/nmap/"},{"categories":["Tools"],"content":"7、nmap设置扫描一个网段下的ip 命令语法： nmap -sP \u003cnetwork address\u003e \u003c/CIDR\u003e 介绍：CIDR为设置的子网掩码（/24,/16,/8等） 例子：nmap -sP 10.1.1.0 /24 ","date":"2021-08-10","objectID":"/nmap/:7:0","tags":["Nmap"],"title":"Nmap","uri":"/nmap/"},{"categories":["Tools"],"content":"8、nmap 操作系统类型的探测 命令语法： nmap -0 \u003ctarget IP\u003e 例子：nmap -O(大写的o) 10.1.112.89 C:\\Users\\26505\u003enmap -O 10.168.9.191 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:42 中国标准时间 Nmap scan report for hp-jd.lan (10.168.9.191) Host is up (0.00083s latency). Not shown: 978 closed tcp ports (reset) PORT STATE SERVICE 135/tcp open msrpc 139/tcp open netbios-ssn 445/tcp open microsoft-ds 902/tcp open iss-realsecure 912/tcp open apex-mesh 1055/tcp open ansyslmd 1060/tcp open polestar 1087/tcp open cplscrambler-in 1117/tcp open ardus-mtrns 3301/tcp open unknown 3306/tcp open mysql 5357/tcp open wsdapi 7001/tcp open afs3-callback 7002/tcp open afs3-prserver 8001/tcp open vcom-tunnel 8002/tcp open teradataordbms 8080/tcp open http-proxy 9000/tcp open cslistener 9002/tcp open dynamid 9090/tcp open zeus-admin 15000/tcp open hydap 50000/tcp open ibm-db2 Device type: general purpose Running: Microsoft Windows 10 OS CPE: cpe:/o:microsoft:windows_10 OS details: Microsoft Windows 10 1809 - 1909 Network Distance: 0 hops OS detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 2.18 seconds ","date":"2021-08-10","objectID":"/nmap/:8:0","tags":["Nmap"],"title":"Nmap","uri":"/nmap/"},{"categories":["Tools"],"content":"9、nmap万能开关 包含了1-10000端口ping扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测 命令语法： nmap -A \u003ctarget ip\u003e 例子：nmap -A 10.1.112.89 C:\\Users\\26505\u003enmap -A 10.168.9.50 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:44 中国标准时间 Service scan Timing: About 83.33% done; ETC: 16:45 (0:00:16 remaining) Nmap scan report for 10.168.9.50 Host is up (0.0041s latency). Not shown: 994 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.0 (protocol 2.0) | ssh-hostkey: | 3072 2e:13:05:c8:dc:42:ba:3e:6b:43:f0:16:04:42:08:cc (RSA) | 256 77:59:df:1b:99:b2:bd:01:e6:db:45:9d:5b:84:e3:e5 (ECDSA) |_ 256 49:ee:8f:ac:cd:f0:79:f8:cd:06:ba:45:ac:2a:9f:8d (ED25519) 80/tcp open http nginx | http-title: Site doesn't have a title (text/html). |_Requested resource was /wcm/edrms 8000/tcp open nagios-nsca Nagios NSCA |_http-title: Site doesn't have a title (text/plain; charset=utf-8). 8002/tcp open teradataordbms? | fingerprint-strings: | FourOhFourRequest, GetRequest: | HTTP/1.1 404 | Content-Type: text/html;charset=utf-8 | Content-Language: en | Content-Length: 431 | Date: Tue, 10 Aug 2021 08:44:29 GMT | Connection: close | \u003c!doctype html\u003e\u003chtml lang=\"en\"\u003e\u003chead\u003e\u003ctitle\u003eHTTP Status 404 | Found\u003c/title\u003e\u003cstyle type=\"text/css\"\u003ebody {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}\u003c/style\u003e\u003c/head\u003e\u003cbody\u003e\u003ch1\u003eHTTP Status 404 | Found\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e | HTTPOptions: | HTTP/1.1 404 | Content-Type: text/html;charset=utf-8 | Content-Language: en | Content-Length: 431 | Date: Tue, 10 Aug 2021 08:44:34 GMT | Connection: close | \u003c!doctype html\u003e\u003chtml lang=\"en\"\u003e\u003chead\u003e\u003ctitle\u003eHTTP Status 404 | Found\u003c/title\u003e\u003cstyle type=\"text/css\"\u003ebody {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}\u003c/style\u003e\u003c/head\u003e\u003cbody\u003e\u003ch1\u003eHTTP Status 404 |_ Found\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e 8008/tcp open http nginx 1.19.10 |_http-title: moblieProject |_http-server-header: nginx/1.19.10 9000/tcp open cslistener? | fingerprint-strings: | GenericLines: | HTTP/1.1 400 Bad Request | Content-Type: text/plain; charset=utf-8 | Connection: close | Request | GetRequest, HTTPOptions: | HTTP/1.0 200 OK | Accept-Ranges: bytes | Cache-Control: max-age=31536000 | Content-Length: 23032 | Content-Type: text/html; charset=utf-8 | Last-Modified: Fri, 26 Jul 2019 02:11:28 GMT | X-Content-Type-Options: nosniff | X-Xss-Protection: 1; mode=block | Date: Tue, 10 Aug 2021 08:44:29 GMT | \u003c!DOCTYPE html\u003e\u003chtml lang=\"en\" ng-app=\"portainer\"\u003e | \u003chead\u003e | \u003cmeta charset=\"utf-8\"\u003e | \u003ctitle\u003ePortainer\u003c/title\u003e | \u003cmeta name=\"description\" content=\"\"\u003e | \u003cmeta name=\"author\" content=\"Portainer.io\"\u003e | \u003c!-- HTML5 shim, for IE6-8 support of HTML5 elements --\u003e | \u003c!--[if lt IE 9]\u003e | \u003cscript src=\"//html5shim.googlecode.com/svn/trunk/html5.js\"\u003e\u003c/script\u003e | \u003c![endif]--\u003e | \u003c!-- Fav and touch icons --\u003e | \u003clink rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"dc4d092847be46242d8c013d1bc7c494.png\"\u003e | \u003clink rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"5ba13dcb526292ae707310a54e103cd1.png\"\u003e |_ \u003clink rel=\"icon\" type=\"image/ 2 services unrecognized despite returning data. If you know the service/version, please submit the following fingerprints at https://nmap.org/cgi-bin/submit.cgi?new-service : ==============NEXT SERVICE FINGERPRINT (SUBMIT INDIVIDUALLY)============== SF-Port8002-TCP:V=7.92%I=7%D=8/10%Time=61123C6D%P=i686-pc-windows-windows% SF:r(GetRequest,24A,\"HTTP/1\\.1\\x20404\\x20\\r\\nContent-Type:\\x20text/html;ch SF:arset=utf-8\\r\\nContent-Language:\\x20en\\r\\nContent-Length:\\x20431\\r\\nDat SF:e:\\x20Tue,\\x2010\\x20Aug\\x202021\\x2008:44:29\\x20GMT\\r\\nConnection:\\x20cl SF:ose\\r\\n\\r\\n\u003c!doctype\\x20html\u003e\u003chtml\\x20lang=\\\"en\\\"\u003e\u003chead\u003e\u003ctitle\u003eHTTP\\x20 SF:Status\\x20404\\x20\\xe2\\x80\\x93\\x20Not\\x20Foun","date":"2021-08-10","objectID":"/nmap/:9:0","tags":["Nmap"],"title":"Nmap","uri":"/nmap/"},{"categories":["Tools"],"content":"10、nmap命令混合式扫描 可以做到类似参数-A所完成的功能，但又能细化我们的需求要求 命令语法： nmap -vv -p1-100 -O \u003ctarget ip\u003e 例子： nmap -vv -p1-100 -O 10.1.112.89 G:\\20H2_app\\hugo\\jindongBlog\u003enmap -vv -p0-1000 10.168.9.50 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:45 中国标准时间 Initiating ARP Ping Scan at 16:45 Scanning 10.168.9.50 [1 port] Completed ARP Ping Scan at 16:45, 0.12s elapsed (1 total hosts) Initiating Parallel DNS resolution of 1 host. at 16:45 Completed Parallel DNS resolution of 1 host. at 16:45, 0.01s elapsed Initiating SYN Stealth Scan at 16:45 Scanning 10.168.9.50 [1001 ports] Discovered open port 22/tcp on 10.168.9.50 Discovered open port 80/tcp on 10.168.9.50 Completed SYN Stealth Scan at 16:45, 0.57s elapsed (1001 total ports) Nmap scan report for 10.168.9.50 Host is up, received arp-response (0.0057s latency). Scanned at 2021-08-10 16:45:02 中国标准时间 for 1s Not shown: 999 closed tcp ports (reset) PORT STATE SERVICE REASON 22/tcp open ssh syn-ack ttl 64 80/tcp open http syn-ack ttl 63 MAC Address: D4:5D:64:B8:DC:4E (Asustek Computer) Read data files from: C:\\Program Files (x86)\\Nmap Nmap done: 1 IP address (1 host up) scanned in 1.43 seconds Raw packets sent: 1002 (44.072KB) | Rcvd: 1002 (40.076KB) ","date":"2021-08-10","objectID":"/nmap/:10:0","tags":["Nmap"],"title":"Nmap","uri":"/nmap/"},{"categories":["Java后端"],"content":"开始 ","date":"2021-08-06","objectID":"/springsecurity/:0:0","tags":[],"title":"Springsecurity","uri":"/springsecurity/"},{"categories":["大三下实训笔记"],"content":"JDBC工具类","date":"2021-07-28","objectID":"/jdbc-01/","tags":[],"title":"JDBC-01","uri":"/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"JDBC-01 ","date":"2021-07-28","objectID":"/jdbc-01/:0:0","tags":[],"title":"JDBC-01","uri":"/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"〇.本章目标 掌握jdbc的快速入门 能够使用jdbc完成对数据库表中数据的crud; 理解如何防止sql注入 使用jdbc完成事务控制 ","date":"2021-07-28","objectID":"/jdbc-01/:0:1","tags":[],"title":"JDBC-01","uri":"/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"一、JDBC快速入门（动手-掌握） 1.jdbc的概念 JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系型数据库提供统一访问，它是由一组用Java语言编写的类和接口组成的。 2.jdbc的本质 其实就是java官方提供的一套规范(接口)。用于帮助开发人员快速实现不同关系型数据库的连接！ 3.jdbc的快速入门程序 导入jar包 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); 获取连接 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db2\", \"root\", \"root\"); 获取执行者对象 Statement stat = con.createStatement(); 执行sql语句，并接收返回结果 String sql = \"SELECT * FROM user\"; ResultSet rs = stat.executeQuery(sql); 处理结果 while(rs.next()) { System.out.println(rs.getInt(\"id\") + \"\\t\" + rs.getString(\"name\")); } 释放资源 con.close(); stat.close(); rs.close(); public class JDBCDemo01 { public static void main(String[] args) throws Exception{ //1.导入jar包 //2.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //3.获取连接 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db04\",\"root\",\"root\"); //4.获取执行者对象 Statement stat = con.createStatement(); //5.执行sql语句，并且接收结果 String sql = \"SELECT * FROM user\"; ResultSet rs = stat.executeQuery(sql); //6.处理结果 while(rs.next()) { System.out.println(rs.getInt(\"id\") + \"\\t\" + rs.getString(\"name\")); } //7.释放资源 con.close(); stat.close(); rs.close(); } } 【小结： 注意： 获取连接这一步 ip地址如果是本机： localhost 快速入门： 抽取到单元测试：（只用关心5、6） ","date":"2021-07-28","objectID":"/jdbc-01/:0:2","tags":[],"title":"JDBC-01","uri":"/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"二、JDBC各个功能类详解（理解） 1.DriverManager DriverManager：驱动管理对象 注册驱动(告诉程序该使用哪一个数据库驱动) static void registerDriver(Driver driver)：注册与给定的驱动程序 DriverManager 写代码使用：Class.forName(“com.mysql.jdbc.Driver”); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(\"Can't register driver!\"); } } 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。在jar包中，存在一个java.sql.Driver配置文件，文件中指定了com.mysql.jdbc.Driver 获取数据库连接(获取到数据库的连接并返回连接对象) static Connection getConnection(String url, String user, String password); 返回值：Connection数据库连接对象 参数 url：指定连接的路径。语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 user：用户名 password：密码 2.Connection Connection：数据库连接对象 获取执行者对象 获取普通执行者对象：Statement createStatement(); 获取预编译执行者对象：PreparedStatement prepareStatement(String sql); 管理事务 开启事务：setAutoCommit(boolean autoCommit); 参数为false，则开启事务。 – (改为手动提交) 提交事务：commit(); 回滚事务：rollback(); 释放资源 立即将数据库连接对象释放：void close(); 3.Statement Statement：执行sql语句的对象 执行DML语句：int executeUpdate(String sql); 返回值int：返回影响的行数。 参数sql：可以执行insert、update、delete语句。 执行DQL语句：ResultSet executeQuery(String sql); 返回值ResultSet：封装查询的结果。 参数sql：可以执行select语句。 释放资源 立即将执行者对象释放：void close(); 4.ResultSet ResultSet：结果集对象 判断结果集中是否还有数据：boolean next(); 有数据返回true，并将索引向下移动一行 没有数据返回false 获取结果集中的数据：XXX getXxx(“列名”); XXX代表数据类型(要获取某列数据，这一列的数据类型) 例如：String getString(“name”); int getInt(“age”); 释放资源 立即将结果集对象释放：void close(); 【小结： ","date":"2021-07-28","objectID":"/jdbc-01/:0:3","tags":[],"title":"JDBC-01","uri":"/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"三、JDBC案例student学生表的CRUD（掌握-动手） 1.数据准备 数据库和数据表 -- 创建db14数据库 CREATEDATABASEdb14;-- 使用db14数据库 USEdb14;-- 创建student表 CREATETABLEstudent(sidINTPRIMARYKEYAUTO_INCREMENT,-- 学生id NAMEVARCHAR(20),-- 学生姓名 ageINT,-- 学生年龄 birthdayDATE-- 学生生日 );-- 添加数据 INSERTINTOstudentVALUES(NULL,'张三',23,'1999-09-23'),(NULL,'李四',24,'1998-08-10'),(NULL,'王五',25,'1996-06-06'),(NULL,'赵六',26,'1994-10-20'); 实体类 Student类，成员变量对应表中的列 注意：所有的基本数据类型需要使用包装类，以防null值无法赋值 package com.itheima02.domain; import java.util.Date; public class Student { private Integer sid; private String name; private Integer age; private Date birthday; public Student() { } public Student(Integer sid, String name, Integer age, Date birthday) { this.sid = sid; this.name = name; this.age = age; this.birthday = birthday; } public Integer getSid() { return sid; } public void setSid(Integer sid) { this.sid = sid; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } @Override public String toString() { return \"Student{\" + \"sid=\" + sid + \", name='\" + name + '\\'' + \", age=\" + age + \", birthday=\" + birthday + '}'; } } 2.需求一：查询全部 持久层 /* 查询所有学生信息 */ @Override public ArrayList\u003cStudent\u003e findAll() { ArrayList\u003cStudent\u003e list = new ArrayList\u003c\u003e(); Connection con = null; Statement stat = null; ResultSet rs = null; try{ //1.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取数据库连接 con = DriverManager.getConnection(\"jdbc:mysql://192.168.59.129:3306/db14\", \"root\", \"itheima\"); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"SELECT * FROM student\"; rs = stat.executeQuery(sql); //5.处理结果集 while(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); //封装Student对象 Student stu = new Student(sid,name,age,birthday); //将student对象保存到集合中 list.add(stu); } } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stat != null) { try { stat.close(); } catch (SQLException e) { e.printStackTrace(); } } if(rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } } //将集合对象返回 return list; } 业务层 /* 查询所有学生信息 */ @Override public ArrayList\u003cStudent\u003e findAll() { return dao.findAll(); } 控制层 /* 查询所有学生信息 */ @Test public void findAll() { ArrayList\u003cStudent\u003e list = service.findAll(); for(Student stu : list) { System.out.println(stu); } } 3.需求二：条件查询 持久层 /* 条件查询，根据id查询学生信息 */ @Override public Student findById(Integer id) { Student stu = new Student(); Connection con = null; Statement stat = null; ResultSet rs = null; try{ //1.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取数据库连接 con = DriverManager.getConnection(\"jdbc:mysql://192.168.59.129:3306/db14\", \"root\", \"itheima\"); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"SELECT * FROM student WHERE sid='\"+id+\"'\"; rs = stat.executeQuery(sql); //5.处理结果集 while(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); //封装Student对象 stu.setSid(sid); stu.setName(name); stu.setAge(age); stu.setBirthday(birthday); } } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 if(con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stat != null) { try { stat.close(); } catch (SQLException e) { e.printStackTrace(); } } if(rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } } //将对象返回 return stu; } 业务层 /* 条件查询，根据id查询学生信息 */ @Override public Student findById(Integer id) { return dao.findById(id); } 控制层 /* 条件查询，根据id查询学生信息 */ @Test public void findById() { Student stu = service.findById(3); System.out.println(stu); } 4.需","date":"2021-07-28","objectID":"/jdbc-01/:0:4","tags":[],"title":"JDBC-01","uri":"/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"四、JDBC工具类(理解) 1.工具类的抽取 配置文件(在src下创建config.properties) driverClass=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/db14 username=root password=itheima 工具类 /* JDBC工具类 */ public class JDBCUtils { //1.私有构造方法 private JDBCUtils(){}; //2.声明配置信息变量 private static String driverClass; private static String url; private static String username; private static String password; private static Connection con; //3.静态代码块中实现加载配置文件和注册驱动 static{ try{ //通过类加载器返回配置文件的字节流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"config.properties\"); //创建Properties集合，加载流对象的信息 Properties prop = new Properties(); prop.load(is); //获取信息为变量赋值 driverClass = prop.getProperty(\"driverClass\"); url = prop.getProperty(\"url\"); username = prop.getProperty(\"username\"); password = prop.getProperty(\"password\"); //注册驱动 Class.forName(driverClass); } catch (Exception e) { e.printStackTrace(); } } //4.获取数据库连接的方法 public static Connection getConnection() { try { con = DriverManager.getConnection(url,username,password); } catch (SQLException e) { e.printStackTrace(); } return con; } //5.释放资源的方法 public static void close(Connection con, Statement stat, ResultSet rs) { if(con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stat != null) { try { stat.close(); } catch (SQLException e) { e.printStackTrace(); } } if(rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } } public static void close(Connection con, Statement stat) { close(con,stat,null); } } 2.使用工具类优化student表的CRUD 查询全部 /* 查询所有学生信息 */ @Override public ArrayList\u003cStudent\u003e findAll() { ArrayList\u003cStudent\u003e list = new ArrayList\u003c\u003e(); Connection con = null; Statement stat = null; ResultSet rs = null; try{ con = JDBCUtils.getConnection(); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"SELECT * FROM student\"; rs = stat.executeQuery(sql); //5.处理结果集 while(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); //封装Student对象 Student stu = new Student(sid,name,age,birthday); //将student对象保存到集合中 list.add(stu); } } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 JDBCUtils.close(con,stat,rs); } //将集合对象返回 return list; } 条件查询 /* 条件查询，根据id查询学生信息 */ @Override public Student findById(Integer id) { Student stu = new Student(); Connection con = null; Statement stat = null; ResultSet rs = null; try{ con = JDBCUtils.getConnection(); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"SELECT * FROM student WHERE sid='\"+id+\"'\"; rs = stat.executeQuery(sql); //5.处理结果集 while(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); //封装Student对象 stu.setSid(sid); stu.setName(name); stu.setAge(age); stu.setBirthday(birthday); } } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 JDBCUtils.close(con,stat,rs); } //将对象返回 return stu; } 新增数据 /* 添加学生信息 */ @Override public int insert(Student stu) { Connection con = null; Statement stat = null; int result = 0; try{ con = JDBCUtils.getConnection(); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 Date d = stu.getBirthday(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); String birthday = sdf.format(d); String sql = \"INSERT INTO student VALUES ('\"+stu.getSid()+\"','\"+stu.getName()+\"','\"+stu.getAge()+\"','\"+birthday+\"')\"; result = stat.executeUpdate(sql); } catch(Exception e) { e.printStackTrace(); } finally { //6.释放资源 JDBCUtils.close(con,stat); } //将结果返回 return result; } 修改数据 /* 修改学生信息 */ @Override public int update(Student stu) { Connection con = null; Statement stat = null; int result = 0; try{ con = JDBCUtils.getConnection(); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 Date d = stu.getBirthday(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); String birthday = sdf.format(d); String sql = \"UPDATE","date":"2021-07-28","objectID":"/jdbc-01/:0:5","tags":[],"title":"JDBC-01","uri":"/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"五、SQL注入攻击（理解） sql注入在以前，网站安全级别较低时， 能够通过错误的用户名和密码完成登录、 甚至删除数据 、拖走数据库！ 什么是sql注入？ 注入有什么后果？ 如何防范？ 1.sql注入攻击的演示 在登录界面，输入一个错误的用户名或密码，也可以登录成功 2.sql注入攻击的原理 按照正常道理来说，我们在密码处输入的所有内容，都应该认为是密码的组成 但是现在Statement对象在执行sql语句时，将一部分内容当做查询条件来执行了 3.PreparedStatement的介绍（预编译对象） 预编译sql语句的执行者对象。在执行sql语句之前，将sql语句进行提前编译。明确sql语句的格式后，就不会改变了。剩余的内容都会认为是参数！参数使用?作为占位符 为参数赋值的方法：setXxx(参数1,参数2); 参数1：?的位置编号(编号从1开始) 参数2：?的实际参数 执行sql语句的方法 执行insert、update、delete语句：int executeUpdate(); 执行select语句：ResultSet executeQuery(); 4.PreparedStatement的使用 /* 使用PreparedStatement的登录方法，解决注入攻击 */ @Override public User findByLoginNameAndPassword(String loginName, String password) { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; User user = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.创建操作SQL对象 String sql = \"SELECT * FROM user WHERE loginname=? AND password=?\"; pstm = conn.prepareStatement(sql); //3.设置参数 pstm.setString(1,loginName); pstm.setString(2,password); System.out.println(sql); //4.执行sql语句，获取结果集 rs = pstm.executeQuery(); //5.获取结果集 if (rs.next()) { //6.封装 user = new User(); user.setUid(rs.getString(\"uid\")); user.setUcode(rs.getString(\"ucode\")); user.setUsername(rs.getString(\"username\")); user.setPassword(rs.getString(\"password\")); user.setGender(rs.getString(\"gender\")); user.setDutydate(rs.getDate(\"dutydate\")); user.setBirthday(rs.getDate(\"birthday\")); user.setLoginname(rs.getString(\"loginname\")); } //7.返回 return user; }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(conn,pstm,rs); } } 5.使用PreparedStatement优化student表的CRUD（作业） public class StudentDaoImpl implements StudentDao { @Override public ArrayList\u003cStudent\u003e findAll() { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; ArrayList\u003cStudent\u003e students = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.获取操作对象 pstm = conn.prepareStatement(\"select * from student\"); //3.执行sql语句，获取结果集 rs = pstm.executeQuery(); //4.遍历结果集 students = new ArrayList\u003cStudent\u003e(); while (rs.next()) { //5.封装 Student student = new Student(); student.setSid(rs.getInt(\"sid\")); student.setName(rs.getString(\"name\")); student.setAge(rs.getInt(\"age\")); student.setBirthday(rs.getDate(\"birthday\")); //加入到集合中 students.add(student); } //6.返回 return students; }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(conn,pstm,rs); } } @Override public Student findById(Integer sid) { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; Student student = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.获取操作对象 pstm = conn.prepareStatement(\"select * from student where sid = ? \"); pstm.setInt(1,sid); //3.执行sql语句，获取结果集 rs = pstm.executeQuery(); //4.遍历结果集 if (rs.next()) { //5.封装 student = new Student(); student.setSid(rs.getInt(\"sid\")); student.setName(rs.getString(\"name\")); student.setAge(rs.getInt(\"age\")); student.setBirthday(rs.getDate(\"birthday\")); } //6.返回 return student; }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(conn,pstm,rs); } } @Override public int insert(Student student) { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; int result = 0; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.获取操作对象 pstm = conn.prepareStatement(\"insert into student(sid,name,age,birthday)values(null,?,?,?)\"); //3.设置参数 //pstm.setInt(1,null); pstm.setString(1,student.getName()); pstm.setInt(2,student.getAge()); pstm.setDate(3,new Date(student.getBirthday().getTime())); //4.执行sql语句 result = pstm.executeUpdate(); }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(conn,pstm); } return result; } @Override public int update(Student student) { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; int result = 0; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.获取操作对象 pstm = conn.prepareStatement(\"update student set name=?,age=?,birthday=? where sid=? \"); //3.设置参数 pstm.setString(1,student.getName()); pstm.setInt(2,stu","date":"2021-07-28","objectID":"/jdbc-01/:0:6","tags":[],"title":"JDBC-01","uri":"/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"六、综合案例-批量新增加事务管理 1.service层 接口 /* 批量添加 */ void batchAdd(List\u003cUser\u003e users); 实现类 /* 事务要控制在此处 */ @Override public void batchAdd(List\u003cUser\u003e users) { //获取数据库连接 Connection connection = JDBCUtils.getConnection(); try { //开启事务 connection.setAutoCommit(false); for (User user : users) { //1.创建ID,并把UUID中的-替换 String uid = UUID.randomUUID().toString().replace(\"-\", \"\").toUpperCase(); //2.给user的uid赋值 user.setUid(uid); //3.生成员工编号 user.setUcode(uid); //模拟异常 //int n = 1 / 0; //4.保存 userDao.save(connection,user); } //提交事务 connection.commit(); }catch (Exception e){ try { //回滚事务 connection.rollback(); }catch (Exception ex){ ex.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtils.close(connection,null,null); } } 2.dao层 接口 /** 支持事务的添加 */ void save(Connection connection,User user); 实现类 /* 支持事务的添加 */ @Override public void save(Connection connection, User user) { //定义必要信息 PreparedStatement pstm = null; try { //1.获取连接 connection = JDBCUtils.getConnection(); //2.获取操作对象 pstm = connection.prepareStatement(\"insert into user(uid,ucode,loginname,password,username,gender,birthday,dutydate)values(?,?,?,?,?,?,?,?)\"); //3.设置参数 pstm.setString(1,user.getUid()); pstm.setString(2,user.getUcode()); pstm.setString(3,user.getLoginname()); pstm.setString(4,user.getPassword()); pstm.setString(5,user.getUsername()); pstm.setString(6,user.getGender()); pstm.setDate(7,new Date(user.getBirthday().getTime())); pstm.setDate(8,new Date(user.getDutydate().getTime())); //4.执行sql语句，获取结果集 pstm.executeUpdate(); }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(null,pstm,null); } } 小结：JDBC事务控制：（动手） 测试： 张三给李四转账： 测试无异常时，转账是否成功； 如果有异常时，转账金额是否一个扣钱、一个没收到？ @Test public void test() throws Exception{ //1.导入jar包 //2.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //3.获取连接 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db04?useUnicode=true\u0026characterEncoding=utf-8\u0026serverTimezone=GMT\",\"root\",\"root\"); PreparedStatement pstat = null; PreparedStatement pstat2 = null; try { //开启手动事务 con.setAutoCommit(false); String sql = \"UPDATE account SET money = (money + 100) WHERE id = 1\"; pstat = con.prepareStatement(sql); int num = pstat.executeUpdate(sql); System.out.println(\"sql1影响的行数： \" + num); // 模拟运行时异常 int i= 1/0; String sql2 = \"UPDATE account SET money = (money - 100) WHERE id = 2\"; pstat2 = con.prepareStatement(sql2); int num2 = pstat2.executeUpdate(sql2); System.out.println(\"sql2影响的行数： \" + num2); // 没有异常： 提交事务 con.commit(); }catch (Exception e){ // 出现异常： 回滚事务 con.rollback(); }finally { //7.释放资源 con.close(); pstat.close(); pstat2.close(); } 补充： 1.关于三层架构： 2.关于web工程驱动找不到： web工程的lib依赖必须在web-inf目录下，否则tomcat找不到依赖，就会引发报错： 3.注入攻击： 4.url指定字符集： 如果你插入数据在数据库中中文乱码，可以指定url参数，设置字符集： url=jdbc:mysql://localhost:3306/你的库?useUnicode=true\u0026characterEncoding=utf-8\u0026serverTimezone=GMT 任务安排： 完成课堂演示的对学生表增删改查案例！（视频8-12） 在1的基础上，将crud操作改造为web功能，使用网页来完成数据的查询、增删改； 预习后面的内容； 附加作业1： 尝试完成下面需求： 在页面上提供一个查询商品的按钮； （不需要查询条件） 用户可以在浏览器点击查询， 然后后台执行查询商品表的sql，并且结果返回到页面输出展示； 附加2： 在附加1的基础上，添加查询条件； 预习： ","date":"2021-07-28","objectID":"/jdbc-01/:0:7","tags":[],"title":"JDBC-01","uri":"/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"会话技术session\u0026jsp\u0026mysql-随堂笔记","date":"2021-07-28","objectID":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/"},{"categories":["大三下实训笔记"],"content":"【会话技术session\u0026jsp\u0026mysql-随堂笔记】 〇.今日重点： session： 服务器端会话技术 session是什么 session如何使用 session的作用范围 jsp: 动态页面 了解即可 mysql:数据库 数据库的安装 数据库集成到idea 数据库的crud 一.request\u0026response综合案例关注点： 客户端添加数据到服务器： 服务器响应数据到客户端（浏览器）： 二.session：服务器端会话技术 ​ 1.session是什么: ==本质也是采用客户端会话管理技术。 (session必须依赖于cookie )== 只不过在客户端保存的是一个特殊标识，而共享的数据保存到了服务器端的内存对象中。 （JSESSIONID) 每次请求时，会将特殊标识带到服务器端，根据这个标识来找到对应的内存空间，从而实现数据共享！ 是 Servlet 规范中四大域对象之一的会话域对象。 **作用：**可以实现数据共享 注意： 从大到小的顺序： servletContext \u003e session \u003e request 当前服务器有100个用户， 每个用户访问100次， 会分别产生多少个 servletContext 、 session 、request？ 2.session的获取：（掌握） HttpSession session = request.getSession(); 3.常用方法：（掌握） // 域对象存取值： session.setAttribute(); session.getAttribute(); session.removeAttribute(); //// 销毁session : 退出功能 session.invalidate(); // 获取的是当前session对应的 JSESSIONID --\u003e 唯一的 （每个会话的id是唯一的） session.getId(); 三.JSP（次要） 1.jsp的概念 JSP全称是Java Server Page，它和Servlet一样，也是sun公司推出的一套开发动态web资源的技术，称为JSP/Servlet规范。 JSP的本质其实就是一个Servlet。 与html的区别： 可以在页面上也后台java代码！ 注意：（虽然能写，但是我们应当尽量不写； 能在后台处理的逻辑，不要在页面处理！） 2.jsp快速入门 3.jsp的本质： jsp效率低下的原因: (所以大型项目基本不用jsp，一些小型的后台系统会使用) 效率对比： 4.jsp语法： JSP语法完整示例代码 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eJSP语法\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!--Java代码块--\u003e \u003c% out.println(\"这是Java代码块\");%\u003e \u003chr/\u003e \u003c!--JSP表达式--\u003e \u003c%=\"这是JSP表达式\"%\u003e\u003cbr/\u003e 就相当于\u003cbr/\u003e \u003c%out.println(\"这是没有JSP表达式输出的\");%\u003e \u003chr/\u003e \u003c!--JSP声明--\u003e \u003c%! String str = \"声明语法格式\";%\u003e \u003c%=str%\u003e \u003chr/\u003e \u003c%--JSP注释--%\u003e \u003c!--HTML注释--\u003e \u003c/body\u003e \u003c/html\u003e 5.四大域对象对比：（理解域对象的名字和范围） 四.MVC模型的理解（重要） 把数据的封装、展示和业务处理，进行分工！ **Servlet：**擅长处理业务逻辑，不擅长输出显示界面。在web开发中多用于控制程序逻辑（流程）。所以我们称之为：控制器。 **JSP：**擅长显示界面，不擅长处理程序逻辑。在web开发中多用于展示动态界面。所以我们称之为：视图。 五、数据库的基本概念 1.为什么要学数据库？ 之前我们如果想将一些数据实现永久化存储，可以怎么做呢？没错。使用IO流的技术将数据保存到本地文件中 但是接下来我有这样一个需求：将下面的user.txt文件中的王五年龄修改为35 张三 23 男 李四 24 男 王五 25 女 赵六 26 女 周七 27 男 我们要如何实现呢？ 可以采用字符缓冲流，将每一行数据读取出来，封装为User对象。将多个User对象保存到集合中 然后遍历集合，将王五对象的年龄修改为35,再重新将集合中的对象信息写回到文件中 这一套操作太麻烦了，而现在我们有一种更加方便的方式来完成这个需求了，这种方式就是数据库！ 2.什么是数据库？ 用于存储和管理数据的仓库 英文单词为：DataBase，简称DB （工种： DBA 数据库管理员） 3.数据库的好处？ 可以持久化存储数据 方便存储和管理数据 使用了统一的方式操作数据库 – SQL ","date":"2021-07-28","objectID":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/:0:0","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/"},{"categories":["大三下实训笔记"],"content":"二、MySQL数据库的介绍和安装 1.MySQL数据库介绍 小型的数据库 开源免费(6版本之前免费) 所属于Oracle公司 2.MySQL数据库安装 —查看安装资料 1.在windows安装mysql服务器； 2.在windows安装mysql连接工具；（图形化界面） ","date":"2021-07-28","objectID":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/:0:1","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/"},{"categories":["大三下实训笔记"],"content":"三、SQL语句 1.数据库、数据表、数据的关系介绍 数据库 用于存储和管理数据的仓库 一个库中可以包含多个数据表 数据表 数据库最重要的组成部分之一 它由纵向的列和横向的行组成(类似excel表格) 可以指定列名、数据类型、约束等 一个表中可以存储多条数据 数据 想要永久化存储的数据 2.SQL介绍 什么是SQL Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”。 SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 数据库的注释： 单行注释：– 注释内容 #注释内容(mysql特有) 多行注释：/* 注释内容 */ SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 ","date":"2021-07-28","objectID":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/:0:2","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/"},{"categories":["大三下实训笔记"],"content":"四.对库和表结构的操作（理解） 3.DDL-操作数据库 R(Retrieve)：查询 查询所有数据库 -- 查询所有数据库 SHOWDATABASES; C(Create)：创建 创建数据库 -- 标准语法 CREATEDATABASE数据库名称;-- 创建db1数据库 CREATEDATABASEdb1;-- 创建一个已存在的数据库会报错 -- 错误代码：1007 Can't create database 'db1'; database exists CREATEDATABASEdb1; 创建数据库(判断，如果不存在则创建) -- 标准语法 CREATEDATABASEIFNOTEXISTS数据库名称;-- 创建数据库db2(判断，如果不存在则创建) CREATEDATABASEIFNOTEXISTSdb2; 创建数据库、并指定字符集 -- 标准语法 CREATEDATABASE数据库名称CHARACTERSET字符集名称;-- 创建数据库db3、并指定字符集utf8 CREATEDATABASEdb3CHARACTERSETutf8;-- 查看db3数据库的字符集 SHOWCREATEDATABASEdb3; 练习：创建db4数据库、如果不存在则创建，指定字符集为utf8 -- 创建db4数据库、如果不存在则创建，指定字符集为 utf8 CREATEDATABASEIFNOTEXISTSdb4CHARACTERSETutf8;-- 查看db4数据库的字符集 SHOWCREATEDATABASEdb4; 使用数据库 -- 标准语法 USE数据库名称；-- 使用db4数据库 USEdb4; 【小结：库操作常用sql （需要记住的sql） -- 1. 创建db4数据库、如果不存在则创建，指定字符集为 utf8 -- CREATE DATABASE IF NOT EXISTS 数据库名 CHARACTER SET 字符集名; CREATEDATABASEIFNOTEXISTSdb01CHARACTERSETutf8;-- 2.展示当前数据库下所有的表： (还没建表的时候没有) showtables;-- 3. 删除数据库： DROP DATABASE 数据库名 DROPDATABASEdb03; 4.DDL-操作数据表 R(Retrieve)：查询 查询数据库中所有的数据表 -- 使用mysql数据库 USEmysql;-- 查询库中所有的表 SHOWTABLES; 查询表结构 -- 标准语法 DESC表名;-- 查询user表结构 DESCuser; 查询表字符集 -- 标准语法 SHOWTABLESTATUSFROM库名LIKE'表名';-- 查看mysql数据库中user表字符集 SHOWTABLESTATUSFROMmysqlLIKE'user'; C(Create)：创建 创建数据表 标准语法 CREATETABLE表名(列名1数据类型1,列名2数据类型2,....列名n数据类型n);-- 注意：最后一列，不需要加逗号 数据类型 1.int：整数类型*ageint2.double:小数类型*scoredouble(5,2)*pricedouble3.date:日期，只包含年月日yyyy-MM-dd4.datetime:日期，包含年月日时分秒yyyy-MM-ddHH:mm:ss5.timestamp:时间戳类型包含年月日时分秒yyyy-MM-ddHH:mm:ss*如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值6.varchar：字符串*namevarchar(20):姓名最大20个字符*zhangsan8个字符张三2个字符*3 创建数据表 -- 使用db3数据库 USEdb3;-- 创建一个product商品表 CREATETABLEproduct(idINT,-- 商品编号 NAMEVARCHAR(30),-- 商品名称 priceDOUBLE,-- 商品价格 stockINT,-- 商品库存 insert_timeDATE-- 上架时间 ); 对库的操作： 都是database关键字； 对表结构的操作： 都是table关键字； 上面的操作都是对数据库、数据表结构操作的sql语句，不涉及数据！ 真正以后非常常用的sql是下面的对数据的crud（增删改查）！ ","date":"2021-07-28","objectID":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/:0:3","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/"},{"categories":["大三下实训笔记"],"content":"五.对数据的操作（重要） – 对数据的增删改查 5.DML-INSERT语句 新增表数据语法 新增格式1：给指定列添加数据 -- 标准语法 INSERTINTO表名(列名1,列名2,...)VALUES(值1,值2,...);-- 向product表添加一条数据 INSERTINTOproduct(id,NAME,price,stock,insert_time)VALUES(1,'手机',1999,22,'2099-09-09');-- 向product表添加指定列数据 INSERTINTOproduct(id,NAME,price)VALUES(2,'电脑',4999);-- 查看表中所有数据 SELECT*FROMproduct; 新增格式2：默认给全部列添加数据 -- 标准语法 INSERTINTO表名VALUES(值1,值2,值3,...);-- 默认给全部列添加数据 INSERTINTOproductVALUES(3,'电视',2999,18,'2099-06-06');-- 查看表中所有数据 SELECT*FROMproduct; 新增格式3：批量添加数据 -- 默认添加所有列数据 标准语法 INSERTINTO表名VALUES(值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...);-- 批量添加数据 INSERTINTOproductVALUES(4,'冰箱',999,26,'2099-08-08'),(5,'洗衣机',1999,32,'2099-05-10');-- 查看表中所有数据 SELECT*FROMproduct;-- 给指定列添加数据 标准语法 INSERTINTO表名(列名1,列名2,...)VALUES(值1,值2,...),(值1,值2,...),(值1,值2,...);-- 批量添加指定列数据 INSERTINTOproduct(id,NAME,price)VALUES(6,'微波炉',499),(7,'电磁炉',899);-- 查看表中所有数据 SELECT*FROMproduct; 注意事项 列名和值的数量以及数据类型要对应 除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引) 6.DML-UPDATE语句 修改表数据语法 -- 标准语法 UPDATE表名SET列名1=值1,列名2=值2,...[where条件];-- 修改手机的价格为3500 UPDATEproductSETprice=3500WHERENAME='手机';-- 查看所有数据 SELECT*FROMproduct;-- 修改电视的价格为1800、库存为36 UPDATEproductSETprice=1800,stock=36WHERENAME='电视';-- 修改电磁炉的库存为10 UPDATEproductSETstock=10WHEREid=7; 注意事项 修改语句中必须加条件 如果不加条件，则将所有数据都修改 7.DML-DELETE语句 删除表数据语法 -- 标准语法 DELETEFROM表名[WHERE条件];-- 删除product表中的微波炉信息 DELETEFROMproductWHERENAME='微波炉';-- 删除product表中库存为10的商品信息 DELETEFROMproductWHEREstock=10;-- 查看所有商品信息 SELECT*FROMproduct; 注意事项 删除语句中必须加条件 如果不加条件，则将所有数据删除 8.DQL-单表查询 数据准备(直接复制执行即可) -- 创建db1数据库 CREATEDATABASEdb1;-- 使用db1数据库 USEdb1;-- 创建数据表 CREATETABLEproduct(idINT,-- 商品编号 NAMEVARCHAR(20),-- 商品名称 priceDOUBLE,-- 商品价格 brandVARCHAR(10),-- 商品品牌 stockINT,-- 商品库存 insert_timeDATE-- 添加时间 );-- 添加数据 INSERTINTOproductVALUES(1,'华为手机',3999,'华为',23,'2088-03-10'),(2,'小米手机',2999,'小米',30,'2088-05-15'),(3,'苹果手机',5999,'苹果',18,'2088-08-20'),(4,'华为电脑',6999,'华为',14,'2088-06-16'),(5,'小米电脑',4999,'小米',26,'2088-07-08'),(6,'苹果电脑',8999,'苹果',15,'2088-10-25'),(7,'联想电脑',7999,'联想',NULL,'2088-11-11'); 查询语法 select字段列表from表名列表where条件列表groupby分组字段having分组之后的条件orderby排序limit分页限定 查询全部 -- 标准语法 SELECT*FROM表名;-- 查询product表所有数据 SELECT*FROMproduct; 查询部分 多个字段查询 -- 标准语法 SELECT列名1,列名2,...FROM表名;-- 查询名称、价格、品牌 SELECTNAME,price,brandFROMproduct; 作业安排： -- 1. 创建db4数据库、如果不存在则创建，指定字符集为 utf8 -- CREATE DATABASE IF NOT EXISTS 数据库名 CHARACTER SET 字符集名; -- 2.展示当前数据库下所有的表： -- 3. 删除数据库： DROP DATABASE 数据库名 -- 4.创建数据库中的表： 创建user表： id, 姓名username(VARCHAR), 年龄age（int）, 性别gender(VARCHAR = string)，生日birthday（date） -- 5. 新需求： 修改user2表username为uname, 新增一列 password. -- 6. 删除表： -- 删除user2表 -- 7.insert插入数据： 在t_user表中插入一条王大锤的数据 -- 8.update修改数据： 修改王大锤的性别为女，年龄为22： -- 9.delete删除数据： 删除名字叫王大锤的数据： -- 10. 删除一批性别为女的用户信息： -- ========================================== -- 【select查询：】 -- 1. 查询全表： * 代表查询所有字段 -- 2. 查询指定字段： -- 3. 别名： 给字段起别名： as,也可以省略 -- 4.去重查询： distinct： ---查询所有用户的名，如果有重复的名字，只展示一个： -- 5. 对列进行数学运算： -- 查询用户信息，对年龄整体增加10岁： -- 对商品数据的价格打五折展示： -- 6.条件查询： where -- 查询所有的小米品牌的商品 -- 查询商品价格 1000-5000之间的商品 -- 查询商品价格 1000-5000之间的小米的商品 -------------------【day02】---------------------------------------- -------------------【day02】---------------------------------------- -------------------【day02】---------------------------------------- -- 7.模糊查询： like关键字 -- \"%\" ：代表匹配任意个数模糊匹配; eg: '%小米%' xxxx小米xxxx -- “_” : 代表模糊匹配一位; eg： '王_' 王思聪x 王五√ -- 查询商品中包含“智能”关键字的商品 -- 查询用户名包含“徐”的用户： -- 查询用户名姓“徐”的用户： -- 查询用户名第二个字是'宝'的用户： -- 8.排序查询： order by 默认升序， 后面加上 desc代表倒序 -- 根据商品价格倒序排列： -- 将所有小米产品，进行价格升序排列： -- 9.聚合函数： 求和sum ,求平均值avg ,最大值max ,最小值min , 计数count SELECT*FROMproduct;-- 对所有的商品价格进行求和： -- 求出所有商品的平均价格； 求出user表中用户的平均年龄 -- 最大年龄 -- 最小年龄 -- 计数： count 男性用户有多少个 -- 10.分组查询： group by xxx列名 -- 分组函数group by 通常结合聚合函数(5个)一起使用, 不能跟随便写其他没有分组的列！ SELECT*FROMproduct;-- 查询商品表，对品牌进行分组： -- 查询商品表，对品牌进行分组, 再统计每个品牌的商品个数 -- 查询用户表，对性别进行分组： -- 查询用户表，对性别进行分组, 统计男性女性分别多少人？ -- 11. 分页查询： limit 参数1,参数2; -- select * from 表名 limit 0,10; (参数1代表起始行的索引， 参数2代表每次查询多少条) -- 每次分页查询时，不同的页数只需要变更参数1 的值！ 参数1=（页码-1）*参数2； -- 查询product表， 展示第1页数据，每页展示5条： -- 查询product表， 展示第2","date":"2021-07-28","objectID":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/:0:4","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AFsessionjspmysql%E7%AC%94%E8%AE%B0/"},{"categories":["大三下实训笔记"],"content":"请求响应对象","date":"2021-07-24","objectID":"/web%E6%A0%B8%E5%BF%83-requestresponse/","tags":[],"title":"request \u0026 response","uri":"/web%E6%A0%B8%E5%BF%83-requestresponse/"},{"categories":["大三下实训笔记"],"content":"【web核心-请求响应对象-随堂笔记】 ","date":"2021-07-24","objectID":"/web%E6%A0%B8%E5%BF%83-requestresponse/:0:0","tags":[],"title":"request \u0026 response","uri":"/web%E6%A0%B8%E5%BF%83-requestresponse/"},{"categories":["大三下实训笔记"],"content":"一.今日重点： 请求对象-request （请求对象的api） 请求参数的获取 请求乱码的处理 请求转发 响应对象-response (响应对象的api) 常见响应状态码 服务器数据响应到浏览器 响应乱码的处理 请求重定向 ","date":"2021-07-24","objectID":"/web%E6%A0%B8%E5%BF%83-requestresponse/:1:0","tags":[],"title":"request \u0026 response","uri":"/web%E6%A0%B8%E5%BF%83-requestresponse/"},{"categories":["大三下实训笔记"],"content":"二.前置案例： 1.请求方式与servlet的方法对应关系： 2.请求对象与响应对象的快速入门： ","date":"2021-07-24","objectID":"/web%E6%A0%B8%E5%BF%83-requestresponse/:2:0","tags":[],"title":"request \u0026 response","uri":"/web%E6%A0%B8%E5%BF%83-requestresponse/"},{"categories":["大三下实训笔记"],"content":"三.request请求对象 1.请求路径：（理解） /** * 请求对象的各种信息获取 * @author 黑马程序员 * @Company http://www.itheima.com */ public class RequestDemo1 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //本机地址：服务器地址 String localAddr = request.getLocalAddr(); //本机名称：服务器名称 String localName = request.getLocalName(); //本机端口：服务器端口 int localPort = request.getLocalPort(); //来访者ip String remoteAddr = request.getRemoteAddr(); //来访者主机 String remoteHost = request.getRemoteHost(); //来访者端口 int remotePort = request.getRemotePort(); //统一资源标识符 String URI = request.getRequestURI(); //统一资源定位符 String URL = request.getRequestURL().toString(); //获取查询字符串 String queryString = request.getQueryString(); //获取Servlet映射路径 String servletPath = request.getServletPath(); //输出内容 System.out.println(\"getLocalAddr() is :\"+localAddr); System.out.println(\"getLocalName() is :\"+localName); System.out.println(\"getLocalPort() is :\"+localPort); System.out.println(\"getRemoteAddr() is :\"+remoteAddr); System.out.println(\"getRemoteHost() is :\"+remoteHost); System.out.println(\"getRemotePort() is :\"+remotePort); System.out.println(\"getRequestURI() is :\"+URI); System.out.println(\"getRequestURL() is :\"+URL); System.out.println(\"getQueryString() is :\"+queryString); System.out.println(\"getServletPath() is :\"+servletPath); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 小结： 2.请求参数的获取：（重要） 1）获取请求参数 getParameter()方法的示例代码 /** * 获取请求正文，一个名称对应一个值。 没有使用确认密码 * @param request * @param response * @throws ServletException * @throws IOException */ private void test1(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); String gender = request.getParameter(\"gender\"); System.out.println(username+\",\"+password+\",\"+gender); } getParameterValues()方法的示例代码 /** * 获取请求正文，一个名称可能对应多个值 使用了确认密码 * @param request * @param response * @throws ServletException * @throws IOException */ private void test2(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文 String username = request.getParameter(\"username\"); String[] password = request.getParameterValues(\"password\");//当表单中有多个名称是一样时，得到是一个字符串数组 String gender = request.getParameter(\"gender\"); System.out.println(username+\",\"+Arrays.toString(password)+\",\"+gender); } \u003chtml\u003e \u003chead\u003e \u003ctitle\u003elogin to request demo 4\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"/day10_1122_requestresponse/RequestDemo4\" method=\"post\" enctype=\"multipart/form-data\"\u003e 用户名：\u003cinput type=\"text\" name=\"username\" /\u003e\u003cbr/\u003e 密码：\u003cinput type=\"password\" name=\"password\" /\u003e\u003cbr/\u003e 确认密码：\u003cinput type=\"password\" name=\"password\" /\u003e\u003cbr/\u003e 性别：\u003cinput type=\"radio\" name=\"gender\" value=\"1\" checked\u003e男 \u003cinput type=\"radio\" name=\"gender\" value=\"0\"\u003e女 \u003cbr/\u003e \u003cinput type=\"submit\" value=\"注册\" /\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e getParameterNames()方法的示例代码 /** * 获取请求正文，一个名称一个值。但是先要获取正文名称的枚举（key的枚举） 没有使用确认密码 * @param request * @param response * @throws ServletException * @throws IOException */ private void test3(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文名称的枚举 Enumeration\u003cString\u003e names = request.getParameterNames(); //2.遍历正文名称的枚举 while(names.hasMoreElements()){ String name = names.nextElement(); String value = request.getParameter(name); System.out.println(name+\":\"+value); } } 小结： ​ 以上三个方法可以获取表单提交过来的请求参数。 ​ 参数的名称是一个字符串，参数的值可能是一个字符串，也可能是一个字符串数组。 掌握两种： a: 单个获取： request.getParameter(“username”); b: 批量获取： request.getParameterMap(); // 获取所有提交的参数，封装到一个map集合中 —\u003e 推荐使用 3.请求参数的封装：（掌握） 第一种：最简单直接的封装方式 /** * 封装请求正文到User对象中 没有使用确认密码 * @param request * @param response * @throws ServletException * @throws IOException */ private void test4(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正","date":"2021-07-24","objectID":"/web%E6%A0%B8%E5%BF%83-requestresponse/:3:0","tags":[],"title":"request \u0026 response","uri":"/web%E6%A0%B8%E5%BF%83-requestresponse/"},{"categories":["大三下实训笔记"],"content":"四.response响应对象： 1.常见状态码：（记住） 2.响应数据到浏览器：（重要） 响应文本数据 如何使用： // 响应一句话到浏览器： response.getWriter().write(\"你好 ~~ hello ~~ 123\"); 如何避免中文乱码问题： //解决响应中文乱码 response.setContentType(\"text/html; charset=utf-8\"); 3.设置响应消息头定时刷新 /** * 设置响应消息头： * 通过定时刷新演示添加消息头 * @author 黑马程序员 * @Company http://www.itheima.com * */ public class ResponseDemo5 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String str = \"用户名和密码不匹配，2秒后转向登录页面...\"; response.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = response.getWriter(); out.write(str); //定时刷新，其实就是设置一个响应消息头 response.setHeader(\"Refresh\", \"2;URL=/login.html\");//Refresh设置的时间单位是秒，如果刷新到其他地址，需要在时间后面拼接上地址 } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 小结： 定时刷新，后期可以结合js一起完成 * resp.setContentType: 告诉客户端浏览器，以何种方式解析内容； * * resp.setHeader: 设置响应头，告诉浏览器应该做什么 * * resp.setHeader(\"Refresh\",\"10;URL=/index.html\"); //告诉浏览器，在10秒后，自动请求URL指定的资源 4.重定向：redirect（重要） 思考： ​ 重定向后， 请求次数有几次？ ​ 重定向后，携带的参数是否可以共享？ ​ 重定向后，浏览器的地址栏是否有变化？ 浏览器端-》servlet1-》servlet2 如何使用： // 重定向 到项目内部 testRedirect02 response.sendRedirect(\"testRedirect02\"); // 演示跨服务器: 重定向到百度 response.sendRedirect(\"https://www.baidu.com/\"); 重定向执行顺序： 重定向和转发的区别：（面试常问） 请求次数 参数是否共享 地址栏是否变化 是否可以跨服务器 5.响应和消息头组合应用-文件下载 首先，在工程的web目录下新建一个目录uploads，并且拷贝一张图片到目录中，如下图所示： 文件下载的Servlet代码如下： /** * 文件下载 */ public class ResponseDemo8 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* * 文件下载的思路： * 1.获取文件路径 * 2.把文件读到字节输入流中 * 3.告知浏览器，以下载的方式打开（告知浏览器下载文件的MIME类型） * 4.使用响应对象的字节输出流输出到浏览器上 */ //1.获取文件路径（绝对路径） ServletContext context = this.getServletContext(); String filePath = context.getRealPath(\"/uploads/6.jpg\");//通过文件的虚拟路径，获取文件的绝对路径 //2.通过文件路径构建一个字节输入流 InputStream in = new FileInputStream(filePath); //3.设置响应消息头 response.setHeader(\"Content-Type\", \"application/octet-stream\");//注意下载的时候，设置响应正文的MIME类型，用application/octet-stream response.setHeader(\"Content-Disposition\", \"attachment;filename=1.jpg\");//告知浏览器以下载的方式打开 //4.使用响应对象的字节输出流输出 OutputStream out = response.getOutputStream(); int len = 0; byte[] by = new byte[1024]; while((len = in.read(by)) != -1){ out.write(by, 0, len); } in.close(); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 小结： 在做下载时，如果时浏览器识别的类型，会默认打开，需要指定响应头 attachment，标识为以附件形式下载； 如果是浏览不支持打开的类型，默认其实就是下载！ 所以，以后做下载： 1.使用响应输出字节流； 2.直接超链接指定资源，也可以完成下载； \u003ch3\u003e文件下载:\u003c/h3\u003e \u003ca href=\"/download/Mojito%20-%20周杰伦.mp4\"\u003eMojito高清MV下载\u003c/a\u003e \u003cbr\u003e \u003ca href=\"/download/最新阿凡达3D.zip\"\u003e 高清无码最新阿凡达3D\u003c/a\u003e 今日任务安排： 练习今天标注的重点代码 理解今天标了重要和掌握的内容 预习后面的内容： ","date":"2021-07-24","objectID":"/web%E6%A0%B8%E5%BF%83-requestresponse/:4:0","tags":[],"title":"request \u0026 response","uri":"/web%E6%A0%B8%E5%BF%83-requestresponse/"},{"categories":["java面试"],"content":"享学hashmap","date":"2021-07-21","objectID":"/hashmap/","tags":["HashMap"],"title":"HashMap","uri":"/hashmap/"},{"categories":["java面试"],"content":"数据结构：数组+链表+红黑树（JDK8） 算法： Hash算法 数组定位 Hash冲突 扩容 多线程安全 1、JDK8为什么加入了红黑树？ 单纯为了效率？ HashMap导致Dos? 线程安全的场景下 CVE-2011-4859 Tomcat邮件组的讨论 max 黑客构造W+的Hash值相等的键key来构造请求参数，那么就造成了Hash冲突，会构成一个W+的链表，而链表的查询效率是十分低的，占用大量的CPU时间，无法响应用户请求。 Map\u003cString,String\u003e hashMap=new HashMap\u003cString, String\u003e(); List\u003cString\u003e list= Arrays.asList(\"Aa\",\"BB\",\"C#\"); for(String string:list){ System.out.println(string.hashCode()); hashMap.put(string,string); } Iterator\u003cString\u003e iterator = hashMap.keySet().iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 2112 2112 2112 Aa BB C# 为什么是红黑树？ 红黑树、二叉树、二叉排序树、平衡二叉树，而平衡二叉树的查询效率最高； 构建平衡二叉树十分消耗性能，涉及二叉树旋转平衡，所以采用折中的方案：红黑树中只有有一个原则：max\u003c=2*min; 2、HashMap出现Dos，表现形式：CPU 100%，怎么解决？ JVM的性能排查，jstack,top,jmap,arthas《JVM性能调优》 3、Hash Map中的算法 ","date":"2021-07-21","objectID":"/hashmap/:0:0","tags":["HashMap"],"title":"HashMap","uri":"/hashmap/"},{"categories":["java面试"],"content":"Hash算法的流程 static final int hash(Object key) { int h; return key == null ? 0 : (h = key.hashCode()) ^ h \u003e\u003e\u003e 16; } public native int hashCode(); ","date":"2021-07-21","objectID":"/hashmap/:1:0","tags":["HashMap"],"title":"HashMap","uri":"/hashmap/"},{"categories":["大三下实训笔记"],"content":"Collection-List","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"1.Collection集合 ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:1:0","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"1.1数组和集合的区别【理解】 相同点 都是容器,可以存储多个数据 不同点 数组的长度是不可变的,集合的长度是可变的 数组可以存基本数据类型和引用数据类型 集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类 ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:1:1","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"1.2集合类体系结构【理解】 ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:1:2","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"1.3Collection 集合概述和使用【应用】 Collection集合概述 是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素 JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现 创建Collection集合的对象 多态的方式 具体的实现类ArrayList Collection集合常用方法 方法名 说明 boolean add(E e) 添加元素 boolean remove(Object o) 从集合中移除指定的元素 boolean removeIf(Object o) 根据条件进行移除 void clear() 清空集合中的元素 boolean contains(Object o) 判断集合中是否存在指定的元素 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中元素的个数 ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:1:3","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"1.4Collection集合的遍历【应用】 迭代器介绍 迭代器,集合的专用遍历方式 Iterator iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到 Iterator中的常用方法 boolean hasNext(): 判断当前位置是否有元素可以被取出 E next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置 Collection集合的遍历 public class IteratorDemo1 { public static void main(String[] args) { //创建集合对象 Collection\u003cString\u003e c = new ArrayList\u003c\u003e(); //添加元素 c.add(\"hello\"); c.add(\"world\"); c.add(\"java\"); c.add(\"javaee\"); //Iterator\u003cE\u003e iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到 Iterator\u003cString\u003e it = c.iterator(); //用while循环改进元素的判断和获取 while (it.hasNext()) { String s = it.next(); System.out.println(s); } } } 迭代器中删除的方法 void remove(): 删除迭代器对象当前指向的元素 public class IteratorDemo2 { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"a\"); list.add(\"b\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); Iterator\u003cString\u003e it = list.iterator(); while(it.hasNext()){ String s = it.next(); if(\"b\".equals(s)){ //指向谁,那么此时就删除谁. it.remove(); } } System.out.println(list); } } ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:1:4","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"1.5增强for循环【应用】 介绍 它是JDK5之后出现的,其内部原理是一个Iterator迭代器 实现Iterable接口的类才可以使用迭代器和增强for 简化数组和Collection集合的遍历 格式 for(集合/数组中元素的数据类型 变量名 : 集合/数组名) { // 已经将当前遍历到的元素封装到变量中了,直接使用变量即可 } 代码 public class MyCollectonDemo1 { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\"); list.add(\"f\"); //1,数据类型一定是集合或者数组中元素的类型 //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素 //3,list就是要遍历的集合或者数组 for(String str : list){ System.out.println(str); } } } ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:1:5","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"2.List集合 ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:2:0","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"2.1List集合的概述和特点【记忆】 List集合的概述 有序集合,这里的有序指的是存取顺序 用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素 与Set集合不同,列表通常允许重复的元素 List集合的特点 存取有序 可以重复 有索引 ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:2:1","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"2.2List集合的特有方法【应用】 方法介绍 方法名 描述 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 示例代码 public class MyListDemo { public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); //method1(list); //method2(list); //method3(list); //method4(list); } private static void method4(List\u003cString\u003e list) { // E get(int index) 返回指定索引处的元素 String s = list.get(0); System.out.println(s); } private static void method3(List\u003cString\u003e list) { // E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 //被替换的那个元素,在集合中就不存在了. String result = list.set(0, \"qqq\"); System.out.println(result); System.out.println(list); } private static void method2(List\u003cString\u003e list) { // E remove(int index) 删除指定索引处的元素，返回被删除的元素 //在List集合中有两个删除的方法 //第一个 删除指定的元素,返回值表示当前元素是否删除成功 //第二个 删除指定索引的元素,返回值表示实际删除的元素 String s = list.remove(0); System.out.println(s); System.out.println(list); } private static void method1(List\u003cString\u003e list) { // void add(int index,E element) 在此集合中的指定位置插入指定的元素 //原来位置上的元素往后挪一个索引. list.add(0,\"qqq\"); System.out.println(list); } } ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:2:2","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"3.数据结构 ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:3:0","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"3.1数据结构之栈和队列【记忆】 栈结构 先进后出 队列结构 先进先出 ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:3:1","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"3.2数据结构之数组和链表【记忆】 数组结构 查询快、增删慢 队列结构 查询慢、增删快 ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:3:2","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"4.List集合的实现类 ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:4:0","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"4.1List集合子类的特点【记忆】 ArrayList集合 底层是数组结构实现，查询快、增删慢 LinkedList集合 底层是链表结构实现，查询慢、增删快 ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:4:1","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"4.2LinkedList集合的特有功能【应用】 特有方法 方法名 说明 public void addFirst(E e) 在该列表开头插入指定的元素 public void addLast(E e) 将指定的元素追加到此列表的末尾 public E getFirst() 返回此列表中的第一个元素 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 示例代码 public class MyLinkedListDemo4 { public static void main(String[] args) { LinkedList\u003cString\u003e list = new LinkedList\u003c\u003e(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); // public void addFirst(E e) 在该列表开头插入指定的元素 //method1(list); // public void addLast(E e) 将指定的元素追加到此列表的末尾 //method2(list); // public E getFirst() 返回此列表中的第一个元素 // public E getLast() 返回此列表中的最后一个元素 //method3(list); // public E removeFirst() 从此列表中删除并返回第一个元素 // public E removeLast() 从此列表中删除并返回最后一个元素 //method4(list); } private static void method4(LinkedList\u003cString\u003e list) { String first = list.removeFirst(); System.out.println(first); String last = list.removeLast(); System.out.println(last); System.out.println(list); } private static void method3(LinkedList\u003cString\u003e list) { String first = list.getFirst(); String last = list.getLast(); System.out.println(first); System.out.println(last); } private static void method2(LinkedList\u003cString\u003e list) { list.addLast(\"www\"); System.out.println(list); } private static void method1(LinkedList\u003cString\u003e list) { list.addFirst(\"qqq\"); System.out.println(list); } } ","date":"2021-07-21","objectID":"/day07%E9%9B%86%E5%90%8801/:4:2","tags":[],"title":"Collection -01","uri":"/day07%E9%9B%86%E5%90%8801/"},{"categories":["大三下实训笔记"],"content":"泛型-Set-TreeSet","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"1.泛型 ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:1:0","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"1.1泛型概述【理解】 泛型的介绍 ​ 泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制 泛型的好处 把运行时期的问题提前到了编译期间 避免了强制类型转换 泛型的定义格式 \u003c类型\u003e: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: \u003c类型1,类型2…\u003e: 指定多种类型的格式,多种类型之间用逗号隔开.例如: \u003cE,T\u003e \u003cK,V\u003e ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:1:1","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"1.2泛型类【应用】 定义格式 修饰符 class 类名\u003c类型\u003e { } 示例代码 泛型类 public class Generic\u003cT\u003e { private T t; public T getT() { return t; } public void setT(T t) { this.t = t; } } 测试类 public class GenericDemo1 { public static void main(String[] args) { Generic\u003cString\u003e g1 = new Generic\u003cString\u003e(); g1.setT(\"杨幂\"); System.out.println(g1.getT()); Generic\u003cInteger\u003e g2 = new Generic\u003cInteger\u003e(); g2.setT(30); System.out.println(g2.getT()); Generic\u003cBoolean\u003e g3 = new Generic\u003cBoolean\u003e(); g3.setT(true); System.out.println(g3.getT()); } } ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:1:2","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"1.3泛型方法【应用】 定义格式 修饰符 \u003c类型\u003e 返回值类型 方法名(类型 变量名) { } 示例代码 带有泛型方法的类 public class Generic { public \u003cT\u003e void show(T t) { System.out.println(t); } } 测试类 public class GenericDemo2 { public static void main(String[] args) { Generic g = new Generic(); g.show(\"柳岩\"); g.show(30); g.show(true); g.show(12.34); } } ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:1:3","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"1.4泛型接口【应用】 定义格式 修饰符 interface 接口名\u003c类型\u003e { } 示例代码 泛型接口 public interface Generic\u003cT\u003e { void show(T t); } 泛型接口实现类1 ​ 定义实现类时,定义和接口相同泛型,创建实现类对象时明确泛型的具体类型 public class GenericImpl1\u003cT\u003e implements Generic\u003cT\u003e { @Override public void show(T t) { System.out.println(t); } } 泛型接口实现类2 ​ 定义实现类时,直接明确泛型的具体类型 public class GenericImpl2 implements Generic\u003cInteger\u003e{ @Override public void show(Integer t) { System.out.println(t); } } 测试类 public class GenericDemo3 { public static void main(String[] args) { GenericImpl1\u003cString\u003e g1 = new GenericImpl\u003cString\u003e(); g1.show(\"林青霞\"); GenericImpl1\u003cInteger\u003e g2 = new GenericImpl\u003cInteger\u003e(); g2.show(30); GenericImpl2 g3 = new GenericImpl2(); g3.show(10); } } ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:1:4","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"1.5类型通配符 类型通配符: ArrayList: 表示元素类型未知的ArrayList,它的元素可以匹配任何的类型 但是并不能把元素添加到ArrayList中了,获取出来的也是父类类型 类型通配符上限: \u003c? extends 类型\u003e ArrayListList \u003c? extends Number\u003e: 它表示的类型是Number或者其子类型 类型通配符下限: \u003c? super 类型\u003e ArrayListList \u003c? super Number\u003e: 它表示的类型是Number或者其父类型 泛型通配符的使用 public class GenericDemo4 { public static void main(String[] args) { ArrayList\u003cInteger\u003e list1 = new ArrayList\u003c\u003e(); ArrayList\u003cString\u003e list2 = new ArrayList\u003c\u003e(); ArrayList\u003cNumber\u003e list3 = new ArrayList\u003c\u003e(); ArrayList\u003cObject\u003e list4 = new ArrayList\u003c\u003e(); method(list1); method(list2); method(list3); method(list4); getElement1(list1); getElement1(list2);//报错 getElement1(list3); getElement1(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); } // 泛型通配符: 此时的泛型?,可以是任意类型 public static void method(ArrayList\u003c?\u003e list){} // 泛型的上限: 此时的泛型?,必须是Number类型或者Number类型的子类 public static void getElement1(ArrayList\u003c? extends Number\u003e list){} // 泛型的下限: 此时的泛型?,必须是Number类型或者Number类型的父类 public static void getElement2(ArrayList\u003c? super Number\u003e list){} } ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:1:5","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"2.Set集合 ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:2:0","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"2.1Set集合概述和特点【应用】 不可以存储重复元素 没有索引,不能使用普通for循环遍历 ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:2:1","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"2.2Set集合的使用【应用】 存储字符串并遍历 public class MySet1 { public static void main(String[] args) { //创建集合对象 Set\u003cString\u003e set = new TreeSet\u003c\u003e(); //添加元素 set.add(\"ccc\"); set.add(\"aaa\"); set.add(\"aaa\"); set.add(\"bbb\"); // for (int i = 0; i \u003c set.size(); i++) { // //Set集合是没有索引的，所以不能使用通过索引获取元素的方法 // } //遍历集合 Iterator\u003cString\u003e it = set.iterator(); while (it.hasNext()){ String s = it.next(); System.out.println(s); } System.out.println(\"-----------------------------------\"); for (String s : set) { System.out.println(s); } } } ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:2:2","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"3.TreeSet集合 ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:3:0","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"3.1TreeSet集合概述和特点【应用】 不可以存储重复元素 没有索引 可以将元素按照规则进行排序 TreeSet()：根据其元素的自然排序进行排序 TreeSet(Comparator comparator) ：根据指定的比较器进行排序 ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:3:1","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"3.2TreeSet集合基本使用【应用】 存储Integer类型的整数并遍历 public class TreeSetDemo01 { public static void main(String[] args) { //创建集合对象 TreeSet\u003cInteger\u003e ts = new TreeSet\u003cInteger\u003e(); //添加元素 ts.add(10); ts.add(40); ts.add(30); ts.add(50); ts.add(20); ts.add(30); //遍历集合 for(Integer i : ts) { System.out.println(i); } } } ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:3:2","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"3.3自然排序Comparable的使用【应用】 案例需求 存储学生对象并遍历，创建TreeSet集合使用无参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 使用空参构造创建TreeSet集合 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的 自定义的Student类实现Comparable接口 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法 重写接口中的compareTo方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 学生类 public class Student implements Comparable\u003cStudent\u003e{ private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } @Override public int compareTo(Student o) { //按照对象的年龄进行排序 //主要判断条件: 按照年龄从小到大排序 int result = this.age - o.age; //次要判断条件: 年龄相同时，按照姓名的字母顺序排序 result = result == 0 ? this.name.compareTo(o.getName()) : result; return result; } } 测试类 public class MyTreeSet2 { public static void main(String[] args) { //创建集合对象 TreeSet\u003cStudent\u003e ts = new TreeSet\u003c\u003e(); //创建学生对象 Student s1 = new Student(\"zhangsan\",28); Student s2 = new Student(\"lisi\",27); Student s3 = new Student(\"wangwu\",29); Student s4 = new Student(\"zhaoliu\",28); Student s5 = new Student(\"qianqi\",30); //把学生添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); //遍历集合 for (Student student : ts) { System.out.println(student); } } } 结果： Student{name='lisi', age=27} Student{name='zhangsan', age=28} Student{name='zhaoliu', age=28} Student{name='wangwu', age=29} Student{name='qianqi', age=30} ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:3:3","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"3.4比较器排序Comparator的使用【应用】 案例需求 存储老师对象并遍历，创建TreeSet集合使用带参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 老师类 public class Teacher { private String name; private int age; public Teacher() { } public Teacher(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Teacher{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class MyTreeSet4 { public static void main(String[] args) { //创建集合对象 TreeSet\u003cTeacher\u003e ts = new TreeSet\u003c\u003e(new Comparator\u003cTeacher\u003e() { @Override public int compare(Teacher o1, Teacher o2) { //o1表示现在要存入的那个元素 //o2表示已经存入到集合中的元素 //主要条件 int result = o1.getAge() - o2.getAge(); //次要条件 result = result == 0 ? o1.getName().compareTo(o2.getName()) : result; return result; } }); //创建老师对象 Teacher t1 = new Teacher(\"zhangsan\",23); Teacher t2 = new Teacher(\"lisi\",22); Teacher t3 = new Teacher(\"wangwu\",24); Teacher t4 = new Teacher(\"zhaoliu\",24); //把老师添加到集合 ts.add(t1); ts.add(t2); ts.add(t3); ts.add(t4); //遍历集合 for (Teacher teacher : ts) { System.out.println(teacher); } } } 结果： Teacher{name='lisi', age=22} Teacher{name='zhangsan', age=23} Teacher{name='wangwu', age=24} Teacher{name='zhaoliu', age=24} ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:3:4","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"3.5两种比较方式总结【理解】 两种比较方式小结 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序 两种方式中关于返回值的规则 如果返回值为负数，表示当前存入的元素是较小值，存左边 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存 如果返回值为正数，表示当前存入的元素是较大值，存右边 ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:3:5","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"4.数据结构 ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:4:0","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"4.1二叉树【理解】 二叉树的特点 二叉树中,任意一个节点的度要小于等于2 节点: 在树结构中,每一个元素称之为节点 度: 每一个节点的子节点数量称之为度 二叉树结构图 ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:4:1","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"4.2二叉查找树【理解】 二叉查找树的特点 二叉查找树,又称二叉排序树或者二叉搜索树 每一个节点上最多有两个子节点 左子树上所有节点的值都小于根节点的值 右子树上所有节点的值都大于根节点的值 二叉查找树结构图 二叉查找树和二叉树对比结构图 二叉查找树添加节点规则 小的存左边 大的存右边 一样的不存 ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:4:2","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"4.3平衡二叉树【理解】 平衡二叉树的特点 二叉树左右两个子树的高度差不超过1 任意节点的左右两个子树都是一颗平衡二叉树 平衡二叉树旋转 旋转触发时机 当添加一个节点之后,该树不再是一颗平衡二叉树 左旋 就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点 右旋 就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点 平衡二叉树和二叉查找树对比结构图 平衡二叉树旋转的四种情况 左左 左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行右旋即可 左右 左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋 右右 右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行左旋即可 右左 右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋 ","date":"2021-07-21","objectID":"/day08%E9%9B%86%E5%90%8802/:4:3","tags":[],"title":"Collection -02","uri":"/day08%E9%9B%86%E5%90%8802/"},{"categories":["大三下实训笔记"],"content":"红黑树-HashSet-Map-HashMap-TreeMap","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"1.红黑树 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:1:0","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"1.1概述【理解】 红黑树的特点 平衡二叉B树 每一个节点可以是红或者黑 红黑树不是高度平衡的,它的平衡是通过\"自己的红黑规则\"进行实现的 红黑树的红黑规则有哪些 每一个节点或是红色的,或者是黑色的 根节点必须是黑色 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况) 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点 红黑树添加节点的默认颜色 添加节点时,默认为红色,效率高 红黑树添加节点后如何保持红黑规则 根节点位置 直接变为黑色 非根节点位置 父节点为黑色 不需要任何操作,默认红色即可 父节点为红色 叔叔节点为红色 将\"父节点\"设为黑色,将\"叔叔节点\"设为黑色 将\"祖父节点\"设为红色 如果\"祖父节点\"为根节点,则将根节点再次变成黑色 叔叔节点为黑色 将\"父节点\"设为黑色 将\"祖父节点\"设为红色 以\"祖父节点\"为支点进行旋转 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:1:1","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"1.2成绩排序案例【应用】 案例需求 用TreeSet集合存储多个学生信息(姓名,语文成绩,数学成绩,英语成绩),并遍历该集合 要求: 按照总分从高到低出现 代码实现 学生类 public class Student implements Comparable\u003cStudent\u003e { private String name; private int chinese; private int math; private int english; public Student() { } public Student(String name, int chinese, int math, int english) { this.name = name; this.chinese = chinese; this.math = math; this.english = english; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getChinese() { return chinese; } public void setChinese(int chinese) { this.chinese = chinese; } public int getMath() { return math; } public void setMath(int math) { this.math = math; } public int getEnglish() { return english; } public void setEnglish(int english) { this.english = english; } public int getSum() { return this.chinese + this.math + this.english; } @Override public int compareTo(Student o) { // 主要条件: 按照总分进行排序 int result = o.getSum() - this.getSum(); // 次要条件: 如果总分一样,就按照语文成绩排序 result = result == 0 ? o.getChinese() - this.getChinese() : result; // 如果语文成绩也一样,就按照数学成绩排序 result = result == 0 ? o.getMath() - this.getMath() : result; // 如果总分一样,各科成绩也都一样,就按照姓名排序 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; } } 测试类 public class TreeSetDemo { public static void main(String[] args) { //创建TreeSet集合对象，通过比较器排序进行排序 TreeSet\u003cStudent\u003e ts = new TreeSet\u003cStudent\u003e(); //创建学生对象 Student s1 = new Student(\"jack\", 98, 100, 95); Student s2 = new Student(\"rose\", 95, 95, 95); Student s3 = new Student(\"sam\", 100, 93, 98); //把学生对象添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); //遍历集合 for (Student s : ts) { System.out.println(s.getName() + \",\" + s.getChinese() + \",\" + s.getMath() + \",\" + s.getEnglish() + \",\" + s.getSum()); } } } ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:1:2","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"2.HashSet集合 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:2:0","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"2.1HashSet集合概述和特点【应用】 底层数据结构是哈希表 存取无序 不可以存储重复元素 没有索引,不能使用普通for循环遍历 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:2:1","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"2.2HashSet集合的基本应用【应用】 存储字符串并遍历 public class HashSetDemo { public static void main(String[] args) { //创建集合对象 HashSet\u003cString\u003e set = new HashSet\u003cString\u003e(); //添加元素 set.add(\"hello\"); set.add(\"world\"); set.add(\"java\"); //不包含重复元素的集合 set.add(\"world\"); //遍历 for(String s : set) { System.out.println(s); } } } ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:2:2","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"2.3哈希值【理解】 哈希值简介 ​ 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值 如何获取哈希值 ​ Object类中的public int hashCode()：返回对象的哈希码值 哈希值的特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:2:3","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"2.4哈希表结构【理解】 JDK1.8以前 ​ 数组 + 链表 JDK1.8以后 节点个数少于等于8个 ​ 数组 + 链表 节点个数多于8个 ​ 数组 + 红黑树 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:2:4","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"2.5HashSet集合存储学生对象并遍历【应用】 案例需求 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合 要求：学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; } @Override public int hashCode() { int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; } } 测试类 public class HashSetDemo02 { public static void main(String[] args) { //创建HashSet集合对象 HashSet\u003cStudent\u003e hs = new HashSet\u003cStudent\u003e(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"张曼玉\", 35); Student s3 = new Student(\"王祖贤\", 33); Student s4 = new Student(\"王祖贤\", 33); //把学生添加到集合 hs.add(s1); hs.add(s2); hs.add(s3); hs.add(s4); //遍历集合(增强for) for (Student s : hs) { System.out.println(s.getName() + \",\" + s.getAge()); } } } 总结 ​ HashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:2:5","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"3.Map集合 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:3:0","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"3.1Map集合概述和特点【理解】 Map集合概述 interface Map\u003cK,V\u003e K：键的类型；V：值的类型 Map集合的特点 双列集合,一个键对应一个值 键不可以重复,值可以重复 Map集合的基本使用 public class MapDemo01 { public static void main(String[] args) { //创建集合对象 Map\u003cString,String\u003e map = new HashMap\u003cString,String\u003e(); //V put(K key, V value) 将指定的值与该映射中的指定键相关联 map.put(\"itheima001\",\"林青霞\"); map.put(\"itheima002\",\"张曼玉\"); map.put(\"itheima003\",\"王祖贤\"); map.put(\"itheima003\",\"柳岩\"); //输出集合对象 System.out.println(map); } } ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:3:1","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"3.2Map集合的基本功能【应用】 方法介绍 方法名 说明 V put(K key,V value) 添加元素 V remove(Object key) 根据键删除键值对元素 void clear() 移除所有的键值对元素 boolean containsKey(Object key) 判断集合是否包含指定的键 boolean containsValue(Object value) 判断集合是否包含指定的值 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中键值对的个数 示例代码 public class MapDemo02 { public static void main(String[] args) { //创建集合对象 Map\u003cString,String\u003e map = new HashMap\u003cString,String\u003e(); //V put(K key,V value)：添加元素 map.put(\"张无忌\",\"赵敏\"); map.put(\"郭靖\",\"黄蓉\"); map.put(\"杨过\",\"小龙女\"); //V remove(Object key)：根据键删除键值对元素 // System.out.println(map.remove(\"郭靖\")); // System.out.println(map.remove(\"郭襄\")); //void clear()：移除所有的键值对元素 // map.clear(); //boolean containsKey(Object key)：判断集合是否包含指定的键 // System.out.println(map.containsKey(\"郭靖\")); // System.out.println(map.containsKey(\"郭襄\")); //boolean isEmpty()：判断集合是否为空 // System.out.println(map.isEmpty()); //int size()：集合的长度，也就是集合中键值对的个数 System.out.println(map.size()); //输出集合对象 System.out.println(map); } } ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:3:2","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"3.3Map集合的获取功能【应用】 方法介绍 方法名 说明 V get(Object key) 根据键获取值 Set keySet() 获取所有键的集合 Collection values() 获取所有值的集合 Set\u003cMap.Entry\u003cK,V» entrySet() 获取所有键值对对象的集合 示例代码 public class MapDemo03 { public static void main(String[] args) { //创建集合对象 Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //V get(Object key):根据键获取值 // System.out.println(map.get(\"张无忌\")); // System.out.println(map.get(\"张三丰\")); //Set\u003cK\u003e keySet():获取所有键的集合 // Set\u003cString\u003e keySet = map.keySet(); // for(String key : keySet) { // System.out.println(key); // } //Collection\u003cV\u003e values():获取所有值的集合 Collection\u003cString\u003e values = map.values(); for(String value : values) { System.out.println(value); } } } ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:3:3","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"3.4Map集合的遍历(方式1)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 把所有的丈夫给集中起来 遍历丈夫的集合，获取到每一个丈夫 根据丈夫去找对应的妻子 步骤分析 获取所有键的集合。用keySet()方法实现 遍历键的集合，获取到每一个键。用增强for实现 根据键去找值。用get(Object key)方法实现 代码实现 public class MapDemo01 { public static void main(String[] args) { //创建集合对象 Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //获取所有键的集合。用keySet()方法实现 Set\u003cString\u003e keySet = map.keySet(); //遍历键的集合，获取到每一个键。用增强for实现 for (String key : keySet) { //根据键去找值。用get(Object key)方法实现 String value = map.get(key); System.out.println(key + \",\" + value); } } } ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:3:4","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"3.5Map集合的遍历(方式2)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 获取所有结婚证的集合 遍历结婚证的集合，得到每一个结婚证 根据结婚证获取丈夫和妻子 步骤分析 获取所有键值对对象的集合 Set\u003cMap.Entry\u003cK,V» entrySet()：获取所有键值对对象的集合 遍历键值对对象的集合，得到每一个键值对对象 用增强for实现，得到每一个Map.Entry 根据键值对对象获取键和值 用getKey()得到键 用getValue()得到值 代码实现 public class MapDemo02 { public static void main(String[] args) { //创建集合对象 Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //获取所有键值对对象的集合 Set\u003cMap.Entry\u003cString, String\u003e\u003e entrySet = map.entrySet(); //遍历键值对对象的集合，得到每一个键值对对象 for (Map.Entry\u003cString, String\u003e me : entrySet) { //根据键值对对象获取键和值 String key = me.getKey(); String value = me.getValue(); System.out.println(key + \",\" + value); } } } ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:3:5","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"4.HashMap集合 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:4:0","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"4.1HashMap集合概述和特点【理解】 HashMap底层是哈希表结构的 依赖hashCode方法和equals方法保证键的唯一 如果键要存储的是自定义对象，需要重写hashCode和equals方法 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:4:1","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"4.2HashMap集合应用案例【应用】 案例需求 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; } @Override public int hashCode() { int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; } } 测试类 public class HashMapDemo { public static void main(String[] args) { //创建HashMap集合对象 HashMap\u003cStudent, String\u003e hm = new HashMap\u003cStudent, String\u003e(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"张曼玉\", 35); Student s3 = new Student(\"王祖贤\", 33); Student s4 = new Student(\"王祖贤\", 33); //把学生添加到集合 hm.put(s1, \"西安\"); hm.put(s2, \"武汉\"); hm.put(s3, \"郑州\"); hm.put(s4, \"北京\"); //遍历集合 Set\u003cStudent\u003e keySet = hm.keySet(); for (Student key : keySet) { String value = hm.get(key); System.out.println(key.getName() + \",\" + key.getAge() + \",\" + value); } } } ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:4:2","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"5.TreeMap集合 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:5:0","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"5.1TreeMap集合概述和特点【理解】 TreeMap底层是红黑树结构 依赖自然排序或者比较器排序,对键进行排序 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则 ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:5:1","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"5.2TreeMap集合应用案例【应用】 案例需求 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序 代码实现 学生类 public class Student implements Comparable\u003cStudent\u003e{ private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } @Override public int compareTo(Student o) { //按照年龄进行排序 int result = o.getAge() - this.getAge(); //次要条件，按照姓名排序。 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; } } 测试类 public class Test1 { public static void main(String[] args) { // 创建TreeMap集合对象 TreeMap\u003cStudent,String\u003e tm = new TreeMap\u003c\u003e(); // 创建学生对象 Student s1 = new Student(\"xiaohei\",23); Student s2 = new Student(\"dapang\",22); Student s3 = new Student(\"xiaomei\",22); // 将学生对象添加到TreeMap集合中 tm.put(s1,\"江苏\"); tm.put(s2,\"北京\"); tm.put(s3,\"天津\"); // 遍历TreeMap集合,打印每个学生的信息 tm.forEach( (Student key, String value)-\u003e{ System.out.println(key + \"---\" + value); } ); } } ","date":"2021-07-21","objectID":"/day09%E9%9B%86%E5%90%8803/:5:2","tags":[],"title":"Collection -03","uri":"/day09%E9%9B%86%E5%90%8803/"},{"categories":["大三下实训笔记"],"content":"可变参数-Stream流","date":"2021-07-21","objectID":"/day10%E9%9B%86%E5%90%8804/","tags":[],"title":"Collection -04","uri":"/day10%E9%9B%86%E5%90%8804/"},{"categories":["大三下实训笔记"],"content":"1.可变参数 ","date":"2021-07-21","objectID":"/day10%E9%9B%86%E5%90%8804/:1:0","tags":[],"title":"Collection -04","uri":"/day10%E9%9B%86%E5%90%8804/"},{"categories":["大三下实训笔记"],"content":"1.1可变参数【应用】 可变参数介绍 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了 方法的参数类型已经确定,个数不确定,我们可以使用可变参数 可变参数定义格式 修饰符 返回值类型 方法名(数据类型… 变量名) { } 可变参数的注意事项 这里的变量其实是一个数组 如果一个方法有多个参数，包含可变参数，可变参数要放在最后 可变参数的基本使用 public class ArgsDemo01 { public static void main(String[] args) { System.out.println(sum(10, 20)); System.out.println(sum(10, 20, 30)); System.out.println(sum(10, 20, 30, 40)); System.out.println(sum(10,20,30,40,50)); System.out.println(sum(10,20,30,40,50,60)); System.out.println(sum(10,20,30,40,50,60,70)); System.out.println(sum(10,20,30,40,50,60,70,80,90,100)); } // public static int sum(int b,int... a) { // return 0; // } public static int sum(int... a) { int sum = 0; for(int i : a) { sum += i; } return sum; } } ","date":"2021-07-21","objectID":"/day10%E9%9B%86%E5%90%8804/:1:1","tags":[],"title":"Collection -04","uri":"/day10%E9%9B%86%E5%90%8804/"},{"categories":["大三下实训笔记"],"content":"1.2创建不可变集合【理解】 方法介绍 在List、Set、Map接口中,都存在of方法,可以创建一个不可变的集合 这个集合不能添加,不能删除,不能修改 但是可以结合集合的带参构造,实现集合的批量添加 在Map接口中,还有一个ofEntries方法可以提高代码的阅读性 首先会把键值对封装成一个Entry对象,再把这个Entry对象添加到集合当中 示例代码 public class MyVariableParameter4 { public static void main(String[] args) { // static \u003cE\u003e List\u003cE\u003e of(E…elements) 创建一个具有指定元素的List集合对象 //static \u003cE\u003e Set\u003cE\u003e of(E…elements) 创建一个具有指定元素的Set集合对象 //static \u003cK , V\u003e Map\u003cK，V\u003e of(E…elements) 创建一个具有指定元素的Map集合对象 //method1(); //method2(); //method3(); //method4(); } private static void method4() { Map\u003cString, String\u003e map = Map.ofEntries( Map.entry(\"zhangsan\", \"江苏\"), Map.entry(\"lisi\", \"北京\")); System.out.println(map); } private static void method3() { Map\u003cString, String\u003e map = Map.of(\"zhangsan\", \"江苏\", \"lisi\", \"北京\", \"wangwu\", \"天津\"); System.out.println(map); } private static void method2() { //传递的参数当中，不能存在重复的元素。 Set\u003cString\u003e set = Set.of(\"a\", \"b\", \"c\", \"d\",\"a\"); System.out.println(set); } private static void method1() { List\u003cString\u003e list = List.of(\"a\", \"b\", \"c\", \"d\"); System.out.println(list); //list.add(\"Q\"); //list.remove(\"a\"); //list.set(0,\"A\"); //System.out.println(list); // ArrayList\u003cString\u003e list2 = new ArrayList\u003c\u003e(); // list2.add(\"aaa\"); // list2.add(\"aaa\"); // list2.add(\"aaa\"); // list2.add(\"aaa\"); //集合的批量添加。 //首先是通过调用List.of方法来创建一个不可变的集合，of方法的形参就是一个可变参数。 //再创建一个ArrayList集合，并把这个不可变的集合中所有的数据，都添加到ArrayList中。 ArrayList\u003cString\u003e list3 = new ArrayList\u003c\u003e(List.of(\"a\", \"b\", \"c\", \"d\")); System.out.println(list3); } } ","date":"2021-07-21","objectID":"/day10%E9%9B%86%E5%90%8804/:1:2","tags":[],"title":"Collection -04","uri":"/day10%E9%9B%86%E5%90%8804/"},{"categories":["大三下实训笔记"],"content":"2.Stream流 ","date":"2021-07-21","objectID":"/day10%E9%9B%86%E5%90%8804/:2:0","tags":[],"title":"Collection -04","uri":"/day10%E9%9B%86%E5%90%8804/"},{"categories":["大三下实训笔记"],"content":"2.1体验Stream流【理解】 案例需求 按照下面的要求完成集合的创建和遍历 创建一个集合，存储多个字符串元素 把集合中所有以\"张\"开头的元素存储到一个新的集合 把\"张\"开头的集合中的长度为3的元素存储到一个新的集合 遍历上一步得到的集合 原始方式示例代码 public class MyStream1 { public static void main(String[] args) { //集合的批量添加 ArrayList\u003cString\u003e list1 = new ArrayList\u003c\u003e(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\")); //list.add() //遍历list1把以张开头的元素添加到list2中。 ArrayList\u003cString\u003e list2 = new ArrayList\u003c\u003e(); for (String s : list1) { if(s.startsWith(\"张\")){ list2.add(s); } } //遍历list2集合，把其中长度为3的元素，再添加到list3中。 ArrayList\u003cString\u003e list3 = new ArrayList\u003c\u003e(); for (String s : list2) { if(s.length() == 3){ list3.add(s); } } for (String s : list3) { System.out.println(s); } } } 使用Stream流示例代码 public class StreamDemo { public static void main(String[] args) { //集合的批量添加 ArrayList\u003cString\u003e list1 = new ArrayList\u003c\u003e(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\")); //Stream流 list1.stream().filter(s-\u003es.startsWith(\"张\")) .filter(s-\u003es.length() == 3) .forEach(s-\u003e System.out.println(s)); } } Stream流的好处 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印 Stream流把真正的函数式编程风格引入到Java中 代码简洁 ","date":"2021-07-21","objectID":"/day10%E9%9B%86%E5%90%8804/:2:1","tags":[],"title":"Collection -04","uri":"/day10%E9%9B%86%E5%90%8804/"},{"categories":["大三下实训笔记"],"content":"2.2Stream流的常见生成方式【应用】 Stream流的思想 Stream流的三类方法 获取Stream流 创建一条流水线,并把数据放到流水线上准备进行操作 中间方法 流水线上的操作 一次操作完毕之后,还可以继续进行其他操作 终结方法 一个Stream流只能有一个终结方法 是流水线上的最后一个操作 生成Stream流的方式 Collection体系集合 使用默认方法stream()生成流， default Stream stream() Map体系集合 把Map转成Set集合，间接的生成流 数组 通过Arrays中的静态方法stream生成流 同种数据类型的多个数据 通过Stream接口的静态方法of(T… values)生成流 代码演示 public class StreamDemo { public static void main(String[] args) { //Collection体系的集合可以使用默认方法stream()生成流 List\u003cString\u003e list = new ArrayList\u003cString\u003e(); Stream\u003cString\u003e listStream = list.stream(); Set\u003cString\u003e set = new HashSet\u003cString\u003e(); Stream\u003cString\u003e setStream = set.stream(); //Map体系的集合间接的生成流 Map\u003cString,Integer\u003e map = new HashMap\u003cString, Integer\u003e(); Stream\u003cString\u003e keyStream = map.keySet().stream(); Stream\u003cInteger\u003e valueStream = map.values().stream(); Stream\u003cMap.Entry\u003cString, Integer\u003e\u003e entryStream = map.entrySet().stream(); //数组可以通过Arrays中的静态方法stream生成流 String[] strArray = {\"hello\",\"world\",\"java\"}; Stream\u003cString\u003e strArrayStream = Arrays.stream(strArray); //同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流 Stream\u003cString\u003e strArrayStream2 = Stream.of(\"hello\", \"world\", \"java\"); Stream\u003cInteger\u003e intStream = Stream.of(10, 20, 30); } } ","date":"2021-07-21","objectID":"/day10%E9%9B%86%E5%90%8804/:2:2","tags":[],"title":"Collection -04","uri":"/day10%E9%9B%86%E5%90%8804/"},{"categories":["大三下实训笔记"],"content":"2.3Stream流中间操作方法【应用】 概念 中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作 常见方法 方法名 说明 Stream filter(Predicate predicate) 用于对流中的数据进行过滤 Stream limit(long maxSize) 返回此流中的元素组成的流，截取前指定参数个数的数据 Stream skip(long n) 跳过指定参数个数的数据，返回由该流的剩余元素组成的流 static Stream concat(Stream a, Stream b) 合并a和b两个流为一个流 Stream distinct() 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 filter代码演示 public class MyStream3 { public static void main(String[] args) { // Stream\u003cT\u003e filter(Predicate predicate)：过滤 // Predicate接口中的方法 boolean test(T t)：对给定的参数进行判断，返回一个布尔值 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"张三丰\"); list.add(\"张无忌\"); list.add(\"张翠山\"); list.add(\"王二麻子\"); list.add(\"张良\"); list.add(\"谢广坤\"); //filter方法获取流中的 每一个数据. //而test方法中的s,就依次表示流中的每一个数据. //我们只要在test方法中对s进行判断就可以了. //如果判断的结果为true,则当前的数据留下 //如果判断的结果为false,则当前数据就不要. // list.stream().filter( // new Predicate\u003cString\u003e() { // @Override // public boolean test(String s) { // boolean result = s.startsWith(\"张\"); // return result; // } // } // ).forEach(s-\u003e System.out.println(s)); //因为Predicate接口中只有一个抽象方法test //所以我们可以使用lambda表达式来简化 // list.stream().filter( // (String s)-\u003e{ // boolean result = s.startsWith(\"张\"); // return result; // } // ).forEach(s-\u003e System.out.println(s)); list.stream().filter(s -\u003es.startsWith(\"张\")).forEach(s-\u003e System.out.println(s)); } } limit\u0026skip代码演示 public class StreamDemo02 { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList\u003cString\u003e list = new ArrayList\u003cString\u003e(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：取前3个数据在控制台输出 list.stream().limit(3).forEach(s-\u003e System.out.println(s)); System.out.println(\"--------\"); //需求2：跳过3个元素，把剩下的元素在控制台输出 list.stream().skip(3).forEach(s-\u003e System.out.println(s)); System.out.println(\"--------\"); //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出 list.stream().skip(2).limit(2).forEach(s-\u003e System.out.println(s)); } } concat\u0026distinct代码演示 public class StreamDemo03 { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList\u003cString\u003e list = new ArrayList\u003cString\u003e(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：取前4个数据组成一个流 Stream\u003cString\u003e s1 = list.stream().limit(4); //需求2：跳过2个数据组成一个流 Stream\u003cString\u003e s2 = list.stream().skip(2); //需求3：合并需求1和需求2得到的流，并把结果在控制台输出 // Stream.concat(s1,s2).forEach(s-\u003e System.out.println(s)); //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复 Stream.concat(s1,s2).distinct().forEach(s-\u003e System.out.println(s)); } } ","date":"2021-07-21","objectID":"/day10%E9%9B%86%E5%90%8804/:2:3","tags":[],"title":"Collection -04","uri":"/day10%E9%9B%86%E5%90%8804/"},{"categories":["大三下实训笔记"],"content":"2.4Stream流终结操作方法【应用】 概念 终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作 常见方法 方法名 说明 void forEach(Consumer action) 对此流的每个元素执行操作 long count() 返回此流中的元素数 代码演示 public class MyStream5 { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"张三丰\"); list.add(\"张无忌\"); list.add(\"张翠山\"); list.add(\"王二麻子\"); list.add(\"张良\"); list.add(\"谢广坤\"); //method1(list); // long count()：返回此流中的元素数 long count = list.stream().count(); System.out.println(count); } private static void method1(ArrayList\u003cString\u003e list) { // void forEach(Consumer action)：对此流的每个元素执行操作 // Consumer接口中的方法void accept(T t)：对给定的参数执行此操作 //在forEach方法的底层,会循环获取到流中的每一个数据. //并循环调用accept方法,并把每一个数据传递给accept方法 //s就依次表示了流中的每一个数据. //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了. list.stream().forEach( new Consumer\u003cString\u003e() { @Override public void accept(String s) { System.out.println(s); } } ); System.out.println(\"====================\"); //lambda表达式的简化格式 //是因为Consumer接口中,只有一个accept方法 list.stream().forEach( (String s)-\u003e{ System.out.println(s); } ); System.out.println(\"====================\"); //lambda表达式还是可以进一步简化的. list.stream().forEach(s-\u003eSystem.out.println(s)); } } ","date":"2021-07-21","objectID":"/day10%E9%9B%86%E5%90%8804/:2:4","tags":[],"title":"Collection -04","uri":"/day10%E9%9B%86%E5%90%8804/"},{"categories":["大三下实训笔记"],"content":"2.5Stream流的收集操作【应用】 概念 对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中 常用方法 方法名 说明 R collect(Collector collector) 把结果收集到集合中 工具类Collectors提供了具体的收集方式 方法名 说明 public static Collector toList() 把元素收集到List集合中 public static Collector toSet() 把元素收集到Set集合中 public static Collector toMap(Function keyMapper,Function valueMapper) 把元素收集到Map集合中 代码演示 // toList和toSet方法演示 public class MyStream7 { public static void main(String[] args) { ArrayList\u003cInteger\u003e list1 = new ArrayList\u003c\u003e(); for (int i = 1; i \u003c= 10; i++) { list1.add(i); } list1.add(10); list1.add(10); list1.add(10); list1.add(10); list1.add(10); //filter负责过滤数据的. //collect负责收集数据. //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中. //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中. List\u003cInteger\u003e list = list1.stream().filter(number -\u003e number % 2 == 0) .collect(Collectors.toList()); System.out.println(list); Set\u003cInteger\u003e set = list1.stream().filter(number -\u003e number % 2 == 0) .collect(Collectors.toSet()); System.out.println(set); } } /** Stream流的收集方法 toMap方法演示 创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄 \"zhangsan,23\" \"lisi,24\" \"wangwu,25\" 保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值 */ public class MyStream8 { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zhangsan,23\"); list.add(\"lisi,24\"); list.add(\"wangwu,25\"); Map\u003cString, Integer\u003e map = list.stream().filter( s -\u003e { String[] split = s.split(\",\"); int age = Integer.parseInt(split[1]); return age \u003e= 24; } // collect方法只能获取到流中剩余的每一个数据. //在底层不能创建容器,也不能把数据添加到容器当中 //Collectors.toMap 创建一个map集合并将数据添加到集合当中 // s 依次表示流中的每一个数据 //第一个lambda表达式就是如何获取到Map中的键 //第二个lambda表达式就是如何获取Map中的值 ).collect(Collectors.toMap( s -\u003e s.split(\",\")[0], s -\u003e Integer.parseInt(s.split(\",\")[1]) )); System.out.println(map); } } ","date":"2021-07-21","objectID":"/day10%E9%9B%86%E5%90%8804/:2:5","tags":[],"title":"Collection -04","uri":"/day10%E9%9B%86%E5%90%8804/"},{"categories":["大三下实训笔记"],"content":"2.6Stream流综合练习【应用】 案例需求 现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作 男演员只要名字为3个字的前三人 女演员只要姓林的，并且不要第一个 把过滤后的男演员姓名和女演员姓名合并到一起 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据 演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法 代码实现 演员类 public class Actor { private String name; public Actor(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 测试类 public class StreamTest { public static void main(String[] args) { //创建集合 ArrayList\u003cString\u003e manList = new ArrayList\u003cString\u003e(); manList.add(\"周润发\"); manList.add(\"成龙\"); manList.add(\"刘德华\"); manList.add(\"吴京\"); manList.add(\"周星驰\"); manList.add(\"李连杰\"); ArrayList\u003cString\u003e womanList = new ArrayList\u003cString\u003e(); womanList.add(\"林心如\"); womanList.add(\"张曼玉\"); womanList.add(\"林青霞\"); womanList.add(\"柳岩\"); womanList.add(\"林志玲\"); womanList.add(\"王祖贤\"); //男演员只要名字为3个字的前三人 Stream\u003cString\u003e manStream = manList.stream().filter(s -\u003e s.length() == 3).limit(3); //女演员只要姓林的，并且不要第一个 Stream\u003cString\u003e womanStream = womanList.stream().filter(s -\u003e s.startsWith(\"林\")).skip(1); //把过滤后的男演员姓名和女演员姓名合并到一起 Stream\u003cString\u003e stream = Stream.concat(manStream, womanStream); // 将流中的数据封装成Actor对象之后打印 stream.forEach(name -\u003e { Actor actor = new Actor(name); System.out.println(actor); }); } } ","date":"2021-07-21","objectID":"/day10%E9%9B%86%E5%90%8804/:2:6","tags":[],"title":"Collection -04","uri":"/day10%E9%9B%86%E5%90%8804/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:0:0","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":"Java 208 道面试题 · Java Web ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:1:0","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":"64. jsp 和 servlet 有什么区别？ jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类） jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。 Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。 Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。 ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:1:1","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":"65. jsp 有哪些内置对象？作用分别是什么？ JSP有9个内置对象： request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Java程序中的this）； exception：封装页面抛出异常的对象。 ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:1:2","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":"66. 说一下 jsp 的 4 种作用域？ JSP中的四种作用域包括page、request、session和application，具体来说： page代表与一个页面相关的对象和属性。 request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。 session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。 application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。 ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:1:3","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":"67. session 和 cookie 有什么区别？ 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:1:4","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":"68. 说一下 session 的工作原理？ 其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。 ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:1:5","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":"69. 如果客户端禁止 cookie 能实现 session 还能用吗？ Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。 假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种： 设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“–enable-trans-sid”选项，让PHP自动跨页传递Session ID。 手动通过URL传值、隐藏表单传递Session ID。 用文件、数据库等形式保存Session ID，在跨页过程中手动调用。 ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:1:6","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":"70. spring mvc 和 struts 的区别是什么？ 拦截机制的不同 Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。 SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。 Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。 底层框架的不同 Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。 性能方面 Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。 配置方面 spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。 ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:1:7","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":"71. 如何避免 sql 注入？ PreparedStatement（简单又有效的方法） 使用正则表达式过滤传入的参数 字符串过滤 JSP中调用该函数检查是否包函非法字符 JSP页面判断代码 ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:1:8","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":"72. 什么是 XSS 攻击，如何避免？ XSS攻击又称CSS,全称Cross Site Script （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。 XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。 ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:1:9","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":"73. 什么是 CSRF 攻击，如何避免？ CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫跨站请求伪造。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。 如何避免： 1. 验证 HTTP Referer 字段 HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF 攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。 2. 使用验证码 关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。 3. 在请求地址中添加token并验证 CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 ，这样就把token以参数的形式加入请求了。 4. 在HTTP 头中自定义属性并验证 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 原文地址：https://blog.csdn.net/sufu1065/article/details/88051083 ","date":"2021-07-19","objectID":"/javaweb%E5%85%AD/:1:10","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/javaweb%E5%85%AD/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%E4%B8%80/:0:0","tags":[],"title":"Java基础 一","uri":"/%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%E4%B8%80/"},{"categories":["java面试"],"content":"Java基础 1.JDK 和 JRE 有什么区别？ JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。 2.== 和 equals 的区别是什么？ == 解读 对于基本类型和引用类型 == 的作用效果是不同的，如下所示： 基本类型：比较的是值是否相同； 引用类型：比较的是引用是否相同； 代码示例： `String x = \"string\"; String y = \"string\"; String z = new String(\"string\"); System.out.println(x==y); // true System.out.println(x==z); // false System.out.println(x.equals(y)); // true System.out.println(x.equals(z)); // true` 代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。 equals 解读 equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。 首先来看默认情况下 equals 比较一个有相同值的对象，代码如下： `class Cat { public Cat(String name) { this.name = name; } private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } Cat c1 = new Cat(\"王磊\"); Cat c2 = new Cat(\"王磊\"); System.out.println(c1.equals(c2)); // false` 输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下： `public boolean equals(Object obj) { return (this == obj); }` 原来 equals 本质上就是 ==。 那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下： `String s1 = new String(\"老王\"); String s2 = new String(\"老王\"); System.out.println(s1.equals(s2)); // true` 同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下： `public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; }` 原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。 总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。 3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？ 不对，两个对象的 hashCode()相同，equals()不一定 true。 代码示例： `String str1 = \"通话\"; String str2 = \"重地\"; System.out.println(String.format(\"str1：%d | str2：%d\", str1.hashCode(),str2.hashCode())); System.out.println(str1.equals(str2));` 执行的结果： str1：1179395 | str2：1179395 false 代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。 4.final 在 java 中有什么作用？ final 修饰的类叫最终类，该类不能被继承。 final 修饰的方法不能被重写。 final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。 5.java 中的 Math.round(-1.5) 等于多少？ 等于 -1。 6.String 属于基础的数据类型吗？ String 不属于基础类型，基础类型有 8 种：byte、boolean、char、short、int、float、long、double，而 String 属于对象。 7.java 中操作字符串都有哪些类？它们之间有什么区别？ 操作字符串的类有：String、StringBuffer、StringBuilder。 String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。 StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。 8.String str=“i\"与 String str=new String(“i”)一样吗？ 不一样，因为内存的分配方式不一样。String str=“i\"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。 9.如何将字符串反转？ 使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。 示例代码： `// StringBuffer reverse StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(\"abcdefg\"); System.out.println(stringBuffer.reverse()); // gfedcba // StringBuilder reverse StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"abcdefg\"); System.out.println(stringBuilder.reverse()); // gfedcba` 10.String 类的常用方法都有那些？ indexOf()：返回指定字符的索引。 charAt()：返回指定索引处的字符。 replace()：字符串替换。 trim()：去除字符串两端空白。 split()：分割字符串，返回一个分割后的字符串数组。 getBytes()：返回字符串的 byte 类型数组。 length()：返回字符串长度。 toLowerCase()：将字符串转成小写字母。 toUpperCase()：将字符串转成大写字符。 substring()：截取字符串。 equals()：字符串比较。 11.抽象类必须要有抽象方法吗？ 不需要，抽象类不一定非要有抽象方法。 示例代码： `abstract class Cat { public static void sayHi() { System.out.println(\"hi~\"); } }` 上面代码，抽象类并没有抽象方法但完全可","date":"2021-07-19","objectID":"/%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%E4%B8%80/:1:0","tags":[],"title":"Java基础 一","uri":"/%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%E4%B8%80/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E4%BA%94/:0:0","tags":["对象拷贝"],"title":"对象拷贝 五","uri":"/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E4%BA%94/"},{"categories":["java面试"],"content":"对象拷贝 ","date":"2021-07-19","objectID":"/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E4%BA%94/:1:0","tags":["对象拷贝"],"title":"对象拷贝 五","uri":"/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E4%BA%94/"},{"categories":["java面试"],"content":"61. 为什么要使用克隆？ 想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。 ","date":"2021-07-19","objectID":"/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E4%BA%94/:1:1","tags":["对象拷贝"],"title":"对象拷贝 五","uri":"/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E4%BA%94/"},{"categories":["java面试"],"content":"62. 如何实现对象克隆？ 有两种方式： 实现Cloneable接口并重写Object类中的clone()方法； 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下： `import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class MyUtil { private MyUtil() { throw new AssertionError(); } @SuppressWarnings(\"unchecked\") public static \u003cT extends Serializable\u003e T clone(T obj) throws Exception { ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 } }` 下面是测试代码： `import java.io.Serializable; /** * 人类 * @author nnngu * */ class Person implements Serializable { private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) { this.name = name; this.age = age; this.car = car; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Car getCar() { return car; } public void setCar(Car car) { this.car = car; } @Override public String toString() { return \"Person []\"; } }` `/** * 小汽车类 * @author nnngu * */ class Car implements Serializable { private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) { this.brand = brand; this.maxSpeed = maxSpeed; } public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public int getMaxSpeed() { return maxSpeed; } public void setMaxSpeed(int maxSpeed) { this.maxSpeed = maxSpeed; } @Override public String toString() { return \"Car [brand=\" + brand + \", maxSpeed=\" + maxSpeed + \"]\"; } }` `class CloneTest { public static void main(String[] args) { try { Person p1 = new Person(\"郭靖\", 33, new Car(\"Benz\", 300)); Person p2 = MyUtil.clone(p1); // 深度克隆 p2.getCar().setBrand(\"BYD\"); // 修改克隆的Person对象p2关联的汽车对象的品牌属性 // 原来的Person对象p1关联的汽车不会受到任何影响 // 因为在克隆Person对象时其关联的汽车对象也被克隆了 System.out.println(p1); } catch (Exception e) { e.printStackTrace(); } } }` 注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时。 ","date":"2021-07-19","objectID":"/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E4%BA%94/:1:2","tags":["对象拷贝"],"title":"对象拷贝 五","uri":"/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E4%BA%94/"},{"categories":["java面试"],"content":"63. 深拷贝和浅拷贝区别是什么？ 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()） 深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型） 转载自：https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA ","date":"2021-07-19","objectID":"/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E4%BA%94/:1:3","tags":["对象拷贝"],"title":"对象拷贝 五","uri":"/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%E4%BA%94/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:0:0","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"Java 208 道面试题 · 多线程 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:0","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"35. 并行和并发有什么区别？ 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。 在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:1","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"36. 线程和进程的区别？ 简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:2","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"37. 守护线程是什么？ 守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:3","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"38. 创建线程有哪几种方式？ ①. 继承Thread类创建线程类 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 创建Thread子类的实例，即创建了线程对象。 调用线程对象的start()方法来启动该线程。 public class ThreadTest extends Thread { public static void main(String[] args){ new Thread(){ @Override public void run() { System.out.println(\"重写Thread类run方法\"); } }.start(); new ThreadTest().start(); } @Override public void run() { super.run(); System.out.println(\"执行thread01线程\"); } } 执行thread01线程 重写Thread类run方法 Process finished with exit code 0 ②. 通过Runnable接口创建线程类 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动该线程。 public class RunnableTest implements Runnable { public static void main(String[] args){ new Thread(new RunnableTest()).start(); } @Override public void run() { System.out.println(\"这是一个Callable接口的具体实现类，没有有返回值哦\"); } } ③. 通过Callable和Future创建线程 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。 public class CallableAndFuture implements Callable { @Override public Object call() throws Exception { return \"通过CallAble和Future创建线程\"; } public static void main(String[] args) throws ExecutionException, InterruptedException { Callable c1=new CallableAndFuture(); FutureTask futureTask=new FutureTask(c1); Thread thread=new Thread(futureTask); thread.start(); System.out.println(futureTask.get()); } } ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:4","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"39. 说一下 runnable 和 callable 有什么区别？ 有点深的问题了，也看出一个Java程序员学习知识的广度。 Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已； Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:5","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"40. 线程有哪些状态？ 线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。 创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。 就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。 死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:6","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"41. sleep() 和 wait() 有什么区别？ sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。 wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:7","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"42. notify()和 notifyAll()有什么区别？ 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:8","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"43. 线程的 run()和 start()有什么区别？ 每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。 start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。 run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:9","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"44. 创建线程池有哪几种方式？ ①. newFixedThreadPool(int nThreads) 创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。 ②. newCachedThreadPool() 创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。 ③. newSingleThreadExecutor() 这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。 ④. newScheduledThreadPool(int corePoolSize) 创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:10","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"45. 线程池都有哪些状态？ 线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。 线程池各个状态切换框架图： 详细解释见:Java多线程线程池（4）–线程池的五种状态 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:11","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"46. 线程池中 submit()和 execute()方法有什么区别？ 接收的参数不一样 submit有返回值，而execute没有 submit方便Exception处理 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:12","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"47. 在 java 程序中怎么保证多线程的运行安全？ 线程安全在三个方面体现： 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）； 可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）； 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:13","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"48. 多线程锁的升级原理是什么？ 在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。 锁升级的图示过程： 锁共有4种状态详解: 【Java多线程策略 一】锁的三种状态切换 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:14","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"49. 什么是死锁？ 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:15","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"50. 怎么防止死锁？ 死锁的四个必要条件： 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放 环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。 所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。 此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:16","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"51. ThreadLocal 是什么？有哪些使用场景？ 线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:17","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"52.说一下 synchronized 底层实现原理？ synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。 Java中每一个对象都可以作为锁，这是synchronized实现同步的基础： 普通同步方法，锁是当前实例对象 静态同步方法，锁是当前类的class对象 同步方法块，锁是括号里面的对象 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:18","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"53. synchronized 和 volatile 的区别是什么？ volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:19","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"54. synchronized 和3 Lock 有什么区别？ 首先synchronized是java内置关键字，在jvm层面，Lock是个java类； synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁； synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）； Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:20","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"55. synchronized 和 ReentrantLock 区别是什么？ synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：  ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁  ReentrantLock可以获取各种锁的信息 ReentrantLock可以灵活地实现多路通知  另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:21","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":"56. 说一下 atomic 的原理？ Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。 Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。 原文地址:https://blog.csdn.net/sufu1065/article/details/88051083 ","date":"2021-07-19","objectID":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/:1:22","tags":["多线程"],"title":"多线程 三","uri":"/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/:0:0","tags":["反射"],"title":"反射 四","uri":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/"},{"categories":["java面试"],"content":"Java 208 道面试题 · 反射 ","date":"2021-07-19","objectID":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/:1:0","tags":["反射"],"title":"反射 四","uri":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/"},{"categories":["java面试"],"content":"57. 什么是反射？ 反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力 Java反射： 在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法 Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类。 在运行时构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。  ","date":"2021-07-19","objectID":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/:1:1","tags":["反射"],"title":"反射 四","uri":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/"},{"categories":["java面试"],"content":"58. 什么是 java 序列化？什么情况下需要序列化？ 简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 什么情况下需要序列化： a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候； b）当你想用套接字在网络上传送对象的时候； c）当你想通过RMI传输对象的时候； ","date":"2021-07-19","objectID":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/:1:2","tags":["反射"],"title":"反射 四","uri":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/"},{"categories":["java面试"],"content":"59. 动态代理是什么？有哪些应用？ 动态代理： 当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。 动代理的应用： Spring的AOP 加事务 加权限 加日志 ","date":"2021-07-19","objectID":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/:1:3","tags":["反射"],"title":"反射 四","uri":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/"},{"categories":["java面试"],"content":"60. 怎么实现动态代理？ 首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。 原文地址：https://blog.csdn.net/sufu1065/article/details/88051083 ","date":"2021-07-19","objectID":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/:1:4","tags":["反射"],"title":"反射 四","uri":"/%E5%8F%8D%E5%B0%84%E5%9B%9B/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:0:0","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"Java 208 道面试题 · 容器 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:0","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"18. java 容器都有哪些？ 常用容器的图录： ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:1","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"19. Collection 和 Collections 有什么区别？ java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。 Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:2","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"20. List、Set、Map 之间的区别是什么？ ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:3","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"21. HashMap 和 Hashtable 有什么区别？ hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。 hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。 hashMap允许空键值，而hashTable不允许。 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:4","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"22. 如何决定使用 HashMap 还是 TreeMap？ 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:5","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"23. 说一下 HashMap 的实现原理？ HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。 需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn) ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:6","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"24. 说一下 HashSet 的实现原理？ HashSet底层由HashMap实现 HashSet的值存放于HashMap的key上 HashMap的value统一为PRESENT ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:7","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"25. ArrayList 和 LinkedList 的区别是什么？ 最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:8","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"26. 如何实现数组和 List 之间的转换？ List转换成为数组：调用ArrayList的toArray方法。 数组转换成为List：调用Arrays的asList方法。 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:9","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"27. ArrayList 和 Vector 的区别是什么？ Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。  ArrayList比Vector快，它因为有同步，不会过载。  ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:10","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"28. Array 和 ArrayList 有何区别？ Array可以容纳基本类型和对象，而ArrayList只能容纳对象。  Array是指定大小后不可变的，而ArrayList大小是可变的。  Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:11","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"29. 在 Queue 中 poll()和 remove()有什么区别？ poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:12","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"30. 哪些集合类是线程安全的？ vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。 statck：堆栈类，先进后出。 hashtable：就比hashmap多了个线程安全。 enumeration：枚举，相当于迭代器。 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:13","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"31. 迭代器 Iterator 是什么？ 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:14","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"32. Iterator 怎么使用？有什么特点？ Java中的Iterator功能比较简单，并且只能单向移动： (1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。 (2) 使用next()获得序列中的下一个元素。 (3) 使用hasNext()检查序列中是否还有元素。 (4) 使用remove()将迭代器新返回的元素删除。　Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:15","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["java面试"],"content":"33. Iterator 和 ListIterator 有什么区别？ Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。  Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。  ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 原文地址：https://blog.csdn.net/sufu1065/article/details/88051083 ","date":"2021-07-19","objectID":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/:1:16","tags":["java容器"],"title":"容器 二","uri":"/%E5%AE%B9%E5%99%A8%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"字符流-转换流-对象操作流-Properties集合","date":"2021-07-19","objectID":"/io%E6%B5%8102/","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"1.字符流 ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:1:0","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"1.1为什么会出现字符流【理解】 字符流的介绍 由于字节流操作中文不是特别的方便，所以Java就提供字符流 字符流 = 字节流 + 编码表 中文的字节存储方式 用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？ 汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数 ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:1:1","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"1.2编码表【理解】 什么是字符集 是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等 常见的字符集 ASCII字符集： lASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) 基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 GBXXX字符集： GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等 Unicode字符集： UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码 编码规则： 128个US-ASCII字符，只需一个字节编码 拉丁文等字符，需要二个字节编码 大部分常用字（含中文），使用三个字节编码 其他极少使用的Unicode辅助字符，使用四字节编码 ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:1:2","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"1.3字符串中的编码解码问题【应用】 相关方法 方法名 说明 byte[] getBytes() 使用平台的默认字符集将该 String编码为一系列字节 byte[] getBytes(String charsetName) 使用指定的字符集将该 String编码为一系列字节 String(byte[] bytes) 使用平台的默认字符集解码指定的字节数组来创建字符串 String(byte[] bytes, String charsetName) 通过指定的字符集解码指定的字节数组来创建字符串 代码演示 public class StringDemo { public static void main(String[] args) throws UnsupportedEncodingException { //定义一个字符串 String s = \"中国\"; //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67] //byte[] bys = s.getBytes(\"UTF-8\"); //[-28, -72, -83, -27, -101, -67] byte[] bys = s.getBytes(\"GBK\"); //[-42, -48, -71, -6] System.out.println(Arrays.toString(bys)); //String ss = new String(bys); //String ss = new String(bys,\"UTF-8\"); String ss = new String(bys,\"GBK\"); System.out.println(ss); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:1:3","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"1.4字符流写数据【应用】 介绍 Writer: 用于写入字符流的抽象父类 FileWriter: 用于写入字符流的常用子类 构造方法 方法名 说明 FileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象 FileWriter(File file, boolean append) 根据给定的 File 对象构造一个 FileWriter 对象 FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象 FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象 成员方法 方法名 说明 void write(int c) 写一个字符 void write(char[] cbuf) 写入一个字符数组 void write(char[] cbuf, int off, int len) 写入字符数组的一部分 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分 刷新和关闭的方法 方法名 说明 flush() 刷新流，之后还可以继续写数据 close() 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 代码演示 public class OutputStreamWriterDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(\"myCharStream\\\\a.txt\"); //void write(int c)：写一个字符 // fw.write(97); // fw.write(98); // fw.write(99); //void writ(char[] cbuf)：写入一个字符数组 char[] chs = {'a', 'b', 'c', 'd', 'e'}; // fw.write(chs); //void write(char[] cbuf, int off, int len)：写入字符数组的一部分 // fw.write(chs, 0, chs.length); // fw.write(chs, 1, 3); //void write(String str)：写一个字符串 // fw.write(\"abcde\"); //void write(String str, int off, int len)：写一个字符串的一部分 // fw.write(\"abcde\", 0, \"abcde\".length()); fw.write(\"abcde\", 1, 3); //释放资源 fw.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:1:4","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"1.5字符流读数据【应用】 介绍 Reader: 用于读取字符流的抽象父类 FileReader: 用于读取字符流的常用子类 构造方法 方法名 说明 FileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader 成员方法 方法名 说明 int read() 一次读一个字符数据 int read(char[] cbuf) 一次读一个字符数组数据 代码演示 public class InputStreamReaderDemo { public static void main(String[] args) throws IOException { FileReader fr = new FileReader(\"myCharStream\\\\b.txt\"); //int read()：一次读一个字符数据 // int ch; // while ((ch=fr.read())!=-1) { // System.out.print((char)ch); // } //int read(char[] cbuf)：一次读一个字符数组数据 char[] chs = new char[1024]; int len; while ((len = fr.read(chs)) != -1) { System.out.print(new String(chs, 0, len)); } //释放资源 fr.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:1:5","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"1.6字符流用户注册案例【应用】 案例需求 将键盘录入的用户名和密码保存到本地实现永久化存储 实现步骤 获取用户输入的用户名和密码 将用户输入的用户名和密码写入到本地文件中 关流,释放资源 代码实现 public class CharStreamDemo8 { public static void main(String[] args) throws IOException { //需求: 将键盘录入的用户名和密码保存到本地实现永久化存储 //要求：用户名独占一行，密码独占一行 //分析： //1，实现键盘录入，把用户名和密码录入进来 Scanner sc = new Scanner(System.in); System.out.println(\"请录入用户名\"); String username = sc.next(); System.out.println(\"请录入密码\"); String password = sc.next(); //2.分别把用户名和密码写到本地文件。 FileWriter fw = new FileWriter(\"charstream\\\\a.txt\"); //将用户名和密码写到文件中 fw.write(username); //表示写出一个回车换行符 windows \\r\\n MacOS \\r Linux \\n fw.write(\"\\r\\n\"); fw.write(password); //刷新流 fw.flush(); //3.关流,释放资源 fw.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:1:6","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"1.7字符缓冲流【应用】 字符缓冲流介绍 BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途 BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途 构造方法 方法名 说明 BufferedWriter(Writer out) 创建字符缓冲输出流对象 BufferedReader(Reader in) 创建字符缓冲输入流对象 代码演示 public class BufferedStreamDemo01 { public static void main(String[] args) throws IOException { //BufferedWriter(Writer out) BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); bw.write(\"hello\\r\\n\"); bw.write(\"world\\r\\n\"); bw.close(); //BufferedReader(Reader in) BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); //一次读取一个字符数据 // int ch; // while ((ch=br.read())!=-1) { // System.out.print((char)ch); // } //一次读取一个字符数组数据 char[] chs = new char[1024]; int len; while ((len=br.read(chs))!=-1) { System.out.print(new String(chs,0,len)); } br.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:1:7","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"1.8字符缓冲流特有功能【应用】 方法介绍 BufferedWriter： 方法名 说明 void newLine() 写一行行分隔符，行分隔符字符串由系统属性定义 BufferedReader: 方法名 说明 String readLine() 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null 代码演示 public class BufferedStreamDemo02 { public static void main(String[] args) throws IOException { //创建字符缓冲输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); //写数据 for (int i = 0; i \u003c 10; i++) { bw.write(\"hello\" + i); //bw.write(\"\\r\\n\"); bw.newLine(); bw.flush(); } //释放资源 bw.close(); //创建字符缓冲输入流 BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); String line; while ((line=br.readLine())!=null) { System.out.println(line); } br.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:1:8","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"1.9字符缓冲流操作文件中数据排序案例【应用】 案例需求 使用字符缓冲流读取文件中的数据，排序后再次写到本地文件 实现步骤 将文件中的数据读取到程序中 对读取到的数据进行处理 将处理后的数据添加到集合中 对集合中的数据进行排序 将排序后的集合中的数据写入到文件中 代码实现 public class CharStreamDemo14 { public static void main(String[] args) throws IOException { //需求：读取文件中的数据，排序后再次写到本地文件 //分析： //1.要把文件中的数据读取进来。 BufferedReader br = new BufferedReader(new FileReader(\"charstream\\\\sort.txt\")); //输出流一定不能写在这里，因为会清空文件中的内容 //BufferedWriter bw = new BufferedWriter(new FileWriter(\"charstream\\\\sort.txt\")); String line = br.readLine(); System.out.println(\"读取到的数据为\" + line); br.close(); //2.按照空格进行切割 String[] split = line.split(\" \");//9 1 2 5 3 10 4 6 7 8 //3.把字符串类型的数组变成int类型 int [] arr = new int[split.length]; //遍历split数组，可以进行类型转换。 for (int i = 0; i \u003c split.length; i++) { String smallStr = split[i]; //类型转换 int number = Integer.parseInt(smallStr); //把转换后的结果存入到arr中 arr[i] = number; } //4.排序 Arrays.sort(arr); System.out.println(Arrays.toString(arr)); //5.把排序之后结果写回到本地 1 2 3 4... BufferedWriter bw = new BufferedWriter(new FileWriter(\"charstream\\\\sort.txt\")); //写出 for (int i = 0; i \u003c arr.length; i++) { bw.write(arr[i] + \" \"); bw.flush(); } //释放资源 bw.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:1:9","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"1.10IO流小结【理解】 IO流小结 ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:1:10","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"2.转换流 ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:2:0","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"2.1字符流中和编码解码问题相关的两个类【理解】 InputStreamReader：是从字节流到字符流的桥梁,父类是Reader ​ 它读取字节，并使用指定的编码将其解码为字符 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 OutputStreamWriter：是从字符流到字节流的桥梁,父类是Writer ​ 是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:2:1","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"2.2转换流读写数据【应用】 构造方法 方法名 说明 InputStreamReader(InputStream in) 使用默认字符编码创建InputStreamReader对象 InputStreamReader(InputStream in,String chatset) 使用指定的字符编码创建InputStreamReader对象 OutputStreamWriter(OutputStream out) 使用默认字符编码创建OutputStreamWriter对象 OutputStreamWriter(OutputStream out,String charset) 使用指定的字符编码创建OutputStreamWriter对象 代码演示 public class ConversionStreamDemo { public static void main(String[] args) throws IOException { //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\")); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); osw.write(\"中国\"); osw.close(); //InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\")); InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); //一次读取一个字符数据 int ch; while ((ch=isr.read())!=-1) { System.out.print((char)ch); } isr.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:2:2","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"3.对象操作流 ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:3:0","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"3.1对象序列化流【应用】 对象序列化介绍 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化 对象序列化流： ObjectOutputStream 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 构造方法 方法名 说明 ObjectOutputStream(OutputStream out) 创建一个写入指定的OutputStream的ObjectOutputStream 序列化对象的方法 方法名 说明 void writeObject(Object obj) 将指定的对象写入ObjectOutputStream 示例代码 学生类 public class Student implements Serializable { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class ObjectOutputStreamDemo { public static void main(String[] args) throws IOException { //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); //创建对象 Student s = new Student(\"佟丽娅\",30); //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream oos.writeObject(s); //释放资源 oos.close(); } } 注意事项 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口 Serializable是一个标记接口，实现该接口，不需要重写任何方法 ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:3:1","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"3.2对象反序列化流【应用】 对象反序列化流： ObjectInputStream ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象 构造方法 方法名 说明 ObjectInputStream(InputStream in) 创建从指定的InputStream读取的ObjectInputStream 反序列化对象的方法 方法名 说明 Object readObject() 从ObjectInputStream读取一个对象 示例代码 public class ObjectInputStreamDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); //Object readObject()：从ObjectInputStream读取一个对象 Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:3:2","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"3.3serialVersionUID\u0026transient【应用】 serialVersionUID 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？ 会出问题，会抛出InvalidClassException异常 如果出问题了，如何解决呢？ 重新序列化 给对象所属的类加一个serialVersionUID private static final long serialVersionUID = 42L; transient 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？ 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程 示例代码 学生类 public class Student implements Serializable { private static final long serialVersionUID = 42L; private String name; // private int age; private transient int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } // @Override // public String toString() { // return \"Student{\" + // \"name='\" + name + '\\'' + // \", age=\" + age + // '}'; // } } 测试类 public class ObjectStreamDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { // write(); read(); } //反序列化 private static void read() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); } //序列化 private static void write() throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); Student s = new Student(\"佟丽娅\", 30); oos.writeObject(s); oos.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:3:3","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"3.4对象操作流练习【应用】 案例需求 创建多个学生类对象写到文件中,再次读取到内存中 实现步骤 创建序列化流对象 创建多个学生对象 将学生对象添加到集合中 将集合对象序列化到文件中 创建反序列化流对象 将文件中的对象数据,读取到内存中 代码实现 学生类 public class Student implements Serializable{ private static final long serialVersionUID = 2L; private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 测试类 public class Demo03 { /** * read(): * 读取到文件末尾返回值是 -1 * readLine(): * 读取到文件的末尾返回值 null * readObject(): * 读取到文件的末尾 直接抛出异常 * 如果要序列化的对象有多个,不建议直接将多个对象序列化到文件中,因为反序列化时容易出异常 * 建议: 将要序列化的多个对象存储到集合中,然后将集合序列化到文件中 */ public static void main(String[] args) throws Exception { /*// 序列化 //1.创建序列化流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myCode\\\\oos.txt\")); ArrayList\u003cStudent\u003e arrayList = new ArrayList\u003c\u003e(); //2.创建多个学生对象 Student s = new Student(\"佟丽娅\",30); Student s01 = new Student(\"佟丽娅\",30); //3.将学生对象添加到集合中 arrayList.add(s); arrayList.add(s01); //4.将集合对象序列化到文件中 oos.writeObject(arrayList); oos.close();*/ // 反序列化 //5.创建反序列化流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myCode\\\\oos.txt\")); //6.将文件中的对象数据,读取到内存中 Object obj = ois.readObject(); ArrayList\u003cStudent\u003e arrayList = (ArrayList\u003cStudent\u003e)obj; ois.close(); for (Student s : arrayList) { System.out.println(s.getName() + \",\" + s.getAge()); } } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:3:4","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"4.Properties集合 ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:4:0","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"4.1Properties作为Map集合的使用【应用】 Properties介绍 是一个Map体系的集合类 Properties可以保存到流中或从流中加载 属性列表中的每个键及其对应的值都是一个字符串 Properties基本使用 public class PropertiesDemo01 { public static void main(String[] args) { //创建集合对象 // Properties\u003cString,String\u003e prop = new Properties\u003cString,String\u003e(); //错误 Properties prop = new Properties(); //存储元素 prop.put(\"itheima001\", \"佟丽娅\"); prop.put(\"itheima002\", \"赵丽颖\"); prop.put(\"itheima003\", \"刘诗诗\"); //遍历集合 Set\u003cObject\u003e keySet = prop.keySet(); for (Object key : keySet) { Object value = prop.get(key); System.out.println(key + \",\" + value); } } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:4:1","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"4.2Properties作为Map集合的特有方法【应用】 特有方法 方法名 说明 Object setProperty(String key, String value) 设置集合的键和值，都是String类型，底层调用 Hashtable方法 put String getProperty(String key) 使用此属性列表中指定的键搜索属性 Set stringPropertyNames() 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 示例代码 public class PropertiesDemo02 { public static void main(String[] args) { //创建集合对象 Properties prop = new Properties(); //Object setProperty(String key, String value)：设置集合的键和值，都是String类型 prop.setProperty(\"itheima001\", \"佟丽娅\"); prop.setProperty(\"itheima002\", \"赵丽颖\"); prop.setProperty(\"itheima003\", \"刘诗诗\"); //String getProperty(String key)：使用此属性列表中指定的键搜索属性 // System.out.println(prop.getProperty(\"itheima001\")); // System.out.println(prop.getProperty(\"itheima0011\")); // System.out.println(prop); //Set\u003cString\u003e stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 Set\u003cString\u003e names = prop.stringPropertyNames(); for (String key : names) { // System.out.println(key); String value = prop.getProperty(key); System.out.println(key + \",\" + value); } } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:4:2","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"4.3Properties和IO流相结合的方法【应用】 和IO流结合的方法 方法名 说明 void load(Reader reader) 从输入字符流读取属性列表（键和元素对） void store(Writer writer, String comments) 将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 示例代码 public class PropertiesDemo03 { public static void main(String[] args) throws IOException { //把集合中的数据保存到文件 // myStore(); //把文件中的数据加载到集合 myLoad(); } private static void myLoad() throws IOException { Properties prop = new Properties(); //void load(Reader reader)： FileReader fr = new FileReader(\"myOtherStream\\\\fw.txt\"); prop.load(fr); fr.close(); System.out.println(prop); } private static void myStore() throws IOException { Properties prop = new Properties(); prop.setProperty(\"itheima001\",\"佟丽娅\"); prop.setProperty(\"itheima002\",\"赵丽颖\"); prop.setProperty(\"itheima003\",\"刘诗诗\"); //void store(Writer writer, String comments)： FileWriter fw = new FileWriter(\"myOtherStream\\\\fw.txt\"); prop.store(fw,null); fw.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:4:3","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"4.4Properties集合练习【应用】 案例需求 在Properties文件中手动写上姓名和年龄,读取到集合中,将该数据封装成学生对象,写到本地文件 实现步骤 创建Properties集合,将本地文件中的数据加载到集合中 获取集合中的键值对数据,封装到学生对象中 创建序列化流对象,将学生对象序列化到本地文件中 代码实现 学生类 public class Student implements Serializable { private static final long serialVersionUID = 1L; private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class Test { public static void main(String[] args) throws IOException { //1.创建Properties集合,将本地文件中的数据加载到集合中 Properties prop = new Properties(); FileReader fr = new FileReader(\"prop.properties\"); prop.load(fr); fr.close(); //2.获取集合中的键值对数据,封装到学生对象中 String name = prop.getProperty(\"name\"); int age = Integer.parseInt(prop.getProperty(\"age\")); Student s = new Student(name,age); //3.创建序列化流对象,将学生对象序列化到本地文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"a.txt\")); oos.writeObject(s); oos.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8102/:4:4","tags":[],"title":"File \u0026 IO 二","uri":"/io%E6%B5%8102/"},{"categories":["大三下实训笔记"],"content":"Servlet使用","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"Servlet 0.学习目标 理解servlet的执行过程 掌握servlet的3种实现方式 理解servlet的生命周期方法 理解servletContext域的使用/学生管理系统的保存的功能 1 Servlet ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:0:0","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"1.1 Servlet概述 Servlet是SUN公司提供的一套规范，名称就叫Servlet规范，它也是JavaEE规范之一。我们可以像学习Java基础一样，通过API来学习Servlet。这里需要注意的是，在我们之前JDK的API中是没有Servlet规范的相关内容，需要使用JavaEE的API。目前在Oracle官网中的最新版本是JavaEE8，该网址中介绍了JavaEE8的一些新特性。当然，我们可以通过访问官方API，学习和查阅里面的内容。 打开官方API网址，在左上部分找到javax.servlet包，在左下部分找到Servlet，如下图显示： 通过阅读API，我们得到如下信息： 第一：Servlet是一个运行在web服务端的java小程序 第二：它可以用于接收和响应客户端的请求 第三：要想实现Servlet功能，可以实现Servlet接口，继承GenericServlet或者HttpServlet 第四：每次请求都会执行service方法 第五：Servlet还支持配置 具体请看下图： ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:1:0","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"1.2 Servlet入门 ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:2:0","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"1.2.1 Servlet编码步骤 1）编码步骤 第一步：前期准备-创建JavaWeb工程 第二步：编写一个普通类继承GenericServlet并重写service方法 第三步：在web.xml配置Servlet 2）测试 在Tomcat中部署项目 在浏览器访问Servlet ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:2:1","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"1.2.2 Servlet执行过程分析 我们通过浏览器发送请求，请求首先到达Tomcat服务器，由服务器解析请求URL，然后在部署的应用列表中找到我们的应用。接下来，在我们的应用中找应用里的web.xml配置文件，在web.xml中找到FirstServlet的配置，找到后执行service方法，最后由FirstServlet响应客户浏览器。整个过程如下图所示： 一句话总结执行过程： 浏览器——\u003eTomcat服务器——\u003e我们的应用——\u003e应用中的web.xml——\u003eFirstServlet——\u003e响应浏览器 ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:2:2","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"1.2.3 Servlet类视图 在《Tomcat和Http协议》这天课程和刚才的入门案例中，我们都定义了自己的Servlet，实现的方式都是选择继承GenericServlet，在Servlet的API介绍中，它提出了我们除了继承GenericServlet外还可以继承HttpServlet，通过查阅servlet的类视图，我们看到GenericServlet还有一个子类HttpServlet。同时，在service方法中还有参数ServletRequest和ServletResponse，它们的关系如下图所示： ![image-20210623095137664](/Users/jianwei/Library/Application Support/typora-user-images/image-20210623095137664.png) ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:2:3","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"1.2.4 Servlet编写方式 1）编写方式说明 我们在实现Servlet功能时，可以选择以下三种方式： 第一种：实现Servlet接口，接口中的方法必须全部实现。 ​ 使用此种方式，表示接口中的所有方法在需求方面都有重写的必要。此种方式支持最大程度的自定义。 第二种：继承GenericServlet，service方法必须重写，其他方可根据需求，选择性重写。 ​ 使用此种方式，表示只在接收和响应客户端请求这方面有重写的需求，而其他方法可根据实际需求选择性重写，使我们的开发Servlet变得简单。但是，此种方式是和HTTP协议无关的。 第三种：继承HttpServlet，它是javax.servlet.http包下的一个抽象类，是GenericServlet的子类。如果我们选择继承HttpServlet时，只需要重写doGet和doPost方法，不要覆盖service方法。 ​ 使用此种方式，表示我们的请求和响应需要和HTTP协议相关。也就是说，我们是通过HTTP协议来访问的。那么每次请求和响应都符合HTTP协议的规范。请求的方式就是HTTP协议所支持的方式（目前我们只知道GET和POST，而实际HTTP协议支持7种请求方式，GET POST PUT DELETE TRACE OPTIONS HEAD )。 2）HttpServlet的使用细节 第一步：在入门案例的工程中创建一个Servlet继承HttpServlet 注意：不要重写任何方法，如下图所示： 第二步：部署项目并测试访问 当我们在地址栏输入ServletDemo2的访问URL时，出现了访问错误，状态码是405。提示信息是：方法不允许。 第三步：分析原因 得出HttpServlet的使用结论： ​ 我们继承了HttpServlet，需要重写里面的doGet和doPost方法来接收get方式和post方式的请求。 为了实现代码的可重用性，我们只需要在doGet或者doPost方法中一个里面提供具体功能即可，而另外的那个方法只需要调用提供了功能的方法。 查看类的所有实现方法：commond+7 查看类的继承体系：control+H 【小结： servlet 实现的三种方式 * servlet 实现的三种方式： * 1. 实现servlet接口 * 2. 继承 GenericServlet * 3. 继承 HttpServlet (和前面区别： 是一个带有http协议的servlet) ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:2:4","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"1.3 Servlet使用细节 ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:3:0","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"1.3.1 Servlet的生命周期(掌握) 对象的生命周期，就是对象从生到死的过程，即：出生——活着——死亡。用更偏向 于开发的官方说法就是对象创建到销毁的过程。 出生：请求第一次到达Servlet时，对象就创建出来，并且初始化成功。只出生一次，就放到内存中。 活着：服务器提供服务的整个过程中，该对象一直存在，每次只是执行service方法。 死亡：当服务停止时，或者服务器宕机时，对象消亡。 通过分析Servlet的生命周期我们发现，它的实例化和初始化只会在请求第一次到达Servlet时执行，而销毁只会在Tomcat服务器停止时执行，由此我们得出一个结论，Servlet对象只会创建一次，销毁一次。所以，Servlet对象只有一个实例。如果一个对象实例在应用中是唯一的存在，那么我们就说它是单实例的，即运用了单例模式。 【小结: servlet的接口定义了5个方法： 其中常用： service : 客户端发起的每次请求当前servlet都会访问到service方法！ （访问N次，执行N次） —\u003e 用于处理业务（处理用户的每次请求） 生命周期方法： init: 初始化 （只执行1次： 对象创建时） –\u003e 我们可以用来加载资源 destroy： 销毁 （只执行1次： 服务器关闭对象销毁时） –\u003e 我们可以释放资源，然后再销毁 ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:3:1","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"1.3.2 Servlet的线程安全 由于Servlet运用了单例模式，即整个应用中只有一个实例对象，所以我们需要分析这个唯一的实例中的类成员是否线程安全。接下来，我们来看下面的的示例： /** * 演示Servlet的线程安全问题： * 示例需求： * 用两个浏览器模拟两条线程，携带一个username参数。 * @author 黑马程序员 * @Company http://www.itheima.com */ public class Servlet05 extends HttpServlet { private String username; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { synchronized (this){ username = req.getParameter(\"username\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } PrintWriter writer = resp.getWriter(); writer.print(\"username is：\"+username); writer.close(); } } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req,resp); } } 通过上面的测试我们发现，在Servlet中定义了类成员之后，多个浏览器都会共享类成员的数据。其实每一个浏览器端发送请求，就代表是一个线程，那么多个浏览器就是多个线程，所以测试的结果说明了多个线程会共享Servlet类成员中的数据，其中任何一个线程修改了数据，都会影响其他线程。因此，我们可以认为Servlet它不是线程安全的。 分析产生这个问题的根本原因，其实就是因为Servlet是单例，单例对象的类成员只会随类实例化时初始化一次，之后的操作都是改变，而不会重新初始化。 解决这个问题也非常简单，就是在Servlet中定义类成员要慎重。如果类成员是共用的，并且只会在初始化时赋值，其余时间都是获取的话，那么是没问题。如果类成员并非共用，或者每次使用都有可能对其赋值，那么就要考虑线程安全问题了，把它定义到doGet或者doPost方法里面去就可以了。 【小结：】 如何避免servlet线程安全问题？ * --servlet其实是单例的！ * 如果是单例对象， 是否存在数据安全问题？(线程安全问题？) * * 如何避免线程安全问题？ * a. 不要在单例对象中，定义成员变量 --- 推荐 * b. 加上锁机制（同步代码代码块） --- 不建议的！ 【补充】： ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:3:2","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"1. 关于单例模式： 什么是单例： 在程序运行过程中，不管获取或者访问该对象多少次，最终都是只创建一个对象； ​ 我们今天使用的servlet就是单例模式的！（默认是懒汉） 什么是多例: 每次访问该对象，都是一个全新的对象，都是新初始化的一个！ （以前用的 new User()）; 单例实现的两种方式： ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:3:3","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"2.单例线程不安全，那么我们为什么还要使用？— 如何避免线程问题？ 我们的servlet等这些单例对象其实，线程都是存在安全问题的！ –\u003e如何避免！ 我们虽然可以通过上锁来解决，但是我们为了性能，不会上锁！ 所以，需要强调开发规范： ​ 在单例对象中，要谨慎使用成员变量！ 如果是没有必要， 建议不要使用； ​ 只要在成员位置没有变量，那么单例模式数据也是安全的！ 为什么servlet被设计成单例呢？ ​ 为了性能！ ","date":"2021-07-19","objectID":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/:3:4","tags":[],"title":"Servlet","uri":"/servlet%E7%9A%84%E5%89%AF%E6%9C%AC/"},{"categories":["大三下实训笔记"],"content":"File类-字节流InputStream-字节缓冲流lBufferOutputStream","date":"2021-07-19","objectID":"/io%E6%B5%8101/","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"1.File类 ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:1:0","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"1.1File类概述和构造方法【应用】 File类介绍 它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的 对于File而言,其封装的并不是一个真正存在的文件,仅仅是一个路径名而已.它可以是存在的,也可以是不存在的.将来是要通过具体的操作把这个路径的内容转换为具体存在的 File类的构造方法 方法名 说明 File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例 File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例 示例代码 public class FileDemo01 { public static void main(String[] args) { //File(String pathname): 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1); //File(String parent, String child): 从父路径名字符串和子路径名字符串创建新的 File实例 File f2 = new File(\"E:\\\\itcast\",\"java.txt\"); System.out.println(f2); //File(File parent, String child): 从父抽象路径名和子路径名字符串创建新的 File实例 File f3 = new File(\"E:\\\\itcast\"); File f4 = new File(f3,\"java.txt\"); System.out.println(f4); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:1:1","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"1.2绝对路径和相对路径【理解】 绝对路径 是一个完整的路径,从盘符开始 相对路径 是一个简化的路径,相对当前项目下的路径 示例代码 public class FileDemo02 { public static void main(String[] args) { // 是一个完整的路径,从盘符开始 File file1 = new File(\"D:\\\\itheima\\\\a.txt\"); // 是一个简化的路径,从当前项目根目录开始 File file2 = new File(\"a.txt\"); File file3 = new File(\"模块名\\\\a.txt\"); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:1:2","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"1.3File类创建功能【应用】 方法分类 方法名 说明 public boolean createNewFile() 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 public boolean mkdir() 创建由此抽象路径名命名的目录 public boolean mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录 示例代码 public class FileDemo02 { public static void main(String[] args) throws IOException { //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1.createNewFile()); System.out.println(\"--------\"); //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE File f2 = new File(\"E:\\\\itcast\\\\JavaSE\"); System.out.println(f2.mkdir()); System.out.println(\"--------\"); //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML File f3 = new File(\"E:\\\\itcast\\\\JavaWEB\\\\HTML\"); // System.out.println(f3.mkdir()); System.out.println(f3.mkdirs()); System.out.println(\"--------\"); //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt File f4 = new File(\"E:\\\\itcast\\\\javase.txt\"); // System.out.println(f4.mkdir()); System.out.println(f4.createNewFile()); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:1:3","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"1.4File类删除功能【应用】 方法分类 方法名 说明 public boolean delete() 删除由此抽象路径名表示的文件或目录 示例代码 public class FileDemo03 { public static void main(String[] args) throws IOException { // File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); //需求1：在当前模块目录下创建java.txt文件 File f1 = new File(\"myFile\\\\java.txt\"); // System.out.println(f1.createNewFile()); //需求2：删除当前模块目录下的java.txt文件 System.out.println(f1.delete()); System.out.println(\"--------\"); //需求3：在当前模块目录下创建itcast目录 File f2 = new File(\"myFile\\\\itcast\"); // System.out.println(f2.mkdir()); //需求4：删除当前模块目录下的itcast目录 System.out.println(f2.delete()); System.out.println(\"--------\"); //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt File f3 = new File(\"myFile\\\\itcast\"); // System.out.println(f3.mkdir()); File f4 = new File(\"myFile\\\\itcast\\\\java.txt\"); // System.out.println(f4.createNewFile()); //需求6：删除当前模块下的目录itcast System.out.println(f4.delete()); System.out.println(f3.delete()); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:1:4","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"1.5File类判断和获取功能【应用】 判断功能 方法名 说明 public boolean isDirectory() 测试此抽象路径名表示的File是否为目录 public boolean isFile() 测试此抽象路径名表示的File是否为文件 public boolean exists() 测试此抽象路径名表示的File是否存在 获取功能 方法名 说明 public String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串 public String getPath() 将此抽象路径名转换为路径名字符串 public String getName() 返回由此抽象路径名表示的文件或目录的名称 public File[] listFiles() 返回此抽象路径名表示的目录中的文件和目录的File对象数组 示例代码 public class FileDemo04 { public static void main(String[] args) { //创建一个File对象 File f = new File(\"myFile\\\\java.txt\"); // public boolean isDirectory()：测试此抽象路径名表示的File是否为目录 // public boolean isFile()：测试此抽象路径名表示的File是否为文件 // public boolean exists()：测试此抽象路径名表示的File是否存在 System.out.println(f.isDirectory()); System.out.println(f.isFile()); System.out.println(f.exists()); // public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串 // public String getPath()：将此抽象路径名转换为路径名字符串 // public String getName()：返回由此抽象路径名表示的文件或目录的名称 System.out.println(f.getAbsolutePath()); System.out.println(f.getPath()); System.out.println(f.getName()); System.out.println(\"--------\"); // public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组 File f2 = new File(\"E:\\\\itcast\"); File[] fileArray = f2.listFiles(); for(File file : fileArray) { // System.out.println(file); // System.out.println(file.getName()); if(file.isFile()) { System.out.println(file.getName()); } } } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:1:5","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"1.6File类练习一【应用】 案例需求 在当前模块下的aaa文件夹中创建一个a.txt文件 实现步骤 创建File对象,指向aaa文件夹 判断aaa文件夹是否存在,如果不存在则创建 创建File对象,指向aaa文件夹下的a.txt文件 创建这个文件 代码实现 public class Test1 { public static void main(String[] args) throws IOException { //练习一：在当前模块下的aaa文件夹中创建一个a.txt文件 /* File file = new File(\"filemodule\\\\aaa\\\\a.txt\"); file.createNewFile();*/ //注意点:文件所在的文件夹必须要存在. //1.创建File对象,指向aaa文件夹 File file = new File(\"filemodule\\\\aaa\"); //2.判断aaa文件夹是否存在,如果不存在则创建 if(!file.exists()){ //如果文件夹不存在,就创建出来 file.mkdirs(); } //3.创建File对象,指向aaa文件夹下的a.txt文件 File newFile = new File(file,\"a.txt\"); //4.创建这个文件 newFile.createNewFile(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:1:6","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"1.7File类练习二【应用】 案例需求 删除一个多级文件夹 实现步骤 定义一个方法,接收一个File对象 遍历这个File对象,获取它下边的每个文件和文件夹对象 判断当前遍历到的File对象是文件还是文件夹 如果是文件,直接删除 如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 代码实现 public class Test2 { public static void main(String[] args) { //练习二：删除一个多级文件夹 //delete方法 //只能删除文件和空文件夹. //如果现在要删除一个有内容的文件夹? //先删掉这个文件夹里面所有的内容. //最后再删除这个文件夹 File src = new File(\"C:\\\\Users\\\\apple\\\\Desktop\\\\src\"); deleteDir(src); } //1.定义一个方法,接收一个File对象 private static void deleteDir(File src) { //先删掉这个文件夹里面所有的内容. //递归 方法在方法体中自己调用自己. //注意: 可以解决所有文件夹和递归相结合的题目 //2.遍历这个File对象,获取它下边的每个文件和文件夹对象 File[] files = src.listFiles(); //3.判断当前遍历到的File对象是文件还是文件夹 for (File file : files) { //4.如果是文件,直接删除 if(file.isFile()){ file.delete(); }else{ //5.如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 deleteDir(file);//参数一定要是src文件夹里面的文件夹File对象 } } //6.参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 src.delete(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:1:7","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"1.8File类练习三【应用】 案例需求 统计一个文件夹中每种文件的个数并打印 打印格式如下： txt:3个 doc:4个 jpg:6个 … 实现步骤 定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 遍历File对象,获取它下边的每一个文件和文件夹对象 判断当前File对象是文件还是文件夹 如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 没出现过,将这种类型文件的后缀名存入集合中,次数存1 出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象 代码实现 public class Test3 { public static void main(String[] args) { //统计一个文件夹中,每种文件出现的次数. //统计 --- 定义一个变量用来统计. ---- 弊端:同时只能统计一种文件 //利用map集合进行数据统计,键 --- 文件后缀名 值 ---- 次数 File file = new File(\"filemodule\"); HashMap\u003cString, Integer\u003e hm = new HashMap\u003c\u003e(); getCount(hm, file); System.out.println(hm); } //1.定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 private static void getCount(HashMap\u003cString, Integer\u003e hm, File file) { //2.遍历File对象,获取它下边的每一个文件和文件夹对象 File[] files = file.listFiles(); for (File f : files) { //3.判断当前File对象是文件还是文件夹 if(f.isFile()){ //如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 String fileName = f.getName(); String[] fileNameArr = fileName.split(\"\\\\.\"); if(fileNameArr.length == 2){ String fileEndName = fileNameArr[1]; if(hm.containsKey(fileEndName)){ //出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 Integer count = hm.get(fileEndName); //这种文件又出现了一次. count++; //把已经出现的次数给覆盖掉. hm.put(fileEndName,count); }else{ // 没出现过,将这种类型文件的后缀名存入集合中,次数存1 hm.put(fileEndName,1); } } }else{ //如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象代码实现 getCount(hm,f); } } } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:1:8","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"2.字节流 ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:2:0","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"2.1 IO流概述和分类【理解】 IO流介绍 IO：输入/输出(Input/Output) 流：是一种抽象概念,是对数据传输的总称.也就是说数据在设备间的传输称为流,流的本质是数据传输 IO流就是用来处理设备间数据传输问题的.常见的应用: 文件复制; 文件上传; 文件下载 IO流的分类 按照数据的流向 输入流：读数据 输出流：写数据 按照数据类型来分 字节流 字节输入流 字节输出流 字符流 字符输入流 字符输出流 IO流的使用场景 如果操作的是纯文本文件,优先使用字符流 如果操作的是图片、视频、音频等二进制文件,优先使用字节流 如果不确定文件类型,优先使用字节流.字节流是万能的流 ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:2:1","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"2.2字节流写数据【应用】 字节流抽象基类 InputStream：这个抽象类是表示字节输入流的所有类的超类 OutputStream：这个抽象类是表示字节输出流的所有类的超类 子类名特点：子类名称都是以其父类名作为子类名的后缀 字节输出流 FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 使用字节输出流写数据的步骤 创建字节输出流对象(调用系统功能创建了文件,创建字节输出流对象,让字节输出流对象指向文件) 调用字节输出流对象的写数据方法 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源) 示例代码 public class FileOutputStreamDemo01 { public static void main(String[] args) throws IOException { //创建字节输出流对象 /* 注意点: 1.如果文件不存在,会帮我们创建 2.如果文件存在,会把文件清空 */ //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //void write(int b)：将指定的字节写入此文件输出流 fos.write(97); // fos.write(57); // fos.write(55); //最后都要释放资源 //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。 fos.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:2:2","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"2.3字节流写数据的三种方式【应用】 写数据的方法分类 方法名 说明 void write(int b) 将指定的字节写入此文件输出流 一次写一个字节数据 void write(byte[] b) 将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据 void write(byte[] b, int off, int len) 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一次写一个字节数组的部分数据 示例代码 public class FileOutputStreamDemo02 { public static void main(String[] args) throws IOException { //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件 // FileOutputStream fos = new FileOutputStream(new File(\"myByteStream\\\\fos.txt\")); //void write(int b)：将指定的字节写入此文件输出流 // fos.write(97); // fos.write(98); // fos.write(99); // fos.write(100); // fos.write(101); // void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流 // byte[] bys = {97, 98, 99, 100, 101}; //byte[] getBytes()：返回字符串对应的字节数组 byte[] bys = \"abcde\".getBytes(); // fos.write(bys); //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 // fos.write(bys,0,bys.length); fos.write(bys,1,3); //释放资源 fos.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:2:3","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"2.4字节流写数据的两个小问题【应用】 字节流写数据如何实现换行 windows:\\r\\n linux:\\n mac:\\r 字节流写数据如何实现追加写入 public FileOutputStream(String name,boolean append) 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头 示例代码 public class FileOutputStreamDemo03 { public static void main(String[] args) throws IOException { //创建字节输出流对象 // FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\",true); //写数据 for (int i = 0; i \u003c 10; i++) { fos.write(\"hello\".getBytes()); fos.write(\"\\r\\n\".getBytes()); } //释放资源 fos.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:2:4","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"2.5字节流写数据加异常处理【应用】 异常处理格式 try-catch-finally try{ 可能出现异常的代码; }catch(异常类名 变量名){ 异常的处理代码; }finally{ 执行所有清除操作; } finally特点 被finally控制的语句一定会执行，除非JVM退出 示例代码 public class FileOutputStreamDemo04 { public static void main(String[] args) { //加入finally来实现释放资源 FileOutputStream fos = null; try { fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); fos.write(\"hello\".getBytes()); } catch (IOException e) { e.printStackTrace(); } finally { if(fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:2:5","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"2.6字节流读数据(一次读一个字节数据)【应用】 字节输入流 FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream,该文件由文件系统中的路径名name命名 字节输入流读取数据的步骤 创建字节输入流对象 调用字节输入流对象的读数据方法 释放资源 示例代码 public class FileInputStreamDemo01 { public static void main(String[] args) throws IOException { //创建字节输入流对象 //FileInputStream(String name) FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); int by; /* fis.read()：读数据 by=fis.read()：把读取到的数据赋值给by by != -1：判断读取到的数据是否是-1 */ while ((by=fis.read())!=-1) { System.out.print((char)by); } //释放资源 fis.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:2:6","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"2.7字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt” (文件可以是任意文件) 实现步骤 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地) 数据源： ​ E:\\itcast\\窗里窗外.txt — 读数据 — InputStream — FileInputStream 目的地： ​ myByteStream\\窗里窗外.txt — 写数据 — OutputStream — FileOutputStream 代码实现 public class CopyTxtDemo { public static void main(String[] args) throws IOException { //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\窗里窗外.txt\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\窗里窗外.txt\"); //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节) int by; while ((by=fis.read())!=-1) { fos.write(by); } //释放资源 fos.close(); fis.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:2:7","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"2.8字节流读数据(一次读一个字节数组数据)【应用】 一次读一个字节数组的方法 public int read(byte[] b)：从输入流读取最多b.length个字节的数据 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数 示例代码 public class FileInputStreamDemo02 { public static void main(String[] args) throws IOException { //创建字节输入流对象 FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); byte[] bys = new byte[1024]; //1024及其整数倍 int len; //循环读取 while ((len=fis.read(bys))!=-1) { System.out.print(new String(bys,0,len)); } //释放资源 fis.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:2:8","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"2.9字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\mn.jpg”复制到模块目录下的“mn.jpg” (文件可以是任意文件去) 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) 释放资源 代码实现 public class CopyJpgDemo { public static void main(String[] args) throws IOException { //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\mn.jpg\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\mn.jpg\"); //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) byte[] bys = new byte[1024]; int len; while ((len=fis.read(bys))!=-1) { fos.write(bys,0,len); } //释放资源 fos.close(); fis.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:2:9","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"3.字节缓冲流 ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:3:0","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"3.1字节缓冲流构造方法【应用】 字节缓冲流介绍 lBufferOutputStream：该类实现缓冲输出流.通过设置这样的输出流,应用程序可以向底层输出流写入字节,而不必为写入的每个字节导致底层系统的调用 lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组.当从流中读取或跳过字节时,内部缓冲区将根据需要从所包含的输入流中重新填充,一次很多字节 构造方法： 方法名 说明 BufferedOutputStream(OutputStream out) 创建字节缓冲输出流对象 BufferedInputStream(InputStream in) 创建字节缓冲输入流对象 示例代码 public class BufferStreamDemo { public static void main(String[] args) throws IOException { //字节缓冲输出流：BufferedOutputStream(OutputStream out) BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\bos.txt\")); //写数据 bos.write(\"hello\\r\\n\".getBytes()); bos.write(\"world\\r\\n\".getBytes()); //释放资源 bos.close(); //字节缓冲输入流：BufferedInputStream(InputStream in) BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"myByteStream\\\\bos.txt\")); //一次读取一个字节数据 // int by; // while ((by=bis.read())!=-1) { // System.out.print((char)by); // } //一次读取一个字节数组数据 byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) { System.out.print(new String(bys,0,len)); } //释放资源 bis.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:3:1","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"3.2字节缓冲流复制视频【应用】 案例需求 把“E:\\itcast\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi” 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制视频 释放资源 代码实现 public class CopyAviDemo { public static void main(String[] args) throws IOException { //复制视频 // method1(); method2(); } //字节缓冲流一次读写一个字节数组 public static void method2() throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) { bos.write(bys,0,len); } bos.close(); bis.close(); } //字节缓冲流一次读写一个字节 public static void method1() throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); int by; while ((by=bis.read())!=-1) { bos.write(by); } bos.close(); bis.close(); } } ","date":"2021-07-19","objectID":"/io%E6%B5%8101/:3:2","tags":[],"title":"File \u0026 IO 一","uri":"/io%E6%B5%8101/"},{"categories":["大三下实训笔记"],"content":"Tomcat服务器使用与常用网络知识","date":"2021-07-17","objectID":"/tomcat-http-3-2/","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"Tomcat\u0026Http （web服务器-重要） 0.今日学习目标： 能够理解cs架构和bs架构的区别 能够安装tomcat 能够启动tomcat 能够在idea中集成tomcat，并访问到web项目 能够知晓常见状态码及其含义 1 企业开发简介 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:0:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"1.1 JavaEE规范 JavaEE规范是J2EE规范的新名称，早期被称为J2EE规范，其全称是Java 2 Platform Enterprise Edition，它是由SUN公司领导、各厂家共同制定并得到广泛认可的工业标准（JCP组织成员）。之所以改名为JavaEE，目的还是让大家清楚J2EE只是Java企业应用。在2004年底中国软件技术大会Ioc微容器(也就是Jdon框架的实现原理)演讲中指出：我们需要一个跨J2SE/WEB/EJB的微容器，保护我们的业务核心组件，以延续它的生命力，而不是依赖J2SE/J2EE版本.此次J2EE改名为Java EE，实际也反映出业界这种共同心声。 JavaEE规范是很多Java开发技术的总称。这些技术规范都是沿用自J2EE的。一共包括了13个技术规范。例如：jsp/servlet，jndi，jaxp，jdbc，jni，jaxb，jmf，jta，jpa，EJB等。 其中，JCP组织的全称是Java Community Process。它是一个开放的国际组织，主要由Java开发者以及被授权者组成，职能是发展和更新。成立于1998年。官网是：JCP JavaEE的版本是延续了J2EE的版本，但是没有继续采用其命名规则。J2EE的版本从1.0开始到1.4结束，而JavaEE版本是从JavaEE 5版本开始，目前最主流的版本是JavaEE 8。 详情请参考：JavaEE8规范概览 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:1:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"1.2 Web概述 Web在英文中的含义是网状物，网络。在计算机领域，它通常指的是后者，即网络。像我们前面接触的WWW，它是由3个单词组成的，即：World Wide Web ，中文含义是万维网。而我们前面学的HTML，CSS和JS的参考文档《W3School全套教程》中的W3C就是万维网联盟。他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为网站。我们通过输入网站的地址（即：网址），就可以访问网站中提供的资源。在网上我们能访问到的内容全是资源（不区分局域网还是广域网）。只不过，不同类型的资源展示的效果不一样。 首先，我们先来介绍资源的分类，它分为静态资源和动态资源。其中： 静态资源指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的html,css,js,图片，多媒体等等都可以称为静态资源。 动态资源它指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在12306上购买火车票，火车票的余票数由于时间的变化，会逐渐的减少，直到最后没有余票。还有，我们在CSDN上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的JSP，servlet，php，ASP等都是动态资源。 关于广域网和局域网的划分，广域网指的就是万维网，也就是我们说的互联网。局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:2:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"小结： web资源： 静态资源： html / css /js / img图片.... 动态资源： jsp 、 servlet （每次请求都会经过服务器，不同的用户查看到的数据可能是不一样的） 端游 ： 客户端 页游： 不用下载（浏览器） ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:2:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"1.3 系统结构 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:3:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"1.3.1 系统结构简介 在我们前面课程的学习中，开发的都是Java工程。这些工程在企业中称之为项目或者产品。项目也好，产品也罢，它是有系统架构的，系统架构的划分有很多种方式。我们今天讨论的是基础结构上的划分。除此之外，还有技术选型划分，部署方式划分等等。 ==基础结构划分：C/S架构，B/S架构两类。== 技术选型划分：Model1模型，Model2模型，MVC模型和三层架构+MVC模型。 部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。 一体化架构是将应用各层（表示层、业务逻辑层、数据访问、应用集成逻辑）打成一个包来部署。 垂直拆分是将同样的系统按照**应用场景(调用方)**进行拆分 。比如支付模块分为商家支付和用户支付 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:3:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"1.3.2 C/S结构 它指的是客户端——服务器的方式。其中C代表着Client，S代表着服务器。C/S结构的系统设计图如下： ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:3:2","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"1.3.3 B/S结构 它指的是浏览器——服务器的方式。其中B代表着Browser，S代表着服务器。B/S结构的系统设计图如下： ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:3:3","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"1.3.4 两种结构的区别及优略 两种结构的区别 第一：硬件环境不同，C/S通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端。而B/S是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。 第二：C/S结构比B/S结构更安全，因为用户群相对固定，对信息的保护更强。 第三：B/S结构维护升级比较简单，而C/S结构维护升级相对困难。 优略 1 C/S：是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。 2 B/S：总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软件就能 实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。 关于课程中结构的选择 我们的课程中涉及的系统结构都是是基于B/S结构。 2 Tomcat ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:3:4","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.1 Tomcat介绍 tomcat是一个免费的开源的 web应用服务器 的 软件！ IOE： ​ ibm – 服务器硬件 ​ oracle – 数据库 ​ emc — 存储 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:4:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.1.1 关于服务器 服务器的概念非常的广泛，它可以指代一台特殊的计算机（相比普通计算机运行更快、负载更高、价格更贵），也可以指代用于部署网站的应用。我们这里说的服务器，其实是web服务器，或者应用服务器。它本质就是一个软件，一个应用。作用就是发布我们的应用（工程），让用户可以通过浏览器访问我们的应用。 常见的应用服务器，请看下表： 服务器名称 说明 weblogic 实现了javaEE规范，重量级服务器，又称为javaEE容器（oracle） websphere 实现了javaEE规范，重量级服务器。（ibm） JBOSS 实现了JavaEE规范，重量级服务器。免费的。 ==Tomcat== 实现了jsp/servlet规范，是一个==轻量级服务器，开源免费。== ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:4:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.1.2 Tomcat下载与安装 Tomcat官网下载地址 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:4:2","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.1.3 Tomcat各版本所需支持 JDK8 + tomcat9 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:4:3","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.1.4 Tomcat目录结构详解 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:4:4","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"小结：（记住） ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:4:5","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.2 Tomcat基本使用 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:5:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.2.1 Tomcat启动和停止及问题分析解决（理解） 1）启动和停止 Tomcat服务器的启动文件在二进制文件目录中：，这两个文件就是Tomcat的启动文件。 Tomcat服务器的停止文件也在二进制文件目录中：，这两个文件就是Tomcat的停止文件。 其中.bat文件是针对windows系统的运行程序，.sh文件是针对linux系统的运行程序。 2）启动问题 第一个问题：启动一闪而过 原因：没有配置JDK环境变量。 解决办法：配置上JAVA_HOME环境变量 第二个：Address already in use : JVM_Bind 原因：端口被占用 解决办法：找到占用该端口的应用 ​ 进程不重要：使用cmd命令：netstat -a -o 查看pid 在任务管理器中结束占用端口的进程。 ​ 进程很重要：修改自己的端口号。修改的是Tomcat目录下\\conf\\server.xml中的配置。 ​ 第三个：启动产生很多异常，但能正常启动 原因：Tomcat中部署着很多项目，每次启动这些项目都会启动。而这些项目中有启动报异常的。 解决办法： ​ 能找到报异常的项目，就把它从发布目录中移除。 ​ 不能确定报异常的项目，就重新解压一个新的Tomcat。 第四个：其它问题 例如：启动产生异常，但是不能正常启动。此时就需要解压一个新的Tomcat启动，来确定是系统问题，还是Tomcat的问题。 所以，此时就需要具体问题，具体分析，然后再对症解决。 如果是中文乱码： 可以改配置文件中的字符集：gbk (可以不配置) ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:5:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.2.2 IDEA集成Tomcat服务器（重要） 第一步 第二步 第三步 第四步 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:5:2","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.2.3 Linux系统安装Tomcat（课下了解） 第一步：下载tomcat 参考**2.1.2小节的《Tomcat下载与安装》**进入Tomcat官网，找到对应版本点击download进入下载页面，如下图： 第二步：上传到linux 在crt上 使用 alt+p 将windows上的软件拖进去即可(root目录) 第三步：在 /usr/local 新建一个文件夹tomcat mkdir /usr/local/tomcat 第四步：移动 tomcat…tar.gz 到 /usr/local/tomcat mv apache-tomcat-8.5.32.tar.gz /usr/local/tomcat/ 第五步：进入/usr/local/tomcat目录,解压Tomcat cd /usr/local/tomcat tar -xvf apache-tomcat-8.5.32.tar.gz 第六步：进入 /usr/local/tomcat/apache-tomcat-8.5.32/bin cd /usr/local/tomcat/apache-tomcat-8.5.32/bin 第七步：启动tomcat 方式1: sh startup.sh 方式2: ./startup.sh **第八步：修改防火墙的规则 ** 方式1:service iptables stop 关闭防火墙(不建议); 用到哪一个端口号就放行哪一个(80,8080,3306...) 方式2:放行8080 端口 修改配置文件 cd /etc/sysconfig vi iptables 复制(yy , p) -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT 改成 -A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 重启加载防火墙或者重启防火墙 service iptables reload 或者 service iptables restart ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:5:3","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.3 Tomcat发布应用-JavaWeb应用 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:6:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.3.1 JavaWeb工程概述 JavaWeb应用是一个全新的应用种类。这类应用程序指供浏览器访问的程序，通常也简称为web应用。 一个web应用由多个静态web资源和动态web资源组成，例如：html、css、js文件，jsp文件、java程序、支持jar包、工程配置文件、图片、音视频等等。 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给Web服务器管理（Tomcat就是Web服务器之一），这个过程称之为虚似目录的映射。 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:6:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.3.2 JavaWeb应用目录结构详解 myapp--------------应用名称 1.html css/css.css js/demo.js WEB-INF--------如果有web.xml或者.class文件时，该目录必须存在，且严格区分大小写。 --------该目录下的资源，客户端是无法直接访问的。 --------目录中内容如下： classes目录----------------web应用的class文件（加载顺序：我们的class，lib目录中的jar包，tomcat的lib目录中的jar包。优先级依次降低） lib目录--------------------web应用所需的jar包（tomcat的lib目录下jar为所有应用共享） web.xml-------------------web应用的主配置文件 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:6:2","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.3.3 JavaWeb应用的创建 第一步 第二步 第三步 第四步 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:6:3","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.3.4 JavaWeb应用的部署 1）IDEA部署 第一步 第二步 第三步 2）war包发布(暂时不用，以后使用maven) 第一步：使用jar -cvf war 包的名称 当前目录中哪些资源要打入war 第二步：把打好的war拷贝到tomcat的webapps目录中 第三步：启动服务时，tomcat会自动解压。 tomcat的webapps目录的作用： ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:6:4","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.4 tomcat配置： ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:7:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.4.1 Tomcat配置虚拟目录 (目前了解) 虚拟目录的配置，支持两种方式。第一种是通过在主配置文件中添加标签实现。第二种是通过写一个独立配置文件实现。 第一种方式：在server.xml的\u003cHost\u003e元素中加一个\u003cContext path=\"\" docBase=\"\"/\u003e元素。 ​ path：访问资源URI。URI名称可以随便起，但是必须在前面加上一个/ ​ docBase：资源所在的磁盘物理地址。 第二种方式：是写一个独立的xml文件，该文件名可以随便起。在文件内写一个\u003cContext/\u003e元素。 ​ 该文件要放在Tomcat目录中的conf\\Catalina\\localhost\\目录下。 需要注意的是，在使用了独立的配置文件之后，访问资源URI就变成了/+文件的名称。而Context的path属性就失效了。 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:7:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"2.4.2 Tomcat默认项配置 配置默认端口 Tomcat的默认端口是8080。 http：的默认端口 80 ， 80是可以省略！ 配置方式如下： \u003cConnector port=\"80\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /\u003e 配置默认应用 有两种方式配置默认应用。 第一种：把要作为默认应用的应用，名称改为ROOT。放到webapps目录中。 第二种：写一个独立的配置文件，文件名称为ROOT.xml。 ​ 注意：ROOT必须大写。当使用了独立的ROOT.xml文件时，webapps下ROOT应用就不是默认应用了。 3 HTTP协议 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:7:2","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.1 HTTP协议概述 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:8:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.1.1 HTTP协议概念 HTTP的全称是：Hyper Text Transfer Protocol，意为 超文本传输协议。它指的是服务器和客户端之间交互必须遵循的一问一答的规则。形容这个规则：问答机制、握手机制。 ==HTTP==规范了==请求==和==响应==内容的类型和格式。 HTTP协议是由W3C组织管理和维护的。 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:8:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.1.2 HTTP协议版本 目前HTTP协议主要是1.0版本和1.1版本。这两个版本的区别主要是两个方面。 第一：HTTP1.1版本比1.0版本多了一些消息头。 第二：HTTP1.1版本和1.0版本的执行过程不一样。执行过程如下： 创建连接（TCP/IP） 创建连接（TCP/IP） HTTP1.0 HTTP1.1 发送请求 发送请求1 得到响应 得到响应1 关闭连接 发送请求2 创建连接（TCP/IP） 得到响应2 发送请求 ……. 得到响应 ……. 关闭连接 连接超时或手动关闭连接 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:8:2","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.1.3 HTTP协议相关说明 HTTP协议概念是客户浏览器和服务器一种一问一答的规则，那么必须要有问有答，而且要先问后答。 但是我们使用\u003cscript\u003e,\u003clink\u003e和\u003cimg\u003e标签，没有手动发起请求，但是仍然能从服务器端拿到数据，原因就是：在浏览器遇到\u003cscript\u003e,\u003clink\u003e,\u003cimg\u003e标签时会自动发出请求。 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:8:3","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.2 HTTP协议组成 由HTTP协议的概念可知，它分为问和答两部分。其中问指的就是请求部分，而答指的就是响应部分。 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:9:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.2.1请求部分 请求行： 永远位于请求的第一行 请求消息头： 从第二行开始，到第一个空行结束 请求的正文： 从第一个空行后开始，到正文的结束 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:9:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.2.2 响应部分 响应行： 永远位于响应的第一行 响应消息头： 从第二行开始，到第一个空行结束 响应的正文： 从第一个空行后开始，到正文的结束 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:9:2","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.3.3 消息头的共性分析 消息头名称首字母大写，多个单词每个单词的首字母都大写。 多个单词用-分隔 名称和值之间用冒号加空格分隔 多个值之间用逗号加空格分隔 两个头之间用回车分隔 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:9:3","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.3 请求部分详解 （后面花一天讲解） ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:10:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.3.1 请求行详解 请求行：GET /myapp/2.html HTTP/1.1 内容 说明 GET 请求的方式。（还有POST） /myapp/2.html 请求的资源。 HTTP/1.1 使用的协议，及协议的版本。 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:10:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.3.2 请求消息头详解 内容 说明 Accept 告知服务器，客户浏览器所支持的MIME类型。 Accept-Encoding 告知服务器，客户浏览器所支持的压缩编码格式。最常用的就是gzip压缩。 Accept-Language 告知服务器，客户浏览器所支持的语言。一般都是zh_CN或en_US等。 Referer 告知服务器，当前请求的来源。只有当前请求有来源的时候，才有这个消息头。从地址栏输入的没有来源。作用：1 投放广告 2 防盗链 Content-Type 告知服务器，请求正文的MIME类型。 Content-Length 告知服务器，请求正文的长度。 User-Agent 浏览器相关信息 Connection: Keep-Alive 连接的状态：保持连接 If-Modified-Since 告知服务器，客户浏览器缓存文件的最后修改时间。 Cookie（********） 会话管理相关，非常的重要。 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:10:2","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.3.3 请求正文详解 第一：只有post请求方式，才有请求的正文。get方式的正文是在地址栏中的。 第二：表单的输入域有name属性的才会被提交。不分get和post的请求方式。 第三：表单的enctype属性取值决定了请求正文的体现形式。概述的含义是：请求正文的MIME编码类型。 enctype取值 请求正文体现形式 示例 application/x-www-form-urlencoded key=value\u0026key=value username=test\u0026password=1234 multipart/form-data 此时变成了多部分表单数据。多部分是靠分隔符分隔的。 —————————–7df23a16c0210Content-Disposition: form-data; name=“username”test—————————–7df23a16c0210Content-Disposition: form-data; name=“password”1234—————————–7df23a16c0210Content-Disposition: form-data; name=“headfile”; filename=“C:\\Users\\zhy\\Desktop\\请求部分.jpg”Content-Type: image/pjpeg—————————–7df23a16c0210 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:10:3","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.4 响应部分详解 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:11:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.4.1 响应行详解 响应行：HTTP/1.1 200 OK 内容 说明 HTTP/1.1 使用协议的版本。 200 响应状态码 OK 状态码描述 常用状态码介绍： 状态码 说明 200 一切都OK 302/307 请求重定向(客户端行为，两次请求，地址栏发生改变) 304 请求资源未发生变化，使用缓存 404 请求资源未找到 500 服务器错误 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:11:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.4.2 响应消息头详解 Location 请求重定向的地址，常与302,307配合使用。 消息头 说明 Server 服务器相关信息。 Content-Type 告知客户浏览器，响应正文的MIME类型。application/json text/html Content-Length 告知客户浏览器，响应正文的长度。 Content-Encoding 告知客户浏览器，响应正文使用的压缩编码格式。常用的gzip压缩。 Content-Language 告知客户浏览器，响应正文的语言。zh_CN或en_US等等。 Content-Disposition 告知客户浏览器，以下载的方式打开响应正文。 Refresh 定时刷新 Last-Modified 服务器资源的最后修改时间。 Set-Cookie（*******） 会话管理相关，非常的重要 Expires:-1 服务器资源到客户浏览器后的缓存时间 Catch-Control: no-catch 不要缓存，//针对http协议1.1版本 Pragma:no-catch 不要缓存，//针对http协议1.0版本 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:11:2","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"3.4.3 响应正文详解 就和我们在浏览器上右键查看源文件看到的内容是一样的。 \u003chtml\u003e \u003chead\u003e \u003clink rel=\"stylesheet\" href=\"css.css\" type=\"text/css\"\u003e \u003cscript type=\"text/javascript\" src=\"demo.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cimg src=\"1.jpg\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:11:3","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"小结：（记忆） 1. 请求分成几部分： 1. 请求行 ---- get www.baidu.com http/1.1 2. 请求头 ---- 很多信息（后面具体使用，展开讲解） 3. 请求空行 ----- 什么都没有（空白） 4. 请求体 ----- （get没有请求体， post有请求体） 响应分成几部分： ​ 同上，4部分 2. get和post的区别： a. 请求的参数位置： b. 请求的参数的容量是否有限制： c. 是否有请求体： d. 安全性： 3. 响应状态码： 200： 成功 302： 重定向 304： 资源有缓存； 404： 资源未找到（请求路径有误） 500： 服务器内部错误（java代码有误） 4 综合案例-Tomcat的具体应用 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:11:4","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"4.1 静态资源案例-门户类网站的部署和访问 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:12:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"4.1.1 案例介绍 需求： ​ 在浏览器中输入地址，访问静态HTML页面。 细节说明： ​ 把HTML和CSS课程中制作的页面加入到JavaWeb工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:12:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"4.1.2 实现步骤 第一步：创建工程并选择使用的Tomcat版本 第二步：拷贝资源到工程的web目录中 第三步：在web.xml中配置默认主页 第四步：部署工程到Tomcat服务器 第五步：测试浏览器访问 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:12:2","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"4.2 动态资源的案例-学生管理系统的部署和访问 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:13:0","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"4.2.1 案例介绍 需求： ​ 把JavaSE进阶阶段的学生管理系统的服务器改用Tomcat实现。 细节说明： ​ 把学生管理系统涉及的HTML和样式以及图片文件拷贝到JavaWeb工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:13:1","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"4.2.2 实现步骤 第一步：创建工程 第二步：拷贝资源 第三步：配置默认主页 第四步：部署项目 注意细节： 注意在idea中的tomcat的配置中添加虚拟访问路径： /crm ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:13:2","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"4.3.2 创建案例中的动态资源-Servlet 1） Servlet简介 Servlet翻译成中文是服务端脚本，它是SUN公司推出的一套规范，称为Servlet规范。Servlet规范是JavaEE规范中的一部分。我们可以通过查阅JavaEE规范的API来了解Servlet的基本概念。通过点击JavaEE8官方文档，就可以看到关于Servlet的内容介绍。 servlet是 运行在客户端和服务器端的一个小程序！ JDK只定义接口规范，并没有实现； 具体的实现在服务器tomcat中！ 2） 按步骤编写Servlet 前期准备：在IDEA创建Javaweb工程 第一步：编写一个普通类实现Servlet接口或者继承GenericServlet类或者继承HttpServlet 第二步：重写service方法，输出一句话 第三步：在web.xml配置Servlet 第四步：启动tomcat服务器测试 在地址栏输入：http://localhost:8585/crm/studentServlet 测试访问结果 3）测试访问 ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:13:3","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["大三下实训笔记"],"content":"小结： 1. servlet的实现步骤： 2.servlet的执行顺序 注意： 两种配置以后使用一种即可 （自己选择） 方式1：注解形式： 方式2：web.xml形式： 【今日总结：】 0.web模块说明及tomcat配置： 1. 请求分成几部分： 1. 请求行 ---- get www.baidu.com 2. 请求头 ---- 很多信息（后面具体使用，展开讲解） 3. 请求空行 ----- 什么都没有（空白） 4. 请求体 ----- （get没有请求体， post有请求体） 响应分成几部分： ​ 同上，4部分 2. get和post的区别： 参数的位置不同 是否有请求体 相对安全性 参数的长度： （post参数可以传递更多） 3. 响应状态码： 200 代表成功 302 重定向 304 代表浏览器缓存（此请求没有真正访问资源） 404 请求路径有误（资源访问不到） 500 后台服务器内部错误（java程序有异常） 【今日作业安排】 完成tomcat的安装（能正常启动，并访问看到tomcat猫） 能够说清楚tomcat解压文件夹下的常用的5个分别是什么？ 能够将idea集成tomcat； 写下常见的响应状态码，及其含义； 能够部署静态页面项目 （参考4.1） 尝试完成补充的登录案例； ==预习servlet== 【补充】 1.实现不重启tomcat，修改页面立即生效： 2.index的特殊含义： 在web项目中， index名字是有特殊含义的（代表首页） 访问到包含有index名的网页时， 不用补全路径的！ 优先级 .html \u003e .jsp 3.在案例1的基础上，实现登录功能： /** * servlet快速入门： * 1. 实现servlet接口； * 2. 重写方法； * 3. 配置servlet * xml配置： * 注解配置: @WebServlet(\"/userServlet\") * * * 用户登录的servlet： * 1.可以在service方法中，接收用户提交的用户名和密码； * 2.判断用户名和密码是否正确； * 3.如果正确，提示登录成功， * 如果不正确，提示登录失败； */ @WebServlet(\"/userLoginServlet\") public class UserLoginServlet implements Servlet{ /** 1.service方法何时执行？ --- 每次访问servlet时，service方法都会执行！ 2.service方法中如何获取请求的参数？ --- request.getparameter(\"参数名\") */ @Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException { // 0.指定字符集，防止乱码： response.setContentType(\"text/html;charset=utf-8\"); System.out.println(\"----------------------servlet的service方法执行了 ......\"); // 1.获取请求的参数： //获取用户名： String username = request.getParameter(\"username\"); //获取密码： String password = request.getParameter(\"password\"); System.out.println(\"------------用户提交的用户名为：\" +username); System.out.println(\"------------用户提交的密码为：\" + password); // 2.判断用户名和密码是否正确； --------以后可以去数据库查询用户名和密码是否正确！ （目前写死） if (\"lisi\".equals(username) \u0026\u0026 \"123456\".equals(password)){ //登录成功 System.out.println(\"-----------登录成功~~~\"); // 3.1 成功： response.getWriter().write(\"欢迎\"+username+\", 登录成功！ \"); }else { // 登录失败 System.out.println(\"-----------登录失败~~~\"); // 3.2 失败： response.getWriter().write(\"您的用户名密码有误，请重新输入!\"); } } ccleaner // ==========其他4个方法，明天详细讲解============================= // ... } ","date":"2021-07-17","objectID":"/tomcat-http-3-2/:13:4","tags":[],"title":"Tomcat\u0026Http","uri":"/tomcat-http-3-2/"},{"categories":["设计模式"],"content":"模式动机 软件系统：一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变，它们之间将产生联动 观察者模式： ​ 定义了对象之间一种一对多的依赖关系，让一个对象的改变能够影响其他对象发生改变的对象称为观察目标， ​ 被通知的对象称为观察者 ​ 一个观察目标可以对应多个观察者 ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式 观察者模式是一种对象行为型模式 代码： //抽象观察者 public interface Observer { public void update(Subject subject); } public class ConcreteObserver implements Observer { private String observername; //观察者名称 private String observerstate; //观察者状态 public ConcreteObserver(String observername) { this.observername = observername; } @Override public void update(Subject subject) { // TODO Auto-generated method stub observerstate=\"观察者 \"+observername+\" 的当前状态是：\"+subject.getState(); System.out.println(observerstate); } } //抽象观察目标 public abstract class Subject { private String state; //状态 protected ArrayList observers=new ArrayList(); //观察者集合 public String getState() { return state; } public void setState(String state) { this.state = state; System.out.println(\"观察目标的状态变为：\"+state); } public void attach(Observer observer) { observers.add(observer); } public void detach(Observer observer) { observers.remove(observer); } public abstract void notifyObservers(); } public class ConcreteSubject extends Subject { @Override public void notifyObservers() { // TODO Auto-generated method stub System.out.println(\"具体观察目标：通知所有观察者\"); for(Object obj:observers) { Observer observer=(Observer)obj; observer.update(this); } } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Subject subject=new ConcreteSubject(); Observer obsA=new ConcreteObserver(\"obsA\"); Observer obsB=new ConcreteObserver(\"obsB\"); subject.attach(obsA); subject.attach(obsB); System.out.println(\"--------------------\"); subject.setState(\"״̬1\"); subject.notifyObservers(); System.out.println(\"--------------------\"); subject.setState(\"״̬2\"); subject.notifyObservers(); System.out.println(\"--------------------\"); Observer obsC=new ConcreteObserver(\"obsC\"); subject.attach(obsC); subject.setState(\"״̬3\"); subject.notifyObservers(); System.out.println(\"--------------------\"); subject.detach(obsB); subject.setState(\"״̬4\"); subject.notifyObservers(); } } ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 有时候在具体观察者类ConcreteObserver中需要使用到具体目标类ConcreteSubject中的状态（属性），会存在关联或依赖关系 如果在具体层之间具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违背了开闭原则，但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响 ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 可以实现表示层和数据逻辑层的分离 在观察目标和观察者之间建立一个抽象的耦合 支持广播通信，简化了一对多系统设计的难度 符合开闭原则，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便 ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 将所有的观察者都通知到会花费很多时间 如果存在循环依赖时可能导致系统崩溃 没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化 ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:5:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用 一个对象的改变将导致一个或多个其他对象发生改变，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁 需要在系统中创建一个触发链 ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:6:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"实例： 假设猫是老鼠和狗的观察目标，老鼠和狗是观察者，猫叫老鼠跑，狗也跟着叫，使用观察者模式描述该过程。 抽象目标类 import java.util.ArrayList; public abstract class Subject { protected ArrayList observers=new ArrayList(); //观察者集合 protected String subjectState; //观察目标自身的状态 public String getSubjectState() { return subjectState; } public void setSubjectState(String subjectState) { this.subjectState = subjectState; } public abstract void attach(Observer obs); //添加一个观察者 public abstract void detach(Observer obs); //删除一个观察者 public void notifyObservers() //通知所有观察者 { for(Object obs:observers) { ((Observer)obs).update(this); } } } 具体目标类 public class ConcreteSubject extends Subject { @Override public void attach(Observer obs) { //添加观察者 // TODO Auto-generated method stub observers.add(obs); } @Override public void detach(Observer obs) { //删除观察者 // TODO Auto-generated method stub observers.remove(obs); } } 抽象观察者类： //抽象观察者 public interface Observer { //更新观察者当前自身的状态 public void update(Subject subject); } 具体观察者1类： public class ConcreteObserver1 implements Observer { private String observerState=\"\"; @Override public void update(Subject subject) { // TODO Auto-generated method stub observerState=subject.getSubjectState(); System.out.println(\"观察者1当前状态：\"+observerState); } } 抽象观察者2类： public class ConcreteObserver2 implements Observer { private String observerState=\"\"; @Override public void update(Subject subject) { // TODO Auto-generated method stub observerState=subject.getSubjectState(); System.out.println(\"观察者2当前状态：\"+observerState); } } 客户端类： public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Subject cs=new ConcreteSubject(); cs.setSubjectState(\"状态1\"); ConcreteObserver1 obs1=new ConcreteObserver1(); ConcreteObserver2 obs2=new ConcreteObserver2(); cs.attach(obs1); cs.attach(obs2); System.out.println(\"观察目标初始状态：\"+cs.getSubjectState()); System.out.println(\"其它观察者的状态：\"); cs.notifyObservers(); System.out.println(\"-------------------\"); cs.setSubjectState(\"状态2\"); System.out.println(\"观察目标更新后状态：\"+cs.getSubjectState()); System.out.println(\"其它观察者更新后的状态：\"); cs.notifyObservers(); System.out.println(\"-------------------\"); cs.detach(obs2); cs.setSubjectState(\"状态3\"); System.out.println(\"观察目标更新后状态：\"+cs.getSubjectState()); System.out.println(\"其它观察者更新后的状态：\"); cs.notifyObservers(); } } ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:7:0","tags":["观察者模式"],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["java"],"content":"Java如何开启线程？怎么保证线程安全？ 线程与进程的区别：进程是操作系统进行资源分配的最小单元，线程是操作系统进行任务分配的最小单元，线程隶属于进程。 如何开启线程？ 基础Thread类，重写run方法(start方法开启线程内部调用run、如果直接调用run就是方法的调用，不会开启线程) 实现Runable接口，实现run方法() 实现Callable接口，实现call方法，通过FutureTask创建一个线程，获取到线程的返回结果， 通过线程池开启线程 如何保证线程安全？（多个线程对同一个资源进行操作）加锁 JVM提供的锁，也就是Synchronized关键字， JDK提供的各种锁LOCK ","date":"2021-05-25","objectID":"/java%E5%B9%B6%E5%8F%91/:1:0","tags":["面试"],"title":"Java并发","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":["java"],"content":"Volatile与Synchronized有什么区别？Volatile能不能保证线程安全？DCL（Double Check Lock）单例为什么要加Volatile？ DCL: Synchronized关键字用来加锁，Volatile只是保持变量的线程可见性，通常适用于一个线程写，多个线程读的场景 不能。Volatile只能保证线程可见性，不能保证原子性， Volatile防止指令重排（Integer i=8 1、分配内存，2、对象初始化、3、建立指针）防止高并发状态下，指令重排造成线程安全问题。 ","date":"2021-05-25","objectID":"/java%E5%B9%B6%E5%8F%91/:1:1","tags":["面试"],"title":"Java并发","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":["java"],"content":"java线程锁机制是怎样的，偏向锁、轻量级锁、重量级锁有什么区别？锁机制是如何升级的？ Java的锁机制就是在对象的Markword中记录一个锁的状态，偏向锁、轻量级锁、重量级锁对应不同的锁标志位状态 Java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。 ","date":"2021-05-25","objectID":"/java%E5%B9%B6%E5%8F%91/:1:2","tags":["面试"],"title":"Java并发","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":["java"],"content":"谈谈你对AQS的理解，AQS如何实现可重入锁？ AQS（AbstractQueueSynchronizer）是一个Java线程同步的框架，是JDK中许多锁工具的核心实现框架。 在AQS中，维护了一个信号量state和一个线程组成的双向链表队列，其中，这个线程队列是用来给线程排队的，state就是一个信号量，用来控制线程排队或者放行的。在不同的场景下有不同的定义 。 在可重入锁这个场景下，state就用来表示加锁的次数，0表示无锁，每加一次锁，state+1，释放锁-1 ","date":"2021-05-25","objectID":"/java%E5%B9%B6%E5%8F%91/:1:3","tags":["面试"],"title":"Java并发","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":["运维"],"content":"一个绿色的小标志","date":"2021-05-20","objectID":"/https%E9%85%8D%E7%BD%AE/","tags":["nginx"],"title":"Https配置","uri":"/https%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"第一步：Nginx的ssl模块安装 在配置ssl证书之前，要确保你的nginx已经安装了ssl模块，一般情况下自己安装的nginx都是不存在ssl模块的。 这里先检查下自己是否存在ssl模块： 进入到你的nginx安装目录下面，我的目录是在（/usr/local/nginx），如果你的nginx安装步骤和上面的文章一致的话，那你的目录和我应该是一致的 进入到目录的sbin目录下，输入 #注意这里是大写的V，小写的只显示版本号 ./nginx -V 如果出现 (configure arguments: –with-http_ssl_module), 则已安装（下面的步骤可以跳过，直接进行第二步）。 一般情况下都是不存在ssl模块的，接下来进入到你的解压缩后的nginx目录，注意这里不是nginx安装目录，是解压缩后的目录，我的是在（/root/nginx），进入目录后，输入 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 接下来执行 make #切记不要执行make install，否则会重新安装nginx 上述操作执行完成以后，你的目录下会出现objs文件夹，文件夹内存在nginx文件，如图： 接下来使用新的nginx文件替换掉之前安装目录sbin下的nginx，注意这里的替换的时候可以先将之前的文件备份下，停掉nginx服务 ./nginx -s stop #停止nginx服务 #替换之前的nginx cp /root/nginx/objs/nginx /usr/local/nginx/sbin 成功之后，进入到nginx安装目录下，查看ssl时候成功 #注意这里是大写的V，小写的只显示版本号 ./nginx -V #可以看到这里出现了configure arguments: --with-http_ssl_module 证明已经安装成功 提示：这里替换后在执行 -V命令如果提示权限不足，先给这个nginx文件提升下权限 我是用的是finalshell连接工具，直接右键就可以修改权限了，当然，也可以通过指令修改，如下： chmod 111 nginx ","date":"2021-05-20","objectID":"/https%E9%85%8D%E7%BD%AE/:1:0","tags":["nginx"],"title":"Https配置","uri":"/https%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"第二步：配置ssl证书 解压缩下载好的证书（证书一般是pem文件和key文件，这里名字可以随便改） 将下载好的证书上上传到服务器，我将证书放在了root目录下的card文件夹 #在root目录下创建card文件夹 cd /root mkdir card ","date":"2021-05-20","objectID":"/https%E9%85%8D%E7%BD%AE/:2:0","tags":["nginx"],"title":"Https配置","uri":"/https%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"第三步：进行nginx.conf配置 进入nginx.conf文件下 cd /usr/locla/nginx/conf #修改nginx.conf文件 vim nginx.conf 打开之后文件内容如图 可以将没用的东西都删除掉，删除的时候注意，括号要对应起来。 然后进行配置，输入： user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; server { #监听443端口 listen 443 ssl; #你的域名 server_name wchat.eccentric.top; #ssl证书的pem文件路径 ssl_certificate /etc/nginx/cart/5663981_wchat.eccentric.top.pem; #ssl证书的key文件路径 ssl_certificate_key /etc/nginx/cart/5663981_wchat.eccentric.top.key; location / { proxy_pass http://120.77.216.116:9981; } } server { listen 80; server_name wchat.eccentric.top; #将请求转成https rewrite ^(.*)$ https://$host$1 permanent; } } 注意：这里需要在安全组中开放443端口。 ","date":"2021-05-20","objectID":"/https%E9%85%8D%E7%BD%AE/:3:0","tags":["nginx"],"title":"Https配置","uri":"/https%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"第四步：重启nginx ok，如果上述步骤都完成了，没有问题，接下来只需要重启nginx服务即可。 进入sbin目录下，输入 ./nginx -s reload ./nginx -s stop ./nginx ps： docker安装nginx配置反向代理，一定要映射80和443端口； 服务器安全组开放80和443端口； docker或者nginx配置完要重启 ","date":"2021-05-20","objectID":"/https%E9%85%8D%E7%BD%AE/:4:0","tags":["nginx"],"title":"Https配置","uri":"/https%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"nginx启动报错 docker run --name postNginx -v /work/html:/usr/share/nginx/html -v /work/nginx:/etc/nginx nginx 2021/05/19 14:46:05 [emerg] 1#1: open() “/etc/nginx/nginx.conf” failed (2: No such file or directory) nginx: [emerg] open() “/etc/nginx/nginx.conf” failed (2: No such file or directory) 意思是没有找到/etc/nginx/nginx.conf文件， 第一种解决办法： docker run --name=mynginx -p 80:80 -p 443:443 \\ --restart=always \\ -v /work/nginx/nginx.conf:/etc/nginx/nginx.conf \\ -v /work/nginx/conf.d:/etc/nginx/conf.d \\ -v /work/nginx/www:/usr/share/nginx/html \\ -v /work/nginx/logs:/var/log/nginx -v /work/nginx/cart:/etc/nginx/cart \\ -d nginx 第二种解决办法： ​ 都提示了是没有权限造成的，那就排查下权限。看看宿主机本地的nginx.conf对other用户是否有读权限，再排查下该配置文件的所有父级目录是否有访问权限。或者像一楼说的用docker run --privileged=true启动容器，这样就是使用root用户权限了。 ","date":"2021-05-19","objectID":"/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/:0:1","tags":["docker 掉坑"],"title":"日常掉坑","uri":"/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/"},{"categories":["运维"],"content":"nginx代理转发错误 connect() failed (111: Connection refused) while connecting to upstream, client: 202.114.144.231, server: 111.47.28.118, request: \"POST /prd-api/authorization-server/oauth/token?username=admin\u0026password=password\u0026grant_type=password\u0026scope=read HTTP/1.1\", upstream: \"http://111.47.28.118:7181/authorization-server/oauth/token?username=admin\u0026password=password\u0026grant_type=password\u0026scope=read\", host: \"111.47.28.118:7191\", referrer: \"http://111.47.28.118:7191/\" 202.114.144.231 - test_client [10/Jun/2021:09:53:55 +0000] \"POST /prd-api/authorization-server/oauth/token?username=admin\u0026password=password\u0026grant_type=password\u0026scope=read HTTP/1.1\" 502 494 \"http://111.47.28.118:7191/\" \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.77 Safari/537.36 Edg/91.0.864.41\" \"-\" 目前nginx配置文件 server { listen 80; listen [::]:80; server_name 111.47.28.118; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/nginx/html/AAMS; index index.html index.htm; } location /prd-api { rewrite ^/prd-api/(.*)$ /$1 break; proxy_pass http://111.47.28.118:7181; proxy_set_header Authorization $http_authorization; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } nginx.conf配置： user nginx; worker_processes auto; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; underscores_in_headers on; add_header Access-Control-Allow-Headers Authorization; include /etc/nginx/conf.d/*.conf; } 解决：","date":"2021-05-19","objectID":"/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/:0:2","tags":["docker 掉坑"],"title":"日常掉坑","uri":"/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/"},{"categories":["数据库"],"content":"JPA 基本查询 Spring Data JPA提供的一个查询规范，查询语句关键字，简单的SQL可根据方法命名来即可，省略了写sql语句 关键字 方法命名 sql where字句 And findByNameAndPwd where name= ? and pwd =? Or findByNameOrSex where name= ? or sex=? Is,Equals findById,findByIdEquals where id= ? Between findByIdBetween where id between ? and ? LessThan findByIdLessThan where id \u003c ? LessThanEquals findByIdLessThanEquals where id \u003c= ? GreaterThan findByIdGreaterThan where id \u003e ? GreaterThanEquals findByIdGreaterThanEquals where id \u003e = ? After findByIdAfter where id \u003e ? Before findByIdBefore where id \u003c ? IsNull findByNameIsNull where name is null isNotNull,NotNull findByNameNotNull where name is not null Like findByNameLike where name like ? NotLike findByNameNotLike where name not like ? StartingWith findByNameStartingWith where name like ‘?%’ EndingWith findByNameEndingWith where name like ‘%?’ Containing findByNameContaining where name like ‘%?%’ OrderBy findByIdOrderByXDesc where id=? order by x desc Not findByNameNot where name \u003c\u003e ? In findByIdIn(Collection c) where id in (?) NotIn findByIdNotIn(Collection c) where id not in (?) True findByAaaTue where aaa = true False findByAaaFalse where aaa = false IgnoreCase findByNameIgnoreCase where UPPER(name)=UPPER(?) ","date":"2021-05-15","objectID":"/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/:1:0","tags":["JPA"],"title":"JPA实现动态SQL","uri":"/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/"},{"categories":["数据库"],"content":"JPA 多条件查询（参数为空判断）语句 工作中遇到一个多条件查询的需求，需要根据名字，性别，年龄以及序号查询数据，名字需要模糊查询，参数有可能为空。 @Query(value = \"select * from people where if(?1 !='',name like concat('%',?1,'%'),1=1) and if(?2 !='',sex=?2,1=1)\"+ \" and if(IFNULL(?3,'') !='',age=?3,1=1) and if(IFNULL(?4,'') !='',num=?4,1=1) \",nativeQuery = true) List\u003cPeople\u003e find(String name,String sex,Integer age,Integer num); 同理： @Query(value = \"select * from post_timer where if(IFNULL(?1,'') !='',is_send=?1,1=1) and if(IFNULL(?2,'') !='',typa=?2,1=1) and if(IFNULL(?3,'') !='',status=?3,1=1) and if(?4 !='',content like concat('%',?4,'%'),1=1) \"+ \"order by create_time DESC limit ?5,?6\",nativeQuery = true) List\u003cPostTimer\u003e findlike(Integer isSend,Integer typa,Integer status,String likeString,Integer page,Integer limit); @Query(value = \"select count(*) from post_timer where if(IFNULL(?1,'') !='',is_send=?1,1=1) and if(IFNULL(?2,'') !='',typa=?2,1=1) and if(IFNULL(?3,'') !='',status=?3,1=1) and if(?4 !='',content like concat('%',?4,'%'),1=1) \",nativeQuery = true) Integer countlike(Integer isSend,Integer typa,Integer status,String likeString); PS： nativeQuery = true 的含义是使用原生SQL，即注解中的SQL语句会生效，false的话就不会生效。 SQL语句中 ?1、?2、?3、?4 的意思是代表方法中的第几个参数。 SQL中模糊查询的写法为 like concat(’%’, ?1, ‘%’) if(?1 !=’’,name like concat(’%’,?1,’%’),1=1) 代表传入的参数name如果不为\"\"（Spring类型空是\"“而不是null）将参数传入name，如果为空时显示1=1 代表参数为真，对查询结果不产生作用。IF 的语法满足mysql的基本语法，IF(expr1,expr2,expr3)， 如果 expr1 为真(expr1 \u003c\u003e 0 以及 expr1 \u003c\u003e NULL)，那么 IF() 返回 expr2，否则返回expr3 if(IFNULL(?3,’’) !=’’,age=?3,1=1) 表示如果传入的年龄是null，则替换成空字符串，然后判断是否为空，不为空则将参数传入age，否则忽略不对查询结果产生影响。IFNULL 是mysql中的一个函数，这个函数一般用来替换 NULL 值的。IFNULL(value1,value2)，判断value1是否为null，如果为null则用value2替换。 **参数定义时，定义数值，应使用Integer，**如果用int定义，当入参为NULL时，程序会报空指针错误。原因是JAVA 中 int 是值类型，非对象，不可以设置为 NULL，integer 是对象类型，可以设置为NULL ","date":"2021-05-15","objectID":"/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/:2:0","tags":["JPA"],"title":"JPA实现动态SQL","uri":"/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/"},{"categories":["前端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 本教程配合官方示例食用更佳！！！ 目录 [TOC] 前言 ColorUI是一个css库！！！在你引入样式后可以根据class来调用组件  快速上手 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:0:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用UniApp开发 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"开始 下载源码解压获得/Colorui-UniApp文件夹，复制目录下的 /colorui 文件夹到你的项目根目录 App.vue 引入关键Css main.css icon.css \u003cstyle\u003e @import \"colorui/main.css\"; @import \"colorui/icon.css\"; @import \"app.css\"; /* 你的项目css */ .... \u003c/style\u003e ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:1","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用自定义导航栏 导航栏作为常用组件有做简单封装，当然你也可以直接复制代码结构自己修改，达到个性化目的。 App.vue 获得系统信息 onLaunch: function() { uni.getSystemInfo({ success: function(e) { // #ifndef MP Vue.prototype.StatusBar = e.statusBarHeight; if (e.platform == 'android') { Vue.prototype.CustomBar = e.statusBarHeight + 50; } else { Vue.prototype.CustomBar = e.statusBarHeight + 45; }; // #endif // #ifdef MP-WEIXIN Vue.prototype.StatusBar = e.statusBarHeight; let custom = wx.getMenuButtonBoundingClientRect(); Vue.prototype.Custom = custom; Vue.prototype.CustomBar = custom.bottom + custom.top - e.statusBarHeight; // #endif // #ifdef MP-ALIPAY Vue.prototype.StatusBar = e.statusBarHeight; Vue.prototype.CustomBar = e.statusBarHeight + e.titleBarHeight; // #endif } }) }, pages.json 配置取消系统导航栏 \"globalStyle\": { \"navigationStyle\": \"custom\" }, 复制代码结构可以直接使用，注意全局变量的获取。 使用封装,在main.js 引入 cu-custom 组件。 import cuCustom from './colorui/components/cu-custom.vue' Vue.component('cu-custom',cuCustom) page.vue 页面可以直接调用了 \u003ccu-custom bgColor=\"bg-gradual-blue\" :isBack=\"true\"\u003e \u003cblock slot=\"backText\"\u003e返回\u003c/block\u003e \u003cblock slot=\"content\"\u003e导航栏\u003c/block\u003e \u003c/cu-custom\u003e 参数作用类型默认值bgColor背景颜色类名String''isBack是否开启返回BooleanfalsebgImage背景图片路径String''slot块作用backText返回时的文字content中间区域right右侧区域(小程序端可使用范围很窄！) ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:2","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用原生小程序开发 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"从现有项目开始 下载源码解压获得/demo，复制目录下的 /colorui 文件夹到你的项目根目录 App.wxss 引入关键Css main.wxss icon.wxss @import \"colorui/main.wxss\"; @import \"colorui/icon.wxss\"; @import \"app.css\"; /* 你的项目css */ .... ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:1","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"从新项目开始 下载源码解压获得/template，复制/template并重命名为你的项目，导入到小程序开发工具既可以开始你的新项目了 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:2","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用自定义导航栏 导航栏作为常用组件有做简单封装，当然你也可以直接复制代码结构自己修改，达到个性化目的。 App.js 获得系统信息 onLaunch: function() { wx.getSystemInfo({ success: e =\u003e { this.globalData.StatusBar = e.statusBarHeight; let custom = wx.getMenuButtonBoundingClientRect(); this.globalData.Custom = custom; this.globalData.CustomBar = custom.bottom + custom.top - e.statusBarHeight; } }) }, App.json 配置取消系统导航栏,并全局引入组件 \"window\": { \"navigationStyle\": \"custom\" }, \"usingComponents\": { \"cu-custom\":\"/colorui/components/cu-custom\" } page.wxml 页面可以直接调用了 \u003ccu-custom bgColor=\"bg-gradual-pink\" isBack=\"{{true}}\"\u003e \u003cview slot=\"backText\"\u003e返回\u003c/view\u003e \u003cview slot=\"content\"\u003e导航栏\u003c/view\u003e \u003c/cu-custom\u003e 参数作用类型默认值bgColor背景颜色类名String''isBack是否开启返回BooleanfalseisCustom是否开启左侧胶囊BooleanfalsebgImage背景图片路径String''slot块作用backText返回时的文字content中间区域right右侧区域(小程序端可使用范围很窄！) 组件 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:3","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"基础元素 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"layout布局 Flex布局 父级添加class名flex 固定尺寸 通过添加class名basic-{{options}}来设置分栏大小，options可以取五个值，分别为xs、sm、df、lg、xl \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"flex flex-wrap\"\u003e \u003cview class=\"basis-xs bg-grey margin-xs padding-sm radius\"\u003exs(20%)\u003c/view\u003e \u003cview class=\"basis-df\"\u003e\u003c/view\u003e \u003cview class=\"basis-sm bg-grey margin-xs padding-sm radius\"\u003esm(40%)\u003c/view\u003e \u003cview class=\"basis-df\"\u003e\u003c/view\u003e \u003cview class=\"basis-df bg-grey margin-xs padding-sm radius\"\u003edf(50%)\u003c/view\u003e \u003cview class=\"basis-lg bg-grey margin-xs padding-sm radius\"\u003elg(60%)\u003c/view\u003e \u003cview class=\"basis-xl bg-grey margin-xs padding-sm radius\"\u003exl(80%)\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 比例布局 通过添加class名flex-{{options}}来设置分栏大小，options可以取值sub、twice、treble，分别代表占比1，2，3 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003cview class=\"flex-twice bg-grey padding-sm margin-xs radius\"\u003e2\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003cview class=\"flex-twice bg-grey padding-sm margin-xs radius\"\u003e2\u003c/view\u003e \u003cview class=\"flex-treble bg-grey padding-sm margin-xs radius\"\u003e3\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 水平对齐（justify） 通过添加class名justify-{{options}}来设置盒子水平对齐方式，options可以取值start、end、center、between、around，效果可以参考flex布局布局中的容器属性justify-content（Flex布局教程） \u003cview class=\"bg-white\"\u003e \u003cview class=\"flex solid-bottom padding justify-start\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003estart\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003estart\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding justify-end\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003eend\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003eend\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding justify-center\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003ecenter\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003ecenter\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding justify-between\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003ebetween\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003ebetween\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding justify-around\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003earound\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003earound\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 垂直对齐（align） 通过添加class名align-{{options}}来设置盒子垂直对齐方式，options可以取值start、end、center，效果可以参考flex布局布局中的容器属性align-item（Flex布局教程） \u003cview class=\"bg-white\"\u003e \u003cview class=\"flex solid-bottom padding align-start\"\u003e \u003cview class=\"bg-grey padding-lg margin-xs radius\"\u003eColorUi\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003estart\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding align-end\"\u003e \u003cview class=\"bg-grey padding-lg margin-xs radius\"\u003eColorUi\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003eend\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding align-center\"\u003e \u003cview class=\"bg-grey padding-lg margin-xs radius\"\u003eColorUi\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003ecenter\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e Grid布局 父级添加class名grid 等分列 通过添加class名col-{{options}}来实现栅格布局，options可以取值1、2、3、4、5 \u003cview class=\"bg-white padding\"\u003e \u003cview class=\"grid margin-bottom text-center\" v-for=\"(item,index) in 5\" :key=\"index\" :class=\"'col-' + (index+1)\"\u003e \u003cview class=\"padding\" :class=\"indexs%2==0?'bg-cyan':'bg-blue'\" v-for=\"(item,indexs) in (index+1)\" :key=\"indexs\"\u003e{{index+1}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 等高 通过添加class名grid-square设置盒子内容等高，添加col-{{options}}来设置分栏个数，options可以取值1、2、3、4、5，将盒子等分 \u003cview class=\"bg-white padding\"\u003e \u003cview class=\"grid col-4 grid-square\"\u003e \u003cview class=\"bg-img\" v-for=\"(item,index) in avatar\" :key=\"index\" :style=\"[{ backgroundImage:'url(' + avatar[index] + ')' }]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e ---------------------------------------------------------------------------------------- data() { return { avatar: ['https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:1","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Background背景  颜色背景 深色   通过添加class名bg-{{options}}设置背景   \u003cview class=\"grid col-3 padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cview class=\"padding radius text-center shadow-blur\" :class=\"'bg-' + item.name\"\u003e \u003cview class=\"text-lg\"\u003e{{item.title}}\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e{{item.name}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 浅色  通过添加class名bg-{{options}}设置背景颜色，添加class名light表示相应的浅色 \u003cview class=\"grid col-3 bg-white padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"index\u003c12\"\u003e \u003cview class=\"padding radius text-center light\" :class=\"'bg-' + item.name\"\u003e \u003cview class=\"text-lg\"\u003e{{item.title}}\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e{{item.name}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e  渐变 通过添加class名bg-gradual-{{options}}设置渐变背景颜色 \u003cview class=\"grid col-2 padding-sm\"\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-red padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e魅红\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#f43f3b - #ec008c\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-orange padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e鎏金\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#ff9700 - #ed1c24\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-green padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e翠柳\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#39b54a - #8dc63f\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-blue padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e靛青\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#0081ff - #1cbbb4\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-purple padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e惑紫\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#9000ff - #5e00ff\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-pink padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e霞彩\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#ec008c - #6739b6\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 图片背景 透明背景（文字层） 通过bg-img设置图片背景，bg-mask设置透明遮罩层 \u003cview class=\"bg-img bg-mask flex align-center\" style=\"background-image: url('https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg');height: 414upx;\"\u003e \u003cview class=\"padding-xl text-white\"\u003e \u003cview class=\"padding-xs text-xxl text-bold\"\u003e 钢铁之翼 \u003c/view\u003e \u003cview class=\"padding-xs text-lg\"\u003e Only the guilty need fear me. \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e  通过bg-shadeTop设置遮罩层上阴影，bg-shadeBottom设置遮罩层下阴影 \u003cview class=\"grid col-2\"\u003e \u003cview class=\"bg-img padding-bottom-xl\" style=\"background-image: url('https://ossweb-img.qq.com/images/lol/web201310/skin/big10007.jpg');height: 207upx;\"\u003e \u003cview class=\"bg-shadeTop padding padding-bottom-xl\"\u003e 上面开始 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"bg-img padding-top-xl flex align-end\" style=\"background-image: url('https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg');height: 207upx;\"\u003e \u003cview class=\"bg-shadeBottom padding padding-top-xl flex-sub\"\u003e 下面开始 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 背景相关class class说明可选值bg-{{options}}设置背景色red/orange/yellow/olive/green/cyan/blue/purple/mauve/pink/ brown/grey/gray/black/white light浅色背景，配合bg-{{options}}使用，取值前12个——bg-gradual-{{options}}渐变色背景red/orange/green/blue/purple/pinkbg-img图片背景——bg-mask遮罩层——bg-shadeTop遮罩层上阴影——bg-shadeBottom遮罩层下阴影——shadow-blur外阴影—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:2","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Text文字 文字大小 通过添加class名text-{{size}}设置文字大小，size取值xs、sm、df、lg、xl、xxl、sl、xsl 文字颜色 通过添加class名text-{{color}}设置文字颜色，color取值red、orange、yellow、olive、green、cyan、blue、purple、mauve、brown、grey、gray、black、white \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cview class=\"text-center\" :class=\"'text-' + item.name\"\u003e {{item.title}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 文字阴影 通过添加class名text-shadow设置文字阴影 \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cview class=\"text-center text-shadow\" :class=\"'text-' + item.name\"\u003e \u003cview class=\"cuIcon-ellipse text-xxl\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 文字截断 通过添加class名text-cut设置文字长度溢出显示省略号 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"text-cut padding bg-grey radius\" style=\"width:220px\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003c/view\u003e 文字对齐 通过添加class名text-{{position}}设置文字长度溢出显示省略号，position取值left、center、right \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"text-left padding\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003cview class=\"text-center padding\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003cview class=\"text-right padding\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003c/view\u003e  特殊文字 通过添加class名text-price表示价格，会显示￥符号，text-Abc设置英文首字母大写，text-ABC设置英文大写，text-abc设置英文小写 \u003cview class=\"padding text-center\"\u003e \u003cview class=\"padding-lr bg-white\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-price\"\u003e80.00\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e价格文本，利用伪元素添加\"¥\"符号\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-lr bg-white margin-top\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-Abc\"\u003ecolor Ui\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e英文单词首字母大写\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-lr bg-white margin-top\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-ABC\"\u003ecolor Ui\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e全部字母大写\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-lr bg-white margin-top\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-abc\"\u003ecolor Ui\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e全部字母小写\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 文字相关class ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:3","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Icon图标 通过添加class名cuIcon-{{iconName}}，直接设置图标 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:4","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Button按钮 按钮必选class cu-btn 按钮形状 通过添加class名设置按钮不同形状，默认只需要添加cu-btn，round为圆角，cuIcon为圆形用来包裹图标 \u003cview class=\"padding flex flex-wrap justify-between align-center bg-white\"\u003e \u003cbutton class=\"cu-btn\"\u003e默认\u003c/button\u003e \u003cbutton class=\"cu-btn round\"\u003e圆角\u003c/button\u003e \u003cbutton class=\"cu-btn cuIcon\"\u003e \u003ctext class=\"cuIcon-goodsfill\"\u003e\u003c/text\u003e \u003c/button\u003e \u003c/view\u003e 按钮尺寸 sm小尺寸，lg大尺寸 \u003cview class=\"padding flex flex-wrap justify-between align-center bg-white\"\u003e \u003cbutton class=\"cu-btn round sm\"\u003e小尺寸\u003c/button\u003e \u003cbutton class=\"cu-btn round\"\u003e默认\u003c/button\u003e \u003cbutton class=\"cu-btn round lg\"\u003e大尺寸\u003c/button\u003e \u003c/view\u003e 按钮颜色 添加背景class名就可以，用法参考背景组件的介绍   \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"margin-tb-sm text-center\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cbutton class=\"cu-btn round\" :class=\"'bg-' + item.name \"\u003e{{item.title}}\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e 幽灵按钮 通过line-{{color}}或者lines-{{color}}设置镂空的幽灵按钮 \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"margin-tb-sm text-center\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='white'\"\u003e \u003cbutton class=\"cu-btn round\" :class=\"'line-' + item.name\"\u003e{{item.title}}\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e 禁用按钮 添加disabled禁用按钮 \u003cview class=\"padding\"\u003e \u003cbutton class=\"cu-btn block bg-blue margin-tb-sm lg\" disabled type=\"\"\u003e无效状态\u003c/button\u003e \u003cbutton class=\"cu-btn block line-blue margin-tb-sm lg\" disabled\u003e无效状态\u003c/button\u003e \u003c/view\u003e 自定义图标按钮 可以直接在button标签class内添加图标名，或者在text等其他标签内添加class，其他标签要包裹在button标签内 \u003cview class=\"padding-xl\"\u003e \u003cbutton class=\"cu-btn block line-orange lg cuIcon-upload\"\u003e\u003ctext class=\"cuIcon-upload\"\u003e\u003c/text\u003e 图标\u003c/button\u003e \u003cbutton class=\"cu-btn block bg-blue margin-tb-sm lg\"\u003e\u003ctext class=\"cuIcon-loading2 cuIconfont-spin\"\u003e\u003c/text\u003e 加载\u003c/button\u003e \u003cbutton class=\"cu-btn block bg-black margin-tb-sm lg\" loading\u003e 原生加载\u003c/button\u003e \u003c/view\u003e 按钮相关class class说明可选值cu-btn按钮必选值——round圆角按钮——cuIcon圆形——sm小尺寸按钮——lg大尺寸按钮——line-{{color}}幽灵按钮，细边框参考背景色lines-{{color}}幽灵按钮，粗边框参考背景色disabled禁用—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:5","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Tag标签 标签必选class cu-tag  标签形状 通过添加class名设置标签不同形状，默认只需要添加cu-tag，round为椭圆，radius为圆角 \u003cview class=\"padding bg-white solid-bottom\"\u003e \u003cview class='cu-tag'\u003e默认\u003c/view\u003e \u003cview class='cu-tag round'\u003e椭圆\u003c/view\u003e \u003cview class='cu-tag radius'\u003e圆角\u003c/view\u003e \u003c/view\u003e  标签尺寸 sm小尺寸 \u003cview class=\"padding bg-white\"\u003e \u003cview class='cu-tag radius sm'\u003e小尺寸\u003c/view\u003e \u003cview class='cu-tag radius'\u003e普通尺寸\u003c/view\u003e \u003c/view\u003e  标签颜色 添加背景class名就可以，用法参考背景组件的介绍 \u003cview class='padding-sm flex flex-wrap'\u003e \u003cview class=\"padding-xs\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='gray'\"\u003e \u003cview class='cu-tag' :class=\"'bg-' + item.name\"\u003e{{item.title}}\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xs\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='gray' \u0026\u0026 item.name!='black' \u0026\u0026 item.name!='white'\"\u003e \u003cview class='cu-tag light' :class=\"'bg-' + item.name\"\u003e{{item.title}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 幽灵标签 通过line-{{color}}设置镂空的幽灵按钮 \u003cview class='padding-sm flex flex-wrap'\u003e \u003cview class=\"padding-xs\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='white'\"\u003e \u003cview class='cu-tag' :class=\"'line-' + item.name\"\u003e{{item.title}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 胶囊样式 通过cu-capsule设置为胶囊样式，内部设置自己想要的样式 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-capsule\"\u003e \u003cview class='cu-tag bg-red'\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-red\"\u003e12\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule round\"\u003e \u003cview class='cu-tag bg-blue '\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-blue\"\u003e23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule round\"\u003e \u003cview class='cu-tag bg-blue '\u003e说明\u003c/view\u003e \u003cview class=\"cu-tag line-blue\"\u003e123\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class='cu-tag bg-grey '\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-grey\"\u003e23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class='cu-tag bg-brown sm'\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-brown sm\"\u003e23\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 数字标签  通过badge设置角标   \u003cview class=\"padding flex justify-between align-center\"\u003e \u003cview class='cu-avatar xl radius'\u003e港\u003cview class=\"cu-tag badge\"\u003e99+\u003c/view\u003e\u003c/view\u003e \u003cview class='cu-avatar xl radius' style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg)\"\u003e \u003cview class='cu-tag badge'\u003e9\u003c/view\u003e \u003c/view\u003e \u003cview class='cu-avatar xl radius'\u003e \u003cview class='cu-tag badge'\u003e99\u003c/view\u003e \u003ctext class='cuIcon-people'\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class='cu-avatar xl radius'\u003e \u003cview class='cu-tag badge'\u003e99+\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 标签相关class class说明可选值cu-tag标签必选值——round椭圆——radius圆角——sm小尺寸标签——line-{{color}}幽灵标签参考背景色cu-capsule胶囊标签——badge数字角标—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:6","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Avatar头像 头像必选class cu-avatar 头像形状 通过round和radius设置头像形状 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar round\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg)\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar radius margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81005.jpg);\"\u003e\u003c/view\u003e \u003c/view\u003e 头像尺寸 通过sm 、lg、xl设置不同大小的头像 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar sm round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg)\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81005.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar lg round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big25002.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar xl round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big99008.jpg);\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar sm round margin-left bg-red\"\u003e 蔚\u003c/view\u003e \u003cview class=\"cu-avatar round margin-left bg-red\"\u003e蓝\u003c/view\u003e \u003cview class=\"cu-avatar lg round margin-left bg-red\"\u003e\u003ctext\u003ewl\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-avatar xl round margin-left bg-red\"\u003e \u003ctext class=\"avatar-text\"\u003e网络\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 内嵌文字 头像内部不仅仅是图片，也可以是自定义文字和图标等 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar radius\"\u003e \u003ctext class=\"cuIcon-people\"\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius margin-left\"\u003e \u003ctext\u003e港\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e  头像颜色 设置背景色即可 \u003cview class=\"padding-sm\"\u003e \u003cview class=\"cu-avatar round lg margin-xs\" :class=\"'bg-' + item.name\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003ctext class=\"avatar-text\"\u003e{{item.name}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 头像组 设置了cu-avatar外部的盒子添加cu-avatar-group的class \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar-group\"\u003e \u003cview class=\"cu-avatar round lg\" v-for=\"(item,index) in avatar\" :key=\"index\" :style=\"[{ backgroundImage:'url(' + avatar[index] + ')' }]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 头像标签 在头像标签内部添加数字标签的角标即可 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar round lg margin-left\" v-for=\"(item,index) in avatar\" :key=\"index\" :style=\"[{ backgroundImage:'url(' + avatar[index] + ')' }]\"\u003e \u003cview class=\"cu-tag badge\" :class=\"index%2==0?'cuIcon-female bg-pink':'cuIcon-male bg-blue'\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 头像相关class class说明可选值cu-avatar头像必选值——cu-avatar-group头像组，包裹cu-avatar——round圆形——radius圆角——sm小尺寸头像——lg大尺寸头像——xl超大尺寸头像—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:7","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Progress进度条  进度条必须值为cu-progress 进度条形状 进度条默认为方形，radius为圆角，round为圆形；代码中loading只是一个变量，初始值为false，页面初始化时赋值为true，即给进度条赋值，使进度条有一个动画效果。 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress\"\u003e \u003cview class=\"bg-red\" style=\"width:61.8%\"\u003e61.8%\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress radius margin-top\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e61.8%\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round margin-top\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e61.8%\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条尺寸 sm为小尺寸，xs为超小尺寸  \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress round\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round margin-top sm\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round margin-top xs\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条颜色 添加背景色即可 \u003cview class=\"padding\" :class=\"color=='white'?'bg-grey':'bg-white'\"\u003e \u003cview class=\"cu-progress round\"\u003e \u003cview :class=\"'bg-' + color\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条条纹 添加striped设置条纹样式，active设置条纹动态效果 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress round sm striped active\" \u003e \u003cview class=\"bg-green\" :style=\"[{ width:loading?'60%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round sm margin-top-sm striped\" \u003e \u003cview class=\"bg-black\" :style=\"[{ width:loading?'40%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条比例 在给定class为cu-progress的标签内按需放置元素并进行分段设计即可 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress radius striped active\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'30%':''}]\"\u003e30%\u003c/view\u003e \u003cview class=\"bg-olive\" :style=\"[{ width:loading?'45%':''}]\"\u003e45%\u003c/view\u003e \u003cview class=\"bg-cyan\" :style=\"[{ width:loading?'25%':''}]\"\u003e25%\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条布局 结合布局、图标等内容，可根据个人所需可以设置不同进度显示的样式 \u003cview class=\"padding bg-white \"\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"cu-progress round\"\u003e \u003cview class=\"bg-green\" :style=\"[{ width:loading?'100%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003ctext class=\"cuIcon-roundcheckfill text-green margin-left-sm\"\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class=\"flex margin-top\"\u003e \u003cview class=\"cu-progress round\"\u003e \u003cview class=\"bg-green\" :style=\"[{ width:loading?'80%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003ctext class=\"margin-left\"\u003e80%\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 进度条相关class class说明可选值cu-progress进度条必选值——radius圆角——round 圆形——sm小尺寸——xs超小尺寸——striped条纹——active 结合striped使用，设置动态条纹效果—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:8","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Border\u0026Shadow边框阴影  默认shadow是根据背景色设置的阴影，shadow-lg为长阴影，但是我肉眼没看出来二者的区别，真是在下愚钝，shadow-warp为翘边阴影（在下愚钝，它翘一点？？？），shadow-blur根据背景图片设置的阴影，有点意思，挺好。关于边框border没什么好展开的，直接看下面表格class说明就好。 \u003cview class=\"padding text-center\"\u003e \u003cview class=\"padding-xl radius shadow bg-white\"\u003e默认阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow bg-gradual-red margin-top\"\u003e根据背景颜色而改变的阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow shadow-lg bg-white margin-top\"\u003e长阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow shadow-lg bg-blue margin-top\"\u003e长阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow-warp bg-white margin-top\"\u003e翘边阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow-blur bg-red margin-top bg-img\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big91005.jpg);\"\u003e \u003cview\u003e根据背景图而改变的阴影\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 边框阴影相关class class说明可选值solid/solids实线四周边框，solid为细边框 ，solids为粗边框——solid/solids-{{options}}不同方向的边框(上下左右)top/right/bottom/leftshadow默认阴影（根据背景色变化）——shadow-lg长阴影——shadow-wrap翘边阴影——shadow-blur根据背景图片变化的阴影  ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:9","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Loading加载 加载必选值cu-load 加载状态 loading正在加载中，over加载完成，erro加载失败 \u003cview class=\"cu-load bg-blue loading\"\u003e\u003c/view\u003e \u003cview class=\"cu-load bg-blue over\"\u003e\u003c/view\u003e \u003cview class=\"cu-load bg-red erro\"\u003e\u003c/view\u003e 弹框加载 设置按钮，弹出弹框，显示加载状态，弹框模板设置load-modal \u003cview class=\"cu-bar bg-white margin-top\"\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-title text-blue\"\u003e\u003c/text\u003e弹框加载 \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn bg-green shadow\" @tap=\"LoadModal\"\u003e 点我 \u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-load load-modal\" v-if=\"loadModal\"\u003e \u003cimage src=\"/static/logo.png\" mode=\"aspectFit\"\u003e\u003c/image\u003e \u003cview class=\"gray-text\"\u003e加载中...\u003c/view\u003e \u003c/view\u003e \u003cscript\u003e export default { data() { return { loadModal: false }; }, methods: { LoadModal(e) { this.loadModal = true; setTimeout(() =\u003e { this.loadModal = false; }, 2000) } } } \u003c/script\u003e 进度条加载 设置进度条加载时需要添加load-progress，变量loadProgress为加载进度条的进度，load-progress-bar代表加载中进度条样式，load-progress-spinner代表加载中旋转的圆圈样式 \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn bg-green shadow\" @tap=\"LoadProgress\"\u003e 点我 \u003c/button\u003e \u003c/view\u003e \u003cview class=\"load-progress\" :class=\"loadProgress!=0?'show':'hide'\" style=\"top:100px\"\u003e \u003cview class=\"load-progress-bar bg-green\" :style=\"[{transform: 'translate3d(-' + (100-loadProgress) + '%, 0px, 0px)'}]\"\u003e\u003c/view\u003e \u003cview class=\"load-progress-spinner text-green\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cscript\u003e export default{ data(){ return{ loadProgress:0 } }, methods:{ LoadProgress(e) { this.loadProgress = this.loadProgress + 3; if (this.loadProgress \u003c 100) { setTimeout(() =\u003e { this.LoadProgress(); }, 100) } else { this.loadProgress = 0; } } } } \u003c/script\u003e 加载相关class class说明可选值cu-load加载必选值（除了进度条加载）——loading加载中——over加载完成——erro加载失败——load-modal弹框加载——load-progress设置进度条加载——load-progress-bar进度条加载样式——load-progress-spinner旋转加载样式——hide隐藏——show显示—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:10","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"交互组件 这篇博客太长了，交互组件的介绍就另写一篇吧，ColorUI组件库简易教程之交互组件 这只是个人的理解写的，有什么不足，望大佬指教，及时更正！ ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:4:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 官方示例在此！！！官方示例在此！！！官方示例在此！！！ 这主要是基于uni-app开发的，所以，请多看uni-app文档，了解一些标签、属性，可以更好的使用该组件 目录 [TOC] ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:0:0","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"交互组件 ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:0","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Bar操作条 底部操作条 我们可以使用Bar操作条自定义小程序底部的tabBar，就拿官方示例代码来说吧。 当我们要自定义tabBar的时候，pages.json文件中的tabBar配置就不写了，直接在首页上代码，pages.json文件中的pages数组中第一项表示应用启动页，即首页。示例中通过变量PageCur来切换不同tabBar页面，控制tabBar图标文字的样式切换。 底部操作条包括底部的tabBar和商场小程序加入购物车的操作条，底部操作条中cu-bar和tabbar是必备的class，foot则设置该操作条固定在页面底部。 \u003ctemplate\u003e \u003cview\u003e \u003cbasics v-if=\"PageCur=='basics'\"\u003e\u003c/basics\u003e \u003ccomponents v-if=\"PageCur=='component'\"\u003e\u003c/components\u003e \u003cplugin v-if=\"PageCur=='plugin'\"\u003e\u003c/plugin\u003e \u003cview class=\"cu-bar tabbar bg-white shadow foot\"\u003e \u003cview class=\"action\" @click=\"NavChange\" data-cur=\"basics\"\u003e \u003cview class='cuIcon-cu-image'\u003e \u003cimage :src=\"'/static/tabbar/basics' + [PageCur=='basics'?'_cur':''] + '.png'\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview :class=\"PageCur=='basics'?'text-green':'text-gray'\"\u003e元素\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\" @click=\"NavChange\" data-cur=\"component\"\u003e \u003cview class='cuIcon-cu-image'\u003e \u003cimage :src=\"'/static/tabbar/component' + [PageCur == 'component'?'_cur':''] + '.png'\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview :class=\"PageCur=='component'?'text-green':'text-gray'\"\u003e组件\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\" @click=\"NavChange\" data-cur=\"plugin\"\u003e \u003cview class='cuIcon-cu-image'\u003e \u003cimage :src=\"'/static/tabbar/plugin' + [PageCur == 'plugin'?'_cur':''] + '.png'\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview :class=\"PageCur=='plugin'?'text-green':'text-gray'\"\u003e扩展\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { PageCur: 'basics' } }, methods: { NavChange: function(e) { this.PageCur = e.currentTarget.dataset.cur } } } \u003c/script\u003e 操作条中的图标，可以是自定义引入的图片，也可以是这个组件中的图标，加角标就是上一章在基础元素中介绍的标签组件cu-tag、badge，背景颜色以及文字图标颜色都可以添加相应的颜色class进行自定义 \u003cview class=\"cu-bar tabbar bg-white\"\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cu-image\"\u003e \u003cimage src=\"/static/tabbar/basics_cur.png\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"text-green\"\u003e元素\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cu-image\"\u003e \u003cimage src=\"/static/tabbar/component.png\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"text-gray\"\u003e组件\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cu-image\"\u003e \u003cimage src=\"/static/tabbar/plugin.png\"\u003e\u003c/image\u003e \u003cview class=\"cu-tag badge\"\u003e99\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray\"\u003e扩展\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cu-image\"\u003e \u003cimage src=\"/static/tabbar/about.png\"\u003e\u003c/image\u003e \u003cview class=\"cu-tag badge\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray\"\u003e关于\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-bar tabbar margin-bottom-xl bg-black\"\u003e \u003cview class=\"action text-orange\"\u003e \u003cview class=\"cuIcon-homefill\"\u003e\u003c/view\u003e 首页 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-similar\"\u003e\u003c/view\u003e 分类 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-recharge\"\u003e\u003c/view\u003e 积分 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-cart\"\u003e \u003cview class=\"cu-tag badge\"\u003e99\u003c/view\u003e \u003c/view\u003e 购物车 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-my\"\u003e \u003cview class=\"cu-tag badge\"\u003e\u003c/view\u003e \u003c/view\u003e 我的 \u003c/view\u003e \u003c/view\u003e  这种操作条就是中间设置了一个midButton，只需在中间的view上添加class add-action，其他设置同上，不赘述 \u003cview class=\"cu-bar tabbar margin-bottom-xl bg-white\"\u003e \u003cview class=\"action text-green\"\u003e \u003cview class=\"cuIcon-homefill\"\u003e\u003c/view\u003e 首页 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-similar\"\u003e\u003c/view\u003e 分类 \u003c/view\u003e \u003cview class=\"action text-gray add-action\"\u003e \u003cbutton class=\"cu-btn cuIcon-add bg-green shadow\"\u003e\u003c/button\u003e 发布 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-cart\"\u003e \u003cview class=\"cu-tag badge\"\u003e99\u003c/view\u003e \u003c/view\u003e 购物车 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-my\"\u003e \u003cview class=\"cu-tag badge\"\u003e\u003c/view\u003e \u003c/view\u003e 我的 \u003c/view\u003e \u003c/view\u003e 加入购物车的操作条增加了shop类名，但是我不清楚，加不加shop有什么区别，我删了他，样式好像也没变，有大佬懂得望指教。submit类名用于加入购物车和立即购买等操作，样式可以撑开占满。  \u003cview class=\"cu-bar bg-white tabbar border shop\"\u003e \u003cbutton class=\"action\" open-type=\"contact\"\u003e \u003cview class=\"cuIcon-service text-green\"\u003e \u003cview class=\"cu-tag badge\"\u003e\u003c/view\u003e \u003c/view\u003e 客服 \u003c/button\u003e \u003cview class=\"action text-orange\"\u003e \u003cview class=\"cuIcon-favorfill\"\u003e\u003c/view\u003e 已收藏 \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cart\"\u003e \u003cview class=\"cu-tag badge\"\u003e99\u003c/view\u003e \u003c/view\u003e 购物车 \u003c/view\u003e \u003cview class=\"bg-red submit\"\u003e立即订购\u003c/view\u003e \u003c/view\u003e 这种样式就是把","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:1","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Nav导航栏 nav导航栏是结合uni-app的scroll-view标签设计出来的，使用的时候一些属性可以参考一下uni-app的文档https://uniapp.dcloud.io/component/scroll-view，类名nav和cu-item是必选值 默认 不知道咋解释，看代码很简单，就是通过index值进行切换每个tab，及其字体边框样式，我就不赘述了 \u003cscroll-view scroll-x class=\"bg-white nav\" scroll-with-animation :scroll-left=\"scrollLeft\"\u003e \u003cview class=\"cu-item\" :class=\"index==TabCur?'text-green cur':''\" v-for=\"(item,index) in 10\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/scroll-view\u003e \u003cscript\u003e export default { data() { return { TabCur: 0, scrollLeft: 0 }; }, methods: { tabSelect(e) { this.TabCur = e.currentTarget.dataset.id; this.scrollLeft = (e.currentTarget.dataset.id - 1) * 60 } } } \u003c/script\u003e 居中 通过text-center居中 \u003cscroll-view scroll-x class=\"bg-white nav text-center\"\u003e \u003cview class=\"cu-item\" :class=\"index==TabCur?'text-blue cur':''\" v-for=\"(item,index) in 3\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/scroll-view\u003e 平分 设置flex和flex-sub实现弹性布局，flex-sub就是css属性flex:1，将弹性盒子内子元素按照1:1:1:1来分配空间   \u003cscroll-view scroll-x class=\"bg-white nav\"\u003e \u003cview class=\"flex text-center\"\u003e \u003cview class=\"cu-item flex-sub\" :class=\"index==TabCur?'text-orange cur':''\" v-for=\"(item,index) in 4\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/view\u003e \u003c/scroll-view\u003e 背景  bg-{{color}}，参考背景色   \u003cscroll-view scroll-x class=\"bg-red nav text-center\"\u003e \u003cview class=\"cu-item\" :class=\"index==TabCur?'text-white cur':''\" v-for=\"(item,index) in 3\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/scroll-view\u003e 图标  cuIcon-{{icon}}，参考图标   \u003cscroll-view scroll-x class=\"bg-green nav text-center\"\u003e \u003cview class=\"cu-item\" :class=\"0==TabCur?'text-white cur':''\" @tap=\"tabSelect\" data-id=\"0\"\u003e \u003ctext class=\"cuIcon-camerafill\"\u003e\u003c/text\u003e 数码 \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"1==TabCur?'text-white cur':''\" @tap=\"tabSelect\" data-id=\"1\"\u003e \u003ctext class=\"cuIcon-upstagefill\"\u003e\u003c/text\u003e 排行榜 \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"2==TabCur?'text-white cur':''\" @tap=\"tabSelect\" data-id=\"2\"\u003e \u003ctext class=\"cuIcon-clothesfill\"\u003e\u003c/text\u003e 皮肤 \u003c/view\u003e \u003c/scroll-view\u003e 导航栏相关class class说明可选值nav导航栏必选值——cu-item导航栏子元素——flexflex布局——flex-subflex:1，平分——text-center居中—— ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:2","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"List列表 cu-list和cu-item配合使用 宫格列表 宫格列表就是列表结合grid布局设计出的样式，通过col-{{number}}设置每行的个数，number取值1~5，默认有边框，可以加类名no-border去除边框 \u003cview class=\"cu-list grid\" :class=\"['col-' + gridCol,gridBorder?'':'no-border']\"\u003e \u003cview class=\"cu-item\" v-for=\"(item,index) in cuIconList\" :key=\"index\" v-if=\"index\u003cgridCol*2\"\u003e \u003cview :class=\"['cuIcon-' + item.cuIcon,'text-' + item.color]\"\u003e \u003cview class=\"cu-tag badge\" v-if=\"item.badge!=0\"\u003e \u003cblock v-if=\"item.badge!=1\"\u003e{{item.badge\u003e99?'99+':item.badge}}\u003c/block\u003e \u003c/view\u003e \u003c/view\u003e \u003ctext\u003e{{item.name}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e data() { return { cuIconList: [{cuIcon: 'cardboardfill',color: 'red',badge: 120,name: 'VR'}, {cuIcon: 'recordfill',color: 'orange',badge: 1,name: '录像'}, {cuIcon: 'picfill',color: 'yellow',badge: 0,name: '图像'}, {cuIcon: 'noticefill',color: 'olive',badge: 22,name: '通知'}, {cuIcon: 'upstagefill',color: 'cyan',badge: 0,name: '排行榜' }, {cuIcon: 'clothesfill',color: 'blue',badge: 0,name: '皮肤'}, {cuIcon: 'discoverfill',color: 'purple',badge: 0,name: '发现'}, {cuIcon: 'questionfill',color: 'mauve',badge: 0,name: '帮助'}, {cuIcon: 'commandfill',color: 'purple',badge: 0,name: '问答'}, {cuIcon: 'brandfill',color: 'mauve',badge: 0,name: '版权'}], gridCol: 3, gridBorder: false }; }, 菜单列表 菜单列表就是列表结合类名menu设计出的样式，可以通过sm-border设置每一行的短边框，通过card-menu将列表设置成卡片样式，通过在列表子元素上添加arrow设置箭头，变化样式效果可以由以下两图对比 \u003cview class=\"cu-list menu\" :class=\"[menuBorder?'sm-border':'',menuCard?'card-menu margin-top':'']\"\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-circlefill text-grey\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e图标 + 标题\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003cimage src=\"/static/logo.png\" class=\"png\" mode=\"aspectFit\"\u003e\u003c/image\u003e \u003ctext class=\"text-grey\"\u003e图片 + 标题\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cbutton class=\"cu-btn content\" open-type=\"contact\"\u003e \u003ctext class=\"cuIcon-btn text-olive\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003eOpen-type 按钮\u003c/text\u003e \u003c/button\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cnavigator class=\"content\" hover-class=\"none\" url=\"../list/list\" open-type=\"redirect\"\u003e \u003ctext class=\"cuIcon-discoverfill text-orange\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003eNavigator 跳转\u003c/text\u003e \u003c/navigator\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-emojiflashfill text-pink\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e头像组\u003c/text\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cu-avatar-group\"\u003e \u003cview class=\"cu-avatar round sm\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar round sm\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81005.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar round sm\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big25002.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar round sm\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big91012.jpg);\"\u003e\u003c/view\u003e \u003c/view\u003e \u003ctext class=\"text-grey text-sm\"\u003e4 人\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-btn text-green\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e按钮\u003c/text\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn round bg-green shadow\"\u003e \u003ctext class=\"cuIcon-upload\"\u003e\u003c/text\u003e 上传\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-tagfill text-red margin-right-xs\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e标签\u003c/text\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cu-tag round bg-orange light\"\u003e音乐\u003c/view\u003e \u003cview class=\"cu-tag round bg-olive light\"\u003e电影\u003c/view\u003e \u003cview class=\"cu-tag round bg-blue light\"\u003e旅行\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-warn text-green\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e文本\u003c/text\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"text-grey text-sm\"\u003e小目标还没有实现！\u003c/","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:3","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Card卡片 cu-card卡片必选值 案例类卡片 cu-card和case结合，在配合子元素的cu-item类名，写出案例类的样式，内部其他样式可以根据其他类名自行设置，cu-item自带margin:30px;可以通过类名no-card去除 \u003cview class=\"cu-card case\" :class=\"isCard?'no-card':''\"\u003e \u003cview class=\"cu-item shadow\"\u003e \u003cview class=\"image\"\u003e \u003cimage src=\"https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg\" mode=\"widthFix\"\u003e\u003c/image\u003e \u003cview class=\"cu-tag bg-blue\"\u003e史诗\u003c/view\u003e \u003cview class=\"cu-bar bg-shadeBottom\"\u003e \u003ctext class=\"text-cut\"\u003e我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。\u003c/text\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-list menu-avatar\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content flex-sub\"\u003e \u003cview class=\"text-grey\"\u003e正义天使 凯尔\u003c/view\u003e \u003cview class=\"text-gray text-sm flex justify-between\"\u003e 十天前 \u003cview class=\"text-gray text-sm\"\u003e \u003ctext class=\"cuIcon-attentionfill margin-lr-xs\"\u003e\u003c/text\u003e 10 \u003ctext class=\"cuIcon-appreciatefill margin-lr-xs\"\u003e\u003c/text\u003e 20 \u003ctext class=\"cuIcon-messagefill margin-lr-xs\"\u003e\u003c/text\u003e 30 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 动态类卡片 该样式类似于QQ动态，由cu-card和dynamic结合，再配合子元素cu-item编写而成，动态下方的评论需要添加类名comment \u003cview class=\"cu-card dynamic\" :class=\"isCard?'no-card':''\"\u003e \u003cview class=\"cu-item shadow\"\u003e \u003cview class=\"cu-list menu-avatar\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content flex-sub\"\u003e \u003cview\u003e凯尔\u003c/view\u003e \u003cview class=\"text-gray text-sm flex justify-between\"\u003e 2019年12月3日 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-content\"\u003e 折磨生出苦难，苦难又会加剧折磨，凡间这无穷的循环，将有我来终结！ \u003c/view\u003e \u003cview class=\"grid flex-sub padding-lr\" :class=\"isCard?'col-3 grid-square':'col-1'\"\u003e \u003cview class=\"bg-img \" :class=\"isCard?'':'only-img'\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\" v-for=\"(item,index) in isCard?9:1\" :key=\"index\"\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray text-sm text-right padding\"\u003e \u003ctext class=\"cuIcon-attentionfill margin-lr-xs\"\u003e\u003c/text\u003e 10 \u003ctext class=\"cuIcon-appreciatefill margin-lr-xs\"\u003e\u003c/text\u003e 20 \u003ctext class=\"cuIcon-messagefill margin-lr-xs\"\u003e\u003c/text\u003e 30 \u003c/view\u003e \u003cview class=\"cu-list menu-avatar comment solids-top\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/img/champion/Morgana.png);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e莫甘娜\u003c/view\u003e \u003cview class=\"text-gray text-content text-df\"\u003e 凯尔，你被自己的光芒变的盲目。 \u003c/view\u003e \u003cview class=\"bg-grey padding-sm radius margin-top-sm text-sm\"\u003e \u003cview class=\"flex\"\u003e \u003cview\u003e凯尔：\u003c/view\u003e \u003cview class=\"flex-sub\"\u003e妹妹，你在帮他们给黑暗找借口吗?\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"margin-top-sm flex justify-between\"\u003e \u003cview class=\"text-gray text-df\"\u003e2018年12月4日\u003c/view\u003e \u003cview\u003e \u003ctext class=\"cuIcon-appreciatefill text-red\"\u003e\u003c/text\u003e \u003ctext class=\"cuIcon-messagefill text-gray margin-left-sm\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 文章类卡片  该卡片由cu-card和article结合，再配合子元素cu-item \u003cview class=\"cu-card article\" :class=\"isCard?'no-card':''\"\u003e \u003cview class=\"cu-item shadow\"\u003e \u003cview class=\"title\"\u003e\u003cview class=\"text-cut\"\u003e无意者 烈火焚身;以正义的烈火拔出黑暗。我有自己的正义，见证至高的烈火吧。\u003c/view\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cimage src=\"https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg\" mode=\"aspectFill\"\u003e\u003c/image\u003e \u003cview class=\"desc\"\u003e \u003cview class=\"text-content\"\u003e 折磨生出苦难，苦难又会加剧折磨，凡间这无穷的循环，将有我来终结！真正的恩典因不完整而美丽，因情感而真诚，因脆弱而自由！\u003c/view\u003e \u003cview\u003e \u003cview class=\"cu-tag bg-red light sm round\"\u003e正义天使\u003c/view\u003e \u003cview class=\"cu-tag bg-green light sm round\"\u003e史诗\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 卡片相关class class说明可选值cu-card卡片必选值——case案例类卡片——dynamic动态类卡片——article文章类卡片——comment评论——no-card配合cu-card，去除子元素cu-item的margin和border——desc纵向的flex布局—— ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:4","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Form表单 input输入框 form表单是用form标签包裹，每一个子元素添加类名cu-form-group，行内自定义，title类名用于设置每行的文字说明，如果想统一宽度，像示例一样，需要自定义宽度 \u003cform\u003e \u003cview class=\"cu-form-group margin-top\"\u003e \u003cview class=\"title\"\u003e邮件\u003c/view\u003e \u003cinput placeholder=\"两字短标题\" name=\"input\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e输入框\u003c/view\u003e \u003cinput placeholder=\"三字标题\" name=\"input\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e收货地址\u003c/view\u003e \u003cinput placeholder=\"统一标题的宽度\" name=\"input\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e收货地址\u003c/view\u003e \u003cinput placeholder=\"输入框带个图标\" name=\"input\"\u003e\u003c/input\u003e \u003ctext class='cuIcon-locationfill text-orange'\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e验证码\u003c/view\u003e \u003cinput placeholder=\"输入框带个按钮\" name=\"input\"\u003e\u003c/input\u003e \u003cbutton class='cu-btn bg-green shadow'\u003e验证码\u003c/button\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e手机号码\u003c/view\u003e \u003cinput placeholder=\"输入框带标签\" name=\"input\"\u003e\u003c/input\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class='cu-tag bg-blue '\u003e+86\u003c/view\u003e \u003cview class=\"cu-tag line-blue\"\u003e中国大陆\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/form\u003e \u003cstyle\u003e .cu-form-group .title { min-width: calc(4em + 15px); } \u003c/style\u003e picker选择器  对于表单中从底部谈起的选择器，写法与上述简单的input相同，而选择器picker的使用，建议查看官方文档 \u003cform\u003e \u003cview class=\"cu-form-group margin-top\"\u003e \u003cview class=\"title\"\u003e普通选择\u003c/view\u003e \u003cpicker @change=\"PickerChange\" :value=\"index\" :range=\"picker\"\u003e \u003cview class=\"picker\"\u003e {{index\u003e-1?picker[index]:'禁止换行，超出容器部分会以 ... 方式截断'}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003c!-- #ifndef MP-ALIPAY --\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e多列选择\u003c/view\u003e \u003cpicker mode=\"multiSelector\" @change=\"MultiChange\" @columnchange=\"MultiColumnChange\" :value=\"multiIndex\" :range=\"multiArray\"\u003e \u003cview class=\"picker\"\u003e {{multiArray[0][multiIndex[0]]}}，{{multiArray[1][multiIndex[1]]}}，{{multiArray[2][multiIndex[2]]}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003c!-- #endif --\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e时间选择\u003c/view\u003e \u003cpicker mode=\"time\" :value=\"time\" start=\"09:01\" end=\"21:01\" @change=\"TimeChange\"\u003e \u003cview class=\"picker\"\u003e {{time}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e日期选择\u003c/view\u003e \u003cpicker mode=\"date\" :value=\"date\" start=\"2015-09-01\" end=\"2020-09-01\" @change=\"DateChange\"\u003e \u003cview class=\"picker\"\u003e {{date}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003c!-- #ifndef H5 || APP-PLUS || MP-ALIPAY --\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e地址选择\u003c/view\u003e \u003cpicker mode=\"region\" @change=\"RegionChange\" :value=\"region\"\u003e \u003cview class=\"picker\"\u003e {{region[0]}}，{{region[1]}}，{{region[2]}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003c!-- #endif --\u003e \u003c/form\u003e switch开关 对于开关的样式，参考switch官方文档，需要注意的阿里小程序的不同，我没有用阿里测试，我测的是微信小程序，在微信小程序上，switch的color属性不生效，想要更改开关颜色，可以用颜色类名，直接写颜色就可以，颜色的取值可以参考上一章背景色 \u003cform\u003e \u003cview class=\"cu-form-group margin-top\"\u003e \u003cview class=\"title\"\u003e开关选择\u003c/view\u003e \u003cswitch @change=\"SwitchA\" :class=\"switchA?'checked':''\" :checked=\"switchA?true:false\"\u003e\u003c/switch\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e定义颜色\u003c/view\u003e \u003c!-- #ifdef MP-ALIPAY --\u003e \u003cswitch class='red' @change=\"SwitchB\" :class=\"switchB?'checked':''\" :checked=\"switchB?true:false\" color=\"#e54d42\"\u003e\u003c/switch\u003e \u003c!-- #endif --\u003e \u003c!-- #ifndef MP-ALIPAY --\u003e \u003cswitch class='red' @change=\"SwitchB\" :class=\"switchB?'checked':''\" :checked=\"switchB?true:false\"\u003e\u003c/switch\u003e \u003c!-- #endif --\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e定义图标\u003c/view\u003e \u003cswitch class='switch-sex' @change=\"SwitchC\" :class=\"switchC?'checked':''\" :checked=\"switchC?true:false\"\u003e\u003c/switch\u003e \u003c/view\u003e \u003c!-- #ifndef MP-ALIPAY --\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e方形开关\u003c/view\u003e \u003cswitch class='orange radius' @change=\"SwitchD\" :class=\"switchD?'checked':''\" :checked=\"switchD?true:false\"\u003e\u003c/switch\u003e \u003c/view\u003e \u003c!-- #endif --\u003e \u003c/form\u003e radio单选框 radio官方文档先奉上，更改颜色同上，使用提供的颜色类名即可，其默认样式是圆形全色中间有个√，可以通过类名radio更改形状为镂空中间一个点 \u003cform\u003e \u003cradio-group class=\"block\" @change=\"RadioChange\"\u003e \u003cview class=\"cu-form-group margin-top\"\u003e \u003cview class=\"title\"\u003e单选操作(radio)\u003c/view\u003e \u003cradio :class=\"radio=='A'?'checked':''\" :checked=\"radio=='A'?true:false\" value=\"A\"\u003e\u003c/radio\u003e \u003c/view\u003e \u003c!-- #ifndef MP-ALIPAY --\u003e \u003cview class=\"cu","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:5","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"TimeLine时间轴 默认 时间轴默认结构如下代码，由cu-timeline包裹cu-time和cu-item，在item内编写内容，由content包裹 \u003cview class=\"cu-timeline\"\u003e \u003cview class=\"cu-time\"\u003e06-17\u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"content\"\u003e \u003ctext\u003e01:30\u003c/text\u003e 【喵星】 MX-12138 已揽收，准备发往银河系 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 多彩时间轴 这个与默认的基本格式相同，只是自定义了内容框颜色和图标，结合基础元素的样式，你可以写个彩虹 \u003cview class=\"cu-timeline\"\u003e \u003cview class=\"cu-time\"\u003e昨天\u003c/view\u003e \u003cview class=\"cu-item cur cuIcon-noticefill\"\u003e \u003cview class=\"content bg-green shadow-blur\"\u003e \u003ctext\u003e22:22\u003c/text\u003e 【广州市】快件已到达地球 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-red cuIcon-attentionforbidfill\"\u003e \u003cview class=\"content bg-red shadow-blur\"\u003e 这是第一次，我家的铲屎官走了这么久。久到足足有三天！！ \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-grey cuIcon-evaluate_fill\"\u003e \u003cview class=\"content bg-grey shadow-blur\"\u003e 这是第一次，我家的铲屎官走了这么久。 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-blue\"\u003e \u003cview class=\"bg-blue content\"\u003e \u003ctext\u003e20:00\u003c/text\u003e 【月球】快件已到达月球，准备发往地球 \u003c/view\u003e \u003cview class=\"bg-cyan content\"\u003e \u003ctext\u003e10:00\u003c/text\u003e 【银河系】快件已到达银河系，准备发往月球 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 自定义 上一个是简单的修改了颜色图标，这一个则是稍微复杂一点，结合之前的标签、列表等，丰富了内容 \u003cview class=\"cu-timeline\"\u003e \u003cview class=\"cu-time\"\u003e06-17\u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"content\"\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class=\"cu-tag bg-cyan\"\u003e上午\u003c/view\u003e \u003cview class=\"cu-tag line-cyan\"\u003e10:00\u003c/view\u003e \u003c/view\u003e \u003cview class=\"margin-top\"\u003e这是第一次，我家的铲屎官走了这么久。久到足足有三天！！ 在听到他的脚步声响在楼梯间的那一刻，我简直想要破门而出，对着他狠狠地吼上10分钟，然后再看心情要不要他进门。\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-blue\"\u003e \u003cview class=\"bg-blue shadow-blur content\"\u003e \u003cview class=\"cu-list menu-avatar radius\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e文晓港\u003c/view\u003e \u003cview class=\"text-gray text-sm\"\u003e \u003ctext class=\"cuIcon-infofill text-red\"\u003e\u003c/text\u003e 消息未送达\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cu-tag round bg-grey sm\"\u003e5\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\"\u003e \u003cview class=\"cu-tag badge\"\u003e99+\u003c/view\u003e \u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e文晓港 \u003cview class=\"cu-tag round orange sm\"\u003eSVIP\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray text-sm\"\u003e \u003ctext class=\"cuIcon-redpacket_fill text-red\"\u003e\u003c/text\u003e 收到红包\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003ctext class=\"cuIcon-notice_forbid_fill text-gray\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 时间轴相关class class说明可选值cu-timeline时间轴必选值——cu-time时间——cu-item子元素——content内容信息—— ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:6","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Chat聊天 cu-chat聊天必选值 基本样式 聊天的外部大框架是cu-chat，cu-item包裹某人的聊天信息，self表示右侧自己的聊天样式，main包含聊天内容，date表示消息时间，cu-info表示提示词 \u003cview class=\"cu-chat\"\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cview class=\"content bg-green shadow\"\u003e \u003ctext\u003e喵喵喵！喵喵喵！喵喵喵！喵喵！喵喵！！喵！喵喵喵！\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big107000.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"date\"\u003e2018年3月23日 13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-info round\"\u003e对方撤回一条消息!\u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big143004.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"main\"\u003e \u003cview class=\"content shadow\"\u003e \u003ctext\u003e喵喵喵！喵喵喵！\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"date \"\u003e 13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-info\"\u003e \u003ctext class=\"cuIcon-roundclosefill text-red \"\u003e\u003c/text\u003e 对方拒绝了你的消息 \u003c/view\u003e \u003cview class=\"cu-info\"\u003e 对方开启了好友验证，你还不是他(她)的好友。请先发送好友验证请求，对方验证通过后，才能聊天。 \u003ctext class=\"text-blue\"\u003e发送好友验证\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 其他聊天内容 聊天内容除了语句，还有图片，语音消息，地理位置消息等 ，main包含的聊天内容不止是消息框里的，还有消息框旁边的提示图标文字等，消息框里的内容由content包裹 \u003cview class=\"cu-chat\"\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cimage src=\"https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg\" class=\"radius\" mode=\"widthFix\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big107000.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"date\"\u003e 13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cview class=\"action text-bold text-grey\"\u003e 3\" \u003c/view\u003e \u003cview class=\"content shadow\"\u003e \u003ctext class=\"cuIcon-sound text-xxl padding-right-xl\"\u003e \u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big107000.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"date\"\u003e13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-locationfill text-orange text-xxl\"\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class=\"content shadow\"\u003e 喵星球，喵喵市 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big107000.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"date\"\u003e13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big143004.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"main\"\u003e \u003cview class=\"content shadow\"\u003e @#$^\u0026** \u003c/view\u003e \u003cview class=\"action text-grey\"\u003e \u003ctext class=\"cuIcon-warnfill text-red text-xxl\"\u003e\u003c/text\u003e \u003ctext class=\"text-sm margin-left-sm\"\u003e翻译错误\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"date\"\u003e13:23\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 发送框 发送框就是之前的操作条，相关内容看最上面操作条的讲解   \u003cview class=\"cu-bar foot input\" :style=\"[{bottom:InputBottom+'px'}]\"\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-sound text-grey\"\u003e\u003c/text\u003e \u003c/view\u003e \u003cinput class=\"solid-bottom\" :adjust-position=\"false\" :focus=\"false\" maxlength=\"300\" cursor-spacing=\"10\" @focus=\"InputFocus\" @blur=\"InputBlur\"\u003e\u003c/input\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-emojifill text-grey\"\u003e\u003c/text\u003e \u003c/view\u003e \u003cbutton class=\"cu-btn bg-green shadow\"\u003e发送\u003c/button\u003e \u003c/view\u003e 聊天相关class class说明可选值cu-chat聊天必选值——cu-item子元素——self右侧本人的聊天样式——main聊天内容——content消息框内容——date消息日期——cu-info提示词—— ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:7","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Swiper轮播图 全屏限高轮播 这是最常见的轮播图，添加类名screen-swiper，宽度为全屏，高度自定义，请直接参考swiper官方文档，可以通过类名square-dot和round-dot定义小圆点样式   \u003ctemplate\u003e \u003cview\u003e \u003cswiper class=\"screen-swiper\" :class=\"dotStyle?'square-dot':'round-dot'\" :indicator-dots=\"true\" :circular=\"true\" :autoplay=\"true\" interval=\"5000\" duration=\"500\"\u003e \u003cswiper-item v-for=\"(item,index) in swiperList\" :key=\"index\"\u003e \u003cimage :src=\"item.url\" mode=\"aspectFill\" v-if=\"item.type=='image'\"\u003e\u003c/image\u003e \u003cvideo :src=\"item.url\" autoplay loop muted :show-play-btn=\"false\" :controls=\"false\" objectFit=\"cover\" v-if=\"item.type=='video'\"\u003e\u003c/video\u003e \u003c/swiper-item\u003e \u003c/swiper\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { swiperList: [{ id: 0, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big84000.jpg' }, { id: 1, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big37006.jpg', }, { id: 2, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big39000.jpg' }, { id: 3, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg' }], dotStyle: true }; } } \u003c/script\u003e 卡片式轮播 在swiper标签上添加类名card-swiper，在swiper-item标签内的子元素上添加类名swiper-item，示例中cardSwiper函数的主要作用是切换类名cur，cur的作用是实现轮播图片中间大，两边小的效果，就是transform的scale()   \u003cswiper class=\"card-swiper\" :class=\"dotStyle?'square-dot':'round-dot'\" :indicator-dots=\"true\" :circular=\"true\" :autoplay=\"true\" interval=\"5000\" duration=\"500\" @change=\"cardSwiper\" indicator-color=\"#8799a3\" indicator-active-color=\"#0081ff\"\u003e \u003cswiper-item v-for=\"(item,index) in swiperList\" :key=\"index\" :class=\"cardCur==index?'cur':''\"\u003e \u003cview class=\"swiper-item\"\u003e \u003cimage :src=\"item.url\" mode=\"aspectFill\" v-if=\"item.type=='image'\"\u003e\u003c/image\u003e \u003cvideo :src=\"item.url\" autoplay loop muted :show-play-btn=\"false\" :controls=\"false\" objectFit=\"cover\" v-if=\"item.type=='video'\"\u003e\u003c/video\u003e \u003c/view\u003e \u003c/swiper-item\u003e \u003c/swiper\u003e cardSwiper(e) { this.cardCur = e.detail.current }, 堆叠式轮播 堆叠轮播是原生写的，注意类名tower-swiper、tower-item以及swiper-item的配合使用，这主要是通过层级的高低来显示图片的，使用时需要配合js和css。（这种轮播图初始化展示效果如图二，需要触动一下才会展示如图一的效果，可以通过在onload()函数中给变量direction赋值解决） \u003ctemplate\u003e \u003cview\u003e \u003cview class=\"tower-swiper\" @touchmove=\"TowerMove\" @touchstart=\"TowerStart\" @touchend=\"TowerEnd\"\u003e \u003cview class=\"tower-item\" :class=\"item.zIndex==1?'none':''\" v-for=\"(item,index) in swiperList\" :key=\"index\" :style=\"[{'--index': item.zIndex,'--left':item.mLeft}]\" :data-direction=\"direction\"\u003e \u003cview class=\"swiper-item\"\u003e \u003cimage :src=\"item.url\" mode=\"aspectFill\" v-if=\"item.type=='image'\"\u003e\u003c/image\u003e \u003cvideo :src=\"item.url\" autoplay loop muted :show-play-btn=\"false\" :controls=\"false\" objectFit=\"cover\" v-if=\"item.type=='video'\"\u003e\u003c/video\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { swiperList: [{ id: 0, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big84000.jpg' }, { id: 1, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big37006.jpg', }, { id: 2, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big39000.jpg' }, { id: 3, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg' }, { id: 4, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big25011.jpg' }, { id: 5, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big21016.jpg' }, { id: 6, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big99008.jpg' }], towerStart: 0, direction: '' }; }, onLoad() { this.TowerSwiper('swiperList'); this.direction = 'left'; // 初始化towerSwiper 传已有的数组名即可 }, methods: { // 初始化towerSwiper TowerSwiper(name) { let list = this[name]; console.log(list) for (let i = 0; i \u003c list.length; i++) { list[i].zIndex = parseInt(list.length / 2) + 1 - Math.abs(i - parseInt(list.length / 2)) list[i].mLeft = i - parseInt(list.length / 2) } this.swiperList = list }, // towerSwiper触摸开始 TowerStart(e) { console.log(e) this.towerStart = e.touches[0].pageX }, // towerSwiper计算方向 TowerMove(e) { this.direction = e.touches[0].pageX - this.tow","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:8","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Modal模态框 cu-modal和cu-dialog为模态框必选值，所有模态框的大体框架都是cu-modal包裹cu-dialog，cu-dialog内部填充操作部分和信息展示部分，操作部分可以用cu-bar操作条来布局，信息展示就直接写。弹框的显示隐藏是通过添加或移除类名show来实现的，示例中隐藏弹框是绑定tap调用hideModal事件，hideModal函数内执行的语句就是将变量modalName赋值为null，从而移除类名show，你想让用户点击哪里隐藏弹框，就可以把hideModal事件绑定在哪里（比如设置点击遮罩层隐藏弹框，就把hideModal事件绑定在有类名cu-modal的标签上） 普通窗口 普通窗口就是cu-modal包裹cu-dialog，只做信息的展示，没有交互效果    \u003cview class=\"cu-modal\" :class=\"modalName=='Modal'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"content\"\u003eModal标题\u003c/view\u003e \u003cview class=\"action\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-close text-red\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 底部窗口 cu-modal结合bottom-modal实现底部弹窗    \u003cview class=\"cu-modal bottom-modal\" :class=\"modalName=='bottomModal'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white\"\u003e \u003cview class=\"action text-green\"\u003e确定\u003c/view\u003e \u003cview class=\"action text-blue\" @tap=\"hideModal\"\u003e取消\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 对话窗口 对话窗口相较于普通窗口底部多了一些用户交互的操作    //示例一 \u003cview class=\"cu-modal\" :class=\"modalName=='DialogModal1'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"content\"\u003eModal标题\u003c/view\u003e \u003cview class=\"action\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-close text-red\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn line-green text-green\" @tap=\"hideModal\"\u003e取消\u003c/button\u003e \u003cbutton class=\"cu-btn bg-green margin-left\" @tap=\"hideModal\"\u003e确定\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e //示例二 \u003cview class=\"cu-modal\" :class=\"modalName=='DialogModal2'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"content\"\u003eModal标题\u003c/view\u003e \u003cview class=\"action\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-close text-red\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003cview class=\"cu-bar bg-white\"\u003e \u003cview class=\"action margin-0 flex-sub text-green \" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-moneybag\"\u003e\u003c/text\u003e微信支付\u003c/view\u003e \u003cview class=\"action margin-0 flex-sub text-green solid-left\" @tap=\"hideModal\"\u003e取消\u003c/view\u003e \u003cview class=\"action margin-0 flex-sub solid-left\" @tap=\"hideModal\"\u003e确定\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 图片窗口 图片窗口用于图片的展示，也可自定义操作    \u003cview class=\"cu-modal\" :class=\"modalName=='Image'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"bg-img\" style=\"background-image: url('https://ossweb-img.qq.com/images/lol/web201310/skin/big91012.jpg');height:200px;\"\u003e \u003cview class=\"cu-bar justify-end text-white\"\u003e \u003cview class=\"action\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-close \"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-bar bg-white\"\u003e \u003cview class=\"action margin-0 flex-sub solid-left\" @tap=\"hideModal\"\u003e我知道了\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 单选窗口 单选窗口是普通窗口内部结合radio标签编写的    \u003cview class=\"cu-modal\" :class=\"modalName=='RadioModal'?'show':''\" @tap=\"hideModal\"\u003e \u003cview class=\"cu-dialog\" @tap.stop=\"\"\u003e \u003cradio-group class=\"block\" @change=\"RadioChange\"\u003e \u003cview class=\"cu-list menu text-left\"\u003e \u003cview class=\"cu-item\" v-for=\"(item,index) in 5\" :key=\"index\"\u003e \u003clabel class=\"flex justify-between align-center flex-sub\"\u003e \u003cview class=\"flex-sub\"\u003eItem {{index +1}}\u003c/view\u003e \u003cradio class=\"round\" :class=\"radio=='radio' + index?'checked':''\" :checked=\"radio=='radio' + index?true:false\" :value=\"'radio' + index\"\u003e\u003c/radio\u003e \u003c/label\u003e \u003c/view\u003e \u003c/view\u003e \u003c/radio-group\u003e \u003c/view\u003e \u003c/view\u003e 多选窗口 多选窗口的内容是配合grid布局自定义的   \u003cview class=\"cu-modal bottom-modal\" :class=\"modalName=='ChooseModal'?'show':''\" @tap=\"hideModal\"\u003e \u003cview class=\"cu-dialog\" @tap.stop=\"\"\u003e \u003cview class=\"cu-bar bg-white\"\u003e \u003cview class=\"action text-blue\" @tap=\"hideModal\"\u003e取消\u003c/view\u003e \u003cview class=\"action text-green\" @tap=\"hideModal\"\u003e确定\u003c/view\u003e \u003c/view\u003e \u003cview class=\"grid col-3 padding-sm\"\u003e \u003cview v-for=\"(item,index) in checkbox\" class=\"padding-xs\" :key=\"index\"\u003e \u003cbutton class=\"cu-btn orange lg block\" :class=\"item.checked?'bg-orange':'line-orange'\" @tap=\"ChooseCheckbox\" :data-value=\"item.value\"\u003e {{item.name}}","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:9","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Steps步骤条 cu-steps步骤条必选值  默认  cu-steps和cu-item配合使用   \u003cview class=\"bg-white padding\"\u003e \u003cview class=\"cu-steps\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003ebasics?'':'text-red'\" v-for=\"(item,index) in basicsList\" :key=\"index\"\u003e \u003ctext :class=\"'cuIcon-' + item.cuIcon\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cscript\u003e export default { data() { return { basicsList: [{cuIcon: 'usefullfill',name: '开始'}, {cuIcon: 'radioboxfill',name: '等待'}, {cuIcon: 'roundclosefill',name: '错误'}, {cuIcon: 'roundcheckfill',name: '完成' }], basics: 0 }; }, methods: { BasicsSteps() { this.basics= this.basics == this.basicsList.length - 1 ? 0 : this.basics + 1 } } } \u003c/script\u003e  步骤条的颜色和图标都可以自定义 \u003cview class=\"bg-white padding margin-top-xs\"\u003e \u003cview class=\"cu-steps\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003ebasics?'':'text-orange'\" v-for=\"(item,index) in basicsList\" :key=\"index\"\u003e \u003ctext :class=\"index\u003ebasics?'cuIcon-title':'cuIcon-' + item.cuIcon\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 步骤之间的连接默认是横线，也可以通过类名steps-arrow换成箭头 \u003cview class=\"bg-white padding margin-top-xs\"\u003e \u003cview class=\"cu-steps steps-arrow\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003ebasics?'':'text-blue'\" v-for=\"(item,index) in basicsList\" :key=\"index\"\u003e \u003ctext :class=\"'cuIcon-' + item.cuIcon\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 数字完成 通过类名num可以设置默认图标为数字，已完成且正确的图标为勾，已完成但错误的图标由类名err定义   \u003cview class=\"bg-white padding\"\u003e \u003cview class=\"cu-steps\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003enum?'':'text-blue'\" v-for=\"(item,index) in numList\" :key=\"index\"\u003e \u003ctext class=\"num\" :class=\"index==2?'err':''\" :data-index=\"index + 1\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 多级显示 多级显示需要配合scroll-view标签使用 ，并增加类名steps-bottom   \u003cscroll-view scroll-x class=\"bg-white padding response cu-steps steps-bottom\" :scroll-into-view=\"'scroll-' + scroll\" scroll-with-animation\u003e \u003cview class=\"cu-item padding-lr-xl\" :class=\"index\u003escroll?'':'text-blue'\" v-for=\"(item,index) in 10\" :key=\"index\" :id=\"'scroll-' + index\"\u003e Level {{index + 1}} \u003ctext class=\"num\" :data-index=\"index + 1\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/scroll-view\u003e \u003cscript\u003e export default { data() { return { scroll: 0 }; }, methods: { ScrollSteps() { this.scroll= this.scroll == 9 ? 0 : this.scroll + 1 } } } \u003c/script\u003e 步骤条相关class class说明可选值cu-steps步骤条必选值——cu-item步骤条子元素——num数字步骤条未完成图标——err错误图标——steps-arrow步骤条连接箭头——steps-bottom配合多级步骤条使用（图标在下，文字在上，放在其他步骤条样式会错乱）—— ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:10","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"扩展插件  交互组件就到此为止了，不足之处请多多指教，便于我及时更正，承接上一篇基础元素的博客，扩展插件部分我们就在再另写一篇，ColorUI组件库简易教程之扩展插件 ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:2:0","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 按照惯例，在此奉上官方示例！！！ 目录 [TOC] ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:0:0","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["前端"],"content":"扩展插件  ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:0","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["前端"],"content":"索引列表 索引列表主要由scroll-view标签实现，类名为indexes，具体js逻辑请看源码，有些我没看懂，希望看懂的大佬教教我 \u003ctemplate\u003e \u003cview\u003e \u003cview class=\"cu-bar bg-white search fixed\"\u003e \u003cview class=\"search-form round\"\u003e \u003ctext class=\"cuIcon-search\"\u003e\u003c/text\u003e \u003cinput type=\"text\" placeholder=\"输入搜索的关键词\" confirm-type=\"search\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn bg-gradual-green shadow-blur round\"\u003e搜索\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003cscroll-view scroll-y class=\"indexes\" :scroll-into-view=\"'indexes-'+ listCurID\" :style=\"[{height:'calc(100vh - 50px)'}]\" :scroll-with-animation=\"true\" :enable-back-to-top=\"true\"\u003e \u003cblock v-for=\"(item,index) in list\" :key=\"index\"\u003e \u003c!-- 这个'indexItem-' + item.name类名，整个colorUI，我也没找到它的作用，删了也没发现什么影响--\u003e \u003cview :class=\"'indexItem-' + item.name\" :id=\"'indexes-' + item.name\" :data-index=\"item.name\"\u003e \u003cview class=\"padding\"\u003e{{item.name}}\u003c/view\u003e \u003cview class=\"cu-list menu-avatar no-padding\"\u003e \u003cview class=\"cu-item\" v-for=\"(items,sub) in 2\" :key=\"sub\"\u003e \u003cview class=\"cu-avatar round lg\"\u003e{{item.name}}\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e{{item.name}}\u003ctext class=\"text-abc\"\u003e{{list[sub].name}}\u003c/text\u003e君\u003c/view\u003e \u003cview class=\"text-gray text-sm\"\u003e 有{{sub+2}}个主子需要伺候 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/block\u003e \u003c/scroll-view\u003e \u003cview class=\"indexBar\" :style=\"[{height:'calc(100vh - 50px)'}]\"\u003e \u003cview class=\"indexBar-box\" @touchstart=\"tStart\" @touchend=\"tEnd\" @touchmove.stop=\"tMove\"\u003e \u003cview class=\"indexBar-item\" v-for=\"(item,index) in list\" :key=\"index\" :id=\"index\" @touchstart=\"getCur\" @touchend=\"setCur\"\u003e {{item.name}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c!--选择显示--\u003e \u003cview v-show=\"!hidden\" class=\"indexToast\"\u003e {{listCur}} \u003c/view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { StatusBar: this.StatusBar, CustomBar: this.CustomBar, hidden: true, listCurID: '', list: [], listCur: '', }; }, onLoad() { let list = [{}]; for (let i = 0; i \u003c 26; i++) { list[i] = {}; list[i].name = String.fromCharCode(65 + i); } this.list = list; this.listCur = list[0]; }, onReady() { let that = this; //这两句大概知道什么意思，但是emmm,这个boxTop和barTop具体是什么数值，不是很理解 uni.createSelectorQuery().select('.indexBar-box').boundingClientRect(function(res) { that.boxTop = res.top }).exec(); uni.createSelectorQuery().select('.indexes').boundingClientRect(function(res) { that.barTop = res.top }).exec() }, methods: { //获取文字信息 getCur(e) { this.hidden = false; this.listCur = this.list[e.target.id].name; }, setCur(e) { this.hidden = true; this.listCur = this.listCur }, //滑动选择Item tMove(e) { console.log(this.boxTop) let y = e.touches[0].clientY, offsettop = this.boxTop, that = this; //判断选择区域,只有在选择区才会生效 if (y \u003e offsettop) { // 这个num计算结果怎么就是字母列表的下标呢，我没想明白，望大佬指教 let num = parseInt((y - offsettop) / 20); this.listCur = that.list[num].name }; }, //触发全部开始选择 tStart() { this.hidden = false }, //触发结束选择 tEnd() { this.hidden = true; this.listCurID = this.listCur }, //源码中有这个函数，但是这个页面中根本没有用到，删了没影响，我也不明白作者为什么写这个 indexSelect(e) { let that = this; let barHeight = this.barHeight; let list = this.list; let scrollY = Math.ceil(list.length * e.detail.y / barHeight); for (let i = 0; i \u003c list.length; i++) { if (scrollY \u003c i + 1) { that.listCur = list[i].name; that.movableY = i * 20 return false } } } } } \u003c/script\u003e \u003cstyle\u003e page { padding-top: 100upx; } .indexes { position: relative; } .indexBar { position: fixed; right: 0px; bottom: 0px; padding: 20upx 20upx 20upx 60upx; display: flex; align-items: center; } .indexBar .indexBar-box { width: 40upx; height: auto; background: #fff; display: flex; flex-direction: column; box-shadow: 0 0 20upx rgba(0, 0, 0, 0.1); border-radius: 10upx; } .indexBar-item { flex: 1; width: 40upx; height: 40upx; display: flex; align-items: center; justify-content: center; font-size: 24upx; color: #888; } movable-view.indexBar-item { width: 40upx; height: 40upx; z-index: 9; position: relative; } movable-view.indexBar-item::before { content: \"\"; display: block; position: absolute; left: 0; top: 10upx; height: 20upx; width: 4upx; background-color: #f37b1d; } .indexToast { position: fixed; top: 0; right: 80upx; bottom: 0; bac","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:1","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["前端"],"content":"微动画 微动画我没办法截图展示出来这种动态效果，我就直接给出class了，想要看效果，可以去官方示例去看，这里有几个gif动画，我可以给个图和代码，看一下 \u003cview class=\"margin radius bg-gradual-green shadow-blur\"\u003e \u003c!-- 这个动图显示不出来，不知道是不是路径问题，还是源文件没了 --\u003e \u003cimage src=\"https://image.weilanwl.com/gif/wave.gif\" mode=\"scaleToFill\" class=\"gif-black response\" style=\"height:100upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"margin flex\"\u003e \u003cview class=\"bg-black flex-sub margin-right radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-black.gif\" mode=\"aspectFit\" class=\"gif-black response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"bg-white flex-sub radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-white.gif\" mode=\"aspectFit\" class=\"gif-white response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"margin flex\"\u003e \u003cview class=\"bg-gradual-blue flex-sub margin-right radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/rhomb-black.gif\" mode=\"aspectFit\" class=\"gif-black response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"bg-white flex-sub radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/rhomb-white.gif\" mode=\"aspectFit\" class=\"gif-white response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"margin flex\"\u003e \u003cview class=\"bg-white flex-sub margin-right radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-1.gif\" mode=\"aspectFit\" class=\"gif-white response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"bg-black flex-sub radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-2.gif\" mode=\"aspectFit\" class=\"gif-black response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003c/view\u003e 微动画相关class class说明可选值animation-{{options}}动画效果fade / scale-up / scale-down / slide-top / slide-bottom / slide-left / slide-right / shakeanimation-reverse反向动画，配合上面的动画效果使用  ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:2","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["前端"],"content":"全屏抽屉  全屏抽屉效果主要分为三个部分，主要有三个类名，第一个类名DrawerPage，就是第一张图总体外部包裹的类名；第二个类名DrawerClose，用来包裹打开抽屉之后关闭部分，如图二红框框出来的部分；第三个类名DrawerWindow，就是打开的抽屉部分了   \u003ctemplate\u003e \u003cview class=\"bg-gradual-blue\"\u003e //全屏主体页面 \u003cscroll-view scroll-y class=\"DrawerPage\" :class=\"modalName=='viewModal'?'show':''\"\u003e \u003ccu-custom bgColor=\"bg-gradual-blue\" :isBack=\"true\"\u003e\u003cblock slot=\"backText\"\u003e返回\u003c/block\u003e \u003cblock slot=\"content\"\u003e全屏抽屉\u003c/block\u003e \u003c/cu-custom\u003e \u003cview class='padding margin text-center'\u003e \u003cview class='cu-btn bg-green lg block shadow radius margin-xl' @tap=\"showModal\" data-target=\"viewModal\"\u003e 打开抽屉 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-list menu card-menu margin-top-xl margin-bottom-xl shadow-lg\"\u003e \u003cview class=\"cu-item arrow\" v-for=\"(item,index) in 20\" :key=\"index\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-github text-grey\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e{{index +1}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class='padding margin text-center'\u003e \u003cview class='cu-btn bg-green lg block shadow radius margin-xl' @tap=\"showModal\" data-target=\"viewModal\"\u003e 打开抽屉 \u003c/view\u003e \u003c/view\u003e \u003c/scroll-view\u003e //关闭部分 \u003cview class=\"DrawerClose\" :class=\"modalName=='viewModal'?'show':''\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-pullright\"\u003e\u003c/text\u003e \u003c/view\u003e //抽屉部分 \u003cscroll-view scroll-y class=\"DrawerWindow\" :class=\"modalName=='viewModal'?'show':''\"\u003e \u003cview class=\"cu-list menu card-menu margin-top-xl margin-bottom-xl shadow-lg\"\u003e \u003cview class=\"cu-item arrow\" v-for=\"(item,index) in 20\" :key=\"index\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-github text-grey\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e{{index +1}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/scroll-view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { modalName:null }; }, methods: { showModal(e) { console.log(e) this.modalName = e.currentTarget.dataset.target }, hideModal(e) { this.modalName = null }, //这个函数没用到，我也不知道为什么源码作者写了 tabSelect(e) { this.TabCur = e.currentTarget.dataset.id; this.scrollLeft = (e.currentTarget.dataset.id - 1) * 60 } }, } \u003c/script\u003e \u003cstyle\u003e page { background-image: var(--gradualBlue); width: 100vw; overflow: hidden; } .DrawerPage { position: fixed; width: 100vw; height: 100vh; left: 0vw; background-color: #f1f1f1; transition: all 0.4s; } .DrawerPage.show { transform: scale(0.9, 0.9); left: 85vw; box-shadow: 0 0 60upx rgba(0, 0, 0, 0.2); transform-origin: 0; } .DrawerWindow { position: absolute; width: 85vw; height: 100vh; left: 0; top: 0; transform: scale(0.9, 0.9) translateX(-100%); opacity: 0; pointer-events: none; transition: all 0.4s; padding: 100upx 0; } .DrawerWindow.show { transform: scale(1, 1) translateX(0%); opacity: 1; pointer-events: all; } .DrawerClose { position: absolute; width: 40vw; height: 100vh; right: 0; top: 0; color: transparent; padding-bottom: 30upx; display: flex; align-items: flex-end; justify-content: center; background-image: linear-gradient(90deg, rgba(0, 0, 0, 0.01), rgba(0, 0, 0, 0.6)); letter-spacing: 5px; font-size: 50upx; opacity: 0; pointer-events: none; transition: all 0.4s; } .DrawerClose.show { opacity: 1; pointer-events: all; width: 15vw; color: #fff; } .DrawerPage .cu-bar.tabbar .action button.cuIcon { width: 64upx; height: 64upx; line-height: 64upx; margin: 0; display: inline-block; } .DrawerPage .cu-bar.tabbar .action .cu-avatar { margin: 0; } .DrawerPage .nav { flex: 1; } .DrawerPage .nav .cu-item.cur { border-bottom: 0; position: relative; } .DrawerPage .nav .cu-item.cur::after { content: \"\"; width: 10upx; height: 10upx; background-color: currentColor; position: absolute; bottom: 10upx; border-radius: 10upx; left: 0; right: 0; margin: auto; } .DrawerPage .cu-bar.tabbar .action { flex: initial; } \u003c/style\u003e ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:3","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["前端"],"content":"垂直导航 垂直导航主要有两个scroll-view标签实现，分别是左侧的导航栏部分和右侧的内容部分，左侧导航栏部分使用类名VerticalBox，右侧内容部分使用类名VerticalMain  \u003ctemplate\u003e \u003cview\u003e \u003cview class=\"fixed\"\u003e \u003ccu-custom :isBack=\"true\" bgColor=\"bg-shadeTop text-white\"\u003e \u003cblock slot=\"backText\"\u003e返回\u003c/block\u003e \u003cblock slot=\"content\"\u003e垂直导航\u003c/block\u003e \u003c/cu-custom\u003e \u003c/view\u003e \u003cswiper class=\"screen-swiper round-dot\" :indicator-dots=\"true\" :circular=\"true\" :autoplay=\"true\" interval=\"5000\" duration=\"500\"\u003e \u003cswiper-item v-for=\"(item,index) in 4\" :key=\"index\"\u003e \u003cimage :src=\"'https://ossweb-img.qq.com/images/lol/web201310/skin/big3900'+index+ '.jpg'\" mode=\"aspectFill\"\u003e\u003c/image\u003e \u003c/swiper-item\u003e \u003c/swiper\u003e \u003cview class=\"VerticalBox\"\u003e \u003cscroll-view class=\"VerticalNav nav\" scroll-y scroll-with-animation :scroll-top=\"verticalNavTop\" style=\"height:calc(100vh - 375upx)\"\u003e \u003cview class=\"cu-item\" :class=\"index==tabCur?'text-green cur':''\" v-for=\"(item,index) in list\" :key=\"index\" @tap=\"TabSelect\" :data-id=\"index\"\u003e Tab-{{item.name}} \u003c/view\u003e \u003c/scroll-view\u003e \u003cscroll-view class=\"VerticalMain\" scroll-y scroll-with-animation style=\"height:calc(100vh - 375upx)\" :scroll-into-view=\"'main-'+mainCur\" @scroll=\"VerticalMain\"\u003e \u003cview class=\"padding-top padding-lr\" v-for=\"(item,index) in list\" :key=\"index\" :id=\"'main-'+index\"\u003e \u003cview class=\"cu-bar solid-bottom bg-white\"\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-title text-green\"\u003e\u003c/text\u003e Tab-{{item.name}}\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-list menu-avatar\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e凯尔\u003c/view\u003e \u003cview class=\"text-gray text-sm flex\"\u003e \u003ctext class=\"text-cut\"\u003e \u003ctext class=\"cuIcon-infofill text-red margin-right-xs\"\u003e\u003c/text\u003e 我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。 \u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cu-tag round bg-grey sm\"\u003e5\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/img/champion/Taric.png);\"\u003e \u003cview class=\"cu-tag badge\"\u003e99+\u003c/view\u003e \u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e \u003ctext class=\"text-cut\"\u003e瓦洛兰之盾-塔里克\u003c/text\u003e \u003cview class=\"cu-tag round bg-orange sm\"\u003e战士\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray text-sm flex\"\u003e \u003ctext class=\"text-cut\"\u003e 塔里克是保护者星灵，用超乎寻常的力量守护着符文之地的生命、仁爱以及万物之美。塔里克由于渎职而被放逐，离开了祖国德玛西亚，前去攀登巨神峰寻找救赎，但他找到的却是来自星界的更高层的召唤。现在的塔里克与古代巨神族的神力相融合，以瓦洛兰之盾的身份，永不疲倦地警惕着阴险狡诈的虚空腐化之力。 \u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cuIcon-notice_forbid_fill text-gray\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item \"\u003e \u003cview class=\"cu-avatar radius lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/img/champion/Morgana.png);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-pink\"\u003e\u003ctext class=\"text-cut\"\u003e莫甘娜\u003c/text\u003e\u003c/view\u003e \u003cview class=\"text-gray text-sm flex\"\u003e \u003ctext class=\"text-cut\"\u003e凯尔，你被自己的光芒变的盲目！\u003c/text\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cu-tag round bg-red sm\"\u003e5\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item grayscale\"\u003e \u003cview class=\"cu-avatar radius lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81007.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview\u003e\u003ctext class=\"text-cut\"\u003e伊泽瑞尔\u003c/text\u003e \u003cview class=\"cu-tag round bg-orange sm\"\u003e断开连接...\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray text-sm flex\"\u003e \u003ctext class=\"text-cut\"\u003e 等我回来一个打十个\u003c/text\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cu-tag round bg-red sm\"\u003e5\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item cur\"\u003e \u003cview class=\"cu-avatar radius lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81020.jpg);\"\u003e \u003cview class=\"cu-tag badge\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview\u003e \u003ctext class=\"text-cut\"\u003e瓦罗兰大陆-睡衣守护者-新手保护营\u003c/text\u003e \u003cview class=\"cu-tag round bg-orange sm\"\u003e6人\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:4","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["Java后端"],"content":"时光邮局---词云分析---Stanford Nlp","date":"2021-05-09","objectID":"/stanford-corenlp/","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"Stanford Nlp是一个比较牛叉的自然语言处理工具，其很多模型都是基于深度学习方法进行训练得到的，准确率比起原来的很多工具有了很大程度的提高。近年来很多开源项目也用到了其中的一些方法。 最近重拾这个工具做点语义分析的工作，但是发现中文资料比较少，入门比较困难，所以整理一下自己的使用方法，希望对有需要的童鞋能够有点帮助。 本文主要是讲如何在Java工程中调用Stanford NLP的API。 ","date":"2021-05-09","objectID":"/stanford-corenlp/:0:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"一、环境准备（导入依赖） ","date":"2021-05-09","objectID":"/stanford-corenlp/:1:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"1、pom原始导入 \u003cproperties\u003e \u003ccorenlp.version\u003e4.0.0\u003c/corenlp.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e${corenlp.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e${corenlp.version}\u003c/version\u003e \u003cclassifier\u003emodels\u003c/classifier\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e${corenlp.version}\u003c/version\u003e \u003cclassifier\u003emodels-chinese\u003c/classifier\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 如果上述方法pom不能导入可以选择第二种方法，把jar包下载到本地，然后本地导入 ","date":"2021-05-09","objectID":"/stanford-corenlp/:1:1","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"2、本地导入 下载地址主要下载两个文件 在resources目录下新建lib包，将一下三个文件导入： pom文件导入本地Jar \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e4.2.1\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/stanford-corenlp-4.2.1.jar\u003c/systemPath\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e4.2.1\u003c/version\u003e \u003cclassifier\u003emodels-chinese\u003c/classifier\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/stanford-corenlp-4.2.1-models-chinese.jar\u003c/systemPath\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.ejml\u003c/groupId\u003e \u003cartifactId\u003eejml\u003c/artifactId\u003e \u003cversion\u003e0.39\u003c/version\u003e \u003c!-- \u003cclassifier\u003emodels\u003c/classifier\u003e--\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/ejml-core-0.39.jar\u003c/systemPath\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e4.2.1\u003c/version\u003e \u003cclassifier\u003emodels\u003c/classifier\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/stanford-corenlp-4.2.1-models.jar\u003c/systemPath\u003e \u003c/dependency\u003e ","date":"2021-05-09","objectID":"/stanford-corenlp/:1:2","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"二、分词 package com.jd.posttimer.Util.SegmentationUtil; import edu.stanford.nlp.ling.CoreAnnotations; import edu.stanford.nlp.ling.CoreLabel; import edu.stanford.nlp.pipeline.Annotation; import edu.stanford.nlp.pipeline.StanfordCoreNLP; import edu.stanford.nlp.util.CoreMap; import edu.stanford.nlp.util.StringUtils; import java.util.ArrayList; import java.util.List; import java.util.Properties; /** * * Created by dd on 2017/6/8. * * 斯坦福NLP 包，中文分词和英文分词 * */ public class Segmentation { public List segInCh(String text) { //载入properties 文件 // StanfordCoreNLP pipline = new StanfordCoreNLP(\"StanfordCoreNLP-chinese.properties\"); //1.2 自定义功能 （1） // Properties properties = new Properties(); // properties.put(\"annotators\", \"tokenize, ssplit, pos, lemma, ner, parse, dcoref\"); // properties.setProperty(\"annotators\", \"tokenize, ssplit, pos, lemma, ner, parse, dcoref\"); // properties.setProperty(\"coref.algorithm\", \"neural\"); // properties.setProperty(\"add-modules \",\"java.se.ee\"); // properties.setProperty(\"ner.useSUTime\", \"false\"); // StanfordCoreNLP pipline = new StanfordCoreNLP(properties); // 自定义功能(2) 自己在项目中建一个properties 文件，然后在文件中设置模型属性，可以参考1中的配置文件 String[] args = new String[]{\"-props\", \"classpath:/properies/StanfordCoreNLP-chinese.properties\"}; Properties properties = StringUtils.argsToProperties(args); StanfordCoreNLP pipline = new StanfordCoreNLP(properties); //自定义功能(3) // StanfordCoreNLP pipline = new StanfordCoreNLP(PropertiesUtils.asProperties( // \"annotators\",\"tokenize,ssplit\", // \"ssplit.isOneSentence\", \"true\", // \"tokenize.language\", \"zh\", // \"segment.model\", \"edu/stanford/nlp/models/segmenter/chinese/ctb.gz\", // \"segment.sighanCorporaDict\", \"edu/stanford/nlp/models/segmenter/chinese\", // \"segment.serDictionary\", \"edu/stanford/nlp/models/segmenter/chinese/dict-chris6.ser.gz\", // \"segment.sighanPostProcessing\", \"true\" // )); //创建一个解析器，传入的是需要解析的文本 Annotation annotation = new Annotation(text); //解析 pipline.annotate(annotation); //根据标点符号，进行句子的切分，每一个句子被转化为一个CoreMap的数据结构，保存了句子的信息() List\u003cCoreMap\u003e sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class); //从CoreMap 中取出CoreLabel List ,打印 System.out.println(\"word\\tpos\\tlemma\\tner\"); List\u003cString\u003e list=new ArrayList(); for (CoreMap sentence : sentences) { for (CoreLabel token : sentence.get(CoreAnnotations.TokensAnnotation.class)) { // \"tokenize, ssplit, pos, lemma, ner, parse, dcoref\", String word = token.get(CoreAnnotations.TextAnnotation.class); // String pos = token.get(CoreAnnotations.PartOfSpeechAnnotation.class); // String ne = token.get(CoreAnnotations.NamedEntityTagAnnotation.class); // String lemma = token.get(CoreAnnotations.LemmaAnnotation.class); // System.out.println(word+\"\\t\"+pos+\"\\t\"+lemma+\"\\t\"+ne); list.add(word); System.out.println(word); } } return list; } } 代码中一共定义了3中配置模型属性的方法，第一种、第三种需要自己写，容易出错，第二种jar包中有默认的配置文件，只需要做部分修改就可以用，但是jar包里的文件只读，所以需要复制出来 2021-05-09 08:31:41.066 INFO 12596 --- [nio-9981-exec-1] e.stanford.nlp.pipeline.StanfordCoreNLP : Adding annotator coref 2021-05-09 08:31:41.107 ERROR 12596 --- [nio-9981-exec-1] e.stanford.nlp.pipeline.CorefAnnotator : Error creating CorefAnnotator...terminating pipeline construction! 2021-05-09 08:31:41.108 ERROR 12596 --- [nio-9981-exec-1] e.stanford.nlp.pipeline.CorefAnnotator : java.lang.RuntimeException: Error initializing coref system edu.stanford.nlp.coref.CorefSystem.\u003cinit\u003e(CorefSystem.java:44) ... Caused by: class edu.stanford.nlp.io.RuntimeIOException: java.io.IOException: Unable to open \"edu/stanford/nlp/models/dcoref/demonyms.txt\" as class path, filename or URL ... 默认配置文件的bug,模型配置了coref（同义词分辨）但是没有找到，想到还有一个modles没有用到，导入进来 pS：该代码的思想是将text字符串交给Stanford CoreNLP处理，StanfordCoreNLP的各个组件（annotator）按“tokenize（分词）, ssplit（断句）, pos（词性标注）, lemma（词元化）, ner（命名实体识别）, parse（语法分析）, dcoref（同义词分辨）”顺序进行处理。 ","date":"2021-05-09","objectID":"/stanford-corenlp/:2:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"1、工具类调用service 工具类为了调用service方法： package com.jd.posttimer.Util; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.BeansException; import org.springframework.beans.factory.DisposableBean; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; @Slf4j public class BeanUtil implements ApplicationContextAware, DisposableBean { private static ApplicationContext applicationContext = null; /** * 从静态变量applicationContext中取得Bean, 自动转型为所赋值对象的类型. */ public static \u003cT\u003e T getBean(Class\u003cT\u003e requiredType) { if(applicationContext==null){ throw new IllegalStateException(\"applicaitonContext属性未注入, 请在SpringBoot启动类中注册BeanUtil.\"); } return applicationContext.getBean(requiredType); } @Override public void destroy() { applicationContext = null; } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { if (BeanUtil.applicationContext != null) { log.warn(\"BeanUtil中的ApplicationContext被覆盖, 原有ApplicationContext为:\" + BeanUtil.applicationContext); } BeanUtil.applicationContext = applicationContext; } } 主类注入 @Bean public BeanUtil beanUtil() { return new BeanUtil(); } 调用 private static LiuMessageService service; private static RedisUtils redisUtils; @Override public void run(){ service= BeanUtil.getBean(LiuMessageService.class); redisUtils=BeanUtil.getBean(RedisUtils.class); getWordCloud(); } ","date":"2021-05-09","objectID":"/stanford-corenlp/:2:1","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"2、调用分词生成词云 词云依赖： \u003cdependency\u003e \u003cgroupId\u003ecom.kennycason\u003c/groupId\u003e \u003cartifactId\u003ekumo-core\u003c/artifactId\u003e \u003cversion\u003e1.13\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.kennycason\u003c/groupId\u003e \u003cartifactId\u003ekumo-tokenizers\u003c/artifactId\u003e \u003cversion\u003e1.12\u003c/version\u003e \u003c/dependency\u003e 生成词云，保存到redis,不等待结果，返回的是上一次的结果 @GetMapping(\"wordscloud\") public String getWordCloud() throws IOException { WordsCloud wordsCloud=new WordsCloud(); wordsCloud.start(); System.out.println(\"wordscloud\"); return redisUtils.get(\"words_cloud\"); } WordsCloud词云类 package com.jd.posttimer.Util.wordscloud; import com.jd.posttimer.Util.BeanUtil; import com.jd.posttimer.Util.Redis.RedisUtils; import com.jd.posttimer.Util.SegmentationUtil.Segmentation; import com.jd.posttimer.entity.LiuMessage; import com.jd.posttimer.service.PostEmailSer.LiuMessageService; import com.kennycason.kumo.CollisionMode; import com.kennycason.kumo.WordCloud; import com.kennycason.kumo.WordFrequency; import com.kennycason.kumo.bg.CircleBackground; import com.kennycason.kumo.font.KumoFont; import com.kennycason.kumo.font.scale.SqrtFontScalar; import com.kennycason.kumo.nlp.FrequencyAnalyzer; import com.kennycason.kumo.nlp.tokenizers.ChineseWordTokenizer; import com.kennycason.kumo.palette.LinearGradientColorPalette; import org.apache.tomcat.util.codec.binary.Base64; import java.awt.*; import java.io.ByteArrayOutputStream; import java.io.OutputStream; import java.util.ArrayList; import java.util.List; import java.util.Random; //@Component public class WordsCloud extends Thread{ // private LiuMessageService liuMessageService; private static LiuMessageService service; private static RedisUtils redisUtils; @Override public void run(){ service= BeanUtil.getBean(LiuMessageService.class); redisUtils=BeanUtil.getBean(RedisUtils.class); getWordCloud(); } public void getWordCloud(){ FrequencyAnalyzer frequencyAnalyzer = new FrequencyAnalyzer(); frequencyAnalyzer.setWordFrequenciesToReturn(600); frequencyAnalyzer.setMinWordLength(2); // 引入中文解析器 frequencyAnalyzer.setWordTokenizer(new ChineseWordTokenizer()); List\u003cLiuMessage\u003e messages = service.findAllByStatus(1); System.out.println(messages.toString()); String words=\"\"; for (LiuMessage liu:messages) { words+=liu.getMessage(); } Segmentation segmentation=new Segmentation(); List\u003cString\u003e list = segmentation.segInCh(words); System.out.println(\"list:\"+list.toString()); //加入分词并随机生成权重，每次生成得图片都不一样,图片基数大可以这么玩 List\u003cWordFrequency\u003e wordFrequencyList=new ArrayList\u003c\u003e(); for ( String liu : list){ wordFrequencyList.add(new WordFrequency(liu,new Random().nextInt(list.size()))); } // 原文链接：https://blog.csdn.net/b644ROfP20z37485O35M/article/details/97583505 // final List\u003cWordFrequency\u003e wordFrequencyList = frequencyAnalyzer.load(words); // 设置图片分辨率 Dimension dimension = new Dimension(500, 500); // 此处的设置采用内置常量即可，生成词云对象 WordCloud wordCloud = new WordCloud(dimension, CollisionMode.PIXEL_PERFECT); java.awt.Font font = new java.awt.Font(\"STSong-Light\", 2, 18); wordCloud.setKumoFont(new KumoFont(font)); wordCloud.setPadding(2); // wordCloud.setColorPalette(new ColorPalette(new Color(237, 25, 65), // new Color(242, 101, 34), new Color(132, 85, 56), // new Color(138, 93, 25),new Color(127, 117, 34), // new Color(92, 122, 41),new Color(29, 149, 63), // new Color(0, 125, 101),new Color(101, 194, 148))); wordCloud.setColorPalette(new LinearGradientColorPalette(Color.RED, Color.BLUE, Color.GREEN, 30, 30)); wordCloud.setBackground(new CircleBackground(200)); wordCloud.setFontScalar(new SqrtFontScalar(10, 40)); wordCloud.setBackgroundColor(new Color(255, 255, 255)); // 生成词云 wordCloud.build(wordFrequencyList); OutputStream output = new ByteArrayOutputStream(); wordCloud.writeToStream(\"png\", output); byte[] outputByte = ((ByteArrayOutputStream)output).toByteArray(); redisUtils.getAndSet(\"words_cloud\", Base64.encodeBase64String(outputByte)); } } 什么是异步调用 对象controller中的方法调用对象\"wordscloud\"的方法，程序并不需要等待对象a的方法返回结果值，直接继续往下走。 为什么不同步？ 由于模型的构建复杂性，生成一个模型并返回结果需要40+秒，如果模型复杂度增加，还会增加响应时间，影响客户端体验。 ","date":"2021-05-09","objectID":"/stanford-corenlp/:2:2","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"三、前端结果显示 后端传的数据是base64编码后的字符串，怎么显示在前端？ uni.request({ url: config.baseUrl + '/liu/wordscloud', method: 'GET', success: res =\u003e { console.log(typeof(res.data)) this.imageHerf='data:image/jpeg;base64,'+res.data }, fail: (res) =\u003e { console.log(\"词云失败结果\") console.log(res) } }) \u003cview\u003e \u003cvan-image class=\"code text-right\" width=\"100%\" height=\"250px\" fit=\"cover\" mode=\"\" :src=\"imageHerf.replace(/[\\r\\n]/g,'')\" /\u003e \u003c/view\u003e ","date":"2021-05-09","objectID":"/stanford-corenlp/:3:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["设计模式"],"content":"模式动机 **蜡笔：**颜色和型号两个不同的变化维度（即两个不同的变化原因）耦合在一起，无论是对颜色进行扩展还是对型号进行扩展都势必会影响另一个维度 **毛笔：**颜色和型号实现了分离，增加新的颜色或者型号对另一方没有任何影响 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:1:0","tags":["桥接模式"],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式 用抽象关联取代了传统的多层继承 将类之间的静态继承关系转换为动态的对象组合关系 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:2:0","tags":["桥接模式"],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:3:0","tags":["桥接模式"],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 模拟毛笔：实例说明 •现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5=15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5=8个类就可以实现15支蜡笔的功能。本实例使用桥接模式来模拟毛笔的使用过程。 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:4:0","tags":["桥接模式"],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码 package com.bridge; public interface Color { public void paint(String penType); } package com.bridge; public class Blue implements Color { @Override public void paint(String penType) { // TODO Auto-generated method stub System.out.println(\"使用\"+penType+\"涂蓝色\"); } } package com.bridge; public abstract class Pen { protected Color color; public void setColor(Color color) { this.color = color; } public abstract void draw(); } package com.bridge; public class SmallPen extends Pen { @Override public void draw() { // TODO Auto-generated method stub System.out.println(\"准备用小号毛笔画画：\"); color.paint(\"小号毛笔\"); } } package com.bridge; import java.io.File; import javax.xml.parsers.*; import org.w3c.dom.*; public class XMLUtil { public static Object getBean(String args) { try { //创建DOM文档对象 DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder builder=dFactory.newDocumentBuilder(); Document doc=builder.parse(new File(\"src/com/bridge/config.xml\")); //获取包含类名的文本节点 NodeList nl=doc.getElementsByTagName(\"className\"); Node classNode=null; //nl.item(0).getFirstChild(); String cName=null; //classNode.getNodeValue(); if(args.equals(\"color\")) { classNode=nl.item(0).getFirstChild(); } else if(args.equals(\"pen\")) { classNode=nl.item(1).getFirstChild(); } cName=classNode.getNodeValue(); //通过类名生成实例对象并返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; } catch(Exception ex) { ex.printStackTrace(); return null; } } } \u003c?xml version=\"1.0\"?\u003e \u003cconfig\u003e \u003cclassName\u003ecom.bridge.Green\u003c/className\u003e \u003cclassName\u003ecom.bridge.BigPen\u003c/className\u003e \u003c/config\u003e package com.bridge; public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Color color=(Color)XMLUtil.getBean(\"color\"); Pen pen=(Pen)XMLUtil.getBean(\"pen\"); pen.setColor(color); pen.draw(); } } ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:4:1","tags":["桥接模式"],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 分离抽象接口及其实现部分 可以取代多层继承方案，极大地减少了子类的个数 提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，不需要修改原有系统，符合开闭原则 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:5:0","tags":["桥接模式"],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就要针对抽象层进行设计与编程 正确识别出系统中两个独立变化的维度并不是一件容易的事情 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:6:0","tags":["桥接模式"],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系 抽象部分和实现部分可以以继承的方式独立扩展而互不影响 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展 不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:7:0","tags":["桥接模式"],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 在树形目录结构中，包含文件和文件夹两类不同的元素 在文件夹中可以包含文件，还可以继续包含子文件夹 在文件中不能再包含子文件或者子文件夹 文件夹 \u003c–\u003e容器(Container) 文件 \u003c–\u003e叶子(Leaf) 如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象？ à 组合模式 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:1:0","tags":["组合模式"],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 组合模式(Composite Pattern)：组合多个对象形成树形结构以表示“部分-整体”的结构层次。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。 对象结构型模式 将对象组织到树形结构中，可以用来描述整体与部分的关系 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:2:0","tags":["组合模式"],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 模式代码实例 package com.composite; public interface Component { //如果是叶子结点，则打印它的名称； //如果是容器结点，则打印它的名称，并利用foreach语句调用每个子结点的operation方法 public void operation(); //添加一个子节点 public void add(Component c); //删除一个子节点 public void remove(Component c); //获取一个子结点 public Component getChild(int i); } package com.composite; public class Leaf implements Component { public String leafname; public Leaf(String leafname) { this.leafname = leafname; } @Override public void operation() { // TODO Auto-generated method stub System.out.println(\"当前结点是叶子结点，叶子名称是 \"+leafname); } @Override public void add(Component c) { // TODO Auto-generated method stub System.out.println(\"叶子结点不能执行add方法\"); } @Override public void remove(Component c) { // TODO Auto-generated method stub System.out.println(\"叶子结点不能执行remove方法\"); } @Override public Component getChild(int i) { // TODO Auto-generated method stub System.out.println(\"叶子结点不能执行getChild方法\"); return null; } } package com.composite; import java.util.ArrayList; public class Composite implements Component { private String compositename; private ArrayList list=new ArrayList(); public Composite(String compositename) { this.compositename = compositename; } @Override public void operation() { // TODO Auto-generated method stub System.out.println(\"当前结点是容器结点，容器名称是 \"+compositename); for(Object child:list) { Component c=(Component)child; c.operation(); } } @Override public void add(Component c) { // TODO Auto-generated method stub list.add(c); System.out.println(\"添加了一个子节点\"); } @Override public void remove(Component c) { // TODO Auto-generated method stub list.remove(c); System.out.println(\"删除了一个子节点\"); } @Override public Component getChild(int i) { // TODO Auto-generated method stub Component c=(Component)list.get(i); return c; } } package com.composite; public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Component root=new Composite(\"C1-1\"); Component C21=new Composite(\"C2-1\"); Component L22=new Leaf(\"L2-2\"); Component C23=new Composite(\"C2-3\"); root.add(C21); root.add(L22); root.add(C23); Component C31=new Composite(\"C3-1\"); Component L32=new Leaf(\"L3-2\"); C21.add(C31); C21.add(L32); Component C33=new Composite(\"C3-3\"); Component C34=new Composite(\"C3-4\"); C23.add(C33); C23.add(C34); Component L41=new Leaf(\"L4-1\"); Component L42=new Leaf(\"L4-2\"); C31.add(L41); C31.add(L42); Component L43=new Leaf(\"L4-3\"); C33.add(L43); Component L44=new Leaf(\"L4-4\"); C34.add(L44); root.operation(); } } ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:3:0","tags":["组合模式"],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 透明组合模式 抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()，以及getChild()等方法 在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象 缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的 安全组合模式 抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法 对于叶子对象，客户端不可能调用到这些方法 缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:4:0","tags":["组合模式"],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控制 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码 增加新的容器构件和叶子构件都很方便，符合开闭原则 为树形结构的面向对象实现提供了一种灵活的解决方案 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:5:0","tags":["组合模式"],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 在增加新构件时很难对容器中的构件类型进行限制 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:6:0","tags":["组合模式"],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们 在一个使用面向对象语言开发的系统中需要处理一个树形结构 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:7:0","tags":["组合模式"],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"实例 在水果盘(Plate)中有一些水果，如苹果(Apple)、香蕉(Banana)、梨子(Pear)，当然大水果盘中还可以有小水果盘，现需要对盘中的水果进行遍历（吃），当然如果对一个水果盘执行“吃”方法，实际上就是吃其中的水果。使用组合模式模拟该场景 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:8:0","tags":["组合模式"],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 通过引入一个新的对象（如小图片和远程代理对象）来实现对真实对象的操作，或者将新的对象作为真实对象的一个替身 引入代理对象来间接访问一个对象 代理模式 ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:1:0","tags":["代理模式"],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用 对象结构型模式 代理对象可以在客户端和目标对象之间起到中介的作用 通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外的新服务 ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:2:0","tags":["代理模式"],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 代理模式代码实例 ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:3:0","tags":["代理模式"],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使(Ambassador) 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果 智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等 ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:4:0","tags":["代理模式"],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性 远程代理：可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率 虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销 缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间 保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限 ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:5:0","tags":["代理模式"],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢（例如保护代理） 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂（例如远程代理） ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:6:0","tags":["代理模式"],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["前端"],"content":"count-code-line ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:0:0","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"特性 支持计算代码行数和代码字符数 丰富的配置文件，支持匹配任意规则的文件或文件夹 支持生成计算结果的json 支持全局安装命令行使用 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:1:0","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"安装 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:2:0","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"1.1 全局安装 npm i count-code-line -g ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:2:1","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"1.2 本地安装 npm i count-code-line -D 1.2 本地安装 npm i count-code-line -D 1 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:2:2","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"使用 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:0","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"2.1 全局安装使用 在任意项目内打开命令行工具，运行一下命令即可 count-code-line 运行成功会在根目录下输出 count.output.json 文件 运行成功会在根目录下输出 count.output.json 文件 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:1","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"2.2 本地安装使用 在 package.json 文件中 的scripts属性中加入如下配置 ... \"scripts\": { ... \"count\": \"count-code-line\" }, ... 然后在根目录下运行 npm run count 运行成功会在根目录下输出 count.output.json 文件 运行成功会在根目录下输出 count.output.json 文件 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:2","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"2.3 nodejs 引用 const count = require('count-code-line'); count(); ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:3","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"配置文件 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:0","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"3.1 默认配置文件及配置项 count-code-line 支持自定义配置文件，以下是默认配置 module.exports = { includes: [], // 需要包含的目录及文件 默认全部包含 excludes: [], // 需要排除的目录及文件 默认全部移除 defaultExcludes: [ // 默认排除的目录及文件 '.git', '.vscode', 'node_modules', 'package.json', 'package-lock.json', 'yarn-lock.json', 'count.output.json', ], defaultExcludesFileType: [ // 默认排除的文件类型 '.zip', '.rar', '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.mp3', '.wma', '.wav', '.mp4', '.flv', '.mov', '.avi', '.wmv', '.rmvb ', '.ogg', '.avi', '.ppt', '.pptx', '.doc','.docx','.xls','.xlsx','.psd','.ttf','.fon','.exe','.msi', ], output: 'count.output.json', // 默认的输出结果文件 outputTrace: '', // 配置输出 trace 结果的文件，默认不输出 encodings: [ // 支持的文件编码，对于不支持的文件将忽略 'ascii', 'utf8', 'utf-8', 'unicode' ] }; ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:1","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"3.2 自定义配置文件 在项目根目录下新建 count.config.js 文件 写入上述配置覆盖默认配置即可 3.2 自定义配置文件 在项目根目录下新建 count.config.js 文件 写入上述配置覆盖默认配置即可 对于为空的配置项，将使用默认配置 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:2","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"3.3 目录匹配规则 includes excludes 等配置项均支持模糊匹配，匹配规则如下 ‘a’ 将匹配 根目录下 a 文件夹内的所有文件及文件夹；正则： new RegExp(^/a/.*) ‘a/a.js’ 仅匹配指定文件 ‘a/’ 仅匹配 a 文件夹内的所有子文件； 正则： new RegExp(^/a/([^/])$) ‘a/**/.js’ 匹配 a 文件夹内的所有以 .js 为后缀的文件； 正则： new RegExp(^/a/([^/]).js$) ‘a/.js’ 仅匹配 a 文件夹内的所有以 .js 为后缀的子文件； 正则： new RegExp(^/a/([^/]).js$) ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:3","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["设计模式"],"content":"模式动机 如何确保一个类只有一个实例并且这个实例易于被访问？ 让类自身负责创建和保存它的唯一实例，并保证不能创建其他实例，并且提供一个访问该实例的方法 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个： 某个类只能有一个实例 必须自行创建这个实例 必须自行向整个系统提供这个实例 单例模式是一种对象创建型模式 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 单例模式的实现 私有构造函数 静态私有成员变量（自身类型） 静态公有的工厂方法 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"饿汉式单例类(Eager Singleton) 代码实现： public class EagerSingleton { private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton(){ } public static EagerSingleton getInstance() { return instance; } } ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:1","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"懒汉式单例类 延时加载： public class LazySingleton { private static LazySingletom instance = null; private IazySingleton( i} public static LazySingleton getInstanceO { if (instance == null){ instance = new LazMSingleton(); } return instance; } } 多个线程同时访问将导致创建多个单例对象!怎么办? instance = new LazMSingleton(); 需要较长时间 synchronized锁方法： public class LazySingleton { private static LazySingletom instance = null; private IazySingleton( i} synchronized public static LazySingleton getInstanceO { if (instance == null){ instance = new LazMSingleton(); } return instance; } } synchronized锁代码段 if (instance == null){ synchronized(LazMSingleton.class){ instance = new LazMSingleton(); } } return instance; ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:2","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Double-Check Locking双重检查锁定 public class LazySingleton { private volatile static LazySingletom instance = null; private IazySingleton( i} public static LazySingleton getInstanceO { //第一重判断 if (instance == null){ //锁定代码块 synchronized(LazMSingleton.class){ //第二重判断 if(instance == null){ instance = new LazMSingleton(); } } } return instance; } } ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:3","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"饿汉式单例类与懒汉式单例类的比较 饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长 懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响 //Initialization on Demand Holder public class Singleton { private Singleton() { } //静态内部类 private static class HolderClass { private final static Singleton instance = new Singleton(); } public static Singleton getInstance() { return HolderClass.instance; } public static void main(String args[]) { Singleton s1, s2; s1 = Singleton.getInstance(); s2 = Singleton.getInstance(); System.out.println(s1 == s2); } } 控制台输出true ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式实例 在操作系统中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。 自定义异常类 public class PrintSpoolerException extends Exception { public PrintSpoolerException(String message){ super(message); } } 单例类 public class PrintSpoolerSingleton { private static PrintSpoolerSingleton instance=null; private PrintSpoolerSingleton(){} public static PrintSpoolerSingleton getInstance() throws PrintSpoolerException { if(instance==null){ System.out.println(\"创建打印池\"); instance=new PrintSpoolerSingleton(); } else{ throw new PrintSpoolerException(\"打印池正在工作中\"); } return instance; } public void manageJobs(){ System.out.println(\"管理打印任务\"); } } 客户端类： public class Client { public static void main(String args[]){ PrintSpoolerSingleton ps1,ps2; try{ ps1=PrintSpoolerSingleton.getInstance(); ps1.manageJobs(); }catch (PrintSpoolerException e){ System.out.println(e.getMessage()); } System.out.println(\"----------------\"); try{ ps2=PrintSpoolerSingleton.getInstance(); ps2.manageJobs(); }catch (PrintSpoolerException e){ System.out.println(e.getMessage()); } } } 结果： 创建打印池 管理打印任务 ---------------- 打印池正在工作中 Process finished with exit code 0 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:6:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 提供了对唯一实例的受控访问 可以节约系统资源，提高系统的性能 允许可变数目的实例（多例类） ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:7:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 扩展困难（缺少抽象层） 单例类的职责过重 由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:8:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:9:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 现实生活： 不兼容：生活用电220V ßà 笔记电脑20V 引入 AC Adapter（交流电适配器） 软件开发： 存在不兼容的结构，例如方法名不一致 引入适配器模式 ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。 适配器模式既可以作为类结构型模式，也可以作为对象结构型模式 定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合 类适配模式 对象适配模式： ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 典型的类适配器示例代码： public class Adapter extends Adaptee implements Target {public void request() { super.specificRequest(); } 典型的对象适配器示例代码 public class Adapter extends Target { private Adaptee adaptee;//维持一个对适配者对象的引用 public Adapter(Adaptee adaptee){ this.adaptee=adaptee; } public void request() { adaptee.specificRequest();//转发调用 } } ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构 增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用 灵活性和扩展性非常好 类适配器模式：置换一些适配者的方法很方便 对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类 ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:4:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 类适配器模式： (1) 一次最多只能适配一个适配者类，不能同时适配多个适配者 ​ (2) 适配者类不能为最终类 ​ (3) 目标抽象类只能为接口，不能为类 对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦 ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:5:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码 创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作 ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:6:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用实例 4-2.现有一个接口DataOperation定义了排序方法sort(int[])和查找方法search(int[],int)，已知类QuickSort的quickSort(int[])方法实现了快速排序算法，类BinarySearch的binarySearch(int[],int)方法实现了二分查找算法。现使用适配器模式设计一个系统，在不修改源代码的情况下，将QuickSort和类BinarySearch的方法适配到接口DataOperation中，绘制类图并实现。 代码： public interface DataOperation { public void sort(int data[]);//排序方法 public void search(int[] list,int key);//查找方法 } public class QuickSort { //快速排序 public void quickSort(int data[]) { java.util.Arrays.sort(data); //直接调用排序方法 print(data); } //数组输出 public void print(int data[]) { for(int x=0;x\u003cdata.length;x++) { System.out.print(data[x]+\"、\"); } } } public class BinarySearch { // 二分查找 public void binarySearch(int[] list,int key) { // 调用java.util.Arrays的binarySearch二分查找方法 System.out.print(java.util.Arrays.binarySearch(list, key)); } } public class DataAdapter implements DataOperation { private QuickSort quicksort; // 定义适配者QuickSort的对象 private BinarySearch binarysearch; // 定义适配者 BinarySearch的对象 // 构造函数初始化适配者对象 public DataAdapter() { quicksort = new QuickSort(); // 实例化QuickSort对象 binarysearch = new BinarySearch(); // 实例化 BinarySearch对象 } @Override public void sort(int data[]) { // 建立连接实现快速排序 quicksort.quickSort(data);// 通过对象调用实现快速排序的功能 } @Override public void search(int[] list, int key) { // 建立连接实现二分查找 binarysearch.binarySearch(list, key);// 通过对象调用实现二分查找的功能 } } public class Client { public static void main(String[] args) { // TODO 自动生成的方法存根 //定义一个数组 int data[]=new int[] {2,4,1,5,3,8,6,7}; DataOperation operation; //定义接口对象 operation=new DataAdapter(); // 实例化接口对象向上转型 System.out.println(\"排序前的数组：\"); for(int i=0;i\u003cdata.length;i++) { System.out.print(data[i]+\"、\"); } System.out.println(\"\\n\\n排序后的数组\"); operation.sort(data);//调用排序 //查找数据4所在的下表 System.out.println(\"\\n\\n输出数字4所在的索引:\"); operation.search(data,4);//调用查找 } } 结果： ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:7:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 复制一个对象，从而克隆出多个与原型对象一模一样的对象——原型模式 有些对象的创建过程较为复杂，而且需要频繁创建 通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 原型模式(Prototype Pattern)：原型模式是一种对象创建型模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。 原型模式允许通过一个原型对象创建一个或多个同类型的其他对象，而无须知道任何创建的细节 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份 在Java中可以直接使用Object提供的clone()方法来实现对象的克隆（浅克隆） 能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制 如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常 浅克隆(Shallow Clone)：当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制 深克隆(Deep Clone)：除了对象本身被复制外，对象所包含的所有成员变量也将被复制 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率 扩展性较好 简化创建结构，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品 可以使用深克隆的方式保存对象的状态，以便在需要的时候使用，可辅助实现撤销操作 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 创建新对象成本较大，新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改 系统要保存对象的状态，而对象的状态变化很小 需要避免使用分层次的工厂类来创建分层次的对象 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:6:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用实例 1.在某OA系统中，用户可以创建工作周报，由于某些岗位每周工作存在重复性，因此可以通过复制原有工作周报并进行局部修改来快速新建工作周报。现使用原型模式来实现该功能，绘制类图并编程实现。周报内容包括姓名、日期、内容。 代码： //工作周报：具体原型类 class WeekLog implements Cloneable{ private String name; private String date; private String content; /* Getter and Setter */ public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDate() { return date; } public void setDate(String date) { this.date = date; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } //克隆方法clone,此处使用Java语言提供的浅克隆机制 public Object clone(){ Object obj = null; try { obj = super.clone(); return obj; }catch (CloneNotSupportedException e){ System.out.println(\"不能复制\"); return null; } } } client: class Client{ public static void main(String[] args) { WeekLog log_previous = new WeekLog(); log_previous.setName(\"张三\"); log_previous.setDate(\"2021年第13周\"); log_previous.setContent(\"这周工作很忙，每天加班！\"); System.out.println(\"****周报****\"); System.out.println(log_previous.getDate()); System.out.println(log_previous.getName()); System.out.println(log_previous.getContent()); System.out.println(\"-----------------------------\"); WeekLog log_now; log_now = (WeekLog) log_previous.clone(); log_now.setDate(\"2021年第14周\"); log_now.setContent(\"清闲的一周！\"); System.out.println(\"****周报****\"); System.out.println(log_now.getDate()); System.out.println(log_now.getName()); System.out.println(log_now.getContent()); } } 结果： ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:7:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["hugo"],"content":"hugo   Github Pages绑定域名","date":"2021-04-28","objectID":"/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/","tags":[],"title":"域名绑定","uri":"/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"categories":["hugo"],"content":"域名解析设置 注册购买后，进入控制台-域名-域名列表-解析，增加一下三条记录： 记录类型选A 记录值就是ip地址，github提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，你还可以ping 部署在github上的地址。主机记录设置为@，线路就默认就行了。 记录类型选CNAME 记录值就是你的github博客地址。主机记录设置为www，线路就默认就行了。 ","date":"2021-04-28","objectID":"/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/:1:0","tags":[],"title":"域名绑定","uri":"/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"categories":["hugo"],"content":"Github Pages绑定域名 在仓库根目录下新建CNAME文件， 此时pages setting界面会自动绑定域名 之后就可以正常访问了： ","date":"2021-04-28","objectID":"/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/:2:0","tags":[],"title":"域名绑定","uri":"/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"categories":["运维"],"content":"本实验，你将使用 Kubernetes 包管理工具 helm 部署一个 wordpress 应用到 ack 集群中，并通过 LoadBalancer 将部署的服务暴露出来由外部访问。 通过本实验，你将学习： Helm 命令的基本用法； ","date":"2021-04-20","objectID":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:0:0","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"Step 2 ：部署业务应用 首先，我们需要添加 WordPress 官方Repo地址： helm3 repo add bitnami https://charts.bitnami.com/bitnami 执行 Helm Install 部署 WordPress： helm3 install wordpress bitnami/wordpress \\ --set mariadb.primary.persistence.enabled=true \\ --set mariadb.primary.persistence.storageClass=alicloud-disk-ssd \\ --set mariadb.primary.persistence.size=20Gi \\ --set persistence.enabled=false 其中： 为了实现数据的持久化，mariadb 使用持久化存储卷保存数据； 持久化存储选用阿里云 ssd 云盘，大小为 20Gi，并通过配置 StorageClassName 自动化创建； WordPress 不需要进行数据持久化，数据卷选项可配置为 false 执行成功后，应该有如下返回： NAME: wordpress LAST DEPLOYED: Wed Jan 20 15:09:45 2021 NAMESPACE: handsonack STATUS: deployed REVISION: 1 NOTES: ** Please be patient while the chart is being deployed ** Your WordPress site can be accessed through the following DNS name from within your cluster: wordpress.handsonack.svc.cluster.local (port 80) To access your WordPress site from outside the cluster follow the steps below: 1. Get the WordPress URL by running these commands: NOTE: It may take a few minutes for the LoadBalancer IP to be available. Watch the status with: 'kubectl get svc --namespace handsonack -w wordpress' export SERVICE_IP=$(kubectl get svc --namespace handsonack wordpress --template \"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}\") echo \"WordPress URL: http://$SERVICE_IP/\" echo \"WordPress Admin URL: http://$SERVICE_IP/admin\" 2. Open a browser and access WordPress using the obtained URL. 3. Login with the following credentials below to see your blog: echo Username: user echo Password: $(kubectl get secret --namespace handsonack wordpress -o jsonpath=\"{.data.wordpress-password}\" | base64 --decode) 也可以通过以下命令查看部署状态： helm3 status wordpress ","date":"2021-04-20","objectID":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:1:0","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"Step 3 ：访问 WordPress 应用 ","date":"2021-04-20","objectID":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:2:0","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"1. 获取访问地址 首先，我们需要找到刚才部署的 WordPress 的访问地址。 通过运行下面的命令来获取 WordPress 的 LoadBalancer 地址： kubectl get svc wordpress 将获得如下的返回： NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE wordpress LoadBalancer 172.21.7.165 120.79.38.52 80:32034/TCP,443:31842/TCP 117s 其中的 EXTERNAL-IP 就是当前 WordPress 应用外网可访问的 IP 地址。 通过浏览器访问该 EXTERNAL-IP 地址，我们可以看到 WordPress 应用的首页： ","date":"2021-04-20","objectID":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:2:1","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"2. 访问后台 为了能进入 WordPress 的后台，我们先要获取后台的用户名和密码。 前文的 helm3 status wordpress 命令的返回值已经给出了提示，访问后台的用户名就是 user。 而 user 用户的密码则需要通过下面的命令来获得： kubectl get secret wordpress -o jsonpath=\"{.data.wordpress-password}\" | base64 --decode 在终端的返回值中，你会看到类似下面的结果： TCEYTlASR8 这一段文本就是用户 user 的密码。 接着，我们需要通过地址 http://47.100.82.29/wp-admin/ 访问 WordPress 的后台： 其中的 EXTERNAL-IP 就是前文中获得的 WordPress 的 LoadBalancer 地址。 在浏览器访问后台地址，并输入用户名和密码会看到如下页面： 至此，WordPress 产品部署完成，并成功访问前台和后台。 ","date":"2021-04-20","objectID":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:2:2","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"Step 4 ：删除 WordPress 应用 最后，通过 uninstall 命令删除部署的workpress： helm3 uninstall wordpress ","date":"2021-04-20","objectID":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:3:0","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"实验介绍 本实验，你将使用 K8s 的原生命令 kubectl 部署一个web应用的镜像到 k8s 集群中，并通过 Ingress 将部署的服务暴露出来由外部访问。 通过本实验，你将学习： kubectl 命令的基本用法； 使用 yaml 定义 K8s 资源的方法； ingress 的基本配置方法； ","date":"2021-04-20","objectID":"/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/:1:0","tags":["”k8s“"],"title":"使用Kubectl部署web服务到K8s集群","uri":"/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"部署业务应用 首先，我们需要将业务应用部署到 k8s 集群中。这里我们已经准备好了一个应用并打包成镜像，镜像地址如下： registry.cn-shanghai.aliyuncs.com/workbench1459088147016887/handsonack_test:3 这是一个使用 spring boot 开发的 java web 应用。这个应用会监听 8080 端口，接受所有路径的访问，并输出一些环境基本信息。 要让这个 web 应用的镜像在 k8s 中运行，我们首先要定义一个 deployment 资源。 通过创建deploy.yaml来描述 deployment 资源： apiVersion:apps/v1kind:Deploymentmetadata:name:myapp-deploymentnamespace:handson-3e8b9bbfb31484d1aaddf1a82156c3bflabels:app:myappspec:replicas:1selector:matchLabels:name:myapptemplate:metadata:labels:name:myappnamespace:handson-3e8b9bbfb31484d1aaddf1a82156c3bfspec:containers:- name:myappimage:registry.cn-shanghai.aliyuncs.com/workbench_1459088147016887/handson_ack_test:3ports:- containerPort:8080 其中： image 属性：就是这个 java web 应用的镜像地址； replicas 属性：代表这个应用只部署一份； 通过下面的命令执行: kubectl apply -f ~/deploy.yaml 完成后，你可以通过下面的命令查看刚才部署的 pod： kubectl get pod 看到如下提升代表应用部署完成，注意其中的 status 字段。只有 Running 才是运行中的状态哦，如果是 ContainerCreating 代表服务容器正在创建中，需要等待一段时间才能使用 NAME READY STATUS RESTARTS AGE myapp-deployment-5cd4d7c78d-lxvcw 1/1 Running 0 12s 至此，我们已经完成了应用本身的部署，下面我们看下如何在 k8s 里配置“服务”； ","date":"2021-04-20","objectID":"/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/:2:0","tags":["”k8s“"],"title":"使用Kubectl部署web服务到K8s集群","uri":"/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"部署服务 由于 deployment 是一个弹性组件，其管理的应用实例不是固定的，而是可以任意伸缩。这带来了很多的好处，例如可以支持弹性伸缩、滚动更新等等。 但是相反的，这也会导致应用实例IP不固定，从访问者的角度我们不可能每次去查找当前的应用实例。 所以，为了能提供稳定的访问入口，我们还需要部署“服务”来接收请求，并屏蔽内部的弹性机制。 部署服务，我们继续 yaml 文件的方式操作，创建 service.yaml： apiVersion:v1kind:Servicemetadata:name:myapp-servicenamespace:handson-3e8b9bbfb31484d1aaddf1a82156c3bfspec:ports:- port:8080targetPort:8080protocol:TCPtype:NodePortselector:name:myapp 我们看到 Service 的定义相对简单很多，其中有几个关键属性需要说明： selector，这是一个选择器，通过 name=myapp 这个条件来选择需要代理的服务 ports，这里定义了服务自身暴露的端口和需要访问的应用的端口 继续通过 kubectl 命令执行： kubectl apply -f ~/service.yaml 然后通过下面的命令查看刚才部署的 service： kubectl get service 我们会看到下面的反馈信息： NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE myapp-service NodePort 172.21.12.82 \u003cnone\u003e 8080:30163/TCP 2s 这里我们就完成了 service 的部署。下面通过 ingress 将内部的服务暴露出去。 ","date":"2021-04-20","objectID":"/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/:3:0","tags":["”k8s“"],"title":"使用Kubectl部署web服务到K8s集群","uri":"/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"配置 ingress 开放外部访问 k8s 是一个集群，deployment、service 都是集群内部的资源，他们通过一个内部虚拟网络互相访问。 但是对于外部的用户，这些所有的资源都是不可见的，所以我们还需要配置一个外部访问的入口到 service 的映射规则，从而将内部服务暴露出去。 这里我们就需要使用 ingress 的来实现服务对外暴露的需求。 我们继续使用 yaml 来定义 ingress 规则： apiVersion:networking.k8s.io/v1beta1kind:Ingressmetadata:name:example-ingressnamespace:handson-3e8b9bbfb31484d1aaddf1a82156c3bfspec:rules:- http:paths:- path:/welcomebackend:serviceName:myapp-serviceservicePort:8080 继续通过 kubectl 命令执行： kubectl apply -f ~/ingress.yaml 然后通过下面的命令查看刚才部署的 service： kubectl get ingress 我们会看到下面的反馈信息： NAME CLASS HOSTS ADDRESS PORTS AGE example-ingress \u003cnone\u003e * 47.100.138.224 80 72s 通过这个返回值信息，我们可以看到，访问地址是47.100.138.224，端口是80。 所以我们可以通过下面的链接访问刚才部署的应用：http://47.100.138.224/welcome 除了部署服务，我们还需要能卸载相关资源，才算完整的流程 ","date":"2021-04-20","objectID":"/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/:4:0","tags":["”k8s“"],"title":"使用Kubectl部署web服务到K8s集群","uri":"/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"卸载资源 光是配置并提供服务只完成了一半的工作，完整的操作周期除了正向的安装，还包含了逆向的卸载，下面我们就来学习如何把刚才配置的各种资源给卸载掉。 资源卸载我们就不使用 yaml 脚本了，直接使用 kubectl 命令就可以完成： 卸载 ingress kubectl delete ingress example-ingress 卸载 service kubectl delete service myapp-service 卸载 deployment kubectl delete deployment myapp-deployment 至此玩我们就完成了卸载工作，最后再用下面的命令确认一下我们的卸载结果： kubectl get deployment kubectl get service kubectl get ingress 你可能会看到： NAME READY STATUS RESTARTS AGE pod/myapp-deployment-5cd4d7c78d-kx7kn 0/1 Terminating 0 29m Terminating 代表 pod 正在卸载中，多运行几次后，会看到下面的提示： No resources found in handson-3e8b9bbfb31484d1aaddf1a82156c3bf namespace. 代表卸载工作完成 ","date":"2021-04-20","objectID":"/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/:5:0","tags":["”k8s“"],"title":"使用Kubectl部署web服务到K8s集群","uri":"/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/"},{"categories":["Tools"],"content":"下载站点 工具：Fiddler 1、打开Fiddler工具，开启Https代理： 2、登录账户，会有50个币，点击页面下载发现Fiddler中并没有拿到下载接口，所以用50币先下载一个能够下载的，先拿到接口： 只能拿到相对路由，手动下载，拿到接口： 接口： https://kuangstudy.oss-cn-beijing.aliyuncs.com/download/note/JavaScript_hvtser8u0.rar?Expires=1618756583\u0026OSSAccessKeyId=LTAI4G9FmSQ5cVvkR2ZVjSYi\u0026Signature=LuaKA5VVvNrPAYERGfvrwC7%2BeXQ%3D 只用把其中的下载路径换一下就OK了 ","date":"2021-04-18","objectID":"/kuangdownload/:0:0","tags":["KuangDownload"],"title":"KuangDownload","uri":"/kuangdownload/"},{"categories":["数据库"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 1、初识MySQL JavaEE：企业级Java开发 Web 前端（页面：展示：数据） 后台 （连接点：连接数据库JDBC,连接前端（控制视图跳转，给前端传递数据）） 数据库（存数据，Txt,Excel,Word） 只会写代码，学好数据库，基本混饭吃： 操作系统，数据结构与算法！当一个不错的程序猿！ 离散数学，数字电路，体系结构，编译原理。+实战经验，优秀程序猿 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"1.1为什么学数据库 1、岗位需求 2、现在的世界，大数据时代，得数据者得天下 3、被迫需求：存数据 4、数据库是所有软件体系中最核心的存在 DBA ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"1.2 什么是数据库 数据库：(DB,DataBase) 概念:数据仓库，软件，安装在操作系统之（windows,Linux。mac）上的！SQL,可以存储大量的数据，500万! 作用:存储数据，管理数据 Excel ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"1.3 数据库分类 关系型数据库：(SQL) MySQL, Oracle, sql Server, DB2, SQLite 通过表和表之间，行和列之间的关系进行数据的存储 非关系型数据库：(NoSQL) Not Only SQL Redis, MongDB 非关系型数据库，对象存储，通过对象自身的属性来决定。 **DBMS(数据库管理系统) ** 数据库的管理软件，科学有效的管理我们的数据，维护和获取 MySQL ，数据管理系统！ ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"1.4 MySQL简介 MySQL是一个**关系型数据库管理系统** 前世： 瑞典MySQL AB 公司 今身： 属于 Oracle 旗下产品 MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 开源的数据库软件 体积小，速度快，总体拥有成本低，招人成本比较低。 中小型网站，或者大型网站，集群 官网： https://www.mysql.com/ ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"1.5连接数据库 命令行连接！ `mysql-uroot-p123456--连接数据库updatemysql.usersetauthentication_string=password('123456')whereuser='root'andHost='localhost';--修改密码flushprivileges;--刷新权限-------------------------------------------------- --所有语句使用;结尾-- showdatabases;--查看所有的数据库mysql\u003euseschool--切换数据库，use数据库名Databasechanged-- show tables;--查看数据库中所有的表 describestudent;--显示数据库中所有的表的信息createdatabasewestos;--创建一个数据库exit;--退出连接--单行注释（sql本来注释）/* 多行注释 */` 2、操作数据库 操作数据库》操作数据库中的表》操作数据库中表的数据 MySQL不区分大小写 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.1操作数据库 1.创建数据库 `CREATEDATABASEIFNOTEXISTSwestos;` 2.删除数据库 `DROPDATABASEIFEXISTSwestos` 3.使用数据库 `-- ``,如果你的表名或者字段名是一个特殊字符，需要带`` USE'school'` 4.产看数据库 `SHOWDATABASES--查看所有数据库` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.2数据库的列类型 数值 tinyint 十分小的数据 1个字节 smallint 较小的数据 2个字节 mediumint 中等大小 3个字节 int 标准的整数 4个字节（常用） bigint 较大的数据 8个字节 float 浮点数 4个字节 double 浮点数 8个字节 （精度问题） decimal 字符串形式的浮点数,金融计算的时候，一般用 字符串 char 字符串固定大小 0-255 varchar 可变字符串 0-65535（常用） tinytext 微型文本 2^8-1 text 文本串 2^16-1 (保存大文本) 时间日期 java.util.Date date YYYY-MM-DD，日期 time HH:mm:ss 时间格式 datetime YYYY-MM-DD HH:mm:ss 最常用的时间格式 timestamp 时间戳 1970.1.1到现在的毫秒数 year 年份表示 null 没有值，未知 注意，不要使用null进行运算，结果为null ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.3数据库的字段类型（重点） unsigened: 无符号的整数 声明该列不能声明负数 zerofill: 0填充的 10的长度 1 – 0000000001 不足位数用0 填充 自增： 通常理解为自增，自动在上一条记录的基础上+1 通常用来设计唯一的主键 index,必须是整数类似 可以自定义设置主键自增的起始值和步长 非空 NULL not Null 假设设置为 not null，如何不给他赋值，就会报错 NULL 如果不填写，默认为NULL 默认： 设置默认的值！ ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.4 创建数据库表 ``--目标:创建一个schoo1数据库--创建学生表(列,字段)使用SQL创建--学号int登录密码varchar(20)姓名,性别varchar(2),出生日期(datatime)，家庭住址，emai1--注意点，使用英文()，表的名称和字段尽量使用括起来-- AUTO_ INCREMENT 自增 --字符串使用单引号括起来!--所有的语句后面加，(英文的)，最后一个不用加-- PRIMARY KEY 主键，一般- 一个表只有一个唯一 -的主键! CREATEDATABASEschoolCREATETABLEIFNOTEXISTS`student`(`id`INT(4)NOTNULLAUTO_INCREMENTCOMMENT'学号',`name`VARCHAR(30)NOTNULLDEFAULT'匿名'COMMENT'姓名',`pwd`VARCHAR(20)NOTNULLDEFAULT'123456'COMMENT'密码',`sex`VARCHAR(2)NOTNULLDEFAULT'男'COMMENT'性别',`birthday`DATETIMEDEFAULTNULLCOMMENT'出生日期',`address`VARCHAR(100)DEFAULTNULLCOMMENT'家庭住址',`email`VARCHAR(50)DEFAULTNULLCOMMENT'邮箱',PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8`` 格式 ``CREATETABLE[IFNOTEXISTS]`表名`（`字段名`列类型[属性][索引][注释],`字段名`列类型[属性][索引][注释],...`字段名`列类型[属性][索引][注释]）[表类型][表的字符集设置][注释]`` 常用命令 `SHOWCREATEDATABASEschool-- 查看创建数据库的语句 SHOWCREATETABLEstudent-- 查看student数据表的定义语句 DESCstudent-- 显示表的结构` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.5数据表的类型 `-- 关于数据库引擎 /* INNODB 默认使用 MYISAM 早些年使用 */` MYISAMINNODB事务支持不支持支持数据行锁定不支持支持外键约束不支持支持全文索引支持不支持表空间的大小较小较大，约为MYISAM的两倍 常规使用操作： MYISAM 节约空间，速度较快， INNODB 安全性高，事务处理，多表多用户操作 在物理空间存在的位置 所有的数据库文件都存在data目录下，一个文件夹就对应一个数据库 本质还是文件的存储 MySQL 引擎在物理文件上的区别 innoDB 在数据库表中，只有一个*.frm文件，以及上级目录下的ibdata1文件 MYISAM 对应的文件 *.frm - 表结构的定义文件 *. MYD -数据文件 *.MYI 索引文件 设置数据库字符集编码 `CHARTSET=UTF8` 不设置的话，会是mysql默认的字符集编码-（不支持中文） 可以在my.ini中配置默认的编码 `character-set-server=utf8` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.6修改删除表 修改 `-- 修改表名 ALTER TABLE 旧表面 AS 新表名 ALTERTABLEstudentRENAMEASstudent1-- 增加表的字段 ALTER TABLE 表名 ADD 字段名 列属性 ALTERTABLEstudent1ADDageINT(11)-- 修改表的字段（重命名，修改约束） ALTERTABLEstudent1MODIFYageVARCHAR(11)-- 修改约束 ALTERTABLEstudent1CHANGEageage1INT(1)-- 字段重命名 -- 删除表的字段 ALTERTABLEstudent1DROPage1` 删除 `-- 删除表 DROPTABLEIFEXISTSstudent1` 所有的创建和删除操作尽量加上判断，以免报错 注意点： `` 字段名，使用这个包裹 注释 – /**/ sql 关键字大小写不敏感，建议写小写 所有的符号全部用英文 3、MySQL数据管理 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"3.1外键（了解） 方式一：在创建表的时候，增加约束（麻烦，比较复杂） ``CREATETABLE`grade`(`gradeid`INT(10)NOTNULLAUTO_INCREMENTCOMMENT'年级id',`gradename`VARCHAR(50)NOTNULLCOMMENT'年级名称',PRIMARYKEY(`gradeid`))ENGINE=INNODBDEFAULTCHARSET=utf8-- 学生表的 gradeid 字段 要去引用年级表的gradeid -- 定义外键KEY -- 给这个外键添加约束（执行引用） references 引用 CREATETABLEIFNOTEXISTS`student`(`id`INT(4)NOTNULLAUTO_INCREMENTCOMMENT'学号',`name`VARCHAR(30)NOTNULLDEFAULT'匿名'COMMENT'姓名',`pwd`VARCHAR(20)NOTNULLDEFAULT'123456'COMMENT'密码',`sex`VARCHAR(2)NOTNULLDEFAULT'男'COMMENT'性别',`birthday`DATETIMEDEFAULTNULLCOMMENT'出生日期',`gradeid`INT(10)NOTNULLCOMMENT'学生年级',`address`VARCHAR(100)DEFAULTNULLCOMMENT'家庭住址',`email`VARCHAR(50)DEFAULTNULLCOMMENT'邮箱',PRIMARYKEY(`id`),KEY`FK_gardeid`(`gradeid`),CONSTRAINT`FK_gardeid`FOREIGNKEY(`gradeid`)REFERENCES`grade`(gradeid))ENGINE=INNODBDEFAULTCHARSET=utf8`` 删除有外键关系的表的时候，必须先删除引用的表（从表），再删除被引用的表（主表） 方式二： 创建表成功后添加外键 ``CREATETABLE`grade`(`gradeid`INT(10)NOTNULLAUTO_INCREMENTCOMMENT'年级id',`gradename`VARCHAR(50)NOTNULLCOMMENT'年级名称',PRIMARYKEY(`gradeid`))ENGINE=INNODBDEFAULTCHARSET=utf8-- 学生表的 gradeid 字段 要去引用年级表的gradeid -- 定义外键KEY -- 给这个外键添加约束（执行引用） references 引用 CREATETABLEIFNOTEXISTS`student`(`id`INT(4)NOTNULLAUTO_INCREMENTCOMMENT'学号',`name`VARCHAR(30)NOTNULLDEFAULT'匿名'COMMENT'姓名',`pwd`VARCHAR(20)NOTNULLDEFAULT'123456'COMMENT'密码',`sex`VARCHAR(2)NOTNULLDEFAULT'男'COMMENT'性别',`birthday`DATETIMEDEFAULTNULLCOMMENT'出生日期',`gradeid`INT(10)NOTNULLCOMMENT'学生年级',`address`VARCHAR(100)DEFAULTNULLCOMMENT'家庭住址',`email`VARCHAR(50)DEFAULTNULLCOMMENT'邮箱',PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8-- 创建表的时候没有外键关系 ALTERTABLE`student`ADDCONSTRAINT`FK_gradeid`FOREIGNKEY(`gradeid`)REFERENCES`grade`(`gradeid`);-- ALTER TABLE`表` ADD CONSTRAINT 约束名 FOREIGN KEY（作为外键的列） 引用到哪个表的哪个字段`` 以上的操作都是物理外键，数据库级别外键，不建议使用。（避免数据库过多造成困扰） 最佳实践 数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段） 我们想使用多张表的数据，想使用外键（程序去实现） ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"3.2 DML语言（全记住） 数据库意义：数据存储，数据管理 DML语言：数据操作语言 Insert update delete ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"3.3添加 insert ``-- 插入语句（添加） -- nsert into 表名（[字段一], [字段二]）values('值1'),('值2') INSERTINTO`grade`(`gradename`)VALUES('大四')-- 由于主键自增我们可以省略（如何不写表的字段，他会一一匹配） INSERTINTO`grade`VALUES('大三')INSERTINTO`grade`(`gradeid`,`gradename`)VALUES('大三','null')-- 一般写插入语句，我们一定要数据和字段一一对应。 -- 插入多个字段 INSERTINTO`grade`(`gradename`)VALUES('大二'),('大一');INSERTINTO`student`(`name`)VALUES('张三')INSERTINTO`student`(`name`,`pwd`,`sex`)VALUES('张三','aaaaa','男')INSERTINTO`student`(`name`,`pwd`,`sex`)VALUES('李四','aaaaa','男'),('王五','23232','女')`` 语法：– insert into 表名（[字段一], [字段二]）values(‘值1’),(‘值2’) 注意事项： 1.字段和字段之间用逗号分开 2.字段可以省略，但是后面的值必须一一对应 3.可以同时插入多条数据，VALUES后面的值需要使用，隔开即可 ``INSERTINTO`student`(`name`,`pwd`,`sex`)VALUES('李四','aaaaa','男'),('王五','23232','女')`` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:14:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"3.4 修改 update 修改谁（条件） set 原来的值=新值 ``-- 修改学员名字 UPDATE`student`SET`name`='囷'WHEREid=1;-- 不指定条件的情况下，会改动所有表 UPDATE`student`SET`name`='233'-- 语法； -- UPDATE 表名 set column_name,[] = value where 条件`` 条件：where 子句 运算符 id 等于 某个值，大于某个值，在某个区间内修改 操作符返回布尔值 操作符含义范围结果=等于5=6false!= \u003c\u003e不等于5！=6true\u003e大于\u003c小于\u003e=\u003c=between and在某个范围内，闭合区间and\u0026\u00265\u003e1and1\u003e2falseor||5\u003e1or1\u003e2true 注意： column_name 是数据库的列，带上`` 条件，是筛选的条件，如果没有指定，则会修改所有的列 value 是一个具体的值，也可以是一个变量 多个设置的属性之间，使用英文逗号隔开 ``UPDATE`student`SET`birthday`=CURRENT_TIMEwhere`name`='李四'ANDSEX='男'`` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:15:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"3.5 删除 delete 命令 语法 delete from 表名 [where 条件] ``-- 删除数据 (避免这样写) DELETEFROM`student`-- 删除指定 DELETEFROM`student`whereid=1`` TRUNCATE 命令 作用：完全清空一个数据库，表的结构和索引不会变 delete 和 TRUNCATE 区别 相同点： 都能删除数据，都不会删除表结构 不同： TRUNCATE 重新设置自增列 计数器会归零 TRUNCATE 不会影响事务 ``-- 测试delete 和 truncate 区别 CREATETABLE`test`(`id`INT(4)NOTNULLAUTO_INCREMENT,`coll`VARCHAR(20)NOTNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTO`test`(`coll`)VALUES('1'),('2'),('3')DELETEFROM`test`-- 不会影响自增 TRUNCATETABLE`test`-- 自增会归零`` 了解即可：delete删除的问题 重启数据库，现象 innoDB 自增列会从1开始（存在内存当中，断电即失） MyISAM 继续从上一个自增量开始（存在文件中，不会丢失） 4、DQL查询数据（最重点） ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:16:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.1DQL (Data Query Language) :数据查询语言 所有的查询操作都用它 Select 简单的查询，复杂的查询它都能做 数据库中最核心的语言 使用频率最高的语言 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:17:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.2指定查询字段 ``-- 查询 SELECT 字段 FROM 表 -- 查询指定字段 such as SELECT`StudentNo`,`StudentName`FROMstudent-- 别名，给结果起一个名字 AS 可以给字段起别名 也可以给表起别名 SELECT`StudentNo`AS学号,`StudentName`AS学生姓名FROMstudentASS-- 函数 Concat(a,b) SELECTCONCAT('姓名：',StudentName)AS新名字FROMstudent`` 语法： SELECT 字段 ... FROM 表 有时候，列名字不是那么见名知意。我们起别名 AS 字段名 AS 别名 表名 AS 别名 去重 作用：去除select语句查询出来的结果中重复的语句，重复的语句只显示一条 ``-- 查询一下有哪些同学参加了考试，成绩 SELECT*FROMresult-- 查询全部的考试成绩 -- 查询有哪些同学参加了考试 SELECT`studentNo`FROMresult-- 发现重复数据，去重 SELECTDISTINCT`studentNo`FROMresult`` 数据库的列（表达式） ``SELECTVERSION()--查询系统版本（函数）SELECT100*3-1AS计算结果-- 用来计算（表达式） SELECT@@auto_increment_increment--查询自增的步长（变量）-- 学员考试成绩+1 分 查看 SELECT`StudentNo`,`StudentResult`+1AS'提分后'FROMresult`` 数据库中的表达式： 文本值，列，Null , 函数，计算表达式，系统变量… select 表达式 from 表 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:18:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.3where 条件子句 作用：检索数据中符合条件的值 逻辑运算符 运算符语法结果and \u0026\u0026a and b a\u0026\u0026b逻辑与or ||a or b a||b逻辑或Not !=not a !a逻辑非 尽量使用英文 ``-- 查询考试成绩在95分到100分之间 SELECT `StduentNo`,`StudentResult` FROM result WHERE StudentResult \u003e=95 AND StudentResult\u003c=100 -- 模糊查询（区间） SELECT `StduentNo`,`StudentResult` FROM result WHERE StudentResult BETWEEN 95 AND 100 -- 除了1000号学生之外的同学成绩 SELECT `StduentNo`,`StudentResult` FROM result WHERE NOT StudentNo = 1000`` 模糊查询：比较运算符 运算符语法描述I S NULLa is null如果操作符为null 结果为真IS NOT NULLa is not null如果操作符为not null 结果为真BETWEENa between b and c若a在b 和c之间则为真LIKEa like bSQL匹配，如果a 匹配到b 则为真INa in (a1,a2,a3…)假设a 在 a1,a2,a3其中的某一个中，为真 ``-- 查询姓刘的同学 -- like结合 %（代表0到任意字符） _(一个字符) SELECT`StudentNo`,`StudentName`FROM`student`WHEREStudentNameLIKE'刘%';-- 查询姓刘的同学，名字后只有一个字 SELECT`StudentNo`,`StudentName`FROM`student`WHEREStudentNameLIKE'刘_';-- 查询姓刘的同学，名字后只有两个字 SELECT`StudentNo`,`StudentName`FROM`student`WHEREStudentNameLIKE'刘__';-- 查询名字中间有嘉字的同学 %嘉% SELECT`StudentNo`,`StudentName`FROM`student`WHEREStudentNameLIKE'%嘉%';===================IN(具体的一个或者多个值)===========================-- 查询1001 1002 1003 学员信息 SELECT`StudentNo`,`StudentName`FROM`student`WHEREStudentNo=1001SELECT`StudentNo`,`StudentName`FROM`student`WHEREStudentNo=1002SELECT`StudentNo`,`StudentName`FROM`student`WHEREStudentNo=1003SELECT`StudentNo`,`StudentName`FROM`student`WHEREStudentNoIN(1001,1002,1003);-- 查询在北京的学生 SELECT`StudentNo`,`StudentName`FROM`student`WHERE`Address`IN('安徽','河南洛阳');===================NULLNOTNULL===================================-- 查询地址为空的学生 null '' SELECT`StudentNo`,`StudentName`FROM`student`WHEREaddress=''ORaddressISNULL-- 查询有出生日期的同学 不为空 SELECT`StudentNo`,`StudentName`FROM`student`WHERE`BornDate`ISNOTNULL;`` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:19:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.4 联表查询 JOIN 对比 `======================联表查询join==============================-- 查询参加考试的同学 （学号，姓名，考试编号，分数） SELECT*FROMstudentSELECT*FROMresult/* 1. 分析需求，分析查询的字段来自哪些表 2.确定使用哪种连接查询？7种 确定交叉点（这两个表中哪个数据是相同的） 判断的条件： 学生表中 studentNo = 成绩表中 studentNo */-- JION（表） ON （判断的条件）连接查询 -- where 等值查询 SELECTstudentNo,studentName,SubjectNo,StudentResultFROMstudentASsINNERJOINresultASrWHEREs.studentNo=r.studentNo--RightJoinSELECTs.studentNo,studentName,SubjectNo,StudentResultFROMstudentASsRIGHTJOINresultASrONs.studentNo=r.studentNo--LEFTJoinSELECTs.studentNo,studentName,SubjectNo,StudentResultFROMstudentASsLEFTJOINresultASrONs.studentNo=r.studentNo` 操作描述Inner join如果表中至少有一个匹配，就返回行left join即使左表中没有匹配，也会从左表中返回所有的值right jion即使右表中没有匹配，也会从右表中返回所有的值 ``-- 查询考的同学 SELECTs.studentNo,studentName,SubjectNo,StudentResultFROMstudentASsLEFTJOINresultASrONs.studentNo=r.studentNoWHEREStudentResultISNULL-- 查询了参加考试同学的信息：学号：学生姓名：科目名：分数 SELECTs.`studentNo`,`studentName`,`SubjectName`,`studentResult`FROMstudentsRIGHTJOINresultrONr.studentNo=s.studentNoINNERJOIN`subject`subONr.SubjectNo=sub.SubjectNo-- 我要查询哪些数据 SELECT .... -- 从哪几个表中查 FROM 表 xxx JOIN 连接的表 ON 交叉条件 -- 假设存在一中多张表查询，先查询两章表，然后再慢慢增加 --FROMaLEFTJOINb左为准--FROMaRIGHTJOINb右为准`` 自连接 自己的表跟自己的表连接，核心：一张表拆为两张一样的表 父类 categoryidcategoryName2信息技术3软件开发5美术设计 子类 pidcategoryidcategoryName34数据库28办公信息36web开发57ps技术 操作：查询父类对应子类关系 父类子类信息技术办公信息软件开发数据库软件开发web开发美术设计ps技术 ``-- 查询父子信息 SELECTa.`categroryName`AS`父栏目`,b.`categroryName`AS`子栏目`FROM`catgroy`ASa,`catgroy`ASbWHEREa.`categoryid`=b.`pid``` ``-- 查询学员所属的年级（学号，学生的姓名，年级） SELECTstudentNo,studentName,gradeNameFROMstudentsINNERJOIN`grade`gONs.`GradeId`=g.`GradeId``` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:20:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.5分页和排序 `============================分页limit和排序orderby=================-- 排序： 升序ASC 降序 DESC SELECTxxFROMxxJOINxxWHERExxORDERBYxxASC||DESC` 分页 ``-- 为什么要分页 -- 缓解数据库压力，给人的体验更好 -- 分页，每页显示五条数据 -- 语法： limit 当前页，页面的大小 -- limit 0,5 1-5 -- limit 1,5 1-5 -- limit 6,5 SELECTs.`StudentNo`,`StudentName`,`SubjectName`,`StudentResult`FROMstudentsINNERJOIN`result`rONs.`StudentNo`=r.`StudentNo`INNERJOIN`subject`subONr.`subjectNo`=sub.`subjectNo`WHEREsubjectName='数据结构-1'ORDERBYStudentResultASCLIMIT0,5-- 第一页 limit 0,5 -- 第二页 limit 5,5 -- 第三页 limit 10,5 -- 第N页 limit 5*（n-1）,5`` 语法 limit(查询起始下标，pagesize) ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:21:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.6 子查询 where (这个值是计算出来的) 本质：在where语句中嵌套一个子查询语句 ``-- ===========================where========================= -- 1.查询 数据库结构-1的所有考试结构（学号，科目编号，成绩） 降序 -- 方式一： 连接查询 SELECT`StudentNo`,r.`SubjectName`,`StudentResult`FROM`result`rINNERJOIN`subject`subONr.SubjectNo=sun.SubjectNoWHEREsubjectName='数据库结构-1'ORDERBYStudentResultDESC-- 方式二：使用子查询(由里及外) SELECT`StudentNo`,r.`SubjectName`,`StudentResult`FROM`result`WHEREStudentNo=(SELECTSubjectNoFROM`subject`WHERESubjectName='数据库结构-1')ORDERBYStudentResultDESC-- 分数不少于80分的学生的学号和姓名 SELECTDISTINCTs.`StudentNo`,`StudentName`FROMstudentsINNERJOINresultrONr.StudentNo=s.StudentNoWHEREStudentResult\u003e=80-- 在这个基础上 增加一个科目 ，高等数学-2 SELECTDISTINCTs.`StudentNo`,`StudentName`FROMstudentsINNERJOINresultrONr.StudentNo=s.StudentNoWHEREStudentResult\u003e=80AND`SubjectNo`=(SELECTSubjectFROM`subject`WHERESubjectName='高等数学-2')-- 查询课程为 高等数学-2 且分数不小于80分的同学的学号和姓名 SELECTs.`StudentNo`,`StudentName`FROMstudentsINNERJOINresultrONs.StudentNo=r.StudentNoINNERJOIN`subject`subONr.`SubjectName`='高等数学-2'WHERE`SubjectaName`='高等数学-2'ANDStudentResult\u003e=80-- 再改造 (由里即外) SELECT`StudentNo`,`StudentName`FROMstudentWHEREStudentNoIN(SELECTStudentNoresultWHEREStudentResult\u003e80ANDSubjectNo=(SELECTSubjectNoFROM`subject`WHERE`SubjectaName`='高等数学-2'))`` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:22:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.7 分组 ``-- 查询不同课程的平均分，最高分，最低分，平均分大于80 -- 核心：（根据不同的课程分组） SELECT`SubjectName`,AVG(StudentResult),MAX(StudentResult)FROMresultrINNERJOIN`Subject`subONr.SubjectNo=sub.SubjectNoGROUPBYr.SubjectNo-- 通过什么字段来分组 HAVINGAVG(StudentResult)\u003e80`` 5、MySQL函数 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:23:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"5.1 常用函数 `-- 数学运算 SELECTABS(-8)-- 绝对值 SELECTCEILING(9.4)-- 向上取整 SELECTFLOOR(9.4)-- 向下取整 SELECTRAND()-- 返回0-1随机数 SELECTSIGN(-10)-- 判断一个数的符号 0-0 负数返回-1 正数返回1 -- 字符串函数 SELECTCHAR_LENGTH('2323232')-- 返回字符串长度 SELECTCONCAT('我','233')-- 拼接字符串 SELECTINSERT('java',1,2,'cccc')-- 从某个位置开始替换某个长度 SELECTUPPER('abc')SELECTLOWER('ABC')SELECTREPLACE('坚持就能成功','坚持','努力')-- 查询姓 周 的同学 ，改成邹 SELECTREPLACE(studentname,'周','邹')FROMstudentWHEREstudentnameLIKE'周%'-- 时间跟日期函数（记住） SELECTCURRENT_DATE()-- 获取当前日期 SELECTCURDATE()-- 获取当前日期 SELECTNOW()-- 获取当前日期 SELECTLOCATIME()-- 本地时间 SELECTSYSDATE()-- 系统时间 SELECTYEAR(NOW())SELECTMONTH(NOW())SELECTDAY(NOW())SELECTHOUR(NOW())SELECTMINUTE(NOW())SELECTSECOND(NOW())-- 系统 SELECTSYSTEM_USER()SELECTUSER()SELECTVERSION()` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"5.2 聚合函数（常用） 函数名称描述COUNT()计数SUM()求和AVG()平均值MAX()最大值MIN()最小值… ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:25:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"5.3 数据库级别MD5加密（拓展） 什么是MD5 主要增强算法复杂度不可逆性。 MD5不可逆，具体的MD5是一样的 MD5破解原理，背后有一个字典，MD5加密后的值，加密前的值 ``CREATETABLE`testmd5`(`id`INT(4)NOTNULL,`name`VARCHAR(20)NOTNULL,`pwd`VARCHAR(50)NOTNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=UTF8-- 明文密码 INSERTINTOtestmd5VALUES(1,'张三','123456'),(2,'李四','123456'),(3,'王五','123456')-- 加密 UPDATEtestmd5SETpwd=MD5(pwd)WHEREid=1UPDATEtestmd5SETpwd=MD5(pwd)WHEREid!=1-- 加密全部 -- 插入时加密 INSERTINTOtestmd5VALUES(4,'小明',MD5('123456'))INSERTINTOtestmd5VALUES(5,'红',MD5('123456'))-- 如何校验，将用户传递过来的密码，进行MD5加密，然后对比加密后的值 SELECT*FROMtestmd5WHERE`name`='红'ANDpwd=MD5('123456')`` 6、事务 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:26:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"6.1 什么是事务 要么都成功，要么都失败 SQL执行， A给B转账 A 1000–\u003e 200 B200 SQL 执行， B收到A的钱 A800 — B400 将一组SQL放在一个批次中执行 事务原则 ： ACID原则 原子性，一致性，隔离性，持久性 （脏读，幻读…） 原子性（Atomicity） 要么都成功，要么都失败 一致性（Consistency） 事务前后的数据完整性要保持一致 持久性（Durability）–事务提交 事务一旦提交就不可逆转，被持久化到数据库中 隔离性 事务产生多并发时，互不干扰 隔离产生的问题 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:27:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"脏读： 指一个事务读取了另外一个事务未提交的数据。 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:28:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"不可重复读： 在一个事务内读取表中的某一行数据，多次读取结果不同。（这个不一定是错误，只是某些场合不对） ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:29:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"虚读(幻读) 是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。 （一般是行影响，多了一行） 执行事务 `-- mysql 自动开启事务提交 SETautocommit=0-- 关闭 SETautocommit=1-- 开启（默认的） -- 手动处理事务 SETautocommit=0-- 关闭自动提交 -- 事务开启 STARTTRANSACTION-- 标记一个事务的开始，从这个之后的SQP都在同一个事务内 INSERTXXINSERTXX-- 提交 ： 持久化(成功) COMMIT-- 回滚： 回到原来的样子（失败） ROLLBACK-- 事务结束 SETautocommit=1-- 开启自动提交 -- 了解 SAVEPOINT保存点名称-- 设置一个事务的保存点 ROLLBACKTOSAVEPOINT保存点名-- 回滚到保存点 RELEASESAVEPOINT保存点-- 删除保存点` [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DfVvNLP7-1594142971424)(C:\\Users\\53424\\AppData\\Roaming\\Typora\\typora-user-images\\1594012051660.png)] 模拟场景 ``CREATEDATABASEshopCHARACTERSETutf8COLLATEutf8_general_ciUSEshopCREATETABLE`account`(`id`INT(3)NOTNULLAUTO_INCREMENT,`name`VARCHAR(30)NOTNULL,`money`DECIMAL(9,2)NOTNULL,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8INSERTINTOaccount(`name`,`money`)VALUES('A',2000),('B',10000)-- 模拟转账：事务 SETautocommit=0;-- 关闭自动提交 STARTTRANSACTION-- 开启事务（一组事务） UPDATEaccountSETmoney=money-500WHERE`name`='A'-- A 转账给B UPDATEaccountSETmoney=money+500WHERE`name`='B'-- B 收到钱 COMMIT;-- 提交事务 ROLLBACK;-- 回滚 SETautocommit=1-- 恢复默认值`` 7、索引 MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:30:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"7.1索引的分类 在一个表中，主键索引只能有一个，唯一索引可以有多个 主键索引 （PRIMARY KEY） 唯一的标识，主键不可重复，只能有一个列作为主键 唯一索引 （UNIQUE KEY） 避免重复的列出现，唯一索引可以重复，多个列都可以标识唯一索引 常规索引（KEY/INDEX） 默认的，index,key关键字来设置 全文索引（FULLTEXT） 在特点的数据库引擎下才有，MyISAM 快速定位数据 `-- 索引的使用 -- 1.在创建表的时候给字段增加索引 -- 2.创建完毕后，增加索引 -- 显示所有的索引信息 SHOWINDEXFROM表-- 增加一个索引 ALTERTABLE表ADDFULLTEXTINDEX索引名（字段名）-- EXPLAIN 分析sql执行状况 EXPLAINSELECT*FROMstudent-- 非全文索引` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:31:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"7.2 测试索引 ``CREATETABLE`app_user`(`id`BIGINT(20)UNSIGNEDNOTNULLAUTO_INCREMENT,`name`VARCHAR(50)DEFAULT'',`email`VARCHAR(50)NOTNULL,`phone`VARCHAR(20)DEFAULT'',`gender`TINYINT(4)UNSIGNEDDEFAULT'0',`password`VARCHAR(100)NOTNULLDEFAULT'',`age`TINYINT(4)DEFAULTNULL,`create_time`DATETIMEDEFAULTCURRENT_TIMESTAMP,`update_time`TIMESTAMPNOTNULLDEFAULTCURRENT_TIMESTAMPONUPDATECURRENT_TIMESTAMP,PRIMARYKEY(`id`))ENGINE=INNODBDEFAULTCHARSET=utf8-- 插入100万数据 DELIMITER$$-- 写函数之前必写 CREATEFUNCTIONmock_data()RETURNSINTBEGINDECLAREnumINTDEFAULT1000000;DECLAREiINTDEFAULT0;WHILEi\u003cnumDO-- 插入语句 INSERTINTOapp_user(`name`,`email`,`phone`,`gender`,`password`,`age`)VALUE(CONCAT('用户',i),'534240118@qq.com',FLOOR(CONCAT('18',RAND()*9999999)),FLOOR(RAND()*2),UUID(),FLOOR(RAND()*100));SETi=i+1;ENDWHILE;RETURNi;END;INSERTINTOapp_user(`name`,`email`,`phone`,`gender`,`password`,`age`)VALUE(CONCAT('用户',i),'534240118@qq.com',FLOOR(CONCAT('18',RAND()*9999999)),FLOOR(RAND()*2),UUID(),FLOOR(RAND()*100))SELECTmock_data();SELECT*FROMapp_userWHERE`name`='用户9999'-- 接近半秒 EXPLAINSELECT*FROMapp_userWHERE`name`='用户9999'-- 查询99999条记录 -- id _ 表名_字段名 -- create index on 字段 CREATEINDEXid_app_user_nameONapp_user(`name`);-- 0.001 s EXPLAINSELECT*FROMapp_userWHERE`name`='用户9999'-- 查询一条记录`` 索引在小数据的时候，用处不大，但是在大数据的时候，区别十分明显 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:32:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"7.3 索引原则 索引不是越多越好 不要对经常变动的数据加索引 小数据量的表不需要加索引 索引一般加在常用来查询的字段上 索引的数据结构 Hash 类型的索引 Btree: 默认innodb 的数据结构 阅读： http://blog.codinglabs.org/articles/theory-of-mysql-index.html 8、权限管理和备份 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:33:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"8.1用户管理 SQLyog 可视化管理 SQL命令操作 用户表：mysql.user 本质：对这张表进行，增删改查 `-- 创建用户 CREATE USER 用户名 IDENTIFIED BY '密码' CREATEUSERsanjinIDENTIFIEDBY'123456'-- 修改密码（修改当前密码） SETPASSWORD=PASSWORD('111111')-- 修改密码（修改指定用户密码） SETPASSWORDFORsanjin=PASSWORD('111111')-- 重命名 rename user 原名字 to 新名字 RENAMEUSERsanjinTOsanjin2-- 用户授权 ALL PRIVILEGES 全部的权限 库，表 -- ALL PRIVILEGES 除了给别人授权，其他都能干 GRANTALLPRIVILEGESON*.*TOsanjin2-- 查询权限 SHOWGRANTSFORsanjin2-- 查看指定用户的权限 SHOWGRANTSFORroot@localhost-- 撤销权限 REVOKE 哪些权限，在哪个库撤销，给谁撤销 REVOKEALLPRIVILEGESON*.*FROMsanjin2-- 删除用户 DROPUSERsanjin2` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:34:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"8.2 MySQL备份 为什么备份： 保证重要数据不丢失 数据转移 MySQL数据库备份的方式 直接拷贝物理文件 在SQLyog这种可视化工具中手动导出 在想要导出的表或者库中，右键选择备份和导出 9、规范数据库设计 当数据库比较复杂的时候，我们就需要设计了 糟糕的数据库设计： 数据冗余，浪费空间 数据库插入和删除都会麻烦，异常【屏蔽使用物理外键】 程序的性能差 良好的数据库设计： 节省内存空间 保证数据库的完整性 方便我们开发系统 软件开发中，关于数据库的设计 分析需求：分析业务和需要处理的数据库的需求 概要设计：设计关系图 E-R图 设计数据库的步骤（个人博客） 收集信息，分析需求 用户表（用户登录注销，用户的个人信息，写博客，创建分类） 分类表（文章分类，谁创建的） 文章表（文章的信息） 友链表（友链信息） 自定义表（系统信息，某个关键的字，或者某些主字段） 说说表（发表心情…id ,content ,time） 标识实体（把需求落地到每个字段） 标识实体之间的关系 写博客 user–\u003eblog 创建分类 user–\u003ecategory 关注 user–\u003euser 友链–\u003elinks 评论 user–\u003euser ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:35:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"9.2三大范式 为什么需要数据规范化？ 信息重复 更新异常 插入异常 删除异常 无法正常显示异常 删除异常 丢失有效的信息 三大范式 第一范式（1NF） 原子性：保证每一列不可再分 第二范式（2NF） 前提：满足第一范式 每张表只描述一件事情 第三范式（3NF） 前提：满足第一范式和第二范式 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 （规范数据库的设计） 规范性和性能的问题 关联查询的表，不得超过三张表 考虑商业化的需求和目标（成本和用户体验） 数据库的性能更加重要 再规范性能的问题的时候，需要适当的考虑一下，规范性 故意给某些表加一些冗余的字段（从多表，变成单表） 故意增加一些计算列（从大数据量降低为小数据量的查询：索引） 10、JDBC(重点) ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:36:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.1 数据库驱动 驱动：声卡，显卡，数据库 我们的程序会通过数据库驱动，和数据库打交道！ ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:37:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.2 JDBC SUN 公司为了简化开发人员的（对数据库的统一）操作，提供了一个(Java操作数据库的)规范，JDBC 这些规范的实现由具体的厂商去做 对于开发人员来说，我们只需要掌握JDBC的接口操作即可 java.sql javax.sql 还需要导入数据库驱动包 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:38:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.3 第一个JDBC程序 创建测试数据库 ``CREATEDATABASEjdbcStudyCHARACTERSETutf8COLLATEutf8_general_ci;USEjdbcStudy;CREATETABLE`users`(idINTPRIMARYKEY,NAMEVARCHAR(40),PASSWORDVARCHAR(40),emailVARCHAR(60),birthdayDATE);INSERTINTO`users`(id,NAME,PASSWORD,email,birthday)VALUES(1,'zhansan','123456','zs@sina.com','1980-12-04'),(2,'lisi','123456','lisi@sina.com','1981-12-04'),(3,'wangwu','123456','wangwu@sina.com','1979-12-04')`` 1.创建一个普通项目 2.导入数据库驱动 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-12VBmers-1594142971429)(C:\\Users\\53424\\AppData\\Roaming\\Typora\\typora-user-images\\1594046904540.png)] 3.编写测试代码 `package com.kuang.lesson01; //我的第一个JDBC程序 import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class JdbcFirstDemo { public static void main(String[] args) throws Exception { //1. 加载驱动 Class.forName(\"com.mysql.jdbc.Driver\");//固定写法 //2. 用户信息和url //useUnicode=true\u0026characterEncoding=utf8\u0026\u0026useSSL=true String url =\"jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true\u0026characterEncoding=utf8\u0026\u0026useSSL=false\"; String name = \"root\"; String password = \"123456\"; //3. 连接成功，返回数据库对象 connection代表数据库 Connection connection= DriverManager.getConnection(url,name,password); //4. 执行SQL的对象 statement 执行SQL的对象 Statement statement = connection.createStatement(); //5. 执行SQL的对象 去执行SQL 可能存在结果，查看返回结果 String sql=\"SELECT * FROM users\"; ResultSet resultSet = statement.executeQuery(sql);//返回的结果集,结果集中封装了我们全部查询的结果 while(resultSet.next()){ System.out.println(\"id+\"+resultSet.getObject(\"id\")); System.out.println(\"name+\"+resultSet.getObject(\"NAME\")); System.out.println(\"password+\"+resultSet.getObject(\"PASSWORD\")); System.out.println(\"email+\"+resultSet.getObject(\"email\")); System.out.println(\"birthday+\"+resultSet.getObject(\"birthday\")); } //6. 释放连接 resultSet.close(); statement.close(); connection.close(); } }` 步骤总结： 1.加载驱动 2.连接数据库 DriverManager 3.获取执行SQL的对象 Statement 4.获得返回的结果集 5.释放连接 DriverManager `//DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName(\"com.mysql.jdbc.Driver\");//固定写法 Connection connection= DriverManager.getConnection(url,name,password); //connection代表数据库 //数据库设置自动提交 //事务提交 //事务回滚 connection.rollback(); connection.commit(); connection.setAutoCommit();` URL `String url =\"jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true\u0026characterEncoding=utf8\u0026\u0026useSSL=false\"; //mysql 默认3306 //协议://主机地址:端口号/数据库名？参数1\u0026参数2\u0026参数3 //Oracle 1521 //jdbc:oralce:thin:@localhost:1521:sid` statement 执行SQL的对象 pPrepareStatement 执行SQL的对象 `String sql=\"SELECT * FROM users\";//编写Sql statement.executeQuery(); statement.execute(); statement.executeUpdate();//更新，插入，删除，返回一个受影响的行数` ResultSet 查询的结果集，封装了所以的查询结果 获得指定的数据类型 `ResultSet resultSet = statement.executeQuery(sql);//返回的结果集,结果集中封装了我们全部查询的结果 resultSet.getObject();//在不知道列类型下使用 resultSet.getString();//如果知道则指定使用 resultSet.getInt();` 遍历,指针 `resultSet.next(); //移动到下一个 resultSet.afterLast();//移动到最后 resultSet.beforeFirst();//移动到最前面 resultSet.previous();//移动到前一行 resultSet.absolute(row);//移动到指定行` 释放内存 `//6. 释放连接 resultSet.close(); statement.close(); connection.close();//耗资源` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:39:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.4statement对象 Jdbc中的statement对象用于向数据库发送SQL语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可。 Statement对象的executeUpdate方法，用于向数据库发送增、删、改的sq|语句， executeUpdate执行完后， 将会返回一个整数(即增删改语句导致了数据库几行数据发生了变化)。 Statement.executeQuery方法用于向数据库发生查询语句，executeQuery方法返回代表查询结果的ResultSet对象。 CRUD操作-create 使用executeUpdate(String sql)方法完成数据添加操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"insert into user(...) values(...)\"; int num = statement.executeUpdate(sql); if(num\u003e0){ System.out.println(\"插入成功\"); }` CRUD操作-delete 使用executeUpdate(String sql)方法完成数据删除操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"delete from user where id =1\"; int num = statement.executeUpdate(sql); if(num\u003e0){ System.out.println(\"删除成功\"); }` CURD操作-update 使用executeUpdate(String sql)方法完成数据修改操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"update user set name ='' where name = ''\"; int num = statement.executeUpdate(sql); if(num\u003e0){ System.out.println(\"修改成功\"); }` CURD操作-read 使用executeUpdate(String sql)方法完成数据查询操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"select * from user where id =1\"; ResultSet rs= statement.executeQuery(sql); if(rs.next()){ System.out.println(\"\"); }` 代码实现 1.提取工具类 `package com.kuang.lesson02.utils; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Properties; public class JdbcUtils { private static String driver = null; private static String url = null; private static String username = null; private static String password = null; static { try{ InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(\"db.properties\"); Properties properties = new Properties(); properties.load(in); driver=properties.getProperty(\"driver\"); url=properties.getProperty(\"url\"); user); password=properties.getProperty(\"password\"); //1.驱动只用加载一次 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } //2.获取连接 public static Connection getConnection() throws Exception{ return DriverManager.getConnection(url, username, password); } //3.释放资源 public static void release(Connection conn, Statement st, ResultSet rs) throws SQLException { if(rs!=null){ rs.close(); } if (st!=null){ st.close(); } if(conn!=null){ conn.close(); } } }` 2.编写增删改的方法，exectueUpdate ``package com.kuang.lesson02.utils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.Statement; import static com.kuang.lesson02.utils.JdbcUtils.*; public class TestInnsert { public static void main(String[] args){ Connection conn =null; Statement st = null; ResultSet rs =null; try { conn = getConnection();//获取连接 st = conn.createStatement();//获取SQL执行对象 String sql = \"INSERT INTO users(id,`NAME`,`PASSWORD`,`email`,`birthday`)\" + \"VALUES(5,'sanjin','123456','233223@qq.com','2020-01-01')\"; int i = st.executeUpdate(sql); if(i\u003e0){ System.out.println(\"插入成功\"); } JdbcUtils.release(conn,st,rs); } catch (Exception e) { e.printStackTrace(); } } }`` 3.查询 executeQuery `package com.kuang.lesson02.utils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import static com.kuang.lesson02.utils.JdbcUtils.*; public class TestInnsert { public static void main(String[] args) throws SQLException { Connection conn =null; Statement st = null; ResultSet rs =null; try { conn = getConnection();//获取连接 st = conn.createStatement();//获取SQL执行对象 String sql = \"select * from users\"; rs=st.executeQuery(sql);//查询完毕返回结果集 while (rs.next()){ System.out.println(rs.getString(\"NAME\")); } JdbcUtils.release(conn,st,rs); } catch (Exception e) { e.printStackTrace(); }finally { JdbcUtils.release(conn,st,rs); } } }` SQL注入问题 sql存在漏洞，会被攻击导致数据泄露 SQL会被拼接 or ``package com.kuang.lesson02.utils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import static com.kuang.lesson02.utils.JdbcUtils.getConnection; public class SQL注入 { public st","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:40:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.5 PreparedStatement对象 PreparedStatement 可以防止SQL注入 ，效率更高。 新增 删除 查询 ``package com.kuang.lesson03; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class Test { public static void main(String[] args) { Connection connection= null; PreparedStatement pstm=null; try { connection = JdbcUtils.getConnection(); //区别 //使用问好占位符代替参数 String sql = \"insert into users(id,`NAME`) values(?,?)\"; pstm = connection.prepareStatement(sql);//预编译sql，先写sql然后不执行 //手动赋值 pstm.setInt(1,8); pstm.setString(2,\"SANJIN\"); //执行 int i = pstm.executeUpdate(); if (i\u003e0){ System.out.println(\"插入成功\"); } } catch (Exception e) { e.printStackTrace(); }finally { try { JdbcUtils.release(connection,pstm,null); } catch (SQLException throwables) { throwables.printStackTrace(); } } } }`` 防止SQL注入本质，传递字符 带有“ ”，转义字符会被转义 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:41:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.6 使用IDEA连接数据库 连接成功后，可以选择数据库 双击数据库 更新数据 编写sql代码的地方 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:42:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.7 JDBC事务 要么都成功，要么都失败 ACID原则 原子性：要么全部完成，要么都不完成 一致性：结果总数不变 隔离性：多个进程互不干扰 持久性：一旦提交不可逆，持久化到数据库了 隔离性的问题： 脏读： 一个事务读取了另一个没有提交的事务 不可重复读：在同一个事务内，重复读取表中的数据，表发生了改变 虚读（幻读）：在一个事务内，读取到了别人插入的数据，导致前后读出来的结果不一致 代码实现 开启事务conn.setAutoCommit(false); 一组业务执行完毕，提交事务 可以在catch语句中显示的定义回滚，但是默认失败会回滚 `package com.kuang.lesson04; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class Action { public static void main(String[] args) { Connection conn =null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); //关闭数据库的自动提交功能， 开启事务 conn.setAutoCommit(false); //自动开启事务 String sql = \"update account set money = money-500 where id = 1\"; ps =conn.prepareStatement(sql); ps.executeUpdate(); String sql2 = \"update account set money = money-500 where id = 2\"; ps=conn.prepareStatement(sql2); ps.executeUpdate(); //业务完毕，提交事务 conn.commit(); System.out.println(\"操作成功\"); } catch (Exception e) { try { //如果失败，则默认回滚 conn.rollback();//如果失败，回滚 } catch (SQLException throwables) { throwables.printStackTrace(); } e.printStackTrace(); }finally { try { JdbcUtils.release(conn,ps,rs); } catch (SQLException throwables) { throwables.printStackTrace(); } } } }` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:43:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.8数据库连接池 数据库连接–执行完毕–释放 连接–释放 十分浪费资源 池化技术： 准备一些预先的资源，过来就连接预先准备好的 常用连接数 100 最少连接数：100 最大连接数 ： 120 业务最高承载上限 排队等待， 等待超时：100ms 编写连接池，实现一个接口 DateSource 开源数据源实现(拿来即用) DBCP C3P0 Druid: 阿里巴巴 使用了这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码了 DBCP 需要用到的jar包 dbcp.ar C3P0 结论 无论使用什么数据源，本质是不变的，DateSource接口不会变，方法就不会变 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:44:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:0","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1. 微服务概述 1.1 什么是微服务？ **什么是微服务？**微服务(Microservice Architecture) 是近几年流行的一种架构思想，关于它的概念很难一言以蔽之。 究竟什么是微服务呢？我们在此引用ThoughtWorks 公司的首席科学家 Martin Fowler 于2014年提出的一段话： 原文：https://martinfowler.com/articles/microservices.html 汉化：https://www.cnblogs.com/liuning8023/p/4493156.html 就目前而言，对于微服务，业界并没有一个统一的，标准的定义。 但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，它体长将单一的应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(HTTP)互相沟通，每个服务都围绕着具体的业务进行构建，并且能狗被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(Maven)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。 再来从技术维度角度理解下： 微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。 1.2 微服务与微服务架构 微服务 强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。 IDEA 工具里面使用Maven开发的一个个独立的小Moudel，它具体是使用SpringBoot开发的一个小模块，专业的事情交给专业的模块来做，一个模块就做着一件事情。 强调的是一个个的个体，每个个体完成一个具体的任务或者功能。 微服务架构 一种新的架构形式，Martin Fowler 于2014年提出。 微服务架构是一种架构模式，它体长将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制**(如HTTP)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如Maven)**对其进行构建。 1.3 微服务优缺点 优点 单一职责原则； 每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求； 开发简单，开发效率高，一个服务可能就是专一的只干一件事； 微服务能够被小团队单独开发，这个团队只需2-5个开发人员组成； 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的； 微服务能使用不同的语言开发； 易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins，Hudson，bamboo； 微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值； 微服务允许利用和融合最新技术； 微服务只是业务逻辑的代码，不会和HTML，CSS，或其他的界面混合; 每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库； 缺点 开发人员要处理分布式系统的复杂性； 多服务运维难度，随着服务的增加，运维的压力也在增大； 系统部署依赖问题； 服务间通信成本问题； 数据一致性问题； 系统集成测试问题； 性能和监控问题； 1.4 微服务技术栈有那些？ 微服务技术条目落地技术服务开发SpringBoot、Spring、SpringMVC等服务配置与管理Netfix公司的Archaius、阿里的Diamond等服务注册与发现Eureka、Consul、Zookeeper等服务调用Rest、PRC、gRPC服务熔断器Hystrix、Envoy等负载均衡Ribbon、Nginx等服务接口调用(客户端调用服务的简化工具)Fegin等消息队列Kafka、RabbitMQ、ActiveMQ等服务配置中心管理SpringCloudConfig、Chef等服务路由(API网关)Zuul等服务监控Zabbix、Nagios、Metrics、Specatator等全链路追踪Zipkin、Brave、Dapper等数据流操作开发包SpringCloud Stream(封装与Redis，Rabbit，Kafka等发送接收消息)时间消息总栈SpringCloud Bus服务部署Docker、OpenStack、Kubernetes等 1.5 为什么选择SpringCloud作为微服务架构 选型依据 整体解决方案和框架成熟度 社区热度 可维护性 学习曲线 当前各大IT公司用的微服务架构有那些？ 阿里：dubbo+HFS 京东：JFS 新浪：Motan 当当网：DubboX … 各微服务框架对比 功能点/服务框架Netflix/SpringCloudMotangRPCThriftDubbo/DubboX功能定位完整的微服务框架RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册发现RPC框架RPC框架服务框架支持Rest是，Ribbon支持多种可拔插的序列号选择否否否否支持RPC否是(Hession2)是是是支持多语言是(Rest形式)否是是否负载均衡是(服务端zuul+客户端Ribbon)，zuul-服务，动态路由，云端负载均衡Eureka（针对中间层服务器）是(客户端)否否是(客户端)配置服务Netfix Archaius，Spring Cloud Config Server 集中配置是(Zookeeper提供)否否否服务调用链监控是(zuul)，zuul提供边缘服务，API网关否否否否高可用/容错是(服务端Hystrix+客户端Ribbon)是(客户端)否否是(客户端)典型应用案例NetflixSinaGoogleFacebook社区活跃程度高一般高一般2017年后重新开始维护，之前中断了5年学习难度中等低高高低文档丰富程度高一般一般一般高其他Spring Cloud Bus为我们的应用程序带来了更多管理端点支持降级Netflix内部在开发集成gRPCIDL定义实践的公司比较多 ","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:1","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"2. SpringCloud入门概述 2.1 SpringCloud是什么？ Spring官网：https://spring.io/ Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry. 翻译： Spring Cloud为开发人员提供了快速构建分布式系统中的一些常见模式的工具(例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导人选举、分布式会话、集群状态)。分布式系统的协调导致了锅炉板模式，而使用Spring Cloud开发人员可以快速建立实现这些模式的服务和应用程序。它们在任何分布式环境中都能很好地工作，包括开发人员自己的笔记本电脑、裸金属数据中心和云计算等托管平台。 2.2 SpringCloud和SpringBoot的关系 SpringBoot专注于开苏方便的开发单个个体微服务； SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、为代理、事件总栈、全局锁、决策竞选、分布式会话等等集成服务； SpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系； SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架； 2.3 Dubbo 和 SpringCloud技术选型 1. 分布式+服务治理Dubbo 目前成熟的互联网架构，应用服务化拆分+消息中间件 2. Dubbo 和 SpringCloud对比 可以看一下社区活跃度： https://github.com/dubbo https://github.com/spring-cloud 对比结果： DubboSpringCloud服务注册中心ZookeeperSpring Cloud Netfilx Eureka服务调用方式RPCREST API服务监控Dubbo-monitorSpring Boot Admin断路器不完善Spring Cloud Netfilx Hystrix服务网关无Spring Cloud Netfilx Zuul分布式配置无Spring Cloud Config服务跟踪无Spring Cloud Sleuth消息总栈无Spring Cloud Bus数据流无Spring Cloud Stream批量任务无Spring Cloud Task 最大区别：Spring Cloud 抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式 严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这个优点在当下强调快速演化的微服务环境下，显得更加合适。 品牌机和组装机的区别 社区支持与更新力度的区别 总结： 二者解决的问题域不一样：Dubbo的定位是一款RPC框架，而SpringCloud的目标是微服务架构下的一站式解决方案。 2.4 SpringCloud能干嘛？ Distributed/versioned configuration 分布式/版本控制配置 Service registration and discovery 服务注册与发现 Routing 路由 Service-to-service calls 服务到服务的调用 Load balancing 负载均衡配置 Circuit Breakers 断路器 Distributed messaging 分布式消息管理 … 2.5 SpringCloud下载 官网：http://projects.spring.io/spring-cloud/ 版本号有点特别： SpringCloud没有采用数字编号的方式命名版本号，而是采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如最早的Realse版本：Angel，第二个Realse版本：Brixton，然后是Camden、Dalston、Edgware，目前最新的是Hoxton SR4 CURRENT GA通用稳定版。 自学参考书： SpringCloud Netflix 中文文档：https://springcloud.cc/spring-cloud-netflix.html SpringCloud 中文API文档(官方文档翻译版)：https://springcloud.cc/spring-cloud-dalston.html SpringCloud中国社区：http://springcloud.cn/ SpringCloud中文网：https://springcloud.cc ","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:2","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"3. SpringCloud Rest学习环境搭建：服务提供者 3.1 介绍 我们会使用一个Dept部门模块做一个微服务通用案例Consumer消费者(Client)通过REST调用Provider提供者(Server)提供的服务。 回顾Spring，SpringMVC，Mybatis等以往学习的知识。 Maven的分包分模块架构复习。 `一个简单的Maven模块结构是这样的： -- app-parent: 一个父项目(app-parent)聚合了很多子项目(app-util\\app-dao\\app-web...) |-- pom.xml | |-- app-core ||---- pom.xml | |-- app-web ||---- pom.xml ......` 一个父工程带着多个Moudule子模块 MicroServiceCloud父工程(Project)下初次带着3个子模块(Module) microservicecloud-api 【封装的整体entity/接口/公共配置等】 microservicecloud-consumer-dept-80 【服务提供者】 microservicecloud-provider-dept-8001 【服务消费者】 3.2 SpringCloud版本选择 大版本说明 SpringBootSpringCloud关系1.2.xAngel版本(天使)兼容SpringBoot1.2x1.3.xBrixton版本(布里克斯顿)兼容SpringBoot1.3x，也兼容SpringBoot1.4x1.4.xCamden版本(卡姆登)兼容SpringBoot1.4x，也兼容SpringBoot1.5x1.5.xDalston版本(多尔斯顿)兼容SpringBoot1.5x，不兼容SpringBoot2.0x1.5.xEdgware版本(埃奇韦尔)兼容SpringBoot1.5x，不兼容SpringBoot2.0x2.0.xFinchley版本(芬奇利)兼容SpringBoot2.0x，不兼容SpringBoot1.5x2.1.xGreenwich版本(格林威治) 实际开发版本关系 spring-boot-starter-parentspring-cloud-dependencles版本号发布日期版本号发布日期1.5.2.RELEASE2017-03Dalston.RC12017-x1.5.9.RELEASE2017-11Edgware.RELEASE2017-111.5.16.RELEASE2018-04Edgware.SR52018-101.5.20.RELEASE2018-09Edgware.SR52018-102.0.2.RELEASE2018-05Fomchiey.BULD-SNAPSHOT2018-x2.0.6.RELEASE2018-10Fomchiey-SR22018-102.1.4.RELEASE2019-04Greenwich.SR12019-03 使用后两个 3.3 创建父工程 新建父工程项目springcloud，切记Packageing是pom模式 主要是定义POM文件，将后续各个子模块公用的jar包等统一提取出来，类似一个抽象父类 pom.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.haust\u003c/groupId\u003e \u003cartifactId\u003espringcloud\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cmodules\u003e \u003cmodule\u003espringcloud-api\u003c/module\u003e \u003cmodule\u003espringcloud-provider-dept-8001\u003c/module\u003e \u003cmodule\u003espringcloud-consumer-dept-80\u003c/module\u003e \u003cmodule\u003espringcloud-eureka-7001\u003c/module\u003e \u003cmodule\u003espringcloud-eureka-70002\u003c/module\u003e \u003cmodule\u003espringcloud-eureka-7003\u003c/module\u003e \u003cmodule\u003espringcloud-provider-dept-8002\u003c/module\u003e \u003cmodule\u003espringcloud-provider-dept-8003\u003c/module\u003e \u003cmodule\u003espringcloud-consumer-dept-feign\u003c/module\u003e \u003cmodule\u003espringcloud-provider-dept-hystrix-8001\u003c/module\u003e \u003cmodule\u003espringcloud-consumer-hystrix-dashboard\u003c/module\u003e \u003cmodule\u003espringcloud-zuul-9527\u003c/module\u003e \u003cmodule\u003espringcloud-config-server-3344\u003c/module\u003e \u003cmodule\u003espringcloud-config-client-3355\u003c/module\u003e \u003cmodule\u003espringcloud-config-eureka-7001\u003c/module\u003e \u003cmodule\u003espringcloud-config-dept-8001\u003c/module\u003e \u003c/modules\u003e \u003c!--打包方式 pom--\u003e \u003cpackaging\u003epom\u003c/packaging\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cmaven.compiler.source\u003e1.8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e1.8\u003c/maven.compiler.target\u003e \u003cjunit.version\u003e4.12\u003c/junit.version\u003e \u003clog4j.version\u003e1.2.17\u003c/log4j.version\u003e \u003clombok.version\u003e1.16.18\u003c/lombok.version\u003e \u003c/properties\u003e \u003cdependencyManagement\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-alibaba-dependencies\u003c/artifactId\u003e \u003cversion\u003e0.2.0.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--springCloud的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-dependencies\u003c/artifactId\u003e \u003cversion\u003eGreenwich.SR1\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--SpringBoot--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.1.4.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--数据库--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e1.1.10\u003c/version\u003e \u003c/dependency\u003e \u003c!--SpringBoot 启动器--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--日志测试~--\u003e \u003cdependency\u003e \u003cgroupId\u003ech.qos.lo","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:3","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"4. Eureka服务注册与发现 4.1 什么是Eureka Netflix在涉及Eureka时，遵循的就是API原则. Eureka是Netflix的有个子模块，也是核心模块之一。Eureka是基于REST的服务，用于定位服务，以实现云端中间件层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心，比如Zookeeper. 4.2 原理理解 Eureka基本的架构 Springcloud 封装了Netflix公司开发的Eureka模块来实现服务注册与发现 (对比Zookeeper). Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心. 而系统中的其他微服务，使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，Springcloud 的一些其他模块 (比如Zuul) 就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑. 和Dubbo架构对比. Eureka 包含两个组件：Eureka Server 和 Eureka Client. Eureka Server 提供服务注册，各个节点启动后，回在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会储存所有课用服务节点的信息，服务节点的信息可以在界面中直观的看到. Eureka Client 是一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳 (默认周期为30秒) 。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除掉 (默认周期为90s). 三大角色 Eureka Server：提供服务的注册与发现 Service Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能狗找到 Service Consumer：服务消费方，从Eureka中获取注册服务列表，从而找到消费服务 目前工程状况 4.3 构建步骤 1. eureka-server springcloud-eureka-7001 模块建立 pom.xml 配置 `\u003c!--导包~--\u003e \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --\u003e \u003c!--导入Eureka Server依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-eureka-server\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!--热部署工具--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e` application.yml `server: port: 7001 #Eureka配置 eureka: instance: hostname: localhost #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---\u003ehttp://localhost:7001/eureka/ defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/` 源码中Eureka的默认端口以及访问路径: 主启动类 `//启动之后，访问 http://localhost:7001/ @SpringBootApplication @EnableEurekaServer //EnableEurekaServer 表示是 Eureka服务端的启动类，可以接受别人注册进来~ public class EurekaServer_7001 { public static void main(String[] args) { SpringApplication.run(EurekaServer_7001.class,args); } }` 启动成功后访问 http://localhost:7001/ 得到以下页面 2. eureka-client 调整之前创建的springlouc-provider-dept-8001 导入Eureca依赖 `\u003c!--Eureka依赖--\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-eureka\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e` application中新增Eureca配置 `# Eureka配置：配置服务注册中心地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/` 为主启动类添加@EnableEurekaClient注解 `@SpringBootApplication @EnableEurekaClient //EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务 public class DeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(DeptProvider_8001.class,args); } }` 先启动7001服务端后启动8001客户端进行测试，然后访问监控页http://localhost:7001/ 产看结果如图，成功 修改Eureka上的默认描述信息 `# Eureka配置：配置服务注册中心地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ instance: instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息` 结果如图： 如果此时停掉springcloud-provider-dept-8001 等30s后 监控会开启保护机制 配置关于服务加载的监控信息 pom.xml中添加依赖 `\u003c!--actuator完善监控信息--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e` application.yml中添加配置 `#info配置 info: app.name: haust-springcloud #项目的名称 company.name: com.haust #公司的名称` 此时刷新监控页，点击进入跳转新页面显示如下内容： 3. EureKa自我保护机制：好死不如赖活着 一句话总结就是：某时刻某一个微服务不可用，eureka不会立即清理，依旧会对该微服务的信息进行保存！ 默认情况下，当eureka server在一定时间内没有收到实例的心跳，便会把该实例从注册表中删除（默认是90秒），但是，如果短时间内丢失大量的实例心跳，便会触发eureka server的自我保护机制，比如在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启（因为在开发过程中不会修改eureka注册中心），当一分钟内收到的心跳数大量减少时，会触发该保护机制。可以在eureka管理界面看到Renews threshold和Renews(last min)，当后者（最后一分钟收到的心跳数）小于前者（心跳阈值）的时候，触发保护机制，会出现红色的警告：**EMERGENCY!EUREKA MAY BE INCORRECTLY CLAIMI","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:4","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5. Ribbon：负载均衡(基于客户端) 5.1 负载均衡以及Ribbon Ribbon是什么？ Spring Cloud Ribbon 是基于Netflix Ribbon 实现的一套客户端负载均衡的工具。 简单的说，Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 的客户端组件提供一系列完整的配置项，如：连接超时、重试等。简单的说，就是在配置文件中列出 LoadBalancer (简称LB：负载均衡) 后面所有的及其，Ribbon 会自动的帮助你基于某种规则 (如简单轮询，随机连接等等) 去连接这些机器。我们也容易使用 Ribbon 实现自定义的负载均衡算法！ Ribbon能干嘛？ LB，即负载均衡 (LoadBalancer) ，在微服务或分布式集群中经常用的一种应用。 负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高用)。 常见的负载均衡软件有 Nginx、Lvs 等等。 Dubbo、SpringCloud 中均给我们提供了负载均衡，SpringCloud 的负载均衡算法可以自定义。 负载均衡简单分类： 集中式LB 即在服务的提供方和消费方之间使用独立的LB设施，如Nginx，由该设施负责把访问请求通过某种策略转发至服务的提供方！ 进程式LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。 Ribbon 就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址！ 5.2 集成Ribbon springcloud-consumer-dept-80向pom.xml中添加Ribbon和Eureka依赖 `\u003c!--Ribbon--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-ribbon\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!--Eureka: Ribbon需要从Eureka服务中心获取要拿什么--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-eureka\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e` 在application.yml文件中配置Eureka `# Eureka配置 eureka: client: register-with-eureka: false # 不向 Eureka注册自己 service-url: # 从三个注册中心中随机取一个去访问 defaultZone: http://eureka700fxgfj1.com:7001/eureka/,http://eureka700fxgfj2.com:70002/eureka/,http://eureka700fxgfj3.com:7003/eureka/` 主启动类加上@EnableEurekaClient注解，开启Eureka `//Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号 @SpringBootApplication @EnableEurekaClient //开启Eureka 客户端 public class DeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_80.class, args); } }` 自定义Spring配置类：ConfigBean.java 配置负载均衡实现RestTemplate `@Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml @LoadBalanced //配置负载均衡实现RestTemplate @Bean public RestTemplate getRestTemplate() { return new RestTemplate(); } }` 修改conroller：DeptConsumerController.java `//Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 //private static final String REST_URL_PREFIX = \"http://localhost:8001\"; private static final String REST_URL_PREFIX = \"http://SPRINGCLOUD-PROVIDER-DEPT\";` 5.3 使用Ribbon实现负载均衡 流程图： 1.新建两个服务提供者Moudle：springcloud-provider-dept-8003、springcloud-provider-dept-8002 2.参照springcloud-provider-dept-8001 依次为另外两个Moudle添加pom.xml依赖 、resourece下的mybatis和application.yml配置，Java代码 3.启动所有服务测试(根据自身电脑配置决定启动服务的个数)，访问http://eureka700fxgfj1.com:70002/查看结果 测试访问http://localhost/consumer/dept/list 这时候随机访问的是服务提供者8003 再次访问http://localhost/consumer/dept/list这时候随机的是服务提供者8001 以上这种每次访问http://localhost/consumer/dept/list随机访问集群中某个服务提供者，这种情况叫做轮询，轮询算法在SpringCloud中可以自定义。 如何切换或者自定义规则呢？ 在springcloud-provider-dept-80模块下的ConfigBean中进行配置，切换使用不同的规则 `@Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml /** * IRule: * RoundRobinRule 轮询 * RandomRule 随机 * AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~ * RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试 */ @LoadBalanced //配置负载均衡实现RestTemplate @Bean public RestTemplate getRestTemplate() { return new RestTemplate(); } @Bean public IRule myRule(){ return new RandomRule();//使用随机规则 } }` 也可以自定义规则，在myRule包下自定义一个配置类MyRule.java，注意：该包不要和主启动类所在的包同级，要跟启动类所在包同级： MyRule.java `/** * @Auther: csp1999 * @Date: 2020/05/19/11:58 * @Description: 自定义规则 */ @Configuration public class MyRule { @Bean public IRule myRule(){ return new MyRandomRule();//默认是轮询RandomRule,现在自定义为自己的 } }` 主启动类开启负载均衡并指定自定义的MyRule配置类 `//Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号 @SpringBootApplication @EnableEurekaClient //在微服务启动的时候就能加载自定义的Ribbon类(自定义的规则会覆盖原有默认的规则) @RibbonClient(name = \"SPRINGCLOUD-PROVIDER-DEPT\",configuration = MyRule.class)//开启负载均衡,并指定自定义的规则 public class DeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_80.class, args); } }` 自定义的规则(这里我们参考Ribbon中默认的规则代码自己稍微改动)：MyRandomRule.java `public class MyRandomRule extends AbstractLoadBalancerRule { /** * 每个服务访问5次则换下一个服务(总共3个服务) * \u003cp\u003e * total=0,默认=0,如果=5","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:5","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.Feign：负载均衡(基于服务端) 6.1 Feign简介 Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Ribbon和Eureka，可以使用Feigin提供负载均衡的http客户端 只需要创建一个接口，然后添加注解即可~ Feign，主要是社区版，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法 微服务名字 【ribbon】 接口和注解 【feign】 Feign能干什么？ Feign旨在使编写Java Http客户端变得更容易 前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一个客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解)，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon 时，自动封装服务调用客户端的开发量。 Feign默认集成了Ribbon 利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。 6.2 Feign的使用步骤 创建springcloud-consumer-fdept-feign模块 拷贝springcloud-consumer-dept-80模块下的pom.xml，resource，以及java代码到springcloud-consumer-feign模块，并添加feign依赖。 `\u003c!--Feign的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-feign\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e` 通过Ribbon实现：—原来的controller：DeptConsumerController.java `package com.haust.springcloud.controller; import com.haust.springcloud.pojo.Dept; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import java.util.List; /** * @Auther: csp1999 * @Date: 2020/05/17/22:44 * @Description: */ @RestController public class DeptConsumerController { // 理解：消费者，不应该有service层~ // RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中 // (url, 实体：Map ,Class\u003cT\u003e responseType) @Autowired private RestTemplate restTemplate; //提供多种便捷访问远程http服务的方法，简单的Restful服务模板~ //Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 //private static final String REST_URL_PREFIX = \"http://localhost:8001\"; private static final String REST_URL_PREFIX = \"http://SPRINGCLOUD-PROVIDER-DEPT\"; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept) { return restTemplate.postForObject(REST_URL_PREFIX + \"/dept/add\", dept, Boolean.class); } @RequestMapping(\"/consumer/dept/get/{id}\") public Dept get(@PathVariable(\"id\") Long id) { return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/get/\" + id, Dept.class); } @RequestMapping(\"/consumer/dept/list\") public List\u003cDept\u003e list() { return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/list\", List.class); } }` 通过Feign实现：—改造后controller：DeptConsumerController.java `@RestController public class DeptConsumerController { @Autowired private DeptClientService deptClientService = null; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept) { return this.deptClientService.addDept(dept); } @RequestMapping(\"/consumer/dept/get/{id}\") public Dept get(@PathVariable(\"id\") Long id) { return this.deptClientService.queryById(id); } @RequestMapping(\"/consumer/dept/list\") public List\u003cDept\u003e list() { return this.deptClientService.queryAll(); } }` Feign和Ribbon二者对比，前者显现出面向接口编程特点，代码看起来更清爽 主配置类 `@SpringBootApplication @EnableEurekaClient //feign客户端注解,并指定要扫描的包以及配置接口DeptClientService @EnableFeignClients(basePackages = {\"com.haust.springcloud\"}) //扫描所有自己的包,让所有注解也能生效 @ComponentScan(\"com.haust.springcloud\") public class FeignDeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(FeignDeptConsumer_80.class, args); } }` 改造springcloud-api模块 pom.xml添加feign依赖 `\u003c!--Feign的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-feign\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e` 新建service包，并新建DeptClientService.java接口， `//@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务 @FeignClient(value = \"SPRINGCLOUD-PROVIDER-DEPT\") public interface DeptClientService { @GetMapping(\"/dept/get/{id}\") public Dept queryById(@PathVariable(\"id\") Long id); @GetMapping(\"/dept/list\") public Dept queryAll(); @GetMap","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:6","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"问题一：一个骰子怎么产生1/7的概率 问题等价于：一个骰子6个面均匀，现在有7个互斥事件，怎么扔能使7个事件均匀分布 答：一个骰子掷两次，共36种等概率的结果。 令其中的35种对应1-7，剩下的一种对应『再掷两次』。 比如：第一个骰子不为6时，第二个骰子掷出几就输出几（1-6，每种有五个可能）。第一个骰子为6，且第二个骰子不为6，输出7（有五个可能）。两个骰子都是6，重掷。于是1-7的概率都是5/36。而且永远掷6的概率是0，一定会在有限次内得到输出。 设第一次的投掷点数为x，第二次的投掷点数为y，则有f(x,y) = (x - 1) * 6 + y。 f(x,y)的取值范围是1~36，按照上述规则，可以达到题目要求 ","date":"2021-04-17","objectID":"/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7/:1:0","tags":[],"title":"骰子等概率1-7与数组","uri":"/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7/"},{"categories":["算法"],"content":"问题二：找出数组中出现次数超过一半的数 现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。 提示：出现次数超过一半的数一定只有一个 **方法一：**创建一个unordered_map，key为数组中的数，value为此数出现的次数。遍历一遍数组，用unordered_map统计每个数出现的次数，并用两个值存储目前出现次数最多的数和对应出现的次数。 这个解法是最简单的，我们来分析一下时间复杂度和空间复杂度,由于这个map底层实现使用hash算法来实现的，故时间复杂度可以为O（n），那么空间复杂度呢？很明显也是O(n)的。 public class HalfTimes { public static void main(String args[]){ int array[]={0,1,2,3,4,1,2,1,1,1,1,0,1,0,1,2,1,1,1,1}; int i = solution1(array); System.out.printf(\"数组中出现次数超过一半的数为：\"+i); } public static int solution1(int arrray[]){ Map\u003cInteger,Integer\u003e unordered_map=new HashMap\u003c\u003e(); for(int item:arrray){ if(unordered_map.containsKey(item)){ Integer value=unordered_map.get(item)+1; unordered_map.replace(item,value); }else{ unordered_map.put(item,1); } } Integer num=0; Integer times=arrray.length/2; for(Integer key:unordered_map.keySet()){ if(unordered_map.get(key)\u003etimes){ num=key; times=unordered_map.get(key); } } return num; } } 那能不能把空间复杂度降下来呢？ **方法二：**使用两个变量A和B，其中A存储某个数组中的数，B用来计数。开始时将B初始化为0。 遍历数组，如果B=0，则令A等于当前数，令B等于1；如果当前数与A相同，则B=B+1；如果当前数与A不同，则令B=B-1。遍历结束时，A中的数就是要找的数。为什么呢？因为题目中说了，那个元素一定是占了数组元素个数的一半以上，所以说，当我们每次删除两个不同的数，剩下存储A的值就是我们要求的结果值。 这个算法的时间复杂度是O(n)，空间复杂度为O(1)。 public static int solution2(int array[]){ int a=0; int b=0; for(int item:array){ if(b==0){ a=item; b=1; }else if(a==item){ b++; }else{ b--; } } return a; } {0,1,2,3,4,1,2,1,1,1,1,0,1,0,1,2,1,1,1,1}; 一共20个数，最多的数为1，共12个，其他数8个 必存在才正确 item a b 0 0 1 1 0 0 2 2 1 3 2 0 4 4 1 1 4 0 2 2 1 1 2 0 1 1 1 1 1 2 1 1 3 0 1 2 1 1 3 0 1 2 1 1 3 2 1 2 1 1 3 1 1 4 1 1 5 1 1 6 ","date":"2021-04-17","objectID":"/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7/:2:0","tags":[],"title":"骰子等概率1-7与数组","uri":"/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7/"},{"categories":["设计模式"],"content":"问题一：抽象工厂模式 某系统为了改进数据库操作的性能，自定义数据库连接对象Connection和语句对象Statement,可针对不同类型的数据库提供不同的连接对象和语句对象，如提供Oracle或MySQL专用连接类和语句类，而且用户可以通过配置文件等方式根据实际需要动态更换系统数据库。使用抽象工厂模式设计该系统。要求绘制类图并编程实现。 类图 代码实现： 抽象Connection接口： public interface Connection { } 具体实现类： public class OracleConnection implements Connection { } public class MySQLConnection implements Connection { } 抽象Statement接口： public interface Statement { } 具体实现类： public class MySQLStatement implements Statement { } public class OracleStatement implements Statement { } 抽象工厂类接口： public interface Factory { Connection createConnecttion(); Statement createStatement(); } 具体工厂实现类： public class MySQLFactory implements Factory { @Override public Connection createConnecttion() { System.out.println(\"正在创建MySQLConnection\"); return new MySQLConnection(); } @Override public Statement createStatement() { System.out.println(\"正在创建MySQLStatement\"); return new MySQLStatement(); } } public class OracleFactory implements Factory { @Override public Connection createConnecttion() { System.out.println(\"正在创建OracleConnection\"); return new OracleConnection(); } @Override public Statement createStatement() { System.out.println(\"正在创建OracleStatement\"); return new OracleStatement(); } } 辅助代码： public class XMLUtil { public static Object getType(){ try{ DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder(); Document document; document= documentBuilder.parse(new File(\"config.xml\")); NodeList nodeList=document.getElementsByTagName(\"type\"); Node classNode=nodeList.item(0).getFirstChild(); String string=classNode.getNodeValue().trim(); Class c=Class.forName(\"cn.hubu.www.\"+string); Object obj=c.newInstance(); return obj; }catch (Exception e) { e.printStackTrace(); return null; } } } client客户端： public class Client { public static void main(String args[]) { try { Connection connection; Statement statement; Factory factory= (Factory) XMLUtil.getType(); connection=factory.createConnecttion(); System.out.println(connection.getClass()); statement = factory.createStatement(); System.out.println(statement.getClass()); } catch (Exception e) { e.printStackTrace(); } } } 运行结果： 正在创建MySQLConnection class cn.hubu.www.MySQLConnection 正在创建MySQLStatement class cn.hubu.www.MySQLStatement ","date":"2021-04-16","objectID":"/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:1","tags":["抽象工厂模式","建造者模式"],"title":"实验三---抽象工厂模式、建造者模式","uri":"/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"问题二：建造者模式 建造者模式实验：某游戏软件中人物角色包括多种类型，不同类型的人物角色，其性别、脸型、服装、发型等外部特性有所差异，使用建造者模式创建人物角色对象，要求绘制类图并编程实现。 代码如下： 人物角色GameRole类： public class GameRole { private String gender; private String face; private String cloth; private String hair; @Override public String toString() { return \"GameRole{\" + \"gender='\" + gender + '\\'' + \", face='\" + face + '\\'' + \", cloth='\" + cloth + '\\'' + \", hair='\" + hair + '\\'' + '}'; } public String getGender() { return this.gender; } public void setGender(String gender) { this.gender = gender; } public String getFace() { return face; } public void setFace(String face) { this.face = face; } public String getCloth() { return cloth; } public void setCloth(String cloth) { this.cloth = cloth; } public String getHair() { return hair; } public void setHair(String hair) { this.hair = hair; } } 抽象建造者类： public abstract class GameRoleBuilder { protected GameRole gameRole=new GameRole(); public abstract void buildGender(); public abstract void buildFace(); public abstract void builCloth(); public abstract void buildHair(); public GameRole getGameRole(){ return this.gameRole; } } 具体建造者类SubGameRoleBuilderA： public class SubGameRoleBuilderA extends GameRoleBuilder { @Override public void buildGender() { gameRole.setGender(\"男\"); } @Override public void buildFace() { gameRole.setFace(\"英俊帅气\"); } @Override public void builCloth() { gameRole.setCloth(\"李宁服饰\"); } @Override public void buildHair() { gameRole.setHair(\"黑色\"); } } 具体建造者类SubGameRoleBuilderB： public class SubGameRoleBuilderB extends GameRoleBuilder { @Override public void buildGender() { gameRole.setGender(\"女\"); } @Override public void buildFace() { gameRole.setFace(\"瓜子脸\"); } @Override public void builCloth() { gameRole.setCloth(\"JK\"); } @Override public void buildHair() { gameRole.setHair(\"黄色\"); } } 指挥者Director类： public class Director { private GameRoleBuilder gameRoleBuilder; public void setGameRoleBuilder(GameRoleBuilder gameRoleBuilder){ this.gameRoleBuilder=gameRoleBuilder; } public GameRole construct(){ gameRoleBuilder.buildGender(); gameRoleBuilder.buildFace(); gameRoleBuilder.builCloth(); gameRoleBuilder.buildHair(); return gameRoleBuilder.getGameRole(); } } 辅助代码与之前类似、、、、、 客户端： public class Client { public static void main(String args[]) { try { GameRoleBuilder gameRoleBuilder= (GameRoleBuilder) XMLUtil.getType(); Director director=new Director(); director.setGameRoleBuilder(gameRoleBuilder); GameRole gameRole=director.construct(); System.out.println(gameRole.toString()); } catch (Exception e) { e.printStackTrace(); } } } 运行结果： GameRole{gender='女', face='瓜子脸', cloth='JK', hair='黄色'} Process finished with exit code 0 ","date":"2021-04-16","objectID":"/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:2","tags":["抽象工厂模式","建造者模式"],"title":"实验三---抽象工厂模式、建造者模式","uri":"/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"区别： ​ 抽象工厂模式比建造者模式的尺度要大，它关注产品整体，而建造者模式关注构建过程，因此建造者模式可以很容易地构建出一个崭新的产品，只要导演类能够提供具体的工艺流程。也正因为如此，两者的应用场景截然不同，如果希望屏蔽对象的创建过程，只提供一个封装良好的对象，则可以选择抽象工厂方法模式。而建造者模式可以用在构件的装配方面，如通过装配不同的组件或者相同组件的不同顺序，可以产生出一个新的对象，它可以产生一个非常灵活的架构，方便地扩展和维护系统。 ","date":"2021-04-16","objectID":"/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:3","tags":["抽象工厂模式","建造者模式"],"title":"实验三---抽象工厂模式、建造者模式","uri":"/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["Windows"],"content":"最近新装的系统发现开机出现了两个引导，一个Windows10，一个Windows，但是只有第一个可以用，第二个用不了，那留着有什么用呢？果断删掉或禁用 Win+R输入msconfig，看到系统配置引导界面果然有两个引导，尝试删除一个，因为Windows10可用，就把第二个删除： 发现系统不让删除，不知道什么鬼畜操作，不让删除那就另寻捷径！！！ 打开此电脑属性，选择高级系统设置，选择高级，启动和故障恢复设置，取消勾选显示操作系统事件列表 设置完成后进入系统就直接进入默认的操作系统，而不会出现选择列表了哦 ","date":"2021-04-16","objectID":"/windows%E5%8F%8C%E5%BC%95%E5%AF%BC%E5%85%B3%E9%97%AD/:0:0","tags":["双引导解决"],"title":"Windows双引导关闭","uri":"/windows%E5%8F%8C%E5%BC%95%E5%AF%BC%E5%85%B3%E9%97%AD/"},{"categories":["设计模式"],"content":"模式动机 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 将客户端与包含多个部件的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可 关注如何逐步创建一个复杂的对象，不同的建造者定义了不同的创建过程 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 建造者模式可以用于描述KFC如何创建套餐：套餐是一个复杂对象，它一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。 产品类Meal： public class Meal { private String food; private String drink; public String getFood() { return food; } public void setFood(String food) { this.food = food; } public String getDrink() { return drink; } public void setDrink(String drink) { this.drink = drink; } } 抽象建造者类MealBuilder: public abstract class MealBuilder { protected Meal meal=new Meal(); public abstract void buildFood(); public abstract void buildDrink(); public Meal getMeal(){ return this.meal; } } 具体建造者类（A套餐） public class SubMealBuilderA extends MealBuilder { @Override public void buildFood() { meal.setFood(\"一个鸡腿\"); } @Override public void buildDrink() { meal.setDrink(\"一杯可乐\"); } } 具体建造者类（B套餐） public class SubMealBuilderB extends MealBuilder { @Override public void buildFood() { meal.setFood(\"一个鸡肉卷\"); } @Override public void buildDrink() { meal.setDrink(\"一杯果汁\"); } } 指挥者类（KFCWaiter） public class KFCWaiter { private MealBuilder mealBuilder; public void setMealBuilder(MealBuilder mealBuilder){ this.mealBuilder=mealBuilder; } public Meal construct(){ mealBuilder.buildFood(); mealBuilder.buildDrink(); return mealBuilder.getMeal(); } } 辅助代码与前面类似。。。。。。 客户端类： public class Client { public static void main(String args[]) { try { MealBuilder mealBuilder= (MealBuilder) XMLUtilTV.getType(); KFCWaiter kfcWaiter=new KFCWaiter(); kfcWaiter.setMealBuilder(mealBuilder); Meal meal = kfcWaiter.construct(); System.out.println(\"套餐组成\"); System.out.println(meal.getFood()); System.out.println(meal.getDrink()); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，符合开闭原则 可以更加精细地控制产品的创建过程 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:5:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，不适合使用建造者模式，因此其使用范围受到一定的限制 如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:6:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量 需要生成的产品对象的属性相互依赖，需要指定其生成顺序 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:7:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 **产品等级结构：**产品等级结构即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 **产品族：**在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 一个电器工厂可以产生多种类型的电器，如海尔工厂可以生产海尔电视机、海尔空调等，TCL工厂可以生产TCL电视机、TCL空调等，相同品牌的电器构成一个产品族，而相同类型的电器构成了一个产品等级结构，现使用抽象工厂模式模拟该场景。 抽象产品接口： public interface TV { public void play(); } 具体产品类： public class HairTV implements TV { @Override public void play() { System.out.println(\"海尔电视播放中、、、、、\"); } } public class HisenseTV implements TV { @Override public void play() { System.out.println(\"海信电视播放中、、、\"); } } 抽象工厂类： public interface Factory { TV produceTV(); AirCondition produceAC(); } 具体工厂类: public class HairFactory implements Factory { @Override public TV produceTV() { System.out.println(\"海尔工厂生产海尔电视机。\"); return new HairTV(); } @Override public AirCondition produceAC() { System.out.println(\"海尔工厂生产海尔空调。\"); return new HairAirCondition(); } } public class HisenseFactory implements Factory { @Override public TV produceTV() { System.out.println(\"海信电视机工厂生产海信电视机。\"); return new HisenseTV(); } @Override public AirCondition produceAC() { System.out.println(\"海信没有空调\"); return null; } } public class TCLFactory implements Factory { @Override public TV produceTV() { System.out.println(\"TCL工厂类正在生产电视\"); return new TCLTV(); } @Override public AirCondition produceAC() { System.out.println(\"CL工厂类正在生产空调\"); return new TCLAirCondition(); } } 产品族抽象类： public interface AirCondition { void changeTemp(); } 具体实现类： public class TCLAirCondition implements AirCondition { @Override public void changeTemp() { System.out.println(\"TC课堂正在调节温度\"); } } public class HairAirCondition implements AirCondition { @Override public void changeTemp() { System.out.println(\"海尔空调正在调节温度\"); } } 辅助工具类： public class XMLUtilTV { public static Object getType(){ try{ DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder(); Document document; document= documentBuilder.parse(new File(\"config.xml\")); NodeList nodeList=document.getElementsByTagName(\"type\"); Node classNode=nodeList.item(0).getFirstChild(); String string=classNode.getNodeValue().trim(); System.out.println(string); Class c=Class.forName(\"io.hubu8.com.\"+string); Object obj=c.newInstance(); return obj; }catch (Exception e) { e.printStackTrace(); return null; } } } xml文件： \u003c?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u003e \u003cconfig\u003e \u003ctype\u003eHairFactory\u003c/type\u003e \u003c/config\u003e 客户端： public class Client { public static void main(String args[]) { try { TV tv; AirCondition airCondition; Factory factory=(Factory) XMLUtilTV.getType(); tv=factory.produceTV(); tv.play(); airCondition=factory.produceAC(); airCondition.changeTemp(); } catch (Exception e) { e.printStackTrace(); } } } TCLFactory TCL工厂类正在生产电视 TCL电视正在播放中、、、 CL工厂类正在生产空调 TC课堂正在调节温度 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 隔离了具体类的生成，使得客户端并不需要知道什么被创建 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 增加新的产品族很方便，无须修改已有系统，符合开闭原则 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:5:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:6:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节 系统中有多于一个的产品族，但每次只使用其中某一产品族 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来 产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:7:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:1:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 工厂方法模式(Factory Method Pattern)简称工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。 在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:2:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 工厂方法模式是简单工厂模式的进一步抽象和推广 工厂方法模式保持了简单工厂模式的优点，并克服了它的缺点 核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给其子类去完成 可以允许系统在不修改工厂角色的情况下引进新产品 增加具体产品–\u003e增加具体工厂，符合“开闭原则” ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:3:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 将原有的电视机工厂进行分割，为每种品牌的电视机提供一个子工厂，海尔工厂专门负责生产海尔电视机，海信工厂专门负责生产海信电视机，如果需要生产TCL电视机或创维电视机，只需要对应增加一个新的TCL工厂或创维工厂即可，原有的工厂无须做任何修改，使得整个系统具有更加的灵活性和可扩展性。 抽象产品接口： public interface TV { public void play(); } 具体产品类： public class HairTV implements TV { @Override public void play() { System.out.println(\"海尔电视播放中、、、、、\"); } } public class HisenseTV implements TV { @Override public void play() { System.out.println(\"海信电视播放中、、、\"); } } 抽象工厂类： public interface TVFactory { public TV produceTV(); } 具体工厂类: public class HisenseTVFactory implements TVFactory { @Override public TV produceTV() { System.out.println(\"海信电视机工厂生产海信电视机。\"); return new HisenseTV(); } } public class HairTVFactory implements TVFactory { @Override public TV produceTV() { System.out.println(\"海尔电视机工厂生产海尔电视机。\"); return new HairTV(); } } 辅助工具类： public class XMLUtilTV { public static Object getType(){ try{ DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder(); Document document; document= documentBuilder.parse(new File(\"config.xml\")); NodeList nodeList=document.getElementsByTagName(\"type\"); Node classNode=nodeList.item(0).getFirstChild(); String string=classNode.getNodeValue().trim(); System.out.println(string); Class c=Class.forName(\"io.hubu8.com.\"+string); Object obj=c.newInstance(); return obj; }catch (Exception e) { e.printStackTrace(); return null; } } } xml文件： \u003c?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u003e \u003cconfig\u003e \u003ctype\u003eHairTVFactory\u003c/type\u003e \u003c/config\u003e 客户端： public class Client { public static void main(String args[]) { try { TV tv; TVFactory factory=(TVFactory) XMLUtilTV.getType(); System.out.println(factory); tv=factory.produceTV(); tv.play(); } catch (Exception e) { e.printStackTrace(); } } } HisenseTVFactory io.hubu8.com.HisenseTVFactory@1540e19d 海信电视机工厂生产海信电视机。 海信电视播放中、、、 如果需要新增一种类型的电视，只需要新增一个具体产品类和一个具体工厂类： public class TCLTV implements TV { @Override public void play() { System.out.println(\"TCL电视正在播放中、、、\"); } } public class TCLTVFactory implements TVFactory { @Override public TV produceTV() { System.out.println(\"TCL电视工厂类正在生产\"); return new TCLTV(); } } ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:4:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节 能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部 在系统中加入新产品时，完全符合开闭原则 ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:5:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销 增加了系统的抽象性和理解难度 ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:6:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 客户端不知道它所需要的对象的类（客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建） 抽象工厂类通过其子类来指定创建哪个对象 闹眼子呢？ java.lang.ClassNotFoundException: HisenseTVFactory at java.net.URLClassLoader.findClass(URLClassLoader.java:382) at java.lang.ClassLoader.loadClass(ClassLoader.java:418) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355) at java.lang.ClassLoader.loadClass(ClassLoader.java:351) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:264) at io.hubu8.com.XMLUtilTV.getType(XMLUtilTV.java:24) at io.hubu8.com.Client.main(Client.java:8) null java.lang.NullPointerException at io.hubu8.com.Client.main(Client.java:11) Process finished with exit code 0 需要在类名前面加上包名： Class c=Class.forName(\"io.hubu8.com.\"+string); ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:7:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 只需要告知水果名称就可以得到相应的水果： ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式 在简单工厂模式中，可以根据参数的不同返回不同类的实例 简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过工厂类类名直接调用，只需要传入一个简单的参数即可，无须知道对象的创建细节 可以将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码 问题：工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 某电视机厂专为各知名电视机品牌代工生产各类电视机，当需要海尔牌电视机时只需要在调用该工厂的工厂方法时传入参数“Haier”，需要海信电视机时只需要传入参数“Hisense”，工厂可以根据传入的不同参数返回不同品牌的电视机。现使用简单工厂模式来模拟该电视机工厂的生产过程。 抽象产品接口： public interface TV { public void play(); } 具体产品类： public class HairTV implements TV { @Override public void play() { System.out.println(\"海尔电视播放中、、、、、\"); } } public class HisenseTV implements TV { @Override public void play() { System.out.println(\"海信电视播放中、、、\"); } } 工厂类： public class TVFactory { public static TV produceTV(String type) throws Exception { if(type.equalsIgnoreCase(\"Hair\")){ return new HairTV(); }else if(type.equalsIgnoreCase(\"Hisense\")){ return new HisenseTV(); }else{ throw new Exception(\"对不起，不支持的电视类型\"); } } } 客户端： public class Client { public static void main(String args[]) { TV tv; try { tv=TVFactory.produceTV(\"Hair\"); tv.play(); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:5:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 实现了对象创建和使用的分离 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:6:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响 增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度 系统扩展困难，一旦添加新产品不得不修改工厂逻辑 由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构，工厂类不能得到很好地扩展 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:7:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:8:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"01 工厂方法 追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。 消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:1","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"02 建造者模式 MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。 建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:2","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"03 抽象工厂 请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。 工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:3","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"04 原型模式 跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要） 原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:4","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"05 单态模式 俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事) 单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:5","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"06 适配器模式 在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我) 适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:6","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"07 桥梁模式 早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了。 桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:7","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"08 合成模式 Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？ 合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:8","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"09 装饰模式 Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？ 装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:9","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"10 门面模式 我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。 门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:10","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"11 享元模式 每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。 享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。 将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:11","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"12 代理模式 跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。 代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。 客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:12","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"13 责任链模式 晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！ 责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:13","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"14 命令模式 俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。” 命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:14","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"15 解释器模式 俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。 解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。 在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:15","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"16 迭代模式 我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？” 迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。 迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:16","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"17 调停者模式 四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。 当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:17","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"18 备忘录模式 同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。 备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:18","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"19 观察者模式 想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。 观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:19","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"20 状态模式 跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。 状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。 状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:20","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"21 策略模式 跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。 策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:21","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"22 模板方法模式 看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)； 模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:22","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"23 访问者模式 情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了； 访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。 访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:23","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["运维"],"content":"学生学术管理系统后端部署--Docker","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"单个微服务部署应用环境： Java：8 python3(pymysql、pandas、numpy、sklearn) ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:1:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"主代码功能： ​ 利用Java与前端交互，Java调用python文件以线程的方式在本地执行，Java也有一个python的依赖，但是可定制读不高，python库支持不完全。 ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:2:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"解决思路： ​ Java利用Process运行外部运行python命令以绝对路径运行py文件，做到java的jar包与python文件解耦，同时，python文件中用到的MySQL环境参数以环境变量获得。 ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:3:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"Java代码： @GetMapping(\"/associRule\") @ApiOperation(\"使用关联规则推荐比赛\") public String test(String uid){ Process proc; String line = null; try { String[] args1 = new String[] { \"python\", \"/data/comp_reco_AssociRule.py\",uid}; //python.exe处为你系统中python的安装位置；python.py为想要执行的python文件位置；test为想要传的参数 //proc = Runtime.getRuntime().exec(\"python.exe python.py \");// 执行py文件 不传参数 proc=Runtime.getRuntime().exec(args1); //用输入输出流来截取结果 BufferedReader in = new BufferedReader(new InputStreamReader(proc.getInputStream(),\"gbk\")); String temp=null; while ((temp = in.readLine()) != null) { line+=temp; } in.close(); proc.waitFor(); } catch (IOException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } return line; } ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:4:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"python部分代码： # 主要展示获取环境变量 if __name__ == \"__main__\": import os hostserver=os.environ.get('DATASOURCE_HOST') username=os.environ.get('DATASOURCE_USERNAME') pwd=os.environ.get('DATASOURCE_PASSWORD') import pandas as pd import pymysql conn = pymysql.connect(host=hostserver, port=3306, user=username, passwd=pwd,charset=\"utf8\") ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:5:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"dockerfile: docker环境要求，Java与python环境，挂载必要的目录，各部分解耦，方便修改代码： #Dockerfile_comp_rec# NOTE: this docker file is used to build runtime environment.# The project is a python app which contains a java jar lib.FROMpython:3MAINTAINERyangpf \u003ccherishpf@163.com\u003e# COPY ./requirements.txt /usr/local/src/requirements.txtRUN set -eux; \\ apt-get update; \\ apt-get install -y --no-install-recommends \\ bzip2 \\ unzip \\ xz-utils \\ \\ # utilities for keeping Debian and OpenJDK CA certificates in sync ca-certificates p11-kit \\ # \\ # java.lang.UnsatisfiedLinkError: /usr/local/openjdk-11/lib/libfontmanager.so: libfreetype.so.6: cannot open shared object file: No such file or directory# java.lang.NoClassDefFoundError: Could not initialize class sun.awt.X11FontManager# https://github.com/docker-library/openjdk/pull/235#issuecomment-424466077 fontconfig libfreetype6 \\ ; \\ rm -rf /var/lib/apt/lists/*# Default to UTF-8 file.encodingENV LANG C.UTF-8ENV JAVA_HOME /usr/local/openjdk-8ENV PATH $JAVA_HOME/bin:$PATH# backwards compatibility shimRUN { echo '#/bin/sh'; echo 'echo \"$JAVA_HOME\"'; } \u003e /usr/local/bin/docker-java-home \u0026\u0026 chmod +x /usr/local/bin/docker-java-home \u0026\u0026 [ \"$JAVA_HOME\" = \"$(docker-java-home)\" ]# https://adoptopenjdk.net/upstream.html# \u003e# \u003e What are these binaries?# \u003e# \u003e These binaries are built by Red Hat on their infrastructure on behalf of the OpenJDK jdk8u and jdk11u projects. The binaries are created from the unmodified source code at OpenJDK. Although no formal support agreement is provided, please report any bugs you may find to https://bugs.java.com/.# \u003eENV JAVA_VERSION 8u252ENV JAVA_BASE_URL https://github.com/AdoptOpenJDK/openjdk8-upstream-binaries/releases/download/jdk8u252-b09/OpenJDK8U-jre_ENV JAVA_URL_VERSION 8u252b09# https://github.com/docker-library/openjdk/issues/320#issuecomment-494050246# \u003e# \u003e I am the OpenJDK 8 and 11 Updates OpenJDK project lead.# \u003e ...# \u003e While it is true that the OpenJDK Governing Board has not sanctioned those releases, they (or rather we, since I am a member) didn't sanction Oracle's OpenJDK releases either. As far as I am aware, the lead of an OpenJDK project is entitled to release binary builds, and there is clearly a need for them.# \u003eRUN set -eux; \\ \\ dpkgArch=\"$(dpkg --print-architecture)\"; \\ case \"$dpkgArch\" in \\ amd64) upstreamArch='x64' ;; \\ arm64) upstreamArch='aarch64' ;; \\ *) echo \u003e\u00262 \"error: unsupported architecture: $dpkgArch\" ;; \\ esac; \\ \\ wget -O openjdk.tgz.asc \"${JAVA_BASE_URL}${upstreamArch}_linux_${JAVA_URL_VERSION}.tar.gz.sign\"; \\ wget -O openjdk.tgz \"${JAVA_BASE_URL}${upstreamArch}_linux_${JAVA_URL_VERSION}.tar.gz\" --progress=dot:giga; \\ \\ export GNUPGHOME=\"$(mktemp -d)\"; \\ # TODO find a good link for users to verify this key is right (https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2019-April/000951.html is one of the only mentions of it I can find); perhaps a note added to https://adoptopenjdk.net/upstream.html would make sense?# no-self-sigs-only: https://salsa.debian.org/debian/gnupg2/commit/c93ca04a53569916308b369c8b218dad5ae8fe07 gpg --batch --keyserver ha.pool.sks-keyservers.net --keyserver-options no-self-sigs-only --recv-keys CA5F11C6CE22644D42C6AC4492EF8D39DC13168F; \\ # also verify that key was signed by Andrew Haley (the OpenJDK 8 and 11 Updates OpenJDK project lead)# (https://github.com/docker-library/openjdk/pull/322#discussion_r286839190) gpg --batch --keyserver ha.pool.sks-keyservers.net --recv-keys EAC843EBD3EFDB98CC772FADA5CD6035332FA671; \\ gpg --batch --list-sigs --keyid-format 0xLONG CA5F11C6CE22644D42C6AC4492EF8D39DC13168F \\ | tee /dev/stderr \\ | grep '0xA5CD6035332FA671' \\ | grep 'Andrew Haley'; \\ gpg --batch --verify openjdk.tgz.asc openjdk.tgz; \\ gpgconf --kill all; \\ rm -rf \"$GNUPGHOME\"; \\ \\ mkdir -p \"$JAVA_HOME\"; \\ tar --extract \\ --file openjdk.tgz \\ --directory \"$JAVA_HOME\" \\ --strip-components 1 \\ --no-same-owner \\ ; \\ rm openjdk.tgz*; \\ \\ # TODO strip \"demo\" and \"man\" folders? \\ # update \"cacerts\" bundle to use Debian's CA certificates (and make s","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:6:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"compose脚本，需要加入微服务网络，环境文件： version:'3'networks:dockercompose_sc-net:external:trueservices:#人员信息服务comp_rec:build:context:./Dockerfilesdockerfile:Dockerfile_comp_reccontainer_name:sc-comp_recrestart:alwaysnetworks:- \"dockercompose_sc-net\"ports:- 5000:9007volumes:- \"/home/hubu/dockerfiles/comp_rec:/data\"command:[\"java\",\"-jar\",\"/data/comp_rec.jar\"]env_file:.env ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:7:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":".env文件（主要存代码中用到的变量，以环境变量进入容器） DATASOURCE_DBTYPE=sc-mysql DATASOURCE_HOST=mysql DATASOURCE_PORT=3306 DATASOURCE_USERNAME=root DATASOURCE_PASSWORD=root123 DATASOURCE_DRIVER=com.mysql.jdbc.Driver ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:8:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"启动停止单个服务命令： docker-compose -f docker-compose_comp_rec.yml up -d docker-compose -f docker-compose_comp_rec.yml down 接口测试： ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:9:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["Windows"],"content":"1 config.toml 配置 首先我们配置好 config.toml 的 algolia 的配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"hugo\" appID = \"CTZ67PPVA3\" searchKey = \"你的搜索密钥\" ","date":"2021-04-13","objectID":"/git_algolia_sh/:1:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2 Algolia 配置 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.1 登录 Algolia 官网 ，注册账号，创建 Application 名为 “test01”作为举例，默认选择 “FREE” 即可，这里自定义名称 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:1","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.2 我这里选择香港作为存储地区 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:2","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.3 创建index，要与config.toml 的配置 index 一样 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:3","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.4 将 API Keys 里面补充到 config.toml 里面 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:4","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3 使用 atomic-algolia 来完成自动更新索引 ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.1 首先安装 npm，这里不介绍 ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:1","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.2 安装 atomic-algolia npm -g install atomic-algolia --save ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:2","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.3 创建 .env 文件存放 algolia 配置 ALGOLIA_APP_ID=\"CTZ67PPVA3\" ALGOLIA_ADMIN_KEY=\"你的超级管理员密钥，上传json\" ALGOLIA_INDEX_NAME=\"hugo\" ALGOLIA_INDEX_FILE=\"public/index.json\" ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:3","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.4 修改根目录下的 package.json 文件（没有就新建），在 scripts 下添加 \"algolia\": \"atomic-algolia\" { \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" } } ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:4","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.5 上传索引的命令 你可以本地执行 npm run algolia 查看运行效果 ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:5","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"4 定制化脚本 #!/bin/sh # If a command fails then the deploy stops set -e start_local_hugo_server(){ hugo server --disableFastRender } update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia ！！！\\033[0m\\n\" sleep 10 } pushMyBlogHugo(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/hubu8/hubu8\"\\033[0m\\n\" git pull # Add changes to git. git add . # Commit changes. msg=\"change MyBlogHugo site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/hubu8/hubu8.github.io\"\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public pwd git pull # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push sleep 10 } case $1 in 1) start_local_hugo_server ;; 2) pushMyBlogHugo $* ;; 3) push_public $* ;; 4) update_algolia ;; 5) hugo serve -e production ;; 6) hugo server --source=themes/LoveIt/exampleSite ;; esac 脚本解析： sh deploy.sh 1：启动 hugo 作为本地调试使用，实时将文章的内容更新到站点，不需要重启也能边修改边观看效果。 sh deploy.sh 2：将 MyHugoBlog 上传到 Github 存储库。 sh deploy.sh 3：将 public 静态文件站点上传到Github Pages 存储库。 sh deploy.sh 4：更新 algolia 的索引. sh deploy.sh 5：主要是用来调试 cdn，评论系统等，所以要用 production 变量来启动。 sh deploy.sh 6：查看官方例子，方便调试。 仓库代码检验： algolia 的索引: ","date":"2021-04-13","objectID":"/git_algolia_sh/:4:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"应用场景： 搭建hugo静态博客时，只需要上传public目录下的静态资源，但是为了源文件不丢失，也想把根目录上传到另一个仓库备份。但是这样就有了两个仓库，每次推送代码需要push两次，比较麻烦 蠢人有蠢人的办法，写一个批处理脚本，在脚本中在两个目录push: echo \"Start submitting code to the local repository\" echo \"The current directory is:%cd%\" git add . echo; echo \"Commit the changes to the local repository\" set now=%date% %time% echo %now% git commit -m \"%now%\" echo; echo \"Commit the changes to the remote git server\" git push echo; echo \"Batch execution complete!\" echo; hugo cd public echo \"Start submitting code to the local repository\" echo \"The current directory is:%cd%\" git add . echo; echo \"Commit the changes to the local repository\" set now=%date% %time% echo %now% git commit -m \"%now%\" echo; echo \"Commit the changes to the remote git server\" git push echo; echo \"Batch execution complete!\" echo; echo. \u0026 pause 最后按任意键退出。 ","date":"2021-04-13","objectID":"/git_bat/:0:0","tags":["bat批处理脚本"],"title":"Git_bat","uri":"/git_bat/"},{"categories":["运维"],"content":"nginx 项目最初上线的时候并发量小、用户使用少，所以在低并发的情况下，一个Jar包、一个tomcat服务器就够了 但是用户多了，并发量就增大了，这时候一台服务器就不能满足需求，于是可以横向扩展服务器，这时候几个项目启动在不同的服务器上，由于session不共享，就需要一个代理服务器，通过代理服务器请求转发： 我们希望这个代理服务器可以帮助我们接受用户请求，然后按照规则转发在不同服务器上，这个过程用户是无感知的，用户并不知道哪台服务器在返回结果，还希望它可以按照服务器性能提供不同的权重选择 ","date":"2021-04-12","objectID":"/nginx/:1:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"什么是nginx Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 在高连接并发的情况下，Nginx是Apache服务器不错的替代品。 nginx相对于apache的优点： 轻量级，同样起web 服务，比apache 占用更少的内存及资源 ，抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能，高度模块化的设计，编写模块相对简单 ，社区活跃，各种高性能模块出品迅速。 官方数据统计表明能够支持50000个并发量。 ","date":"2021-04-12","objectID":"/nginx/:2:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"nginx作用 http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。 ","date":"2021-04-12","objectID":"/nginx/:3:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"正向代理： 例如我们用的VPN，相当于一个中介跳转；正向代理代理的是客户端，反向代理代理的是服务器。 ","date":"2021-04-12","objectID":"/nginx/:3:1","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"反向代理： ","date":"2021-04-12","objectID":"/nginx/:3:2","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"负载均衡： nginx提供两种负载均衡策略：内置策略和扩展策略；内置策略为轮询、加权轮询，ip hash;扩展策略就是天马行空，任意的定制 轮询： 加权轮询： ip hash: 动静分离： 动静分离，通过中间将动静分离和静态请求进行分离； 通过中间件将动态请求和静态请求分离，可以建上不必要的请求消耗，同时能减少请求的延时。 通过中间件将动态请求和静态请求分离，逻辑图如下 : 动静分离只有好处：动静分离后，即使动态服务不可用，但静态资源不会受到影响。 ","date":"2021-04-12","objectID":"/nginx/:3:3","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"nginx安装： 官网地址：http://nginx.org/en/download.html ","date":"2021-04-12","objectID":"/nginx/:4:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"Windows下安装： 1、官网下载稳定版本，下载即运行，不用任何安装 2、命令行输入nginx.exe,双击运行一闪而过看不到效果，浏览查看80端口： ","date":"2021-04-12","objectID":"/nginx/:4:1","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"linux下安装： 1、官网下载稳定版本，上传到服务器： 2、解压安装： #解压 tar -zxvf nginx-1.18.0.tar.gz #执行配置 ./configure #执行make命令： make make install 第三步报错： ./configure: error: the HTTP rewrite module requires the PCRE library. You can either disable the module by using --without-http_rewrite_module option, or install the PCRE library into the system, or build the PCRE library statically from the source with nginx by using --with-pcre=\u003cpath\u003e option. #执行命令 安装pcre-devel yum -y install pcre-devel 依旧报错： ./configure: error: the HTTP gzip module requires the zlib library. You can either disable the module by using --without-http_gzip_module option, or install the zlib library into the system, or build the zlib library statically from the source with nginx by using --with-zlib=\u003cpath\u003e option. #安装zlib wget http://www.zlib.net/zlib-1.2.11.tar.gz tar -xzvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make make install 3、查看是否安装成功： [root@jd nginx-1.18.0]# whereis nginx nginx: /usr/local/nginx [root@jd nginx-1.18.0]# cd /usr/local/nginx/ [root@jd nginx]# ls conf html logs sbin [root@jd nginx]# ./sbin/nginx [root@jd nginx]# curl localhost \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eWelcome to nginx!\u003c/title\u003e \u003cstyle\u003e body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eWelcome to nginx!\u003c/h1\u003e \u003cp\u003eIf you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u003c/p\u003e \u003cp\u003eFor online documentation and support please refer to \u003ca href=\"http://nginx.org/\"\u003enginx.org\u003c/a\u003e.\u003cbr/\u003e Commercial support is available at \u003ca href=\"http://nginx.com/\"\u003enginx.com\u003c/a\u003e.\u003c/p\u003e \u003cp\u003e\u003cem\u003eThank you for using nginx.\u003c/em\u003e\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 4、nginx常用命令： cd /usr/local/nginx/sbin/ ./nginx #启动 ./nginx -s stop #停止 ./nginx -s quit #安全退出 ./nginx -s reload #重新加载配置文件 ps aux|grep nginx #查看nginx进程 ","date":"2021-04-12","objectID":"/nginx/:4:2","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"nginx配置使用： 应用场景：现在有多台配置不一样的服务器，根据服务器性能设置不同的权重轮询： 配置实例：8000代表一台服务器，8001代表一台服务器，加权轮询1：3 upstream eccentric{ server 127.0.0.1:8000 weight=1; server 127.0.0.1:8001 weight=3; } server { listen 7999; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location /hello { root html; index index.html index.htm; proxy_pass http://eccentric; } #访问后台管理系统/admin location /admin { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } 本地模拟两个服务器： java -jar democompose-0.0.1-SNAPSHOT.jar --server.port=8000 java -jar democompose-0.0.1-SNAPSHOT.jar --server.port=8001 本地访问localhost:7999: 两台服务器接受到的请求次数： Windows双击运行nginx.exe带来的问题，没有办法通过命令行关闭，nginx80端口一直被占用： #查看占用80端口的进程 netstat -ano | findstr \":80 \" #查看对应进程的应用 tasklist /fi \"PID eq 752\" #杀死进程 taskkill /pid 752 /f #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream eccentric{ server 127.0.0.1:8000 weight=1; server 127.0.0.1:8001 weight=3; } server { listen 7999; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location /hello { root html; index index.html index.htm; proxy_pass http://eccentric; } #访问后台管理系统/admin location /admin { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} } ","date":"2021-04-12","objectID":"/nginx/:5:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"实际开发生成环境中需要频繁修改代码或者环境变量的值（例如：服务器ip,数据库密码等），如果频繁去修改代码重新上线需要花费大量的事件，为了解决这一问题，今天用到了docker-compose中的env_file： 应用环境变量设置，不用修改代码，重新打包 代码之间解耦，提高可读性 应用环境： Spring Cloud docker ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:0:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"简介 springboot配置文件如下： spring:cloud:bus:trace:enabled:truerabbitmq:host:${RABBIT_MQ_HOST:localhost}port:${RABBIT_MQ_PORT:5672}username:${RABBIT_MQ_USERNAME:guest}password:${RABBIT_MQ_PASSWORD:guest}redis:host:${REDIS_HOST:localhost}port:${REDIS_PORT:6379}lettuce:pool:max-active:300#password: ${REDIS_PASSWORD:123456}datasource:driver-class-name:com.mysql.jdbc.Driverurl:jdbc:${DATASOURCE_DBTYPE:mysql}://${DATASOURCE_HOST:localhost}:${DATASOURCE_PORT:3306}/sys_users?characterEncoding=UTF-8\u0026useUnicode=true\u0026useSSL=falseusername:${DATASOURCE_USERNAME:root}password:${DATASOURCE_PASSWORD:root123} **${RABBIT_MQ_HOST:localhost}**的含义：如果MQ_HOST设置的有值，就用他；如果没有设置值，就用localhost默认值，这样写的好处是做到全局配置的统一性，避免改配置多处修改； 在开发环节为了调试方便，我们可以在application.yml文件中添加如下配置， DATASOURCE_HOST:191.168.1.105DATASOURCE_PORT:7000DATASOURCE_PASSWORD:root123DATASOURCE_USERNAME:root 但是当部署到生产环境这样写没有任何意义，当需要修改变量值，还是需要重新打包。 为此docker-compose提供了一种解决方案：从文件添加环境变量。可以是单个值或列表的多个值【env_file】： DATASOURCE_DBTYPE=sc-mysql DATASOURCE_HOST=mysql DATASOURCE_PORT=3306 DATASOURCE_USERNAME=root DATASOURCE_PASSWORD=root123 DATASOURCE_DRIVER=com.mysql.jdbc.Driver 只需要在docker-compose文件中的某个service下添加： env_file:.env 或者： env_file:- ./common.env- ./apps/web.env- /opt/secrets.env 通过以上配置就可以把相关的环境变量的值存进你的image ps:同一个变量多次赋值，以最后一次为准，覆盖前面的旧值 ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:1:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"场景应用： 利用docker-compose启动web服务，做到改变IP、密码等配置时不修改代码 ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"1、信件env结尾的文件： ### 数据源mysql实例 DATASOURCE_DBTYPE=mysql DATASOURCE_HOST=sc-mysql DATASOURCE_PORT=3306 DATASOURCE_USERNAME=root DATASOURCE_PASSWORD=root123 DATASOURCE_DRIVER=com.mysql.jdbc.Driver ### 分布式缓存 REDIS_HOST=redis REDIS_PORT=6379 ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:1","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"2、编写docker-compose文件添加env_file: # docker-compose.person.ymlversion:'3'services:#人员信息服务person_info:image:java:8container_name:sc-person_inforestart:alwaysnetworks:- sc-netports:- 9009:9009volumes:- \"/home/hubu/dockerfiles/person_info:/data\"command:[\"java\",\"-jar\",\"/data/person.jar\"]env_file:.env ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:2","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"3、上传服务器相关文件，生成镜像，运行容器： # 还运行了其他docker-compose,-f指定文件 docker-compose -f docker-compose.yml -f docker-compose.person.yml -f docker-compose.auth.yml up -d #关闭： docker-compose -f docker-compose.yml -f docker-compose.person.yml -f docker-compose.auth.yml down ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:3","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"4、查看环境变量是否进入容器： #通过docker logs 查看系统日志，如果没有错误就是正确的 docker exec -it sc-person_info /bin/bash env ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:4","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"5、愉快地开始部署项目了！！！ ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:5","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"6、日常小计 限制内存(1.20版本以上)： version:'3'networks:dockercompose_sc-net:external:trueservices:#人员信息服务comp:image:java:8container_name:sc-comprestart:alwaysnetworks:- \"dockercompose_sc-net\"# networks:# - sc-netports:- 5002:9011volumes:- \"/home/hubu/dockerfiles/comp:/data\"deploy:resources:limits:cpus:'0.50'memory:1Gcommand:[\"java\",\"-jar\",\"/data/comp.jar\"]env_file:.env 运行加参数： docker-compose --compatibility up -d ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:6","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["Java后端"],"content":"抽了点时间，整理了一些 maven 常用命令参数，以便参考； ","date":"2021-04-11","objectID":"/mvn/:0:0","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"mvn 命令参数 mvn -v, –version 显示版本信息; mvn -V, –show-version 显示版本信息后继续执行 Maven 其他目标; mvn -h, –help 显示帮助信息; mvn -e, –errors 控制 Maven 的日志级别, 产生执行错误相关消息; mvn -X, –debug 控制 Maven 的日志级别, 产生执行调试信息; mvn -q, –quiet 控制 Maven 的日志级别, 仅仅显示错误; mvn -Pxxx 激活 id 为 xxx 的 profile (如有多个，用逗号隔开); mvn -Dxxx=yyy 指定 java 全局属性; mvn -o , –offline 运行 offline 模式, 不联网更新依赖; mvn -N, –non-recursive 仅在当前项目模块执行命令, 不构建子模块; mvn -pl, –module_name 在指定模块上执行命令; mvn -ff, –fail-fast 遇到构建失败就直接退出; mvn -fn, –fail-never 无论项目结果如何, 构建从不失败; mvn -fae, –fail-at-end 仅影响构建结果, 允许不受影响的构建继续; mvn -C, –strict-checksums 如果校验码不匹配的话, 构建失败; mvn -c, –lax-checksums 如果校验码不匹配的话, 产生告警; mvn -U 强制更新 snapshot 类型的插件或依赖库 (否则 maven 一天只会更新一次 snapshot 依赖); mvn -npu, –no-plugin-updates 对任何相关的注册插件, 不进行最新检查 (使用该选项使 Maven 表现出稳定行为，该稳定行为基于本地仓库当前可用的所有插件版本); mvn -cpu, –check-plugin-updates 对任何相关的注册插件, 强制进行最新检查 (即使项目 POM 里明确规定了 Maven 插件版本, 还是会强制更新); mvn -up, –update-plugins [mvn -cpu] 的同义词; mvn -B, –batch-mode 在非交互（批处理）模式下运行 (该模式下, 当 Mven 需要输入时, 它不会停下来接受用户的输入, 而是使用合理的默认值); mvn -f, –file 强制使用备用的 POM 文件; mvn -s, –settings 用户配置文件的备用路径; mvn -gs, –global-settings 全局配置文件的备用路径; mvn -emp, –encrypt-master-password 加密主安全密码, 存储到 Maven settings 文件里; mvn -ep, –encrypt-password 加密服务器密码, 存储到 Maven settings 文件里; mvn -npr, –no-plugin-registry 对插件版本不使用~/.m2/plugin-registry.xml(插件注册表) 里的配置; ","date":"2021-04-11","objectID":"/mvn/:0:1","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"mvn 常用命令 创建 Maven 的普通 java 项目： mvn archetype:create -DgroupId=packageName -DartifactId=projectName 创建 Maven 的 Web 项目： mvn archetype:create -DgroupId=packageName -DartifactId=webappName -DarchetypeArtifactId=maven-archetype-webapp 编译源代码：mvn compile 编译测试代码：mvn test-compile 运行测试：mvn test 产生 site：mvn site 打包：mvn package 在本地 Repository 中安装 jar：mvn install 清除产生的项目：mvn clean 生成 eclipse 项目：mvn eclipse:eclipse 生成 idea 项目：mvn idea:idea 组合使用 goal 命令，如只打包不测试：mvn -Dtest package 编译测试的内容：mvn test-compile 只打 jar 包: mvn jar:jar 只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile (-skipping 的灵活运用，当然也可以用于其他组合命令) 清除 eclipse 的一些系统设置: mvn eclipse:clean ps 一般使用情况是这样，首先通过 cvs 或 svn 下载代码到本机，然后执行 mvn eclipse:eclipse 生成 ecllipse 项目文件，然后导入到 eclipse 就行了；修改代码后执行 mvn compile 或 mvn test 检验，也可以下载 eclipse 的 maven 插件。 mvn -version/-v 显示版本信息 mvn archetype:generate 创建 mvn 项目 mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app 创建 mvn 项目 mvn package 生成 target 目录，编译、测试代码，生成测试报告，生成 jar/war 文件 mvn jetty:run 运行项目于 jetty 上, mvn compile 编译 mvn test 编译并测试 mvn clean 清空生成的文件 mvn site 生成项目相关信息的网站 mvn -Dwtpversion=1.0 eclipse:eclipse 生成 Wtp 插件的 Web 项目 mvn -Dwtpversion=1.0 eclipse:clean 清除 Eclipse 项目的配置信息 (Web 项目) mvn eclipse:eclipse 将项目转化为 Eclipse 项目 在应用程序用使用多个存储库 \u003crepositories\u003e \u003crepository\u003e \u003cid\u003eIbiblio\u003c/id\u003e \u003cname\u003eIbiblio\u003c/name\u003e \u003curl\u003ehttp://www.ibiblio.org/maven/\u003c/url\u003e \u003c/repository\u003e \u003crepository\u003e \u003cid\u003ePlanetMirror\u003c/id\u003e \u003cname\u003ePlanet Mirror\u003c/name\u003e \u003curl\u003ehttp://public.planetmirror.com/pub/maven/\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e 命令： mvn deploy:deploy-file -DgroupId=com -DartifactId=client -Dversion=0.1.0-Dpackaging=jar -Dfile=d:\\client-0.1.0.jar-DrepositoryId=maven-repository-inner -Durl=ftp://xxxxxxx/opt/maven/repository/ 发布第三方 Jar 到本地库中： mvn install:install-file -DgroupId=com -DartifactId=client -Dversion=0.1.0-Dpackaging=jar -Dfile=d:\\client-0.1.0.jar -DdownloadSources=true -DdownloadJavadocs=true mvn -e 显示详细错误 信息. mvn validate 验证工程是否正确，所有需要的资源是否可用。 mvn test-compile 编译项目测试代码。 mvn integration-test 在集成测试可以运行的环境中处理和发布包。 mvn verify 运行任何检查，验证包是否有效且达到质量标准。 mvn generate-sources 产生应用需要的任何额外的源代码，如 xdoclet。 ","date":"2021-04-11","objectID":"/mvn/:0:2","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"mvn 常用命令 2 mvn -v 显示版本 mvn help:describe -Dplugin=help 使用 help 插件的 describe 目标来输出 Maven Help 插件的信息。 mvn help:describe -Dplugin=help -Dfull 使用 Help 插件输出完整的带有参数的目标列 mvn help:describe -Dplugin=compiler -Dmojo=compile -Dfull 获取单个目标的信息, 设置 mojo 参数和 plugin 参数。此命令列出了 Compiler 插件的 compile 目标的所有信息 mvn help:describe -Dplugin=exec -Dfull 列出所有 Maven Exec 插件可用的目标 mvn help:effective-pom 看这个 “有效的 (effective)”POM，它暴露了 Maven 的默认设置 mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 -DartifactId=simple -DpackageName=org.sonatype.mavenbook 创建 Maven 的普通 java 项目，在命令行使用 Maven Archetype 插件 mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main Exec 插件让我们能够在不往 classpath 载入适当的依赖的情况下，运行这个程序 mvn dependency:resolve 打印出已解决依赖的列表 mvn dependency:tree 打印整个依赖树 mvn install -X 想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开 Maven 的调试标记运行 mvn install -Dmaven.test.skip=true 给任何目标添加 maven.test.skip 属性就能跳过测试 mvn install assembly:assembly 构建装配 Maven Assembly 插件是一个用来创建你应用程序特有分发包的插件 mvn jetty:run 调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用 mvn compile 编译你的项目 mvn clean install 删除再编译 mvn hibernate3:hbm2ddl 使用 Hibernate3 插件构造数据库 ","date":"2021-04-11","objectID":"/mvn/:0:3","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"短信验证服务编写","date":"2021-04-10","objectID":"/message/","tags":["短信验证码"],"title":"短信验证码实现","uri":"/message/"},{"categories":["Java后端"],"content":"阿里云短信服务 1、添加用户组和相关权限 2、创建一个用户、获取相应的Acessce Key 要将这个账户保存下来，只显示一次，如果被泄露马上禁用生成新的，后面需要用到 开通阿里云短信服务 帮助指南 1、开通短信服务，找到短信控制台面板 2、添加短信模板、添加签名（中括号里面的名称） 编写代码测试 在pom文件中添加如下依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-core\u003c/artifactId\u003e \u003cversion\u003e4.5.16\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.62\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e 2、编写服务与服务实现： package com.example.democompose.Service.Impl; import com.alibaba.fastjson.JSONObject; import com.aliyuncs.CommonRequest; import com.aliyuncs.CommonResponse; import com.aliyuncs.DefaultAcsClient; import com.aliyuncs.IAcsClient; import com.aliyuncs.exceptions.ClientException; import com.aliyuncs.exceptions.ServerException; import com.aliyuncs.http.MethodType; import com.aliyuncs.profile.DefaultProfile; import com.example.democompose.Service.SendSms; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.Map; @Service public class SendSmsImpl implements SendSms { @Override public boolean send(String phoneNum, String templateCode, Map\u003cString, Object\u003e map) { DefaultProfile profile = DefaultProfile.getProfile(\"cn-qingdao\", \"accessKeyIdxxxxxx\", \"accessKeySecretxxxxxxx\"); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); request.setSysMethod(MethodType.POST); request.setSysDomain(\"dysmsapi.aliyuncs.com\"); request.setSysVersion(\"2017-05-25\"); request.setSysAction(\"SendSms\"); request.putQueryParameter(\"PhoneNumbers\", phoneNum); request.putQueryParameter(\"SignName\", \"东猿叔\"); request.putQueryParameter(\"TemplateCode\", templateCode); request.putQueryParameter(\"TemplateParam\", JSONObject.toJSONString(map)); try { CommonResponse response = client.getCommonResponse(request); System.out.println(response.getData()); return response.getHttpResponse().isSuccess(); } catch (ServerException e) { e.printStackTrace(); } catch (ClientException e) { e.printStackTrace(); } return false; } } 3、controller调用： package com.example.democompose.Controller; import com.aliyuncs.utils.StringUtils; import com.example.democompose.Service.SendSms; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import java.util.HashMap; import java.util.UUID; import java.util.concurrent.TimeUnit; @RestController @CrossOrigin public class SendSmsController { @Autowired private SendSms sendSms; @Autowired private RedisTemplate redisTemplate; @GetMapping(\"/send/{phone}\") public String code(@PathVariable(\"phone\")String phone){ String code=(String) redisTemplate.opsForValue().get(phone); if(!StringUtils.isEmpty(code)){ return phone+\":\"+code+\"已经存在，还没有过期\"; } code = UUID.randomUUID().toString().substring(0, 4); HashMap\u003cString,Object\u003e param=new HashMap\u003c\u003e(); param.put(\"code\",code); boolean isSend = sendSms.send(phone, \"SMS_215116099\", param); if(isSend){ redisTemplate.opsForValue().set(phone,code,5, TimeUnit.MINUTES); return phone+\":\"+code+\"发送成功\"; }else{ return phone+\":\"+code+\"发送失败\"; } } } ","date":"2021-04-10","objectID":"/message/:0:0","tags":["短信验证码"],"title":"短信验证码实现","uri":"/message/"},{"categories":["运维"],"content":"Docker compose  \u0026  Docker Swarm","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Docker Compose Using Compose is basically a three-step process: Define your app’s environment with a Dockerfile so it can be reproduced anywhere. Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment. Run docker compose up and the Docker compose command starts and runs your entire app. You can alternatively run docker-compose up using the docker-compose binary. Compose是官方的开源项目，需要安装， ​ Dockerfile可以让程序在任何地方运行，但是现在有一个web服务，但是它又需要redis、MySQL、nginx等多个容器，一个一个启动就会十分麻烦。 Compose例子： version:\"3.9\"# optional since v1.27.0services:web:build:.ports:- \"5000:5000\"volumes:- .:/code- logvolume01:/var/loglinks:- redisredis:image:redisvolumes:logvolume01:{} ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:0:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"安装Compose 1、下载： sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo curl -L \"https://get.daocloud.io/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 2、授权 sudo chmod +x /usr/local/bin/docker-compose 3、全局使用 [root@node4 /]# docker-compose version docker-compose version 1.29.0, build 07737305 docker-py version: 5.0.0 CPython version: 3.7.10 OpenSSL version: OpenSSL 1.1.0l 10 Sep 2019 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:1:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"快速体验 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 1: 创建应用 Define the application dependencies. Create a directory for the project(创建目录): $ mkdir composetest $ cd composetest Create a file called app.py in your project directory and paste this in（创建python文件）: import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) 在这个例子中, redis 是应用网络中redis的容器名称. 使用端口, 6379. 注意get_hit_coun函数的编写方式。这个基本的重试循环允许我们在redis服务不可用时多次尝试请求。当应用程序上线时，这在启动时很有用，但如果在应用程序的生命周期内需要随时重新启动Redis服务，也会使我们的应用程序更有弹性。在集群中，这也有助于处理节点之间的瞬时连接中断。 创建 requirements.txt 文件: flask redis ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 2: 编写Dockerfile 这一步将编写dockerfile并build image ,这个镜像包含了python所需要的环境 Dockerfile 文件: FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP=app.py ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers COPY requirements.txt requirements.txt RUN pip install -r requirements.txt EXPOSE 5000 COPY . . CMD [\"flask\", \"run\"] This tells Docker to: Build an image starting with the Python 3.7 image. Set the working directory to /code. Set environment variables used by the flask command. Install gcc and other dependencies Copy requirements.txt and install the Python dependencies. Add metadata to the image to describe that the container is listening on port 5000 Copy the current directory . in the project to the workdir . in the image. Set the default command for the container to flask run. For more information on how to write Dockerfiles, see the Docker user guide and the Dockerfile reference. ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 3: 在Compose文件中定义Service 创建 docker-compose.yml 文件: version: \"3.9\" services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 这个Compose声明了两个service: web and redis. [root@node4 composetest]# ll 总用量 16 -rw-r--r--. 1 root root 514 4月 9 16:48 app.py -rw-r--r--. 1 root root 111 4月 9 17:00 docker-compose.yml -rw-r--r--. 1 root root 252 4月 9 16:50 Dockerfile -rw-r--r--. 1 root root 12 4月 9 16:49 requirements.txt ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 4: 用Compose启动多个容器 docker-compose up [root@node4 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9a28f238ee73 composetest_web \"flask run\" 34 seconds ago Up 32 seconds 0.0.0.0:5000-\u003e5000/tcp composetest_web_1 e4cb9836d38d redis:alpine \"docker-entrypoint.s…\" 34 seconds ago Up 32 seconds 6379/tcp composetest_redis_1 [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 1 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 2 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 3 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 4 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 5 times. [root@node4 ~]# docker network inspect composetest_default [ { \"Name\": \"composetest_default\", \"Id\": \"25ec9a55f82b6ff2c9b190c911cf6a89ce998759b912c3f2dbf5c2849a6c89d5\", \"Created\": \"2021-04-09T17:01:45.524551071+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": null, \"Config\": [ { \"Subnet\": \"172.18.0.0/16\", \"Gateway\": \"172.18.0.1\" } ] }, \"Internal\": false, \"Attachable\": true, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"9a28f238ee7334688d70f20a2838cbcea964bb3f1282b99b4c787b61370bd202\": { \"Name\": \"composetest_web_1\", \"EndpointID\": \"920c033116c19419b0e2807f75284d768436cb272735642b7e8257f9564d9e45\", \"MacAddress\": \"02:42:ac:12:00:03\", \"IPv4Address\": \"172.18.0.3/16\", \"IPv6Address\": \"\" }, \"e4cb9836d38deb2d2dbd4211106dd2364ace9f97ab5e8827736fc7d39b5ba166\": { \"Name\": \"composetest_redis_1\", \"EndpointID\": \"7f359906cf87650c9ef25939d25c7cfe070ac1135855ff888f1b7a881682aa31\", \"MacAddress\": \"02:42:ac:12:00:02\", \"IPv4Address\": \"172.18.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": { \"com.docker.compose.network\": \"default\", \"com.docker.compose.project\": \"composetest\", \"com.docker.compose.version\": \"1.29.0\" } } ] 流程： 创建网络 执行docker-compose.yml 启动服务 默认规则： 默认服务名（容器名）：文件夹名_服务名__num num为副本数量，因为服务不可能只有一个，弹性扩容，高可用 docker images 会自动pull所需images docker network ls 自动生成网络（同一个网络通过service名称连通） composetest_自定义网络名称 停止compose： docker-compose down ctrl+c #一键停止所有容器 ^CGracefully stopping... (press Ctrl+C again to force) Stopping composetest_web_1 ... Stopping composetest_web_1 ... done ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"yml文件编写规则 compose文件编写参考：https://docs.docker.com/compose/compose-file/compose-file-v3/ #第一层version:''#向下兼容#第二层service:#服务服务1:#服务配置images:build:network:...服务2:...#第三层volumes:network:config:... 多看官方文档，开源项目的compose ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"部署Woedpress项目 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"1、创建目录： mkdir my_wordpress cd my_wordpress/ ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"2、创建compose文件： nano docker-compose.ymlversion:\"3.9\"services:db:image:mysql:5.7volumes:- db_data:/var/lib/mysqlrestart:alwaysenvironment:MYSQL_ROOT_PASSWORD:somewordpressMYSQL_DATABASE:wordpressMYSQL_USER:wordpressMYSQL_PASSWORD:wordpresswordpress:depends_on:- dbimage:wordpress:latestports:- \"8000:80\"restart:alwaysenvironment:WORDPRESS_DB_HOST:db:3306WORDPRESS_DB_USER:wordpressWORDPRESS_DB_PASSWORD:wordpressWORDPRESS_DB_NAME:wordpressvolumes:db_data:{} ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"3、启动： docker-compose up -d #后台启动 [root@node4 my_wordpress]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a56f5f6a9eb6 wordpress:latest \"docker-entrypoint.s…\" About a minute ago Up About a minute 0.0.0.0:8000-\u003e80/tcp my_wordpress_wordpress_1 63f261196b58 mysql:5.7 \"docker-entrypoint.s…\" About a minute ago Up About a minute 3306/tcp, 33060/tcp my_wordpress_db_1 All are easy!!!! ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"实战：自己编写服务上线 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"1、编写自己的服务： package com.example.democompose.Controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @Autowired StringRedisTemplate redisTemplate; @GetMapping(\"/hello\") public String hello(){ Long views=redisTemplate.opsForValue().increment(\"views\"); return \"hello,这是第\"+views+\"次访问\"; } } server.port=8080 spring.redis.host=redis ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"2、编写Dockerfile文件： FROM java:8 COPY *.jar /app.jar CMD [\"--server.port=8080\"] EXPOSE 8888 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"3、编写docker-compose.yml文件 version:'3.8'services:myapp:build:.image:mytextappcomposedepends_on:- redisports:- \"8080:8080\"redis:image:\"library/redis:alpine\" ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"4、打jar包上传服务器 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"5、运行服务： docker-compose up -d docker-compose up --build #重新构建 Docker Swarm ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:5","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"搭建集群 集群—–4台服务器（一主三从） 4台机器安装Docker(Xshell窗口右键：发送键输入到所有会话): sudo yum install -y yum-utils # 3、设置镜像仓 sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 默认是国外的 可换国内 yum makecache fast # 4、安装相关的额 sudo yum install docker-ce docker-ce-cli containerd.io # 5、启动 sudo systemctl start docker docker version noe2 192.168.80.133 noe3 192.168.80.134 node4 192.168.80.135 test 192.168.80.136 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化管理节点node2: # 初始化一个manager节点 docker swarm init --advertise-addr 192.168.80.133 [root@node2 network-scripts]# docker swarm init --advertise-addr 192.168.80.133 Swarm initialized: current node (a5gz7qpsgbjolzgzg1tlaj8lh) is now a manager. To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions. docker swarm join加入一个节点： #获取令牌 docker swarm join-token manager #管理节点 docker swarm join-token worker #工作节点 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化工作节点node3: [root@node3 ~]# docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 This node joined a swarm as a worker. 查看现有集群状态： [root@node2 /]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Leader 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Ready Active 20.10.5 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化工作节点node4: [root@node2 /]# docker swarm join-token worker To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 [root@node2 /]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Leader 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Ready Active 20.10.5 6ne9u5knznm8ei0c5uz7znka9 node4 Ready Active 20.10.5 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化管理节点test: docker swarm join-token manager docker node ls [root@localhost ~]# docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-66whvjsogw3qsqozb79oprffr 192.168.80.133:2377 Error response from daemon: manager stopped: can't initialize raft node: rpc error: code = Unknown desc = could not connect to prospective new cluster member using its advertised address: rpc error: code = Unavailable desc = connection error: desc = \"transport: Error while dialing dial tcp 192.168.80.136:2377: connect: no route to host\" 试了好多次发现总是加入管理节点错误，一开始怀疑自己网络通信问题，后来网上无脑抄袭一致认为代理问题： 最终发现是自己新建的虚拟机test防火墙没有关: #查看防火墙状态 systemctl status firewalld.service #停止防火墙 systemctl stop firewalld.service #永久停止 systemctl disable firewalld.service ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Raft协议 现在：双主双从，假设一个节点挂了，其他节点是否可用？？ Raft协议：保证大多数节点存活集群才可用，至少大于1台，集群至少大于3台！！ 实验： 1、将node2管理节点停止，宕机，另外一个管理节点也不能用了 systemctl stop docker 在test管理节点查看集群，发现不可用： 2、重新启动node2: systemctl start docker 发现leader节点变了： 3、工作节点node3离开： docker swarm --help docker swarm leave 4、三主一工作： docker swarm join-token manager jb30cv8ej8xjokjc1cu5l8kjo localhost.localdomain Ready Active Leader 20.10.5 a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Reachable 20.10.5 nmhr2t2b5cgy4l64bcwl0mxjt node3 Ready Active Reachable 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Down Active 20.10.5 6ne9u5knznm8ei0c5uz7znka9 node4 Ready Active 20.10.5 现在就是3台作为管理节点： 5、停掉Leader(test)： 现在Leader是test节点，停掉： 在node2查看集群状态,发现node3变成了leader，集群任然可用 6、大多数存活可用 现在只有两个管理节点（node2/node3），一个工作节点(node4)，如果再停止一个管理节点，那就无法使用了： [root@node3 ~]# docker node ls Error response from daemon: rpc error: code = Unknown desc = The swarm does not have a leader. It's possible that too few managers are online. Make sure more than half of the managers are online. 大多数管理节点存活才可用 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:7:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"集群部署应用、弹性、扩缩容 以后告别docker run 集群：高可用，web-\u003eredis(分布在三台不同主机上，服务副本，挂了一个没事，其他可用) 容器=》服务=》副本 docker run # 容器启动，不具备扩缩容功能 docker service #服务，具备扩缩容、滚动跟新、灰度发布 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"服务部署 #前提是swarm搭建好 #在node2中创建服务 docker service create -p 8888:80 --name mynginx nginx docker service ls docker service ps mynginx docker service inspect mynginx [root@node2 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS ndtmy83nj0v3 mynginx.1 nginx:latest node3 Running Running 34 seconds ago [root@node2 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 1/1 nginx:latest *:8888-\u003e80/tcp # 服务副本只有一个，并且服务运行在node3主机上 [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 4 minutes ago Up 4 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v 现在服务只随机创建了一个服务，在node3主机上，假如现在访问量加大，需要扩容： # 创建3个副本 docker service update --replicas 3 mynginx [root@node3 ~]# docker service update --replicas 3 mynginx mynginx overall progress: 3 out of 3 tasks 1/3: running [==================================================\u003e] 2/3: running [==================================================\u003e] 3/3: running [==================================================\u003e] verify: Service converged [root@node3 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 3/3 nginx:latest *:8888-\u003e80/tcp [root@node3 ~]# docker service inspect mynginx 此时三个服务副本在node3、node4、test主机上 在集群中的任意一个节点都可访问，服务可以有多个副本来实现高可用： 但是现在通过node3IP无法访问服务，其他正常 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"大无语事件来了，有彩蛋: #如果把副本数量讲到1个会怎么样？？降！！！ [root@node3 ~]# docker service update --replicas 1 mynginx mynginx overall progress: 1 out of 1 tasks 1/1: running [==================================================\u003e] verify: Service converged #那就是只有这个一个副本？？？（bug） [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 40 minutes ago Up 40 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v #发现还是访问不了，查看日志，发现他的日志启动一半，少了许多日志，那就重启 [root@node3 ~]# docker restart mynginx.1.ndtmy83nj0v3oathgaleiw37v mynginx.1.ndtmy83nj0v3oathgaleiw37v [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 42 minutes ago Up About a minute 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v [root@node3 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 1/1 nginx:latest *:8888-\u003e80/tcp 但是我又发现，怎么会有两个： [root@node2 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2bc639d336dd nginx:latest \"/docker-entrypoint.…\" 13 minutes ago Up 13 minutes 80/tcp mynginx.1.wgk7pwm0mm7zs6fawmb7p6otf [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 55 minutes ago Up 14 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v 我把其中一个关掉还是不能访问，此时通过mynginx信息发现如下错误： [root@node2 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS x8advkit107e mynginx.1 nginx:latest node4 Running Running 6 minutes ago wgk7pwm0mm7z \\_ mynginx.1 nginx:latest node2 Shutdown Complete 6 minutes ago ndtmy83nj0v3 \\_ mynginx.1 nginx:latest node3 Shutdown Failed 25 minutes ago \"task: non-zero exit (137)\" 那就只能重来一遍： docker service rm mynginx docker service create -p 8888:80 --replicas 3 --name mynginxtest nginx [root@node2 ~]# docker service ps mynginxtest ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS fultv05jwsbm mynginxtest.1 nginx:latest localhost.localdomain Running Running 15 seconds ago yikbwlzinhd5 mynginxtest.2 nginx:latest node3 Running Running 17 seconds ago f5cljf1f6d73 mynginxtest.3 nginx:latest node2 Running Running 16 seconds ago [root@node2 ~]# docker service ps mynginxtest ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS fultv05jwsbm mynginxtest.1 nginx:latest localhost.localdomain Running Running 7 minutes ago yikbwlzinhd5 mynginxtest.2 nginx:latest node3 Running Running 7 minutes ago f5cljf1f6d73 mynginxtest.3 nginx:latest node2 Running Running 7 minutes ago [root@node2 ~]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION jb30cv8ej8xjokjc1cu5l8kjo localhost.localdomain Ready Active Reachable 20.10.5 a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Reachable 20.10.5 nmhr2t2b5cgy4l64bcwl0mxjt node3 Ready Active Leader 20.10.5 6ne9u5knznm8ei0c5uz7znka9 node4 Ready Active 20.10.5 问题依旧存在(只有node3不能访问)，不搞了，等后续，欢迎留言？？？ 问题最终还是解决了？？？ #以为node3的防火墙没有关，或者是leader节点不能访问？ systemctl stop docker #让他重新选举leader，发现还是可以访问leader， systemctl status firewalld.service #防火墙状态关闭 systemctl start docker #重新启动又好了,玄学 副本服务与全局服务 docker service create --mode replicated --name mytom tomcat:7 #默认worker节点创建服务 docker service create --mode global --name mytom tomcat:7 #全局 减少副本： docker service update --replicas 1 mynginx 扩缩容： docker service scale mynginxtest=5 docker service update --replicas 5 mynginxtest ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS fultv05jwsbm mynginxtest.1 nginx:latest localhost.localdomain Running Running 12 minutes ago yikbwlzinhd5 mynginxtest.2 nginx:latest node3 Running Running 12 minutes ago f5cljf1f6d73 mynginxtest.3 nginx:latest node2 Running Running 12 minutes ago l4blkh6mq996 mynginxtest.4 nginx:latest node4 Running Running about a minute kvn9nhtwymds mynginxtest.5 nginx:latest node4 Running Running about a minute ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"总结 swarm: ​ 集群的管理和编排，docker可以初始化一个swarm集群，其他节点可以加入（manager OR worker） node： ​ 就是一个docker节点，多个节点就组成了一个网络集群 service ​ 就是一个任务，可以在管理节点或者工作节点运行，核心 ​ swarm网络：overlay,ingress Docker Stack docker-compose:适合单机部署项目！ docker stack：集群部署项目(已经快被k8s替代了) #单机部署 docker-compose up -d wordpress.yml #集群部署 docker stack deploy wordpress.yml Docker Secret 安全，密码、证书配置： Docker Config 配置： ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:9:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["算法"],"content":"冒泡排序 ​ 冒泡排序是通过比较两个相邻元素的大小实现排序，如果前一个元素大于后一个元素，就交换这两个元素。这样就会让每一趟冒泡都能找到最大一个元素并放到最后。 以 [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，对它进行冒泡排序： ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] maopaoSort(int[] array){ boolean isChanged=false; for(int i=0;i\u003carray.length-1;i++){ for(int j=0;j\u003carray.length-1-i;j++){ if(array[j]\u003earray[j+1]){ int temp=array[j+1]; array[j+1]=array[j]; array[j]=temp; isChanged=true; } } } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它是指对同样的数据进行排序，会不会改变它的相对位置。比如 [ 1, 3, 2, 4, 2 ] 经过排序后，两个相同的元素 2 位置会不会被交换。冒泡排序是比较相邻两个元素的大小，显然不会破坏稳定性。 空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1); 时间复杂度：由于嵌套了 2 层循环，故为 O(n*n); ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"选择排序 ​ 选择排序的思想是，依次从「无序列表」中找到一个最小的元素放到「有序列表」的最后面。以 arr = [ 8, 1, 4, 6, 2, 3, 5, 4 ] 为例，排序开始时把 arr 分为有序列表 A = [ ], 无序列表 B = [ 8, 1, 4, 6, 2, 3, 5, 4 ]，依次从 B 中找出最小的元素放到 A 的最后面。这种排序也是逻辑上的分组，实际上不会创建 A 和 B，只是用下标来标记 A 和 B。 ​ 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 4 ] 为例，第一次找到最小元素 1 与 8 进行交换，这时有列表 A = [1], 无序列表 B = [8, 4, 6, 2, 3, 5, 4]；第二次从 B 中找到最小元素 2，与 B 中的第一个元素进行交换，交换后 A = [1，2]，B = [4, 6, 8, 3, 5, 4]；就这样不断缩短 B，扩大 A，最终达到有序。 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 方法一： public static int[] selectSort(int[] array){ for(int i=0;i\u003carray.length-1;i++){ int index=i; //找出n次无序列表中的最小值和他的下标 for(int j=i;j\u003carray.length;j++){ if(array[j]\u003carray[index]) { index = j; } } int temp=array[index]; array[index]=array[i]; array[i]=temp; } return array; } 方法二： public static int[] selectSort(int[] array){ for(int i=0;i\u003carray.length-1;i++){ int index=i; int temp=999; //找出n次无序列表中的最小值和他的下标 for(int j=i;j\u003carray.length;j++){ if(array[j]\u003carray[index]){ index=j; } temp=array[index]; } //把[i,index]后移一位，给有序增加空位，插入最小值 for(int m=index;m\u003ei;m--){ array[m]=array[m-1]; } array[i]=temp; } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：排序过程中元素是按顺序进行遍历，相同元素相对位置不会发生变化，故稳定。 空间复杂度：在原序列进行操作，故为 O( 1 ); 时间复杂度：需要 2 次循环遍历，故为 O( n * n ); ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"插入排序 ​ 在整个排序过程如图所示，以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7] 为例，它会把 arr 分成两组 A = [ 8 ] 和 B = [ 1, 4, 6, 2, 3, 5, 7] ，逐步遍历 B 中元素插入到 A 中，最终构成一个有序序列： ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] insertSort(int[] array){ for(int i=1;i\u003carray.length;i++){ int preindex=i-1; // 必须记录这个元素，不然会被覆盖掉 int current=array[i]; // 当前元素小于排序好的元素，就移动到下一个位置,从后向前找位置插入 while(preindex\u003e=0\u0026\u0026current\u003carray[preindex]){ array[preindex+1]=array[preindex]; preindex--; } array[preindex+1]=current; } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它是从后往前遍历已排序好的序列，相同元素不会改变位置，故为稳定排序； 空间复杂度：它是在原序列进行排序，故为 O ( 1 ); 时间复杂度：排序的过程中，首先要遍历所有的元素，然后在已排序序列中找到合适的位置并插入。共需要 2 层循环，故为 O ( n * n ); ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"希尔排序 ​ 希尔排序，它是由 D.L.Shell 于1959 年提出而得名。根据它的名字很难想象算法的核心思想。[ 所以只能死记硬背了，面试官问：希尔排序的思想是什么？]。它的核心思想是把一个序列分组，对分组后的内容进行插入排序，这里的分组只是逻辑上的分组，不会重新开辟存储空间。它其实是插入排序的优化版，插入排序对基本有序的序列性能好，希尔排序利用这一特性把原序列分组，对每个分组进行排序，逐步完成排序。 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，通过 floor(8/2) 来分为 4 组，8 表示数组中元素的个数。分完组后，对组内元素进行插入排序。 「 利用第 1 次分组结果进行第 2 次分组 」 「 利用第 2 次分组结果进行最后一次分组 」 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] lshellSort(int[] array){ //len=9 int len=array.length; //floor向下取整，4，2，1 for(int gap=(int)Math.floor(len/2);gap\u003e0;gap=gap/2){ //i=4; for (int i = gap; i \u003c len; i++) { // j=0,1,2,3,4 // [0]-[4] [1]-[5] [2]-[6] [3]-[7] [4]-[8] for (int j = i - gap; j \u003e= 0 \u0026\u0026 array[j] \u003e array[j+gap]; j-=gap) { // 交换位置 int temp = array[j]; array[j] = array[gap+j]; array[gap+j] = temp; } } } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它可能会把相同元素分到不同的组中，那么两个相同的元素就有可能调换相对位置，故不稳定。 空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1); 时间复杂度：希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(log n的3/2)，希尔排序时间复杂度的下界是n*log2n ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"快速排序 快速排序的核心思想是对待排序序列通过一个「支点」（支点就是序列中的一个元素，别把它想的太高大上）进行拆分，使得左边的数据小于支点，右边的数据大于支点。然后把左边和右边再做一次递归，直到递归结束。支点的选择也是一门大学问，我们以 （左边index + 右边index）/ 2 来选择支点。 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，选择一个支点, index= (L+R)/2 = (0+7)/2=3, 支点的值 pivot = arr[index] = arr[3] = 6，接下来需要把 arr 中小于 6 的移到左边，大于 6 的移到右边。 快速排序使用一个高效的方法做数据拆分。 用一个指向左边的游标 i，和指向右边的游标 j，逐渐移动这两个游标，直到找到 arr[i] \u003e 6 和 arr[j] \u003c 6, 停止移动游标，交换 arr[i] 和 arr[j]，交换完后 i++，j–（对下一个元素进行比较），直到 i\u003e=j，停止移动。 图中的 L，R 是指快速排序开始时序列的起始和结束索引，在一趟快速排序中，它们的值不会发生改变，直到下一趟排序时才会改变。 一趟快速排序完成后，分别对小于6和大于等于6的部分进行快速排序，递归就好了。对 [ 5, 1, 4, 3, 2 ] 进行一趟快速排序。 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["运维"],"content":"Docker基础、Docker file 、Docker网络","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"docker概述 从开发到上线，两套环境，版本不同导致软件不可用，开发与运维有差距！部署配置环境费时费力 原：jar——-redis,mysql,jdk,项目能不能带上环境安装打包？跨平台，隔离， docker容器技术也是一种虚拟化技术 官网：https://www.docker.com/ 文档：https://docs.docker.com/ 仓库地址： https://hub.docker.com/ 镜像（image）:模板，通过这个模板来创建容器服务，可创建多个容器（最终服务或者项目运行在容器中） 容器（container）：一个或一组应用，可以启动，停止，删除，基本命令 仓库（repository）：存放镜像（公有私有），docker hub(默认) 阿里云（国内镜像加速） 安装 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:0:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"start 卸载旧版本 # 1、卸载旧版本 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2、 需要的安装包 sudo yum install -y yum-utils # 3、设置镜像仓库 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 默认是国外的 可换国内 yum makecache fast # 4、安装相关的额 sudo yum install docker-ce docker-ce-cli containerd.io # 5、启动 sudo systemctl start docker docker version # 6、测试 sudo docker run hello-World 查看镜像 docker images 阿里云镜像加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://ax7mfl6a.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"hello-world流程 sudo docker run hello-World–\u003e本机寻找镜像–No–\u003e仓库地址下载—\u003e是否找到—\u003e下载镜像到本地—\u003e使用镜像创建容器运行 docker常用命令 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:2:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"帮助命令 docker version # 显示版本信息 docker info #系统信息，镜像、容器 docker 命令 --help ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:3:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"镜像命令 docker images docker search mysql docker pull mysql docker pull mysql:5.7 #docker分层下载，节省空间 删除镜像docker rmi -f docker rmi -f 容器id docker rmi -f $(docker images -aq) #删除所有镜像 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:4:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"容器命令 拉取镜像 docker pull centos 创建容器并启动 docker run [可选参数] image # 参数设置 --name=\"name\" 容器名称，tomcat01，tomcat02 -it 交互方式运行， -d 后台运行 -p 指定荣放弃的端口 -p 8080:8080 -p ip:主机端口：容器端口 -p 主机端口：容器端口 -p 容器端口 容器端口 -P 随机指定端口 C:\\Users\\26505\u003edocker pull centos Using default tag: latest latest: Pulling from library/centos 7a0437f04f83: Pulling fs layer latest: Pulling from library/centos 7a0437f04f83: Pull complete Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1 Status: Downloaded newer image for centos:latest docker.io/library/centos:latest C:\\Users\\26505\u003edocker run -it centos /bin/bash [root@177a03668b45 /]# exit exit C:\\Users\\26505\u003edocker ps #正在运行的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bc1f05966db8 mysql \"docker-entrypoint.s…\" 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-\u003e3306/tcp mysql 741b6a4bccc2 docker/getting-started \"/docker-entrypoint.…\" 7 hours ago Up 7 hours 0.0.0.0:8080-\u003e80/tcp docker-test C:\\Users\\26505\u003edocker ps -a #历史容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 177a03668b45 centos \"/bin/bash\" 4 minutes ago Exited (0) 3 minutes ago stoic_rosalind bc1f05966db8 mysql \"docker-entrypoint.s…\" 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-\u003e3306/tcp mysql 741b6a4bccc2 docker/getting-started \"/docker-entrypoint.…\" 7 hours ago Up 7 hours 0.0.0.0:8080-\u003e80/tcp docker-test 70b02a4a1833 hello-world \"/hello\" 7 hours ago Exited (0) 7 hours ago stupefied_neumann ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:5:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"退出容器 exit #退出并停止容器 ctrl+P+Q #退出终端不停止容器 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:6:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"删除容器 rm -f docker rm 容器id #不能删除正在运行的容器 docker rm -f $(docker pa -aq) #删除全部容器 docker ps -a -q|xargs docker rm #删除全部容器(管道) ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:7:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"启动停止容器 docker start id #启动 docker restart id #重启 docker stop id #停止 docker kill id #强制停止 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:8:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"常用的其他命令 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"后台启动 docker run -d centos #问题 :docker ps 发现centos停止了 # 常见的坑，后台运行后，就必须有一个前台进程，docker发现没有应用，就自动停止了 #nginx 容器启动后，没有提供服务，就会立刻停止 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:1","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"日志命令 docker logs --help docker logs -tf --tail 10 id #查看后10条日志 docker logs -tf id #查看所有日志 docker run -d centos /bin/sh -C \"while true ;do echo tanjindong;sleep 1;done\" ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:2","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"查看容器中的进程信息 # top命令 docker top --help docker top id ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:3","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"查看镜像源数据 # inspect docker inspect id C:\\Users\\26505\u003edocker inspect 741b6a4bccc2 [ { \"Id\": \"741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3\", \"Created\": \"2021-03-21T07:20:22.6575041Z\", \"Path\": \"/docker-entrypoint.sh\", \"Args\": [ \"nginx\", \"-g\", \"daemon off;\" ], \"State\": { \"Status\": \"running\", \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 2067, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2021-03-21T07:20:26.022246Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, \"Image\": \"sha256:3ba8f2ff0727d36bccad59f6344f7f3a101bcd9c70b984aa2dd006914c496cb8\", \"ResolvConfPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/hostname\", \"HostsPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/hosts\", \"LogPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3-json.log\", \"Name\": \"/docker-test\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"MountLabel\": \"\", \"ProcessLabel\": \"\", \"AppArmorProfile\": \"\", \"ExecIDs\": [ \"4ac8b9a918d39e7560ebf5e35fad12ef83ed66cabc27035095870d4fe13ac56c\" ], \"HostConfig\": { \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": { \"Type\": \"json-file\", \"Config\": {} }, \"NetworkMode\": \"default\", \"PortBindings\": { \"80/tcp\": [ { \"HostIp\": \"\", \"HostPort\": \"8080\" } ] }, \"RestartPolicy\": { \"Name\": \"no\", \"MaximumRetryCount\": 0 }, \"AutoRemove\": false, \"VolumeDriver\": \"\", \"VolumesFrom\": null, \"CapAdd\": null, \"CapDrop\": null, \"CgroupnsMode\": \"host\", \"Dns\": [], \"DnsOptions\": [], \"DnsSearch\": [], \"ExtraHosts\": null, \"GroupAdd\": null, \"IpcMode\": \"private\", \"Cgroup\": \"\", \"Links\": null, \"OomScoreAdj\": 0, \"PidMode\": \"\", \"Privileged\": false, \"PublishAllPorts\": false, \"ReadonlyRootfs\": false, \"SecurityOpt\": null, \"UTSMode\": \"\", \"UsernsMode\": \"\", \"ShmSize\": 67108864, \"Runtime\": \"runc\", \"ConsoleSize\": [ 31, 120 ], \"Isolation\": \"\", \"CpuShares\": 0, \"Memory\": 0, \"NanoCpus\": 0, \"CgroupParent\": \"\", \"BlkioWeight\": 0, \"BlkioWeightDevice\": [], \"BlkioDeviceReadBps\": null, \"BlkioDeviceWriteBps\": null, \"BlkioDeviceReadIOps\": null, \"BlkioDeviceWriteIOps\": null, \"CpuPeriod\": 0, \"CpuQuota\": 0, \"CpuRealtimePeriod\": 0, \"CpuRealtimeRuntime\": 0, \"CpusetCpus\": \"\", \"CpusetMems\": \"\", \"Devices\": [], \"DeviceCgroupRules\": null, \"DeviceRequests\": null, \"KernelMemory\": 0, \"KernelMemoryTCP\": 0, \"MemoryReservation\": 0, \"MemorySwap\": 0, \"MemorySwappiness\": null, \"OomKillDisable\": false, \"PidsLimit\": null, \"Ulimits\": null, \"CpuCount\": 0, \"CpuPercent\": 0, \"IOMaximumIOps\": 0, \"IOMaximumBandwidth\": 0, \"MaskedPaths\": [ \"/proc/asound\", \"/proc/acpi\", \"/proc/kcore\", \"/proc/keys\", \"/proc/latency_stats\", \"/proc/timer_list\", \"/proc/timer_stats\", \"/proc/sched_debug\", \"/proc/scsi\", \"/sys/firmware\" ], \"ReadonlyPaths\": [ \"/proc/bus\", \"/proc/fs\", \"/proc/irq\", \"/proc/sys\", \"/proc/sysrq-trigger\" ] }, \"GraphDriver\": { \"Data\": { \"LowerDir\": \"/var/lib/docker/overlay2/6d343bc9ad04de2e498e78ef2f579175c692ed808c08b393d1eb997f1dd5d84b-init/diff:/var/lib/docker/overlay2/214cc931af263a16f14aeb6d585e2dbee7150a57e19e84650bfdc32734a5846f/diff:/var/lib/docker/overlay2/47fae1cab0a2404c969f4cea1cfcb6b054b1bbdea8d8c6149c21848a77c816dc/diff:/var/lib/docker/overlay2/17096a2500c8f19f644b2554a0bd01af1b469f6f3b1b0d47718f826fe6c1e01e/diff:/var/lib/docker/overlay2/bbe4a1e6f6189b486a01f819c7fc91f2c558eb60e3eda0a16629e9b40cef3937/diff:/var/lib/docker/overlay2/98581fdc9425566ddfa8a8b96d8fe61544f2140e026d1df3cbdc507d38f582cd/diff:/var/lib/docker/overlay2/66a3d69a78eff1300e49d125d6a2ad49e2e9b48f826c802ae6e654b83db3016d/diff:/var/lib/docker/overlay2/8dafe228d5bec8620615e6252f815baeb01884e592865f8edac2f7fec8317da8/diff:/var/lib/docker/overlay2/d0ca3a53296feb329ea10d4f75f54b57bed2bdf53b67a24de0a1b6d726877d85/diff\", \"MergedDir\": \"/var/l","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:4","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"进入当前正在运行的容器 docker exec -it 容器id bashshell docker ps # 方式一 进入容器之后开启一个新的终端(常用) docker exec -it id /bin/bash #方式二 进入执行的终端 docker attach 容器id 正在执行的代码。。。。。 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:5","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"从容器拷贝文件到主机 cp docker cp id:/home/test.java /home docker cp 容器id:容器目录 本机目录 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:6","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业一：部署nginx docker pull nginx #下载镜像 docker images docker run -d --name nginx-01 -p 3344:80 nginx #运行容器 curl localhost:3344 #测试 pi@raspberrypi:~ $ docker exec -it nginx-01 /bin/bash #进入容器 root@9ddb6ad99473:/# whereis nginx nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx root@9ddb6ad99473:/# cd etc/nginx/ root@9ddb6ad99473:/etc/nginx# ls conf.d fastcgi_params koi-utf koi-win mime.types modules nginx.conf scgi_params uwsgi_params win-utf pi@raspberrypi:~ $ docker stop nginx-01 #停止容器 nginx-01 pi@raspberrypi:~ $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES #每次修改nginx配置，都需要进入容器，十分麻烦，映射路径，达到修改容器配置的目的，数据卷技术！！！！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:10:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业二：部署tomcat #官方使用 docker run -it --rm tomcat:9.0 #之前都是后台，停止了之后，容器还可以查到，docker run -it --rm用完即删，一般用来测试 #下载启动 docker pull tomcat docker images docker run -d --name tomcat-01 -p 3355:8080 tomcat #运行 外部3355 but 原因：官方镜像最简化，所以找不到资源文件： docker exec -it tomcat-01 /bin/bash #进入容器 cp -r webapps.dist/* webapps ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:11:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业三：部署es+kibana # elasticsearch暴露端口十分多 # ES 十分耗内存 # 数据一般挂载在安全目录 # --net somenetwork ？网络配置 docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.11.2 docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.11.2 C:\\Users\\26505\u003ecurl localhost:9200 { \"name\" : \"2ab0292e5b49\", \"cluster_name\" : \"docker-cluster\", \"cluster_uuid\" : \"661wGGJlSRqiLH_ht2P48A\", \"version\" : { \"number\" : \"7.11.2\", \"build_flavor\" : \"default\", \"build_type\" : \"docker\", \"build_hash\" : \"3e5a16cfec50876d20ea77b075070932c6464c7d\", \"build_date\" : \"2021-03-06T05:54:38.141101Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.7.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } # 启动之后非常卡 how to 解决 docker stats 查看cpu状态 docker stats # 解决一：增加内存限制，修改配置文件， -e 环境的配置修改 docker run -d --name elasticsearch -p 9201:9200 -p 9301:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" elasticsearch:7.11.2 使用kibana连接ES： ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:12:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"可视化工具 portainer(不是最佳选择，先用) # -v /var/run/docker.sock 挂载，里面数据挂载到本机 # --privileged=true 授权，本机可访问 docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 测试访问：8088 Rancher（CI/CD） docker镜像原理 UFS 联合文件系统，分层轻量，分层下载，分层加载，多镜像共用 公共内核(bootfs) 对于一个OS，rootfs可以很小，只需要包含基本的命令、工具和程序库就可以了，因为底层直接用host的kernel，自己只需要提供rootfs就可以了，由此可见，不同版本的Linux发行版，bootfs是相同的，只是rootfs不同罢了。 bootfs引导启动非常慢，rootfs库启动非常快，所以虚拟机启动分钟级别，docker启动秒级。 分层理解： ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:13:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"如何打包一个自己的镜像：commit docker commit #提交容器 docker commit -m=\"提交描述信息\" -a=\"作者\" 容器id 目标镜像名:[tag] docker commit -a=\"jd\" -m=\"add webapps\" 7sssdvhfgs tomcat02:1.0 容器数据卷 如果数据都在容器中，容器删除之后，数据就会丢失，需求：数据可持久化， MySQL，容器删除了，MySQL数据就没了，MySQL可以保存在本地吗？ 数据共享技术，docker容器中产生的数据同步到本地， 卷技术，？目录挂载，将容器内的目录挂载在宿主机上，持久化与同步操作，容器间数据可以共享 # 方式一：使用-v挂载 docker run -d -v 主机目录:容器目录 docker run -it -v /home/ceshi:/home --name ubuntu01 ubuntu /bin/bash docker inspect 容器id docker stop 1bfb0a3ad95e #停止docker 容器 sudo nano test.txt #修改Host文件 docker start 1bfb0a3ad95e #重新启动 # 进入容器查看文件变化 pi@raspberrypi:~ $ docker exec -it 1bfb0a3ad95e /bin/bash root@1bfb0a3ad95e:/# cd /home root@1bfb0a3ad95e:/home# ls test test.b test.java test.txt root@1bfb0a3ad95e:/home# cat test/txt cat: test/txt: No such file or directory root@1bfb0a3ad95e:/home# cat test.txt yasethbitgejk nadeuioaguhno arezln # 容器内的数据依旧是同步的！！！！！！ # 通过-v挂载配置文件和资源文件，就不用进入容器修改，只用修改本地，容器自动同步 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:14:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"部署MySQL mysql数据持久化问题 docker pull mysql:5.7 #需要配置密码 -e MYSQL_ROOT_PASSWORD=my-secret-pw # docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag docker run -d -p 3310:3306 --name mysql-test -v H:\\myNotsBooks\\docker\\conf:/etc/mysql/conf.d -v H:\\myNotsBooks\\docker\\data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 链接成功： 数据挂载成功：（conf） 即使删除容器，本地的数据卷依旧没有丢失，这就达到了数据持久化 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:15:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"具名和匿名挂载 #匿名挂载 # -v 容器内路径！ docker run -d -P --name nginx-test -v /etc/nginx nginx # 查看所有卷volume的挂载情况 pi@raspberrypi:/home/ceshi $ docker run -d -P --name nginx-test -v /etc/nginx nginx 9f4ba2383cab2eedc09916c2191858b88673cc43ef85194b42eb67cb8c2bca54 pi@raspberrypi:/home/ceshi $ docker volume --help Usage: docker volume COMMAND Manage volumes Commands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumes Run 'docker volume COMMAND --help' for more information on a command. pi@raspberrypi:/home/ceshi $ docker volume ls DRIVER VOLUME NAME local 27f1cec7789cd92096fc7177238808528b7201f2b7f2628c57fc4f350bff7c09 #匿名挂载 local 28ce6884130cf729f12f33decf67c96f0bab95032c193302553cd9050f8ff7e8 # -v 的时候只写了容器内部的路径 #具名挂载 pi@raspberrypi:~ $ docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx nginx 70500d6c7b7f937a953990007fc0af3db4628df5687eead2081abdfaeb582b4f pi@raspberrypi:~ $ docker volume ls DRIVER VOLUME NAME local 27f1cec7789cd92096fc7177238808528b7201f2b7f2628c57fc4f350bff7c09 local 28ce6884130cf729f12f33decf67c96f0bab95032c193302553cd9050f8ff7e8 local jumingfs pi@raspberrypi:~ $ docker volume inspect nginx-juming [] Error: No such volume: nginx-juming pi@raspberrypi:~ $ docker volume inspect jumingfs [ { \"CreatedAt\": \"2021-03-25T11:06:02+08:00\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/jumingfs/_data\", \"Name\": \"jumingfs\", \"Options\": null, \"Scope\": \"local\" } ] 所有docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/jumingfs/_data 我们通过具名挂载可以方便找到我们的一个大卷，大多数情况下使用的是具名挂载 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:16:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"如何区分是具名挂载还是匿名挂载还是指定路径挂载 -v 容器内路径 #匿名挂载 -v 卷名:容器内路径 #具名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:17:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"扩展 #设置容器权限，对挂载数据卷有限制 docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx:ro nginx docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx:rw nginx # ro 只能通过宿主机来操作，不能通过容器内部操作 # 默认rw: 可读可写 Dockerfile:构建docker的文件 一段命令脚本 pi@raspberrypi:/home/docker-test-file-volume $ docker build -f ./dockerfile1 -t jd/centos:1.0 . #构建镜像 Sending build context to Docker daemon 2.048kB Step 1/4 : FROM ubuntu ---\u003e 3324772e8bdf Step 2/4 : VOLUME [\"volume01\",\"volume02\"] ---\u003e Running in e07670d15bd9 Removing intermediate container e07670d15bd9 ---\u003e 067080c3c46e Step 3/4 : CMD echo \"........end........\" ---\u003e Running in 0ac9ebb25a05 Removing intermediate container 0ac9ebb25a05 ---\u003e 5fa9a5e368ba Step 4/4 : CMD /bin/bash ---\u003e Running in 492dcb1825df Removing intermediate container 492dcb1825df ---\u003e e5bd1def5d82 Successfully built e5bd1def5d82 Successfully tagged jd/centos:1.0 pi@raspberrypi:/home/docker-test-file-volume $ docker images #查看镜像 REPOSITORY TAG IMAGE ID CREATED SIZE jd/centos 1.0 e5bd1def5d82 7 seconds ago 49.8MB portainer/portainer latest 9b438d60114e 6 days ago 62.4MB nginx latest 4f718772a0b3 13 days ago 103MB ubuntu latest 3324772e8bdf 5 months ago 49.8MB hello-world latest 851163c78e4a 14 months ago 4.85kB java 8 d23bdf5b1b1b 4 years ago 643MB pi@raspberrypi:/home/docker-test-file-volume $ cat dockerfile1 FROM ubuntu VOLUME [\"volume01\",\"volume02\"] #匿名挂载 CMD echo \"........end........\" CMD /bin/bash docker inspect id #查看卷挂载路径 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:18:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"多个docker同步数据 # 多个MySQL数据同步 # 启动三个容器 docker run -it --name docker01 jd/centos:1.0 docker run -it --name docker02 --volumes-from docker01 jd/centos:1.0 docker run -it --name docker03 --volumes-from docker01 jd/centos:1.0 # 进入docker01创建文件 root@450d606a17a0:/# pi@raspberrypi:/ $ docker attach 0721edbafafb root@0721edbafafb:/# ls bin dev home media opt root sbin sys usr volume01 boot etc lib mnt proc run srv tmp var volume02 root@0721edbafafb:/# cd vo bash: cd: vo: No such file or directory root@0721edbafafb:/# cd volume01 root@0721edbafafb:/volume01# ls root@0721edbafafb:/volume01# touch docker01.txt touch: setting times of 'docker01.txt': Operation not permitted root@0721edbafafb:/volume01# ls docker01.txt #进入docker02查看 pi@raspberrypi:/ $ docker attach 450d606a17a0 root@450d606a17a0:/# ls bin dev home media opt root sbin sys usr volume01 boot etc lib mnt proc run srv tmp var volume02 root@450d606a17a0:/# cd volume01 root@450d606a17a0:/volume01# ls docker01.txt docker02 volumesfrom docker01 docker03 volumesfrom docker01 如果把1删除了，2，3还在吗？？？ 发现还在，只要有一个容器使用，就依旧存在，共享备份机制，双向拷贝的概念 # 多个mysql实现数据共享 docker run -d -p 3301:3306 --name mysql01 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 docker run -d -p 3302:3306 --name mysql02 --volumes-from mysql01 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 #这个时候可以实现两个容器数据同步 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止， 但是一旦持久化挂载-v到本地，本地不会被删除！！！！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:19:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerfile 命令参数脚本 1、编写一个dockerfile文件 2、docker build 一个镜像 3、docker run 运行容器 4、docker push 发布镜像（dockerhub,阿里云镜像） 查看一下官方这么做的： FROM scratch ADD centos-8-x86_64.tar.xz / LABEL org.label-schema.schema-version=\"1.0\" org.label-schema.name=\"CentOS Base Image\" org.label-schema.vendor=\"CentOS\" org.label-schema.license=\"GPLv2\" org.label-schema.build-date=\"20201204\" CMD [\"/bin/bash\"] ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:20:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"构建过程 从上到下顺序执行，指令大写，每个指令就会创建一个新的镜像层 企业交付的标准！！！！！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:21:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerfile指令 dockerHub 80% 来自FROM scratch FROM #基础镜像，一切从这里开始构建 MAINTAINER #镜像是谁写的，姓名+邮箱 RUN #构建镜像时需要运行的命令 ADD #步骤，tomcat压缩包，添加内容 WORKDIR #镜像的工作目录 VOLUME #挂载卷 EXPOSE #指定暴露端口原来-p CMD #指定这个容器启动的时候运行的命令，只有最后一个会失效，可被替代 ENTRYPOINT #指定这个容器启动的时候运行的命令，可追加 ONBUILD #当构建一个被继承dockerfile,触发指令 COPY #类似ADD，拷贝文件到镜像 ENV #构建的时候设置环境变量 -e 自己写一个dockerfile：：：：：：：：： ＃　entos-vim-ip FROM centos MAINTAINER 金东\u003c2650523664@qq.com ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"------end-----\" CMD /bin/bash docker build -f centos-vim-ip -t mycentos:1.0 . docker images docker run -it --name mycentostest mycentos:1.0 # 现在vim 与 ifconfig命令都可以用了,官方不可用 docker history mycentos:1.0 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:22:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"CMD与ENTRYPOINT区别 FROM centos CMD [\"ls\",\"-a\"]　# 指定容器启动时运行的命令，只有最后一个生效，可被替代 H:\\myNotsBooks\\docker\\dockerfile\u003edocker run -it cmdtest -l docker: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: \"-l\": executable file not found in $PATH: unknown. # cmd的清理下，-l代替了CMD [\"ls\",\"-a\"],但是-l不是命令，所以报错 H:\\myNotsBooks\\docker\\dockerfile\u003edocker run -it cmdtest ls -al #这就对了 total 56 drwxr-xr-x 1 root root 4096 Mar 25 14:21 . drwxr-xr-x 1 root root 4096 Mar 25 14:21 .. -rwxr-xr-x 1 root root 0 Mar 25 14:21 .dockerenv lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -\u003e usr/bin drwxr-xr-x 5 root root 360 Mar 25 14:21 dev drwxr-xr-x 1 root root 4096 Mar 25 14:21 etc drwxr-xr-x 2 root root 4096 Nov 3 15:22 home lrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -\u003e usr/lib lrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -\u003e usr/lib64 drwx------ 2 root root 4096 Dec 4 17:37 lost+found drwxr-xr-x 2 root root 4096 Nov 3 15:22 media drwxr-xr-x 2 root root 4096 Nov 3 15:22 mnt drwxr-xr-x 2 root root 4096 Nov 3 15:22 opt dr-xr-xr-x 196 root root 0 Mar 25 14:21 proc dr-xr-x--- 2 root root 4096 Dec 4 17:37 root drwxr-xr-x 11 root root 4096 Dec 4 17:37 run lrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -\u003e usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 15:22 srv dr-xr-xr-x 11 root root 0 Mar 25 14:21 sys drwxrwxrwt 7 root root 4096 Dec 4 17:37 tmp drwxr-xr-x 12 root root 4096 Dec 4 17:37 usr drwxr-xr-x 20 root root 4096 Dec 4 17:37 var #ENTRYPOINT 命令可追加 FROM centos ENTRYPOINT [\"ls\",\"-a\"] docker build -f docker-entrypoint-test -t entrypointtest . docker run -it entrypointtest H:\\myNotsBooks\\docker\\dockerfile\\cmd ENTRYPOINT\u003edocker run -it entrypointtest . .dockerenv dev home lib64 media opt root sbin sys usr .. bin etc lib lost+found mnt proc run srv tmp var H:\\myNotsBooks\\docker\\dockerfile\\cmd ENTRYPOINT\u003edocker run -it entrypointtest -l #加-l不报错,加到a前面了 total 56 drwxr-xr-x 1 root root 4096 Mar 25 14:29 . drwxr-xr-x 1 root root 4096 Mar 25 14:29 .. -rwxr-xr-x 1 root root 0 Mar 25 14:29 .dockerenv lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -\u003e usr/bin drwxr-xr-x 5 root root 360 Mar 25 14:29 dev drwxr-xr-x 1 root root 4096 Mar 25 14:29 etc drwxr-xr-x 2 root root 4096 Nov 3 15:22 home lrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -\u003e usr/lib lrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -\u003e usr/lib64 drwx------ 2 root root 4096 Dec 4 17:37 lost+found drwxr-xr-x 2 root root 4096 Nov 3 15:22 media drwxr-xr-x 2 root root 4096 Nov 3 15:22 mnt drwxr-xr-x 2 root root 4096 Nov 3 15:22 opt dr-xr-xr-x 195 root root 0 Mar 25 14:29 proc dr-xr-x--- 2 root root 4096 Dec 4 17:37 root drwxr-xr-x 11 root root 4096 Dec 4 17:37 run lrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -\u003e usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 15:22 srv dr-xr-xr-x 11 root root 0 Mar 25 14:29 sys drwxrwxrwt 7 root root 4096 Dec 4 17:37 tmp drwxr-xr-x 12 root root 4096 Dec 4 17:37 usr drwxr-xr-x 20 root root 4096 Dec 4 17:37 var ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:22:1","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"实战：tomcat镜像 1、准备镜像文件：tomcat jdk 2、编写dockerfile文件 FROM centos MAINTAINER jd\u003c2650523664@qq.com\u003e COPY readme.txt /usr/local/readme.txt ADD apache-tomcat-9.0.44.tar.gz /usr/local/ ADD jdk-8u201-linux-x64.tar.gz /usr/local/ RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_201 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.44 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.44 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.44/bin/startup.sh \u0026\u0026 tail -F /usr/local/apache-tomcat-9.0.44/bin/logs/catalina.out 3、构建镜像 docker build -t mytomcat . # 构建镜像 4、启动镜像 docker run -d -p 9090:8080 --name testmytomcat -v /root/environment/tomcat-test-3-26/test:/usr/local/apache-tomcat-9.0.44/webapps/test -v /root/environment/tomcat-test-3-26/tomlogs:/usr/local/apache-tomcat-9.0.44/logs mytomcat 5、访问测试 6、发布项目（由于实现了卷挂载，所以我们就直接在本地写项目发布就可以了） jps页面 \u003chtml\u003e \u003chead\u003e\u003ctitle\u003eHello World\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e Hello World!\u003cbr/\u003e \u003c% System.out.println(\"-----------start my tomcat-----\"); %\u003e \u003c/body\u003e \u003c/html\u003e web.xml文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\" metadata-complete=\"true\"\u003e \u003c/web-app\u003e ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:23:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"发布镜像 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:24:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerHub镜像 1、注册账户：https://registry.hub.docker.com/ 2、客户端提交镜像 [root@jd tomcat-test-3-26]# docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username [root@jd tomcat-test-3-26]# docker login -u hubu8023 Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 3、发布镜像 [root@jd ~]# docker tag 5599ee6a7e53 hubu8023/mytest:1.0 [root@jd ~]# docker push hubu8023/mytest:1.0 [root@jd ~]# docker tag hello-world:latest hubu8023/myhello:2.0 #增加标签 [root@jd ~]# docker push hubu8023/myhello:2.0 # The push refers to repository [docker.io/hubu8023/myhello] f22b99068db9: Mounted from library/hello-world 2.0: digest: sha256:1b26826f602946860c279fce658f31050cff2c596583af237d971f4629b57792 size: 525 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:24:1","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"阿里云镜像 1、登录阿里云https://cr.console.aliyun.com/cn-hangzhou/instance/repositories 2、找到容器镜像服务 3、创建命名空间 4、创建容器镜像 5、浏览页面信息 登录阿里云Docker Registry $ sudo docker login --username=18871955259东 registry.cn-hangzhou.aliyuncs.com 用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在访问凭证页面修改凭证密码。 从Registry中拉取镜像 $ sudo docker pull registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] 将镜像推送到Registry $ sudo docker login --username=18871955259东 registry.cn-hangzhou.aliyuncs.com $ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] $ sudo docker push registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] 请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 小结： Docker网络 docker网络核心docker0: 两个容器之间如何访问？？？？？ docker run -d -P --name tomcat01 tomcat [root@jd ~]# docker exec -it tomcat01 ip addr 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 18: eth0@if19: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 查看容器内网IP地址，发现容器启动的时候得到一个eth0@if19 IP地址，这是docker分配的！！！ 现在能不能ping通容器？？？linux可以ping通容器内部 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:24:2","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"原理： 1、我们每启动一个docker容器，docker就会给容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0(桥接模式–evth-pair) 2、再启动一个docker容器，发现又多了一对网卡： # 容器的网卡都是成对出现的， # evth-pair就是一对虚拟设备接口，他们都是成对出现的，一端连接协议，一端彼此相连 # 正因为有这个特性，evth-pair充当一个桥梁，连接各种虚拟网络设备， 3、测试两个tomcat能不能互通： 网络模型 结论：tomcat01和tomcat02 共用一个路由器docker0, 所有的容器不指定网络，都是docker0路由的，docker会给容器分配一个默认可用IP 255.255.0.1/16 : 能用IP;255*255-0.0-255.255=255*255-1-1 255.255.0.1/24 : 能用IP;255*255-0.0-255.255=255-1-1 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:25:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"–link(基本不用) 场景：微服务或者springboot中database.url配置怎么写？？IP一直变 项目不重启，数据库IP变了，我们希望可以通过名字来访问容器 [root@jd ~]# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known # 实现tomcat03 ping tomcat02 [root@jd ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat 7dd6fe9dbe2e5732dfa53d3d2b2e6f14eb7abaccbf2771c44ae03db2dcc4faaf [root@jd ~]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.109 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.079 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.100 ms # 反向tomcat02 不能ping tomcat03 [root@jd ~]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 探究inspect: [root@jd ~]# docker network ls NETWORK ID NAME DRIVER SCOPE c592ad97632c bridge bridge local c9c57d03a4a4 host host local 85a3888c406a none null local [root@jd ~]# docker network inspect c592ad97632c #docker0网卡信息 docker inspect tomcat03 # 原理发现！！！！！！！！！！！！！！！！！！！！ # 查看tomcat03 hosts文件 docker exec -it tomcat03 cat /etc/hosts [root@jd ~]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.3 tomcat02 9dce1424d4fe #9dce1424d4fe tomcat02容器id 172.17.0.4 7dd6fe9dbe2e #7dd6fe9dbe2e tomcat03本机容器id 容器02： [root@jd ~]# docker exec -it tomcat02 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.3 9dce1424d4fe 只要在这里增加容器03的网络配置就可以实现互通， 但是现在docker已经不建议使用–link技术了，自定义网络，不用docker0, docker0问题：他不支持容器名链接访问！ ！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:26:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"自定义网络 # 查看所有网络 [root@jd ~]# docker network ls NETWORK ID NAME DRIVER SCOPE c592ad97632c bridge bridge local c9c57d03a4a4 host host local 85a3888c406a none null local 网络模式： bridge : 桥接模式（默认），自己创建也是使用bridge模式 none: 不配置网络， host: 和Linux主机共享网络 container: 容器网络连通（用的少，局限性很大） 测试 # 原来启动容器，默认--net bridge 二这个就是我们的docker0 docker run -d -P --name tomcat01 --net bridge tomcat docker run -d -P --name tomcat01 tomcat # docker0特点： 默认。域名不能访问，--link可以打通 # 因此我们需要自定义一个网络 [root@jd ~]# docker network --help Usage: docker network COMMAND Manage networks Commands: connect Connect a container to a network create Create a network disconnect Disconnect a container from a network inspect Display detailed information on one or more networks ls List networks prune Remove all unused networks rm Remove one or more networks docker network create --help # --subnet子网地址 192.168.0.2--------192.168.255.255 # --gateway 网关，路由器地址 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mytestnet docker network ls [root@jd ~]# docker network inspect mytestnet [ { \"Name\": \"mytestnet\", \"Id\": \"779b38cb0d482db5eb7156e0ba327da1740a86d71106438f27f22f6ceee2e82e\", \"Created\": \"2021-03-27T14:17:45.675341638+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": {}, \"Options\": {}, \"Labels\": {} } ] 用自己创建的网络模式创建容器 [root@jd ~]# docker run -d -P --name tomcat-net-01 --net mytestnet tomcat 56554c258e04f1ed4c300e26d337ca39c35087aa4d92f782e0a2b87138484b99 [root@jd ~]# docker run -d -P --name tomcat-net-02 --net mytestnet tomcat 1ccb18d09020622d029b4373c6d09f40259b5944ee27269ee0195ad8bd94269 [root@jd ~]# docker network inspect mytestnet [ { \"Name\": \"mytestnet\", \"Id\": \"779b38cb0d482db5eb7156e0ba327da1740a86d71106438f27f22f6ceee2e82e\", \"Created\": \"2021-03-27T14:17:45.675341638+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"1ccb18d09020622d029b4373c6d09f40259b5944ee27269ee0195ad8bd942694\": { \"Name\": \"tomcat-net-02\", \"EndpointID\": \"fa949ca6e5a71662a6656b83ed483d812972e815e5f1fc8d1c4c1f33e714cadb\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" }, \"56554c258e04f1ed4c300e26d337ca39c35087aa4d92f782e0a2b87138484b99\": { \"Name\": \"tomcat-net-01\", \"EndpointID\": \"5e2022a9c3c27a9d225d7b2d54f2ab16196fff5cfa9aa3f9a28be4e4d2a8f649\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": {} } ] #此时tomcat-net-01与02就处于我们自己创建的网络模式中 好处： [root@jd ~]# docker exec -it tomcat-net-01 ping tomcat-net-02 PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data. 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=1 ttl=64 time=0.125 ms 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=2 ttl=64 time=0.085 ms 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=3 ttl=64 time=0.107 ms [root@jd ~]# docker exec -it tomcat-net-02 ping tomcat-net-01 PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data. 64 bytes from tomcat-net-01.mytestnet (192.168.0.2): icmp_seq=1 ttl=64 time=0.108 ms 64 bytes from tomcat-net-01.mytestnet (192.168.0.2): icmp_seq=2 ttl=64 time=0.098 ms # 可以直接通过容器名称互通，不用使用--link 自定义网络已经维护好了对应关系，推荐使用自定义网络 redis集群，mysql集群使用不同的网络，保证集群的隔离性与数据安全 ，网络互相隔离 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:27:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"网络互通 测试 [root@jd ~]# docker run -d -P --name tomcat01 tomcat 999d0f449539783be990b3bb36f5036a4dc4419a8cfba1ffe9907e0bc08352d6 [root@jd ~]# docker run -d -P --name tomcat02 tomcat 5b6d4843a2fe7aede6cc377f4825dfb014bf035333ecf16d739576dc1a9b3237 [root@jd ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 5b6d4843a2fe tomcat \"catalina.sh run\" 6 seconds ago Up 5 seconds 0.0.0.0:49160-\u003e8080/tcp tomcat02 999d0f449539 tomcat \"catalina.sh run\" 16 seconds ago Up 16 seconds 0.0.0.0:49159-\u003e8080/tcp tomcat01 1ccb18d09020 tomcat \"catalina.sh run\" 15 minutes ago Up 15 minutes 0.0.0.0:49158-\u003e8080/tcp tomcat-net-02 56554c258e04 tomcat \"catalina.sh run\" 15 minutes ago Up 15 minutes 0.0.0.0:49157-\u003e8080/tcp tomcat-net-01 [root@jd ~]# docker network connect mytestnet tomcat01 [root@jd ~]# docker network inspect mytestnet 连通之后就是将tomcat01放在了mytestnet网络下 其实就是一个容器两个IP [root@jd ~]# docker exec -it tomcat-net-01 ping tomcat01 PING tomcat01 (192.168.0.4) 56(84) bytes of data. 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=1 ttl=64 time=0.126 ms 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=2 ttl=64 time=0.083 ms 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=3 ttl=64 time=0.084 ms tomcat02依旧不同 加入需要跨网络操作容器，就需要使用dockers network connect mytestnet tomcat-sjvbk ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:28:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"部署redis集群 分片+高可用+负载均衡 # 创建网络 docker network create redis-net --subnet 172.38.0.0/16 docker network ls docker network inspect redis-net # 通过脚本创建6个redis for port in $(seq 1 6); \\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003e/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done for port in $(seq 1 6); \\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003e/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done # 创建6个redis节点 docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\ -v /mydata/redis/node-1/data:/data \\ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis-net --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6373:6379 -p 16373:16379 --name redis-3 \\ -v /mydata/redis/node-3/data:/data \\ -v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis-net --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf # 通过脚本一次启动6个redis容器 docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \\ -v /mydata/redis/node-${port}/data:/data \\ -v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf done docker ps # 交互模式进节点 docker exec -it redis-1 /bin/sh # 创建redis集群 redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 \\ 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 \\ 172.38.0.16:6379 --cluster-replicas 1 # 输入yes 测试 redis-cli -c cluster info cluster nodes /data # redis-cli -c 127.0.0.1:6379\u003e cluster info cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:7 cluster_my_epoch:1 cluster_stats_messages_ping_sent:866 cluster_stats_messages_pong_sent:847 cluster_stats_messages_fail_sent:5 cluster_stats_messages_auth-ack_sent:1 cluster_stats_messages_update_sent:1 cluster_stats_messages_sent:1720 cluster_stats_messages_ping_received:842 cluster_stats_messages_pong_received:833 cluster_stats_messages_meet_received:5 cluster_stats_messages_fail_received:1 cluster_stats_messages_auth-req_received:1 cluster_stats_messages_received:1682 127.0.0.1:6379\u003e cluster nodes 9d043104052b4904cb3c6587ae09a72691953b02 172.38.0.13:6379@16379 slave #从d6411ab58802fd1408e66c304760d1f31688321b 0 1616830729000 7 connected 62ae6caadcf0a38c0d5c3a26c1364026a926b7e9 172.38.0.15:6379@16379 slave #从69169db2f42fb6d9015a23b7fe7cb13a8e6d62b1 0 1616830730548 5 connected 53634e5afa3791069ca0b97183be5bd1d4496bb4 172.38.0.16:6379@16379 slave #从344c681321b27f5b53f59674fb21876889a92020 0 1616830730548 6 connected 344c681321b27f5b53f59674fb21876889a92020 172.38.0.12:6379@16379 master - 0 1616830730648 2 connected 5461-10922 #主 d6411ab58802fd1408e66c304760d1f31688321b 172.38.0.14:6379@16379 master - 0 1616830729000 7 connected 10923-16383 #主 69169db2f42fb6d9015a23b7fe7cb13a8e6d62b1 172.38.0.11:6379@16379 myself,master - 0 1616830730000 1 connected 0-5460 #主 127.0.0.1:6379\u003e get a -\u003e Redirected to slot [15495] located at 172.38.0.14:6379 \"b\" springboot项目部署 1、构建项目 2、打包应用 3、编写dockerfile FROM java:8 COPY *.jar /app/ CMD [\"----server.port=8080------\"] EXPOSE 9980 ENTRYPOINT [\"java\",\"-jar\",\"/app/posttimer.jar\"] 4、构建镜像 docker build -t posttimer . [root@jd posttimer]# docker build -t posttimer . Sending build context to Docker daemon 56.69MB Step 1/5 : FROM java:8 8: Pulling from library/java 5040bd298390: Pull comple","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:29:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"安装Jenkins 预先安装docker、docker-compose环境 拉取Jenkins镜像，运行容器： docker run --name myjenkins -p 9980:8080 -p 50000:50000 -v /var/jenkins_home jenkins：2.60.3 映射端口为本地9980映射内部8080端口，50000映射50000端口。 学习Jenkins的DockerFile： FROM openjdk:8-jdk RUN apt-get update \u0026\u0026 apt-get install -y git curl \u0026\u0026 rm -rf /var/lib/apt/lists/* ARG user=jenkins ARG group=jenkins ARG uid=1000 ARG gid=1000 ARG http_port=8080 ARG agent_port=50000 ENV JENKINS_HOME /var/jenkins_home ENV JENKINS_SLAVE_AGENT_PORT ${agent_port} # Jenkins is run with user `jenkins`, uid = 1000 # If you bind mount a volume from the host or a data container, # ensure you use the same uid RUN groupadd -g ${gid} ${group} \\ \u0026\u0026 useradd -d \"$JENKINS_HOME\" -u ${uid} -g ${gid} -m -s /bin/bash ${user} # Jenkins home directory is a volume, so configuration and build history # can be persisted and survive image upgrades VOLUME /var/jenkins_home # `/usr/share/jenkins/ref/` contains all reference configuration we want # to set on a fresh new installation. Use it to bundle additional plugins # or config file with your custom jenkins Docker image. RUN mkdir -p /usr/share/jenkins/ref/init.groovy.d ENV TINI_VERSION 0.14.0 ENV TINI_SHA 6c41ec7d33e857d4779f14d9c74924cab0c7973485d2972419a3b7c7620ff5fd # Use tini as subreaper in Docker container to adopt zombie processes RUN curl -fsSL https://github.com/krallin/tini/releases/download/v${TINI_VERSION}/tini-static-amd64 -o /bin/tini \u0026\u0026 chmod +x /bin/tini \\ \u0026\u0026 echo \"$TINI_SHA/bin/tini\" | sha256sum -c - COPY init.groovy /usr/share/jenkins/ref/init.groovy.d/tcp-slave-agent-port.groovy # jenkins version being bundled in this docker image ARG JENKINS_VERSION ENV JENKINS_VERSION ${JENKINS_VERSION:-2.60.3} # jenkins.war checksum, download will be validated using it ARG JENKINS_SHA=2d71b8f87c8417f9303a73d52901a59678ee6c0eefcf7325efed6035ff39372a # Can be used to customize where jenkins.war get downloaded from ARG JENKINS_URL=https://repo.jenkins-ci.org/public/org/jenkins-ci/main/jenkins-war/${JENKINS_VERSION}/jenkins-war-${JENKINS_VERSION}.war # could use ADD but this one does not check Last-Modified header neither does it allow to control checksum # see https://github.com/docker/docker/issues/8331 RUN curl -fsSL ${JENKINS_URL} -o /usr/share/jenkins/jenkins.war \\ \u0026\u0026 echo \"${JENKINS_SHA}/usr/share/jenkins/jenkins.war\" | sha256sum -c - ENV JENKINS_UC https://updates.jenkins.io ENV JENKINS_UC_EXPERIMENTAL=https://updates.jenkins.io/experimental RUN chown -R ${user} \"$JENKINS_HOME\" /usr/share/jenkins/ref # for main web interface: EXPOSE ${http_port} # will be used by attached slave agents: EXPOSE ${agent_port} ENV COPY_REFERENCE_FILE_LOG $JENKINS_HOME/copy_reference_file.log USER ${user} COPY jenkins-support /usr/local/bin/jenkins-support COPY jenkins.sh /usr/local/bin/jenkins.sh ENTRYPOINT [\"/bin/tini\", \"--\", \"/usr/local/bin/jenkins.sh\"] # from a derived Dockerfile, can use `RUN plugins.sh active.txt` to setup /usr/share/jenkins/ref/plugins from a support bundle COPY plugins.sh /usr/local/bin/plugins.sh COPY install-plugins.sh /usr/local/bin/install-plugins.sh ","date":"2021-04-06","objectID":"/jenkins%E7%AC%94%E8%AE%B0/:0:0","tags":["jenkins"],"title":"jenkins安装","uri":"/jenkins%E7%AC%94%E8%AE%B0/"},{"categories":["运维"],"content":"初始化 初始化过程中会提示出密码： ************************************************************* ************************************************************* ************************************************************* Jenkins initial setup is required. An admin user has been created and a password generated. Please use the following password to proceed to installation: a8e55644a46a468497388c8f771e9923 This may also be found at: /var/jenkins_home/secrets/initialAdminPassword 如果-d后台运行，那么前台不会出现日志，此时，密码会记录再日志中，访问Jenkins：localhost:9980，发现密码提示： C:\\Users\\26505\u003edocker exec -it myjenkins /bin/bash jenkins@22ef3b5b9610:/$ cat /var/jenkins_home/secrets/initialAdminPassword a8e55644a46a468497388c8f771e9923 然后输入密码，进入配置：下载插件过程中不下载任何插件，进入配置超级管理员用户密码： http://updates.jenkins-ci.org/update-center.json ","date":"2021-04-06","objectID":"/jenkins%E7%AC%94%E8%AE%B0/:1:0","tags":["jenkins"],"title":"jenkins安装","uri":"/jenkins%E7%AC%94%E8%AE%B0/"},{"categories":["运维"],"content":"EditPreview 《Jenkins持续集成入门到精通》 1 、持续集成及Jenkins介绍 2 、Jenkins安装和持续集成环境配置 3 、Jenkins构建Maven项目 4 、Jenkins+Docker+SpringCloud微服务持续集成 5 、基于Kubernetes/K8S构建Jenkins微服务持续集成平台 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:0:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"1 、持续集成及Jenkins介绍 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"软件开发生命周期 软件开发生命周期又叫做SDLC（Software Development Life Cycle），它是集合了计划、开发、测试 和部署过程的集合。如下图所示 ： 需求分析 这是生命周期的第一阶段，根据项目需求，团队执行一个可行性计划的分析。项目需求可能是公司内部 或者客户提出的。这阶段主要是对信息的收集，也有可能是对现有项目的改善和重新做一个新的项目。 还要分析项目的预算多长，可以从哪方面受益及布局，这也是项目创建的目标。 设计 第二阶段就是设计阶段，系统架构和满意状态（就是要做成什么样子，有什么功能），和创建一个项目 计划。计划可以使用图表，布局设计或者文者的方式呈现。 实现 优势 劣势 简单易用和理解 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。 当前一阶段完成后，您只需要 去关注后续阶段。 由于开发模型是线性的，用户只有等到整个过程的末期才能见 到开发成果，从而增加了开发风险。 为项目提供了按阶段划分的检 查节点 瀑布模型的突出缺点是不适应用户需求的变化。 第三阶段就是实现阶段，项目经理创建和分配工作给开者，开发者根据任务和在设计阶段定义的目标进 行开发代码。依据项目的大小和复杂程度，可以需要数月或更长时间才能完成。 测试 测试人员进行代码测试 ，包括功能测试、代码测试、压力测试等。 进化 最后进阶段就是对产品不断的进化改进和维护阶段，根据用户的使用情况，可能需要对某功能进行修 改，bug修复，功能增加等。 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"软件开发瀑布模型 瀑布模型是最著名和最常使用的软件开发模型。瀑布模型就是一系列的软件开发过程。它是由制造业繁 衍出来的。一个高度化的结构流程在一个方向上流动，有点像生产线一样。在瀑布模型创建之初，没有 其它开发的模型，有很多东西全靠开发人员去猜测，去开发。这样的模型仅适用于那些简单的软件开 发， 但是已经不适合现在的开发了。 下图对软件开发模型的一个阐述。 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"软件的敏捷开发 什么是敏捷开发？ 敏捷开发（Agile Development） 的核心是迭代开发（Iterative Development） 与 增量开发 （Incremental Development） 。 ===何为迭代开发？=== 对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次\"大 开发\"；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次\"大开发\"变成多次\"小开 发\"，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。 举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而 是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨 道。然后，开发了中型火箭 Falcon 9，九年中发射了 70 次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。 ===何为增量开发？=== 软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。 举例来说，房产公司开发一个 10 栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一 号楼，第二个迭代交付二号楼……每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好 10 栋楼的地 基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶…… 敏捷开发如何迭代？ 虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按 照软件工程的方法论，进行正规的流程管理。 敏捷开发有什么好处？ ==早期交付== 敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照 传统的\"瀑布开发模式\"，先挖 10 栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完 成后开始，可能需要两年才能一次性交付 10 栋楼。也就是说，如果不考虑预售，该项目必须等到两年后 才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后 面每个月都会有现金流，资金压力就大大减轻了。 ==降低风险=== 敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比 较小： 10 栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后 面 9 栋楼？ ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"什么是持续集成 持续集成（ Continuous integration ， 简称 CI ）指的是，频繁地（一天多次）将代码集成到主干。 持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干 之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。 通过持续集成， 团队可以快速的从一个功能到另一个功能，简而言之，敏捷软件开发很大一部分都要归 功于持续集成。 === 持续集成的流程=== 根据持续集成的设计，代码从提交到生产，整个过程有以下几步。 提交 流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交 （commit）。 测试（第一轮） 代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。 构建 通过第一轮测试，代码就可以合并进主干，就算可以交付了。 交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实 际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。 测试（第二轮） 构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时 构建步骤也要移到第一轮测试前面。 部署 过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。 回滚 一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指 向上一个版本的目录。 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成的组成要素 一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、 测试统计等都是自动完成 的， 无需人工干预。 一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般 使用SVN或Git。 一个持续集成服务器， Jenkins 就是一个配置简单和使用方便的持续集成服务器。 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成的好处 1 、降低风险，由于持续集成不断去构建，编译和测试，可以很早期发现问题，所以修复的代价就少； 2 、对系统健康持续检查，减少发布风险带来的问题； 3 、减少重复性工作； 4 、持续部署，提供可部署单元包； 5 、持续交付可供使用的版本； 6 、增强团队信心； ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins介绍 Jenkins 是一款流行的开源持续集成（Continuous Integration）工具，广泛用于项目开发，具有自动 化构建、测试和部署等功能。官网： http://jenkins-ci.org/。 Jenkins的特征： 开源的Java语言开发持续集成工具，支持持续集成，持续部署。 易于安装部署配置：可通过yum安装,或下载war包以及通过docker容器等快速实现安装部署，可 方便web界面配置管理。 消息通知及测试报告：集成RSS/E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知，生 成JUnit/TestNG测试报告。 名称 IP地址 安装的软件 代码托管服务 器 192.168.66.100 Gitlab-12.4. 持续集成服务 器 192.168.66. Jenkins-2.190.3，JDK1.8，Maven3.6.2，Git， SonarQube 应用测试服务 器 192.168.66.102 JDK1.8，Tomcat8. 分布式构建：支持Jenkins能够让多台计算机一起构建/测试。 文件识别：Jenkins能够跟踪哪次构建生成哪些jar，哪次构建使用哪个版本的jar等。 丰富的插件支持：支持扩展插件，你可以开发适合自己团队使用的工具，如git，svn，maven， docker等。 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"2 、Jenkins安装和持续集成环境配置 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成流程说明 1 ）首先，开发人员每天进行代码提交，提交到Git仓库 2 ）然后，Jenkins作为持续集成工具，使用Git工具到Git仓库拉取代码到集成服务器，再配合JDK， Maven等软件完成代码编译，代码测试与审查，测试，打包等工作，在这个过程中每一步出错，都重新 再执行一次整个流程。 3 ）最后，Jenkins把生成的jar或war包分发到测试服务器或者生产服务器，测试人员或用户就可以访问 应用。 服务器列表 本课程虚拟机统一采用CentOS7。 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Gitlab代码托管服务器安装 Gitlab简介 官网： https://about.gitlab.com/ GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的 web服务。 GitLab和GitHub一样属于第三方基于Git开发的作品，免费且开源（基于MIT协议），与Github类似， 可以注册用户，任意提交你的代码，添加SSHKey等等。不同的是，GitLab是可以部署到自己的服务器 上，数据库等一切信息都掌握在自己手上，适合团队内部协作开发，你总不可能把团队内部的智慧总放 在别人的服务器上吧？简单来说可把GitLab看作个人版的GitHub。 Gitlab安装 安装相关依赖 yum -y install policycoreutils openssh-server openssh-clients postfix 启动ssh服务\u0026设置为开机启动 systemctl enable sshd \u0026\u0026 sudo systemctl start sshd 设置postfix开机自启，并启动，postfix支持gitlab发信功能 systemctl enable postfix \u0026\u0026 systemctl start postfix 开放ssh以及http服务，然后重新加载防火墙列表 firewall-cmd –add-service=ssh –permanent firewall-cmd –add-service=http –permanent firewall-cmd –reload 如果关闭防火墙就不需要做以上配置 下载gitlab包，并且安装 在线下载安装包： wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6/gitlab-ce-12.4.2-ce.0.el6.x 86_64.rpm 安装： rpm -i gitlab-ce-12.4.2-ce.0.el6.x86_64.rpm 修改gitlab配置 vi /etc/gitlab/gitlab.rb 修改gitlab访问地址和端口，默认为 80 ，我们改为 82 external_url ‘http://192.168.66.100:82’ nginx[’listen_port’] = 82 重载配置及启动gitlab gitlab-ctl reconfigure gitlab-ctl restart 把端口添加到防火墙 firewall-cmd –zone=public –add-port=82/tcp –permanent firewall-cmd –reload 启动成功后，看到以下修改管理员root密码的页面，修改密码后，然后登录即可 Gitlab添加组、创建用户、创建项目 1 ）创建组 使用管理员 root 创建组，一个组里面可以有多个项目分支，可以将开发添加到组里面进行设置权限， 不同的组就是公司不同的开发项目或者服务模块，不同的组添加不同的开发即可实现对开发设置权限的 管理 2 ）创建用户 创建用户的时候，可以选择Regular或Admin类型。 创建完用户后，立即修改密码 3 ）将用户添加到组中 选择某个用户组，进行Members管理组的成员 Gitlab用户在组里面有 5 种不同权限： Guest：可以创建issue、发表评论，不能读写版本库 Reporter：可以克隆代码，不能提交，QA、PM 可以赋予这个权限 Developer：可以克隆代码、开发、提交、push，普通开发可以赋予这个权限 Maintainer：可以创建项目、添加tag、保护分支、添加项目成员、编辑项目，核心开发可以赋予这个 权限 Owner：可以设置项目访问权限 - Visibility Level、删除项目、迁移项目、管理组成员，开发组组 长可以赋予这个权限 4 ）在用户组中创建项目 以刚才创建的新用户身份登录到Gitlab，然后在用户组中创建新的项目 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"源码上传到Gitlab仓库 下面来到IDEA开发工具，我们已经准备好一个简单的Web应用准备到集成部署。 我们要把源码上传到Gitlab的项目仓库中。 1 ）项目结构说明 我们建立了一个非常简单的web应用，只有一个index.jsp页面，如果部署好，可以访问该页面就成功 啦！ 2 ）开启版本控制 2 ）提交代码到本地仓库 先Add到缓存区 再Commit到本地仓库 3 ）推送到Gitlab项目仓库中 这时都Gitlab的项目中拷贝url地址 输入gitlab的用户名和密码，然后就可以把代码推送到远程仓库啦 刷新gitlab项目 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(1)-Jenkins安装 1 ）安装JDK Jenkins需要依赖JDK，所以先安装JDK1. yum install java-1.8.0-openjdk* -y 安装目录为：/usr/lib/jvm 2 ）获取jenkins安装包 下载页面：https://jenkins.io/zh/download/ 安装文件：jenkins-2.190.3-1.1.noarch.rpm 3 ）把安装包上传到192.168.66.101服务器，进行安装 rpm -ivh jenkins-2.190.3-1.1.noarch.rpm 4 ）修改Jenkins配置 vi /etc/syscofig/jenkins 修改内容如下： JENKINS_USER=“root” JENKINS_PORT=“8888” 5 ）启动Jenkins systemctl start jenkins 6 ）打开浏览器访问 http://192.168.66.101: 注意：本服务器把防火墙关闭了，如果开启防火墙，需要在防火墙添加端口 7 ）获取并输入admin账户密码 cat /var/lib/jenkins/secrets/initialAdminPassword 8 ）跳过插件安装 因为Jenkins插件需要连接默认官网下载，速度非常慢，而且经过会失败，所以我们暂时先跳过插件安 装 9 ）添加一个管理员账户，并进入Jenkins后台 保存并完成 开始使用Jenkins ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(2)-Jenkins插件管理 Jenkins本身不提供很多功能，我们可以通过使用插件来满足我们的使用。例如从Gitlab拉取代码，使用 Maven构建项目等功能需要依靠插件完成。接下来演示如何下载插件。 修改Jenkins插件下载地址 Jenkins国外官方插件地址下载速度非常慢，所以可以修改为国内插件地址： Jenkins-\u003eManage Jenkins-\u003eManage Plugins，点击Available 这样做是为了把Jenkins官方的插件列表下载到本地，接着修改地址文件，替换为国内插件地址 cd /var/lib/jenkins/updates sed -i ’s/http://updates.jenkins- ci.org/download/https://mirrors.tuna.tsinghua.edu.cn/jenkins/g’ default.json \u0026\u0026 sed -i ’s/http://www.google.com/https://www.baidu.com/g’ default.json 最后，Manage Plugins点击Advanced，把Update Site改为国内插件下载地址 https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json Sumbit后，在浏览器输入： http://192.168.66.101:8888/restart ，重启Jenkins。 下载中文汉化插件 Jenkins-\u003eManage Jenkins-\u003eManage Plugins，点击Available，搜索\"Chinese\" 完成后如下图： 重启Jenkins后，就看到Jenkins汉化了！（PS：但可能部分菜单汉化会失败） ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(3)-Jenkins用户权限管理 我们可以利用Role-based Authorization Strategy 插件来管理Jenkins用户权限 安装Role-based Authorization Strategy插件 开启权限全局安全配置 授权策略切换为\"Role-Based Strategy\"，保存 创建角色 在系统管理页面进入 Manage and Assign Roles 点击\"Manage Roles\" Global roles（全局角色）：管理员等高级用户可以创建基于全局的角色 Project roles（项目角色）： 针对某个或者某些项目的角色 Slave roles（奴隶角色）：节点相关的权限 我们添加以下三个角色： baseRole：该角色为全局角色。这个角色需要绑定Overall下面的Read权限，是为了给所有用户绑 定最基本的Jenkins访问权限。注意：如果不给后续用户绑定这个角色，会报错误：用户名 is missing the Overall/Read permission role1：该角色为项目角色。使用正则表达式绑定\"itcast.\"，意思是只能操作itcast开头的项目。 role2：该角色也为项目角色。绑定\"itheima.\"，意思是只能操作itheima开头的项目。 保存。 创建用户 在系统管理页面进入 Manage Users 分别创建两个用户：jack和eric 给用户分配角色 系统管理页面进入Manage and Assign Roles，点击Assign Roles 绑定规则如下： eric用户分别绑定baseRole和role1角色 jack用户分别绑定baseRole和role2角色 保存。 创建项目测试权限 以itcast管理员账户创建两个项目，分别为itcast01和itheima01 结果为： eric用户登录，只能看到itcast01项目 jack用户登录，只能看到itheima01项目 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(4)-Jenkins凭证管理 凭据可以用来存储需要密文保护的数据库密码、Gitlab密码信息、Docker私有仓库密码等，以便 Jenkins可以和这些第三方的应用进行交互。 安装Credentials Binding插件 要在Jenkins使用凭证管理功能，需要安装Credentials Binding插件 安装插件后，左边多了\"凭证\"菜单，在这里管理所有凭证 可以添加的凭证有 5 种： Username with password：用户名和密码 SSH Username with private key： 使用SSH用户和密钥 Secret file：需要保密的文本文件，使用时Jenkins会将文件复制到一个临时目录中，再将文件路径 设置到一个变量中，等构建结束后，所复制的Secret file就会被删除。 Secret text：需要保存的一个加密的文本串，如钉钉机器人或Github的api token Certificate：通过上传证书文件的方式 常用的凭证类型有：Username with password（用户密码）和SSH Username with private key（SSH 密钥） 接下来以使用Git工具到Gitlab拉取项目源码为例，演示Jenkins的如何管理Gitlab的凭证。 安装Git插件和Git工具 为了让Jenkins支持从Gitlab拉取源码，需要安装Git插件以及在CentOS7上安装Git工具。 Git插件安装： CentOS7上安装Git工具： yum install git -y 安装 git –version 安装后查看版本 用户密码类型 1 ）创建凭证 Jenkins-\u003e凭证-\u003e系统-\u003e全局凭证-\u003e添加凭证 选择\"Username with password\"，输入Gitlab的用户名和密码，点击\"确定\"。 2 ）测试凭证是否可用 创建一个FreeStyle项目：新建Item-\u003eFreeStyle Project-\u003e确定 找到\"源码管理\"-\u003e“Git”，在Repository URL复制Gitlab中的项目URL 这时会报错说无法连接仓库！在Credentials选择刚刚添加的凭证就不报错啦 保存配置后，点击构建”Build Now“ 开始构建项目 查看/var/lib/jenkins/workspace/目录，发现已经从Gitlab成功拉取了代码到Jenkins中。 SSH密钥类型 SSH免密登录示意图 1 ）使用root用户生成公钥和私钥 ssh-keygen -t rsa 在/root/.ssh/目录保存了公钥和使用 id_rsa：私钥文件 id_rsa.pub：公钥文件 2 ）把生成的公钥放在Gitlab中 以root账户登录-\u003e点击头像-\u003eSettings-\u003eSSH Keys 复制刚才id_rsa.pub文件的内容到这里，点击\"Add Key\" 3 ）在Jenkins中添加凭证，配置私钥 在Jenkins添加一个新的凭证，类型为\"SSH Username with private key\"，把刚才生成私有文件内容复 制过来 4 ）测试凭证是否可用 新建\"test02\"项目-\u003e源码管理-\u003eGit，这次要使用Gitlab的SSH连接，并且选择SSH凭证 同样尝试构建项目，如果代码可以正常拉取，代表凭证配置成功！ ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:7","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(5)-Maven安装和配置 在Jenkins集成服务器上，我们需要安装Maven来编译和打包项目。 安装Maven 先上传Maven软件到192.168.66.101 tar -xzf apache-maven-3.6.2-bin.tar.gz 解压 mkdir -p /opt/maven 创建目录 mv apache-maven-3.6.2/* /opt/maven 移动文件 配置环境变量 vi /etc/profile source /etc/profile 配置生效 mvn -v 查找Maven版本 全局工具配置关联JDK和Maven Jenkins-\u003eGlobal Tool Configuration-\u003eJDK-\u003e新增JDK，配置如下： Jenkins-\u003eGlobal Tool Configuration-\u003eMaven-\u003e新增Maven，配置如下： export JAVA_HOME=/usr/lib/jvm/java- 1. 8. 0 - openjdk export MAVEN_HOME=/opt/maven export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin 添加Jenkins全局变量 Manage Jenkins-\u003eConfigure System-\u003eGlobal Properties ，添加三个全局变量 JAVA_HOME、M2_HOME、PATH+EXTRA 修改Maven的settings.xml mkdir /root/repo 创建本地仓库目录 vi /opt/maven/conf/settings.xml 本地仓库改为：/root/repo/ 添加阿里云私服地址： alimaven aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ central 测试Maven是否配置成功 使用之前的gitlab密码测试项目，修改配置 构建-\u003e增加构建步骤-\u003eExecute Shell 输入 mvn clean package 再次构建，如果可以把项目打成war包，代表maven环境配置成功啦！ ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:8","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(6)-Tomcat安装和配置 安装Tomcat8.5 把Tomcat压缩包上传到192.168.66.102服务器 yum install java-1.8.0-openjdk* -y 安装JDK（已完成） tar -xzf apache-tomcat-8.5.47.tar.gz 解压 mkdir -p /opt/tomcat 创建目录 mv /root/apache-tomcat-8.5.47/* /opt/tomcat 移动文件 /opt/tomcat/bin/startup.sh 启动tomcat 注意：服务器已经关闭了防火墙，所以可以直接访问Tomcat啦 地址为：http://192.168.66.102/8080 配置Tomcat用户角色权限 默认情况下Tomcat是没有配置用户角色权限的 但是，后续Jenkins部署项目到Tomcat服务器，需要用到Tomcat的用户，所以修改tomcat以下配置， 添加用户及权限 vi /opt/tomcat/conf/tomcat-users.xml 内容如下： 用户和密码都是：tomcat 注意：为了能够刚才配置的用户登录到Tomcat，还需要修改以下配置 vi /opt/tomcat/webapps/manager/META-INF/context.xml 把上面这行注释掉即可！ 重启Tomcat，访问测试 /opt/tomcat/bin/shutdown.sh 停止 /opt/tomcat/bin/startup.sh 启动 访问： http://192.168.66.102:8080/manager/html ，输入tomcat和tomcat，看到以下页面代表成功 啦 \u003ctomcat-users\u003e \u003crole rolename=\"tomcat\"/\u003e \u003crole rolename=\"role 1 \"/\u003e \u003crole rolename=\"manager-script\"/\u003e \u003crole rolename=\"manager-gui\"/\u003e \u003crole rolename=\"manager-status\"/\u003e \u003crole rolename=\"admin-gui\"/\u003e \u003crole rolename=\"admin-script\"/\u003e \u003cuser username=\"tomcat\" password=\"tomcat\" roles=\"manager-gui,manager- script,tomcat,admin-gui,admin-script\"/\u003e \u003c/tomcat-users\u003e \u003c!– \u003cValve className=\"org.apache.catalina.valves.RemoteAddrValve\" allow=\" 127 \\.\\d+\\.\\d+\\.\\d+|:: 1 | 0 : 0 : 0 : 0 : 0 : 0 : 0 : 1 \" /\u003e -\u003e ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:9","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"3 、Jenkins构建Maven项目 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建类型(1)-Jenkins构建的项目类型介绍 Jenkins中自动构建项目的类型有很多，常用的有以下三种： 自由风格软件项目（FreeStyle Project） Maven项目（Maven Project） 流水线项目（Pipeline Project） 每种类型的构建其实都可以完成一样的构建过程与结果，只是在操作方式、灵活度等方面有所区别，在 实际开发中可以根据自己的需求和习惯来选择。（PS：个人推荐使用流水线类型，因为灵活度非常高） ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建类型(2)-自由风格项目构建 下面演示创建一个自由风格项目来完成项目的集成过程： 拉取代码-\u003e编译-\u003e打包-\u003e部署 拉取代码 1 ）创建项目 2 ）配置源码管理，从gitlab拉取代码 编译打包 构建-\u003e添加构建步骤-\u003eExecutor Shell 部署 把项目部署到远程的Tomcat里面 1 ）安装 Deploy to container插件 Jenkins本身无法实现远程部署到Tomcat的功能，需要安装Deploy to container插件实现 echo \"开始编译和打包\" mvn clean package echo \"编译和打包结束\" 2 ）添加Tomcat用户凭证 3 ）添加构建后操作 点击\"Build Now\"，开始构建过程 4 ）部署成功后，访问项目 http://192.168.66.102:8080/web_demo-1.0-SNAPSHOT/ 演示改动代码后的持续集成 1 ）IDEA中源码修改并提交到gitlab 2 ）在Jenkins中项目重新构建 3 ）访问Tomcat ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建类型(3)-Maven项目构建 1 ）安装Maven Integration插件 2 ）创建Maven项目 3 ）配置项目 拉取代码和远程部署的过程和自由风格项目一样，只是\"构建\"部分不同 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建类型(4)-Pipeline流水线项目构建(*) Pipeline简介 1 ）概念 Pipeline，简单来说，就是一套运行在 Jenkins 上的工作流框架，将原来独立运行于单个或者多个节点 的任务连接起来，实现单个任务难以完成的复杂流程编排和可视化的工作。 2 ）使用Pipeline有以下好处（来自翻译自官方文档）： 代码：Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑，审查和迭代其传送流 程。 持久：无论是计划内的还是计划外的服务器重启，Pipeline都是可恢复的。 可停止：Pipeline可接 收交互式输入，以确定是否继续执行Pipeline。 多功能：Pipeline支持现实世界中复杂的持续交付要 求。它支持fork/join、循环执行，并行执行任务的功能。 可扩展：Pipeline插件支持其DSL的自定义扩 展 ，以及与其他插件集成的多个选项。 3 ）如何创建 Jenkins Pipeline呢？ Pipeline 脚本是由 Groovy 语言实现的，但是我们没必要单独去学习 Groovy Pipeline 支持两种语法：Declarative(声明式)和 Scripted Pipeline(脚本式)语法 Pipeline 也有两种创建方法：可以直接在 Jenkins 的 Web UI 界面中输入脚本；也可以通过创建一 个 Jenkinsfile 脚本文件放入项目源码库中（一般我们都推荐在 Jenkins 中直接从源代码控制(SCM) 中直接载入 Jenkinsfile Pipeline 这种方法）。 安装Pipeline插件 Manage Jenkins-\u003eManage Plugins-\u003e可选插件 安装插件后，创建项目的时候多了“流水线”类型 Pipeline语法快速入门 1 ）Declarative声明式-Pipeline 创建项目 流水线-\u003e选择HelloWorld模板 生成内容如下： stages：代表整个流水线的所有执行阶段。通常stages只有 1 个，里面包含多个stage pipeline { agent any stages { stage('Hello') { steps { echo 'Hello World' } } } } stage：代表流水线中的某个阶段，可能出现n个。一般分为拉取代码，编译构建，部署等阶段。 steps：代表一个阶段内需要执行的逻辑。steps里面是shell脚本，git拉取代码，ssh远程发布等任意内 容。 编写一个简单声明式Pipeline： 点击构建，可以看到整个构建过程 2 ）Scripted Pipeline脚本式-Pipeline 创建项目 pipeline { agent any stages { stage('拉取代码') { steps { echo '拉取代码' } } stage('编译构建') { steps { echo '编译构建' } } stage('项目部署') { steps { echo '项目部署' } } } } 这次选择\"Scripted Pipeline\" Node：节点，一个 Node 就是一个 Jenkins 节点，Master 或者 Agent，是执行 Step 的具体运行 环境，后续讲到Jenkins的Master-Slave架构的时候用到。 Stage：阶段，一个 Pipeline 可以划分为若干个 Stage，每个 Stage 代表一组操作，比如： Build、Test、Deploy，Stage 是一个逻辑分组的概念。 Step：步骤，Step 是最基本的操作单元，可以是打印一句话，也可以是构建一个 Docker 镜像， 由各类 Jenkins 插件提供，比如命令：sh ‘make’，就相当于我们平时 shell 终端中执行 make 命令 一样。 编写一个简单的脚本式Pipeline node { def mvnHome stage('Preparation') { // for display purposes } stage('Build') { } stage('Results') { } } 构建结果和声明式一样！ 拉取代码 编译打包 node { def mvnHome stage('拉取代码') { // for display purposes echo '拉取代码' } stage('编译构建') { echo '编译构建' } stage('项目部署') { echo '项目部署' } } pipeline { agent any stages { stage('拉取代码') { steps { checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ' 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 ', url: 'git@ 192. 168. 66. 100 :itheima_group/web_demo.git']]]) } } } } pipeline { agent any stages { stage('拉取代码') { steps { checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ' 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 ', url: 'git@ 192. 168. 66. 100 :itheima_group/web_demo.git']]]) } } stage('编译构建') { steps { sh label: '', script: 'mvn clean package' } } } } 部署 Pipeline Script from SCM 刚才我们都是直接在Jenkins的UI界面编写Pipeline代码，这样不方便脚本维护，建议把Pipeline脚本放 在项目中（一起进行版本控制） 1 ）在项目根目录建立Jenkinsfile文件，把内容复制到该文件中 pipeline { agent any stages { stage('拉取代码') { steps { checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ' 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 ', url: 'git@ 192. 168. 66. 100 :itheima_group/web_demo.git']]]) } } stage('编译构建') { steps { sh label: '', script: 'mvn clean package' } } stage('项目部署') { steps { deploy adapters: [tomcat 8 (credentialsId: 'afc 43 e 5 e- 4 a 4 e- 4 de 6 - 984 f- b 1 d 5 a 254 e 434 ', path: '', url: 'http:// 192. 168. 66. 102 : 8080 ')], contextPath: null, war: 'target/*.war' } } } } 把Jenkinsfile上传到Gitlab 2 ）在项目中引用该文件 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建细节(1)-常用的构建触发器 Jenkins内置 4 种构建触发器： 触发远程构建 其他工程构建后触发（Build after other projects are build） 定时构建（Build periodically） 轮询SCM（Poll SCM） 触发远程构建 触发构建url：http://192.168.66.101:8888/job/web_demo_pipeline/build?token=6666 其他工程构建后触发 1 ）创建pre_job流水线工程 2 ）配置需要触发的工程 定时构建 定时字符串从左往右分别为： 分 时 日 月 周 一些定时表达式的例子： 每 30 分钟构建一次：H代表形参 H/30 * * * * 10:02 10:32 每 2 个小时构建一次: H H/2 * * * 每天的 8 点， 12 点， 22 点，一天构建 3 次： (多个时间点中间用逗号隔开) 0 8,12,22 * * * 每天中午 12 点定时构建一次 H 12 * * * 每天下午 18 点定时构建一次 H 18 * * * 在每个小时的前半个小时内的每 10 分钟 H(0-29)/10 * * * * 每两小时一次，每个工作日上午 9 点到下午 5 点(也许是上午10:38，下午12:38，下午2:38，下午 4:38) H H(9-16)/2 * * 1-5 轮询SCM 轮询SCM，是指定时扫描本地代码仓库的代码是否有变更，如果代码有变更就触发项目构建。 注意：这次构建触发器，Jenkins会定时扫描本地整个项目的代码，增大系统的开销，不建议使用。 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建细节(2)-Git hook自动触发构建(*) 刚才我们看到在Jenkins的内置构建触发器中，轮询SCM可以实现Gitlab代码更新，项目自动构建，但是 该方案的性能不佳。那有没有更好的方案呢？ 有的。就是利用Gitlab的webhook实现代码push到仓 库，立即触发项目自动构建。 安装Gitlab Hook插件 需要安装两个插件： Gitlab Hook和GitLab Jenkins设置自动构建 等会需要把生成的webhook URL配置到Gitlab中。 Gitlab配置webhook 1 ）开启webhook功能 使用root账户登录到后台，点击Admin Area -\u003e Settings -\u003e Network 勾选\"Allow requests to the local network from web hooks and services\" 2 ）在项目添加webhook 点击项目-\u003eSettings-\u003eIntegrations 注意：以下设置必须完成，否则会报错！ Manage Jenkins-\u003eConfigure System ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建细节(3)-Jenkins的参数化构建 有时在项目构建的过程中，我们需要根据用户的输入动态传入一些参数，从而影响整个构建结果，这时 我们可以使用参数化构建。 Jenkins支持非常丰富的参数类型 接下来演示通过输入gitlab项目的分支名称来部署不同分支项目。 项目创建分支，并推送到Gitlab上 新 新建分支：v1，代码稍微改动下，然后提交到gitlab上。 这时看到gitlab上有一个两个分支：master和v1 在Jenkins添加字符串类型参数 改动pipeline流水线代码 点击Build with Parameters 输入分支名称，构建即可！构建完成后访问Tomcat查看结果 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:7","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建细节(4)-配置邮箱服务器发送构建结果 安装Email Extension插件 Jenkins设置邮箱相关参数 Manage Jenkins-\u003eConfigure System 设置邮件参数 设置Jenkins默认邮箱信息 准备邮件内容 在项目根目录编写email.html，并把文件推送到Gitlab，内容如下： 编写Jenkinsfile添加构建后发送邮件 \u003ctr\u003e \u003ctd\u003e \u003cul\u003e \u003cli\u003e历史变更记录 : \u003ca href=\"${PROJECT_URL}changes\"\u003e${PROJECT_URL}changes\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e ${CHANGES_SINCE_LAST_SUCCESS,reverse=true, format=\"Changes for Build #%n:\u003cbr /\u003e%c\u003cbr /\u003e\",showPaths=true,changesFormat=\"\u003cpre\u003e[%a]\u003cbr /\u003e%m\u003c/pre\u003e\",pathFormat=\"\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;%p\"} \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003cb\u003eFailed Test Results\u003c/b\u003e \u003chr size=\" 2 \" width=\" 100 %\" align=\"center\" /\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003cpre style=\"font-size: 11 pt; font-family: Tahoma, Arial, Helvetica, sans-serif\"\u003e$FAILED_TESTS\u003c/pre\u003e \u003cbr /\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003cb\u003e\u003cfont color=\"# 0 B 610 B\"\u003e构建日志 (最后 100 行):\u003c/font\u003e\u003c/b\u003e \u003chr size=\" 2 \" width=\" 100 %\" align=\"center\" /\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ctextarea cols=\" 80 \" rows=\" 30 \" readonly=\"readonly\" style=\"font-family: Courier New\"\u003e${BUILD_LOG, maxLines= 100 }\u003c/textarea\u003e \u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e pipeline { agent any stages { stage('拉取代码') { steps { checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ' 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 ', url: 'git@ 192. 168. 66. 100 :itheima_group/web_demo.git']]]) } } stage('编译构建') { steps { sh label: '', script: 'mvn clean package' } } stage('项目部署') { steps { 测试 PS：邮件相关全局参数参考列表： 系统设置-\u003eExtended E-mail Notification-\u003eContent Token Reference，点击旁边的?号 deploy adapters: [tomcat 8 (credentialsId: 'afc 43 e 5 e- 4 a 4 e- 4 de 6 - 984 f- b 1 d 5 a 254 e 434 ', path: '', url: 'http:// 192. 168. 66. 102 : 8080 ')], contextPath: null, war: 'target/*.war' } } } post { always { emailext( subject: '构建通知：${PROJECT_NAME} - Build # ${BUILD_NUMBER} - ${BUILD_STATUS}!', body: '${FILE,path=\"email.html\"}', to: 'xxx@qq.com' ) } } } 软件 服务器 版本 JDK 192.168.66.101 1.8 MySQL 192.168.66.101 5.7 SonarQube 192.168.66.101 6.7.4 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:8","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+SonarQube代码审查(1) - 安装SonarQube SonaQube简介 SonarQube是一个用于管理代码质量的开放平台，可以快速的定位代码中潜在的或者明显的错误。目前 支持java,C#,C/C++,Python,PL/SQL,Cobol,JavaScrip,Groovy等二十几种编程语言的代码质量管理与检 测。 官网：https://www.sonarqube.org/ 环境要求 安装SonarQube 1 ）安装MySQL（已完成） 2 ）安装SonarQube 在MySQL创建sonar数据库 下载sonar压缩包： https://www.sonarqube.org/downloads/ 解压sonar，并设置权限 yum install unzip unzip sonarqube-6.7.4.zip 解压 mkdir /opt/sonar 创建目录 mv sonarqube-6.7.4/* /opt/sonar 移动文件 useradd sonar 创建sonar用户，必须sonar用于启动，否则报错 chown -R sonar. /opt/sonar 更改sonar目录及文件权限 修改sonar配置文件 vi /opt/sonarqube-6.7.4/conf/sonar.properties 内容如下： sonar.jdbc.username=root sonar.jdbc.password=Root@123 sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar? useUnicode=true\u0026characterEncoding=utf8\u0026rewriteBatchedStatements=true\u0026useConfigs= maxPerformance\u0026useSSL=false 注意：sonar默认监听 9000 端口，如果 9000 端口被占用，需要更改。 启动sonar cd /opt/sonarqube-6.7.4 su sonar ./bin/linux-x86-64/sonar.sh start 启动 su sonar ./bin/linux-x86-64/sonar.sh status 查看状态 su sonar ./bin/linux-x86-64/sonar.sh stop 停止 tail -f logs/sonar.logs 查看日志 访问sonar http://192.168.66.101:9000 默认账户：admin/admin 创建token bb8b6c53d9d921e101343cef0395243e6c1dc8a3 token要记下来后面要使用 0151ae8c548a143eda9253e4334ad030b56047ee ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:9","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+SonarQube代码审查(2) - 实现代码审查 安装SonarQube Scanner插件 添加SonarQube凭证 Jenkins进行SonarQube配置 Manage Jenkins-\u003eConfigure System-\u003eSonarQube servers Manage Jenkins-\u003eGlobal Tool Configuration SonaQube关闭审查结果上传到SCM功能 在项目添加SonaQube代码审查（非流水线项目） 添加构建步骤： 在项目添加SonaQube代码审查（流水线项目） 1 ）项目根目录下，创建sonar-project.properties文件 2 ）修改Jenkinsfile，加入SonarQube代码审查阶段 # must be unique in a given SonarQube instance sonar.projectKey=web_demo # this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6. 1. sonar.projectName=web_demo sonar.projectVersion= 1. 0 # Path is relative to the sonar-project.properties file. Replace \"\\\" by \"/\" on Windows. # This property is optional if sonar.modules is set. sonar.sources=. sonar.exclusions=**/test/**,**/target/** sonar.java.source= 1. 8 sonar.java.target= 1. 8 # Encoding of the source code. Default is default system encoding sonar.sourceEncoding=UTF- 8 # must be unique in a given SonarQube instance sonar.projectKey=web_demo # this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6. 1. sonar.projectName=web_demo sonar.projectVersion= 1. 0 # Path is relative to the sonar-project.properties file. Replace \"\\\" by \"/\" on Windows. # This property is optional if sonar.modules is set. sonar.sources=. sonar.exclusions=**/test/**,**/target/** sonar.java.source= 1. 8 sonar.java.target= 1. 8 # Encoding of the source code. Default is default system encoding sonar.sourceEncoding=UTF- 8 3 ）到SonarQube的UI界面查看审查结果 pipeline { agent any stages { stage('拉取代码') { steps { checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ' 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 ', url: 'git@ 192. 168. 66. 100 :itheima_group/web_demo.git']]]) } } stage('编译构建') { steps { sh label: '', script: 'mvn clean package' } } stage('SonarQube代码审查') { steps{ script { scannerHome = tool 'sonarqube-scanner' } withSonarQubeEnv('sonarqube 6. 7. 4 ') { sh \"${scannerHome}/bin/sonar-scanner\" } } } stage('项目部署') { steps { deploy adapters: [tomcat 8 (credentialsId: 'afc 43 e 5 e- 4 a 4 e- 4 de 6 - 984 f- b 1 d 5 a 254 e 434 ', path: '', url: 'http:// 192. 168. 66. 102 : 8080 ')], contextPath: null, war: 'target/*.war' } } } post { always { emailext( subject: '构建通知：${PROJECT_NAME} - Build # ${BUILD_NUMBER} - ${BUILD_STATUS}!', body: '${FILE,path=\"email.html\"}', to: ' 1014671449 @qq.com' ) } } } 服务器名称 IP地址 安装的软件 代码托管服务器 192.168.66.100 Gitlab 持续集成服务器 192.168.66.101 Jenkins，Maven，Docker18.06.1-ce Docker仓库服务器 192.168.66.102 Docker18.06.1-ce，Harbor1.9.2 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:10","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"4 、Jenkins+Docker+SpringCloud微服务持续集成(上) ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+Docker+SpringCloud持续集成流程说明 大致流程说明： 1 ）开发人员每天把代码提交到Gitlab代码仓库 2 ）Jenkins从Gitlab中拉取项目源码，编译并打成jar包，然后构建成Docker镜像，将镜像上传到 Harbor私有仓库。 3 ）Jenkins发送SSH远程命令，让生产部署服务器到Harbor私有仓库拉取镜像到本地，然后创建容器。 4 ）最后，用户可以访问到容器 服务列表(红色的软件为需要安装的软件，黑色代表已经安装) 服务器名称生产部署服务器 IP192.168.66.103地址 安装的软件Docker18.06.1-ce ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"SpringCloud微服务源码概述 项目架构：前后端分离 后端技术栈：SpringBoot+SpringCloud+SpringDataJpa（Spring全家桶） 微服务项目结构： tensquare_parent：父工程，存放基础配置 tensquare_common：通用工程，存放工具类 tensquare_eureka_server：SpringCloud的Eureka注册中心 tensquare_zuul：SpringCloud的网关服务 tensquare_admin_service：基础权限认证中心，负责用户认证（使用JWT认证） tensquare_gathering：一个简单的业务模块，活动微服务相关逻辑 数据库结构： tensquare_user：用户认证数据库，存放用户账户数据。对应tensquare_admin_service微服务 tensquare_gathering：活动微服务数据库。对应tensquare_gathering微服务 微服务配置分析： tensquare_eureka tensquare_zuul tensquare_admin_service tensquare_gathering ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"本地部署(1)-SpringCloud微服务部署 本地运行微服务 1 ）逐一启动微服务 2 ）使用postman测试功能是否可用 本地部署微服务 1 ）SpringBoot微服务项目打包 必须导入该插件 打包后在target下产生jar包 2 ）本地运行微服务的jar包 java -jar xxx.jar 3 ）查看效果 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"本地部署(2)-前端静态web网站 前端技术栈：NodeJS+VueJS+ElementUI 使用Visual Studio Code打开源码 1 ）本地运行 npm run dev 2 ）打包静态web网站 npm run build 打包后，产生dist目录的静态文件 3 ）部署到nginx服务器 把dist目录的静态文件拷贝到nginx的html目录，启动nginx 4 ）启动nginx，并访问 http://localhost:82 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"环境准备(1)-Docker快速入门 Docker简介 \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e 虚拟机 容器 占用磁盘空间 非常大，GB级 小，MB甚至KB级 启动速度 慢，分钟级 快，秒级 运行形态 运行于Hypervisor上 直接运行在宿主机内核上 并发性 一台宿主机上十几个，最多几十个 上百个，甚至数百上千个 性能 逊于宿主机 接近宿主机本地进程 资源利用率 低 高 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流 行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销 极低。 Docker容器技术 vs 传统虚拟机技术 简单一句话总结：Docker技术就是让我们更加高效轻松地将任何应用在Linux服务器部署和使用。 Docker安装 1 ）卸载旧版本 yum list installed | grep docker 列出当前所有docker的包 yum -y remove docker的包名称 卸载docker包 rm -rf /var/lib/docker 删除docker的所有镜像和容器 2 ）安装必要的软件包 sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 3 ）设置下载的镜像仓库 sudo yum-config-manager \\ –add-repo \\ https://download.docker.com/linux/centos/docker- ce.repo 4 ）列出需要安装的版本列表 yum list docker-ce –showduplicates | sort -r 5 ）安装指定版本（这里使用18.0.1版本） sudo yum install docker-ce-18.06.1.ce 6 ）查看版本 docker -v 7 ）启动Docker sudo systemctl start docker 启动 sudo systemctl enable docker 设置开机启动 8 ）添加阿里云镜像下载地址 vi /etc/docker/daemon.json 内容如下： 9 ）重启Docker sudo systemctl restart docker Docker基本命令快速入门 1 ）镜像命令 镜像：相当于应用的安装包，在Docker部署的任何应用都需要先构建成为镜像 docker search 镜像名称 搜索镜像 docker pull 镜像名称 拉取镜像 docker images 查看本地所有镜像 docker-ce.x 86 _ 64 3 : 18. 09. 1 - 3 .el 7 docker-ce-stable docker-ce.x 86 _ 64 3 : 18. 09. 0 - 3 .el 7 docker-ce-stable docker-ce.x 86 _ 64 18. 06. 1 .ce- 3 .el 7 docker-ce-stable docker-ce.x 86 _ 64 18. 06. 0 .ce- 3 .el 7 docker-ce-stable ...... { \"registry-mirrors\": [\"https://zydiol 88 .mirror.aliyuncs.com\"] } docker rmi -f 镜像名称 删除镜像 docker pull openjdk:8-jdk-alpine 2 ）容器命令 容器：容器是由镜像创建而来。容器是Docker运行应用的载体，每个应用都分别运行在Docker的每个 容器中。 docker run -i 镜像名称:标签 运行容器（默认是前台运行） docker ps 查看运行的容器 docker ps -a 查询所有容器 常用的参数： -i：运行容器 -d：后台守方式运行（守护式） –name：给容器添加名称 -p：公开容器端口给当前宿主机 -v：挂载目录 docker exec -it 容器ID/容器名称 /bin/bash 进入容器内部 docker start/stop/restart 容器名称/ID 启动/停止/重启容器 docker rm -f 容器名称/ID 删除容器 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"环境准备(2)-Dockerfile镜像脚本快速入门 Dockerfile简介 Dockerfile其实就是我们用来构建Docker镜像的源码，当然这不是所谓的编程源码，而是一些命令的组 合，只要理解它的逻辑和语法格式，就可以编写Dockerfile了。 简单点说，Dockerfile的作用：它可以让用户个性化定制Docker镜像。因为工作环境中的需求各式各 样，网络上的镜像很难满足实际的需求。 Dockerfile常见命令 命令 作用 FROM image_name:tag MAINTAINER user_name 声明镜像的作者 ENV key value 设置环境变量 (可以写多条) RUN command 编译镜像时运行的脚本(可以写多条) CMD 设置容器的启动命令 ENTRYPOINT 设置容器的入口程序 ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复 制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 ARG 设置编译镜像时加入的参数 VOLUMN 设置容器的挂载卷 镜像构建示意图： 可以看到，新镜像是从基础镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一 层 RUN、CMD、ENTRYPOINT的区别？ RUN：用于指定 docker build 过程中要运行的命令，即是创建 Docker 镜像（image）的步骤 CMD：设置容器的启动命令， Dockerfile 中只能有一条 CMD 命令，如果写了多条则最后一条生效， CMD不支持接收docker run的参数。 ENTRYPOINT：入口程序是容器启动时执行的程序， docker run 中最后的命令将作为参数传递给入口 程序 ，ENTRYPOINY类似于 CMD 指令，但可以接收docker run的参数 。 以下是mysql官方镜像的Dockerfile示例： FROM oraclelinux: 7 - slim ARG MYSQL_SERVER_PACKAGE=mysql-community-server-minimal- 5. 7. 28 ARG MYSQL_SHELL_PACKAGE=mysql-shell- 8. 0. 18 使用Dockerfile制作微服务镜像 我们利用Dockerfile制作一个Eureka注册中心的镜像 1 ）上传Eureka的微服务jar包到linux 2 ）编写Dockerfile 3 ）构建镜像 docker build –build-arg JAR_FILE=tensquare_eureka_server-1.0-SNAPSHOT.jar -t eureka:v1. 4 ）查看镜像是否创建成功 docker images 5 ）创建容器 docker run -i –name=eureka -p 10086:10086 eureka:v1 6 ）访问容器 http://192.168.66.101:10086 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"环境准备(3)-Harbor镜像仓库安装及使用 Harbor简介 # Install server RUN yum install - y https://repo.mysql.com/mysql-community-minimal-release- el 7 .rpm \\ https://repo.mysql.com/mysql-community-release-el 7 .rpm \\ \u0026\u0026 yum-config-manager - -enable mysql 57 - server-minimal \\ \u0026\u0026 yum install - y \\ $MYSQL_SERVER_PACKAGE \\ $MYSQL_SHELL_PACKAGE \\ libpwquality \\ \u0026\u0026 yum clean all \\ \u0026\u0026 mkdir /docker-entrypoint-initdb.d VOLUME /var/lib/mysql COPY docker-entrypoint.sh /entrypoint.sh COPY healthcheck.sh /healthcheck.sh ENTRYPOINT [\"/entrypoint.sh\"] HEALTHCHECK CMD /healthcheck.sh EXPOSE 3306 33060 CMD [\"mysqld\"] FROM openjdk: 8 - jdk-alpine ARG JAR_FILE COPY ${JAR_FILE} app.jar EXPOSE 10086 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] Harbor（港口，港湾）是一个用于存储和分发Docker镜像的企业级Registry服务器。 除了Harbor这个私有镜像仓库之外，还有Docker官方提供的Registry。相对Registry，Harbor具有很 多优势： 提供分层传输机制，优化网络传输 Docker镜像是是分层的，而如果每次传输都使用全量文件(所以 用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定 传输的对象。 提供WEB界面，优化用户体验 只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界 面可以支持登陆、搜索功能，包括区分公有、私有镜像。 支持水平扩展集群 当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分 解。 良好的安全机制 企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限， 具有更好的安全性。 Harbor安装 Harbor需要安装在192.168.66.102上面 1 ）先安装Docker并启动Docker（已完成） 参考之前的安装过程 2 ）先安装docker-compose 3 ）给docker-compose添加执行权限 sudo chmod +x /usr/local/bin/docker-compose 4 ）查看docker-compose是否安装成功 docker-compose -version 5 ）下载Harbor的压缩包（本课程版本为：v1.9.2） https://github.com/goharbor/harbor/releases 6 ）上传压缩包到linux，并解压 tar -xzf harbor-offline-installer-v1.9.2.tgz mkdir /opt/harbor mv harbor/* /opt/harbor cd /opt/harbor 7 ）修改Harbor的配置 sudo curl - L https://github.com/docker/compose/releases/download/ 1. 21. 2 /docker- compose-$(uname - s)-$(uname - m) - o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose vi harbor.yml 修改hostname和port hostname: 192.168.66.102 port: 85 8 ）安装Harbor ./prepare ./install.sh 9 ）启动Harbor docker-compose up -d 启动 docker-compose stop 停止 docker-compose restart 重新启动 10 ）访问Harbor http://192.168.66.102:85 默认账户密码：admin/Harbor12345 在Harbor创建用户和项目 1 ）创建项目 Harbor的项目分为公开和私有的： 公开项目：所有用户都可以访问，通常存放公共的镜像，默认有一个library公开项目。 私有项目：只有授权用户才可以访问，通常存放项目本身的镜像。 我们可以为微服务项目创建一个新的项目： 2 ）创建用户 创建的用户为： itcast/Itcast123 3 ）给私有项目分配用户 进入tensquare项目-\u003e成员 角色 权限说明 访客 对于指定项目拥有只读权限 开发人员 对于指定项目拥有读写权限 维护人员 对于指定项目拥有读写权限，创建 Webhooks 项目管理员 除了读写权限，同时拥有用户管理/镜像扫描等管理权限 4 ）以新用户登录Harbor 把镜像上传到Harbor 1 ）给镜像打上标签 docker tag eureka:v1 192.168.66.102:85/tensquare/eureka:v1 2 ）推送镜像 docker push 192.168.66.102:85/tensquare/eureka:v1 这时会出现以上报错，是因为Docker没有把Harbor加入信任列表中 3 ）把Harbor地址加入到Docker信任列表 vi /etc/docker/daemon.json The push refers to repository [ 192. 168. 66. 102 : 85 /tensquare/eureka] Get https:// 192. 168. 66. 102 : 85 /v 2 /: http: server gave HTTP response to HTTPS client 需要重启Docker 4 ）再次执行推送命令，会提示权限不足 需要先登录Harbor，再推送镜像 5 ）登录Harbor docker login -u 用户名 -p 密码 192.168.66.102:85 从Harbor下载镜像 需求：在192.168.66.103服务器完成从Harbor下载镜像 1 ）安装Docker，并启动Docker（已经完成） 2 ）修改Docker配置 vi /etc/docker/daemon.json 重启docker 3 ）先登录，再从Harbor下载镜像 docker login -u 用户名 -p 密码 192.168.66.102:85 { \"registry-mirrors\": [\"https://zydiol 88 .mirror.aliyuncs.com\"], \"insecure-registries\": [\" 192. 168. 66. 102 : 85 \"] } denied: requested access to the resource is denied WARNING! Using - -password via the CLI is insecure. Use - -password-stdin. WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded { \"registry-mirrors\": [\"https://zydiol 88 .mirror.aliyuncs.com\"], \"insecure-registries\": [\" 192. 168. 66. 102 : 85 \"] } docker pull 192.168.66.102:85/tensquare/eureka:v1 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:7","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(1)-项目代码上传到Gitlab 在IDEA操作即可，参考之前的步骤。包括后台微服务和前端web网站代码 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:8","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(2)-从Gitlab拉取项目源码 1 ）创建Jenkinsfile文件 2 ）拉取Jenkinsfile文件 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" node { stage('拉取代码') { checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: \"${git_auth}\", url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_back.git']]]) } } ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:9","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(3)-提交到SonarQube代码审查 1 ）创建项目，并设置参数 创建tensquare_back项目，添加两个参数 2 ）每个项目的根目录下添加sonar-project.properties 注意：修改sonar.projectKey和sonar.projectName 3 ）修改Jenkinsfile构建脚本 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:10","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(4)-使用Dockerfile编译、生成镜像 利用dockerfile-maven-plugin插件构建Docker镜像 1 ）在每个微服务项目的pom.xml加入dockerfile-maven-plugin插件 # must be unique in a given SonarQube instance sonar.projectKey=tensquare_zuul # this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6. 1. sonar.projectName=tensquare_zuul sonar.projectVersion= 1. 0 # Path is relative to the sonar-project.properties file. Replace \"\\\" by \"/\" on Windows. # This property is optional if sonar.modules is set. sonar.sources=. sonar.exclusions=**/test/**,**/target/** sonar.java.binaries=. sonar.java.source= 1. 8 sonar.java.target= 1. 8 sonar.java.libraries=**/target/classes/** # Encoding of the source code. Default is default system encoding sonar.sourceEncoding=UTF- 8 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = \"latest\" node { stage('拉取代码') { checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: \"${git_auth}\", url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_back.git']]]) } stage('代码审查') { def scannerHome = tool 'sonarqube-scanner' withSonarQubeEnv('sonarqube 6. 7. 4 ') { sh \"\"\" cd ${project_name} ${scannerHome}/bin/sonar-scanner \"\"\" } } } 2 ）在每个微服务项目根目录下建立Dockerfile文件 注意：每个项目公开的端口不一样 3 ）修改Jenkinsfile构建脚本 \u003cplugin\u003e \u003cgroupId\u003ecom.spotify\u003c/groupId\u003e \u003cartifactId\u003edockerfile-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e 1. 3. 6 \u003c/version\u003e \u003cconfiguration\u003e \u003crepository\u003e${project.artifactId}\u003c/repository\u003e \u003cbuildArgs\u003e \u003cJAR_FILE\u003etarget/${project.build.finalName}.jar\u003c/JAR_FILE\u003e \u003c/buildArgs\u003e \u003c/configuration\u003e \u003c/plugin\u003e #FROM java: 8 FROM openjdk: 8 - jdk-alpine ARG JAR_FILE COPY ${JAR_FILE} app.jar EXPOSE 10086 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = \"latest\" //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 /tensquare/\" node { stage('拉取代码') { checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: \"${git_auth}\", url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_back.git']]]) } stage('代码审查') { def scannerHome = tool 'sonarqube-scanner' withSonarQubeEnv('sonarqube 6. 7. 4 ') { sh \"\"\" cd ${project_name} ${scannerHome}/bin/sonar-scanner \"\"\" } } stage('编译，构建镜像') { //定义镜像名称 def imageName = \"${project_name}:${tag}\" //编译，安装公共工程 注意：如果出现找不到父工程依赖，需要手动把父工程的依赖上传到仓库中 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:11","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(5)-上传到Harbor镜像仓库 1 ）修改Jenkinsfile构建脚本 sh \"mvn - f tensquare_common clean install\" //编译，构建本地镜像 sh \"mvn - f ${project_name} clean package dockerfile:build\" } } //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = \"latest\" //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 \" //Harbor的项目名称 def harbor_project_name = \"tensquare\" //Harbor的凭证 def harbor_auth = \"ef 499 f 29 - f 138 - 44 dd- 975 e-ff 1 ca 1 d 8 c 933 \" node { stage('拉取代码') { checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: \"${git_auth}\", url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_back.git']]]) } stage('代码审查') { def scannerHome = tool 'sonarqube-scanner' withSonarQubeEnv('sonarqube 6. 7. 4 ') { sh \"\"\" cd ${project_name} ${scannerHome}/bin/sonar-scanner \"\"\" } } stage('编译，构建镜像') { //定义镜像名称 def imageName = \"${project_name}:${tag}\" //编译，安装公共工程 sh \"mvn - f tensquare_common clean install\" //编译，构建本地镜像 sh \"mvn - f ${project_name} clean package dockerfile:build\" //给镜像打标签 sh \"docker tag ${imageName} ${harbor_url}/${harbor_project_name}/${imageName}\" 2 ）使用凭证管理Harbor私服账户和密码 先在凭证建立Harbor的凭证，在生成凭证脚本代码 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:12","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(6)-拉取镜像和发布应用 //登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId: \"${harbor_auth}\", passwordVariable: 'password', usernameVariable: 'username')]) { //登录 sh \"docker login - u ${username} - p ${password} ${harbor_url}\" //上传镜像 sh \"docker push ${harbor_url}/${harbor_project_name}/${imageName}\" } //删除本地镜像 sh \"docker rmi - f ${imageName}\" sh \"docker rmi - f ${harbor_url}/${harbor_project_name}/${imageName}\" } } 注意：192.168.66.103服务已经安装Docker并启动 安装 Publish Over SSH 插件 安装以下插件，可以实现远程发送Shell命令 配置远程部署服务器 1 ）拷贝公钥到远程服务器 ssh-copy-id 192.168.66.103 2 ）系统配置-\u003e添加远程服务器 修改Jenkinsfile构建脚本 生成远程调用模板代码 添加一个port参数 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = \"latest\" //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 \" //Harbor的项目名称 def harbor_project_name = “tensquare” //Harbor的凭证 def harbor_auth = “ef 499 f 29 - f 138 - 44 dd- 975 e-ff 1 ca 1 d 8 c 933 \" node { stage(‘拉取代码’) { checkout([$class: ‘GitSCM’, branches: [[name: ‘*/${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: “${git_auth}”, url: ‘git@ 192. 168. 66. 100 :itheima_group/tensquare_back.git’]]]) } stage(‘代码审查’) { def scannerHome = tool ‘sonarqube-scanner’ withSonarQubeEnv(‘sonarqube 6. 7. 4 ‘) { sh \"”\" cd ${project_name} ${scannerHome}/bin/sonar-scanner \"\"\" } } stage(‘编译，构建镜像，部署服务’) { //定义镜像名称 def imageName = “${project_name}:${tag}” //编译并安装公共工程 sh “mvn - f tensquare_common clean install” //编译，构建本地镜像 sh “mvn - f ${project_name} clean package dockerfile:build” //给镜像打标签 sh “docker tag ${imageName} ${harbor_url}/${harbor_project_name}/${imageName}” //登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId: “${harbor_auth}”, passwordVariable: ‘password’, usernameVariable: ‘username’)]) { //登录 sh “docker login - u ${username} - p ${password} ${harbor_url}” //上传镜像 sh “docker push ${harbor_url}/${harbor_project_name}/${imageName}” } //删除本地镜像 sh “docker rmi - f ${imageName}” sh “docker rmi - f ${harbor_url}/${harbor_project_name}/${imageName}” //=====以下为远程调用进行项目部署======== 编写deploy.sh部署脚本 sshPublisher(publishers: [sshPublisherDesc(configName: 'master_server', transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: \"/opt/jenkins_shell/deploy.sh $harbor_url$harbor_project_name$project_name$tag$port\", execTimeout: 120000 , flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)]) } } #! /bin/sh #接收外部参数 harbor_url=$ 1 harbor_project_name=$ 2 project_name=$ 3 tag=$ 4 port=$ 5 imageName=$harbor_url/$harbor_project_name/$project_name:$tag echo \"$imageName\" #查询容器是否存在，存在则删除 containerId=`docker ps - a | grep - w ${project_name}:${tag} | awk '{print $ 1 }'` if [ \"$containerId\" != \"\" ] ; then #停掉容器 docker stop $containerId #删除容器 docker rm $containerId echo \"成功删除容器\" fi #查询镜像是否存在，存在则删除 imageId=`docker images | grep - w $project_name | awk '{print $ 3 }'` if [ \"$imageId\" != \"\" ] ; then #删除镜像 docker rmi - f $imageId echo \"成功删除镜像\" fi # 登录Harbor私服 docker login - u itcast - p Itcast 123 $harbor_url # 下载镜像 docker pull $imageName # 启动容器 docker run - di - p $port:$port $imageName 上传deploy.sh文件到/opt/jenkins_shell目录下，且文件至少有执行权限！ chmod +x deploy.sh 添加执行权限 导入数据，测试微服务 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:13","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(7)-部署前端静态web网站 安装Nginx服务器 yum install epel-release yum -y install nginx 安装 修改nginx的端口，默认 80 ，改为 9090 ： vi /etc/nginx/nginx.conf 还需要关闭selinux，将SELINUX=disabled setenforce 0 先临时关闭 vi /etc/selinux/config 编辑文件，永久关闭 SELINUX=disabled 启动Nginx echo \"容器启动成功\" server { listen 9090 default_server; listen [::]: 9090 default_server; server_name _; root /usr/share/nginx/html; systemctl enable nginx 设置开机启动 systemctl start nginx 启动 systemctl stop nginx 停止 systemctl restart nginx 重启 访问：http://192.168.66.103:9090/ 安装NodeJS插件 Jenkins配置Nginx服务器 Manage Jenkins-\u003eGlobal Tool Configuration 创建前端流水线项目 建立Jenkinsfile构建脚本 完成后，访问：http://192.168.66.103:9090 进行测试。 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:14","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"5 、Jenkins+Docker+SpringCloud微服务持续集成(下) ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+Docker+SpringCloud部署方案优化 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" node { stage('拉取代码') { checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: \"${git_auth}\", url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_front.git']]]) } stage('打包，部署网站') { //使用NodeJS的npm进行打包 nodejs('nodejs 12 '){ sh ''' npm install npm run build ''' } //=====以下为远程调用进行项目部署======== sshPublisher(publishers: [sshPublisherDesc(configName: 'master_server', transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: '', execTimeout: 120000 , flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '/usr/share/nginx/html', remoteDirectorySDF: false, removePrefix: 'dist', sourceFiles: 'dist/**')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)]) } } 上面部署方案存在的问题： 1 ）一次只能选择一个微服务部署 2 ）只有一台生产者部署服务器 3 ）每个微服务只有一个实例，容错率低 优化方案： 1 ）在一个Jenkins工程中可以选择多个微服务同时发布 2 ）在一个Jenkins工程中可以选择多台生产服务器同时部署 3 ）每个微服务都是以集群高可用形式部署 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+Docker+SpringCloud集群部署流程说明 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"修改所有微服务配置 注册中心配置(*) # 集群版 spring: application: name: EUREKA-HA server: port: 10086 spring: 指定profile=eureka-server 1 profiles: eureka-server 1 eureka: instance: 指定当profile=eureka-server 1 时，主机名是eureka-server 1 hostname: 192. 168. 66. 103 client: 在启动微服务的时候，加入参数: spring.profiles.active 来读取对应的配置 其他微服务配置 除了Eureka注册中心以外，其他微服务配置都需要加入所有Eureka服务 把代码提交到Gitlab中 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"设计Jenkins集群项目的构建参数 1 ）安装Extended Choice Parameter插件 支持多选框 2 ）创建流水线项目 service-url: # 将自己注册到eureka-server 1 、eureka-server 2 这个Eureka上面去 defaultZone: http:// 192. 168. 66. 103 : 10086 /eureka/,http:// 192. 168. 66. 104 : 10086 /eureka/ server: port: 10086 spring: profiles: eureka-server 2 eureka: instance: hostname: 192. 168. 66. 104 client: service-url: defaultZone: http:// 192. 168. 66. 103 : 10086 /eureka/,http:// 192. 168. 66. 104 : 10086 /eureka/ # Eureka配置 eureka: client: service-url: defaultZone: http:// 192. 168. 66. 103 : 10086 /eureka,http:// 192. 168. 66. 104 : 10086 /eureka # Eureka访 问地址 instance: prefer-ip-address: true 3 ）添加参数 字符串参数：分支名称 多选框：项目名称 最后效果： ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"完成微服务构建镜像，上传私服 tensquare_eureka_server@ 10086 ,tensquare_zuul@ 10020 ,tensquare_admin_service@ 9001 , tensquare_gathering@ 9002 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = “latest” //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 \" //Harbor的项目名称 def harbor_project_name = “tensquare” //Harbor的凭证 def harbor_auth = “ef 499 f 29 - f 138 - 44 dd- 975 e-ff 1 ca 1 d 8 c 933 \" node { //把选择的项目信息转为数组 def selectedProjects = “${project_name}\".split(’,’) stage(‘拉取代码’) { checkout([$class: ‘GitSCM’, branches: [[name: ‘*/${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ‘${git_auth}’, url: ‘git@ 192. 168. 66. 100 :itheima_group/tensquare_back_cluster.git’]]]) } stage(‘代码审查’) { def scannerHome = tool ‘sonarqube-scanner’ withSonarQubeEnv(‘sonarqube 6. 7. 4 ‘) { for(int i= 0 ;i\u003cselectedProjects.size();i++){ //取出每个项目的名称和端口 def currentProject = selectedProjects[i]; //项目名称 def currentProjectName = currentProject.split(’@’)[ 0 ] //项目启动端口 def currentProjectPort = currentProject.split(’@’)[ 1 ] sh \"”” cd ${currentProjectName} ${scannerHome}/bin/sonar-scanner \"\"\" echo “${currentProjectName}完成代码审查” } } } stage(‘编译，构建镜像，部署服务’) { //编译并安装公共工程 sh “mvn - f tensquare_common clean install” for(int i= 0 ;i\u003cselectedProjects.size();i++){ //取出每个项目的名称和端口 def currentProject = selectedProjects[i]; //项目名称 def currentProjectName = currentProject.split(’@’)[ 0 ] //项目启动端口 def currentProjectPort = currentProject.split(’@’)[ 1 ] //定义镜像名称 def imageName = “${currentProjectName}:${tag}” //编译，构建本地镜像 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"完成微服务多服务器远程发布 1 ）配置远程部署服务器 拷贝公钥到远程服务器 ssh-copy-id 192.168.66.104 系统配置-\u003e添加远程服务器 sh \"mvn - f ${currentProjectName} clean package dockerfile:build\" //给镜像打标签 sh \"docker tag ${imageName} ${harbor_url}/${harbor_project_name}/${imageName}\" //登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId: \"${harbor_auth}\", passwordVariable: 'password', usernameVariable: 'username')]) { //登录 sh \"docker login - u ${username} - p ${password} ${harbor_url}\" //上传镜像 sh \"docker push ${harbor_url}/${harbor_project_name}/${imageName}\" } //删除本地镜像 sh \"docker rmi - f ${imageName}\" sh \"docker rmi - f ${harbor_url}/${harbor_project_name}/${imageName}\" //=====以下为远程调用进行项目部署======== //sshPublisher(publishers: [sshPublisherDesc(configName: 'master_server', transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: \"/opt/jenkins_shell/deployCluster.sh $harbor_url $harbor_project_name $currentProjectName $tag $currentProjectPort\", execTimeout: 120000 , flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)]) echo \"${currentProjectName}完成编译，构建镜像\" } } } 2 ）修改Docker配置信任Harbor私服地址 重启Docker 3 ）添加参数 多选框：部署服务器 { \"registry-mirrors\": [\"https://zydiol 88 .mirror.aliyuncs.com\"], \"insecure-registries\": [\" 192. 168. 66. 102 : 85 \"] } 最终效果： 4 ）修改Jenkinsfile构建脚本 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = \"latest\" //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 \" //Harbor的项目名称 def harbor_project_name = \"tensquare\" //Harbor的凭证 def harbor_auth = \"ef 499 f 29 - f 138 - 44 dd- 975 e-ff 1 ca 1 d 8 c 933 \" node { //把选择的项目信息转为数组 def selectedProjects = \"${project_name}\".split(',') //把选择的服务区信息转为数组 def selectedServers = \"${publish_server}\".split(',') stage('拉取代码') { checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: '${git_auth}', url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_back_cluster.git']]]) } stage(‘代码审查’) { def scannerHome = tool ‘sonarqube-scanner’ withSonarQubeEnv(‘sonarqube 6. 7. 4 ‘) { for(int i= 0 ;i\u003cselectedProjects.size();i++){ //取出每个项目的名称和端口 def currentProject = selectedProjects[i]; //项目名称 def currentProjectName = currentProject.split(’@’)[ 0 ] //项目启动端口 def currentProjectPort = currentProject.split(’@’)[ 1 ] sh \"\"\" cd ${currentProjectName} ${scannerHome}/bin/sonar-scanner \"\"\" echo “${currentProjectName}完成代码审查” } } } stage(‘编译，构建镜像，部署服务’) { //编译并安装公共工程 sh “mvn - f tensquare_common clean install” for(int i= 0 ;i\u003cselectedProjects.size();i++){ //取出每个项目的名称和端口 def currentProject = selectedProjects[i]; //项目名称 def currentProjectName = currentProject.split(’@’)[ 0 ] //项目启动端口 def currentProjectPort = currentProject.split(’@’)[ 1 ] //定义镜像名称 def imageName = “${currentProjectName}:${tag}” //编译，构建本地镜像 sh “mvn - f ${currentProjectName} clean package dockerfile:build” //给镜像打标签 sh “docker tag ${imageName} ${harbor_url}/${harbor_project_name}/${imageName}” //登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId: “${harbor_auth}”, passwordVariable: ‘password’, usernameVariable: ‘username’)]) { //登录 sh “docker login - u ${username} - p ${password} ${harbor_url}” //上传镜像 sh “docker push ${harbor_url}/${harbor_project_name}/${imageName}” } 5 ）编写deployCluster.sh部署脚本 //删除本地镜像 sh \"docker rmi - f ${imageName}\" sh \"docker rmi - f ${harbor_url}/${harbor_project_name}/${imageName}\" //=====以下为远程调用进行项目部署======== for(int j= 0 ;j\u003cselectedServers.size();j++){ //每个服务名称 def currentServer = selectedServers[j] //添加微服务运行时的参数：spring.profiles.active def activeProfile = \"--spring.profiles.active=\" if(currentServer==\"master_server\"){ activeProfile = activeProfile+\"eureka-server 1 \" }else if(currentServer==\"slave_server 1 \"){ activeProfile = activeProfile+\"eureka-server 2 \" } sshPublisher(publ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Nginx+Zuul集群实现高可用网关 1 ）安装Nginx（已完成） 2 ）修改Nginx配置 vi /etc/nginx/nginx.conf 内容如下： docker stop $containerId #删除容器 docker rm $containerId echo \"成功删除容器\" fi #查询镜像是否存在，存在则删除 imageId=`docker images | grep - w $project_name | awk '{print $ 3 }'` if [ \"$imageId\" != \"\" ] ; then #删除镜像 docker rmi - f $imageId echo \"成功删除镜像\" fi # 登录Harbor私服 docker login - u itcast - p Itcast 123 $harbor_url # 下载镜像 docker pull $imageName # 启动容器 docker run - di - p $port:$port $imageName $profile echo \"容器启动成功\" upstream zuulServer{ 3 ）重启Nginx： systemctl restart nginx 4 ）修改前端Nginx的访问地址 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:7","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"6 、基于Kubernetes/K8S构建Jenkins持续集成平台(上) ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins的Master-Slave分布式构建 什么是Master-Slave分布式构建 server 192. 168. 66. 103 : 10020 weight= 1 ; server 192. 168. 66. 104 : 10020 weight= 1 ; } server { listen 85 default_server; listen [::]: 85 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { ### 指定服务器负载均衡服务器 proxy_pass http://zuulServer/; } Jenkins的Master-Slave分布式构建，就是通过将构建过程分配到从属Slave节点上，从而减轻Master节 点的压力，而且可以同时构建多个，有点类似负载均衡的概念。 如何实现Master-Slave分布式构建 1 ）开启代理程序的TCP端口 Manage Jenkins -\u003e Configure Global Security 2 ）新建节点 Manage Jenkins—Manage Nodes—新建节点 有两种在Slave节点连接Master节点的方法 我们选择第二种： 2 ）安装和配置节点 下载agent.jar，并上传到Slave节点，然后执行页面提示的命令： 刷新页面 java - jar agent.jar - jnlpUrl http:// 192. 168. 66. 101 : 8888 /computer/slave 1 /slave- agent.jnlp - secret f 2 ecbb 99 e 0 c 81331 e 8 b 7 a 7917 a 94 d 478 f 39 cb 9763 fc 6 c 66 d 9 a 9741 c 61 f 9 ae 6 d 6 - workDir \"/root/jenkins\" 3 ）测试节点是否可用 自由风格和Maven风格的项目： 流水线风格的项目： ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Kubernetes实现Master-Slave分布式构建方案 传统Jenkins的Master-Slave方案的缺陷 Master节点发生单点故障时，整个流程都不可用了 每个 Slave节点的配置环境不一样，来完成不同语言的编译打包等操作，但是这些差异化的配置导 致管理起来非常不方便，维护起来也是比较费劲 资源分配不均衡，有的 Slave节点要运行的job出现排队等待，而有的Slave节点处于空闲状态 资源浪费，每台 Slave节点可能是实体机或者VM，当Slave节点处于空闲状态时，也不会完全释放 掉资源 以上种种问题，我们可以引入Kubernates来解决！ Kubernates简介 node('slave 1 ') { stage('check out') { checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ' 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 ', url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_back_cluster.git']]]) } } Kubernetes（简称，K8S）是Google开源的容器集群管理系统，在Docker技术的基础上，为容器化的 应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的 便捷性。 其主要功能如下： 使用Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。 以集群的方式运行、管理跨机器的容器。以集群的方式运行、管理跨机器的容器。 解决Docker跨机器容器之间的通讯问题。解决Docker跨机器容器之间的通讯问题。 Kubernetes的自我修复机制使得容器集群总是运行在用户期望的状态。 Kubernates+Docker+Jenkins持续集成架构图 大致工作流程：手动/自动构建 -\u003e Jenkins 调度 K8S API -＞动态生成 Jenkins Slave pod -＞ Slave pod 拉取 Git 代码／编译／打包镜像 -＞推送到镜像仓库 Harbor -＞ Slave 工作完成，Pod 自动销毁 -＞部署 到测试或生产 Kubernetes平台。（完全自动化，无需人工干预） Kubernates+Docker+Jenkins持续集成方案好处 服务高可用：当 Jenkins Master 出现故障时，Kubernetes 会自动创建一个新的 Jenkins Master 容器，并且将 Volume 分配给新创建的容器，保证数据不丢失，从而达到集群服务高可用。 动态伸缩，合理使用资源：每次运行 Job 时，会自动创建一个 Jenkins Slave，Job 完成后，Slave 自动注销并删除容器，资源自动释放，而且 Kubernetes 会根据每个资源的使用情况，动态分配 Slave 到空闲的节点上创建，降低出现因某节点资源利用率高，还排队等待在该节点的情况。 扩展性好：当 Kubernetes 集群的资源严重不足而导致 Job 排队等待时，可以很容易的添加一个 Kubernetes Node 到集群中，从而实现扩展。 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Kubeadm安装Kubernetes Kubernetes的架构 API Server：用于暴露Kubernetes API，任何资源的请求的调用操作都是通过kube-apiserver提供的接 口进行的。 Etcd：是Kubernetes提供默认的存储系统，保存所有集群数据，使用时需要为etcd数据提供备份计 划。 Controller-Manager：作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点 （Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额 （ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化 修复流程，确保集群始终处于预期的工作状态。 Scheduler：监视新创建没有分配到Node的Pod，为Pod选择一个Node。 Kubelet：负责维护容器的生命周期，同时负责Volume和网络的管理 Kube proxy：是Kubernetes的核心组件，部署在每个Node节点上，它是实现Kubernetes Service的通 信与负载均衡机制的重要组件。 安装环境说明 主机名称 IP地址 安装的软件 代码托管服 务器 192.168.66.100 Gitlab-12.4.2 Docker仓库 服务器 192.168.66.102 Harbor1.9.2 k8s-master 192.168.66.101 kube-apiserverscheduler、dock、erkube-contr、etcd、calicooller-manager，NFS 、kube- k8s-node1 192.168.66.103 kubelet、kubeproxy、Docker18.06.1-ce k8s-node2 192.168.66.104 kubelet、kubeproxy、Docker18.06.1-ce 三台机器都需要完成 修改三台机器的hostname及hosts文件 hostnamectl set-hostname k8s-master hostnamectl set-hostname k8s-node1 hostnamectl set-hostname k8s-node2 cat \u003e\u003e/etc/hosts\u003c\u003cEOF 192.168.66.101 k8s-master 192.168.66.103 k8s-node1 192.168.66.104 k8s-node2 EOF 关闭防火墙和关闭SELinux systemctl stop firewalld systemctl disable firewalld setenforce 0 临时关闭 vi /etc/sysconfig/selinux 永久关闭 改为SELINUX=disabled 设置系统参数 设置允许路由转发，不对bridge的数据进行处理 创建文件 vi /etc/sysctl.d/k8s.conf 内容如下： net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 vm.swappiness = 0 执行文件 sysctl -p /etc/sysctl.d/k8s.conf kube-proxy开启ipvs的前置条件^ 所有节点关闭swap swapoff -a 临时关闭 vi /etc/fstab 永久关闭 注释掉以下字段 /dev/mapper/cl-swap swap swap defaults 0 0 安装kubelet、kubeadm、kubectl kubeadm: 用来初始化集群的指令。 kubelet: 在集群中的每个节点上用来启动 pod 和 container 等。 kubectl: 用来与集群通信的命令行工具。 清空yum缓存 设置yum安装源 安装： kubelet设置开机启动（注意：先不启动，现在启动的话会报错） cat \u003e /etc/sysconfig/modules/ipvs.modules \u003c\u003cEOF #!/bin/bash modprobe - - ip_vs modprobe - - ip_vs_rr modprobe - - ip_vs_wrr modprobe - - ip_vs_sh modprobe - - nf_conntrack_ipv 4 EOF chmod 755 /etc/sysconfig/modules/ipvs.modules \u0026\u0026 bash /etc/sysconfig/modules/ipvs.modules \u0026\u0026 lsmod | grep - e ip_vs - e nf_conntrack_ipv 4 yum clean all cat \u003c\u003cEOF \u003e /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el 7 - x 86 _ 64 / enabled= 1 gpgcheck= 0 repo_gpgcheck= 0 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF yum install - y kubelet kubeadm kubectl 查看版本 安装的是最新版本：Kubernetes v1.16.3（可能会变化） Master节点需要完成 1 ）运行初始化命令 注意：apiserver-advertise-address这个地址必须是master机器的IP 常用错误： 错误一：[WARNING IsDockerSystemdCheck]: detected “cgroupfs” as the Docker cgroup driver 作为Docker cgroup驱动程序。，Kubernetes推荐的Docker驱动程序是“systemd” 解决方案：修改Docker的配置: vi /etc/docker/daemon.json，加入 然后重启Docker 错误二：[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2 解决方案：修改虚拟机的CPU的个数，至少为 2 个 安装过程日志： systemctl enable kubelet kubelet - -version kubeadm init - -kubernetes-version= 1. 17. 0 \\ -apiserver-advertise-address= 192. 168. 66. 101 \\ -image-repository registry.aliyuncs.com/google_containers \\ -service-cidr= 10. 1. 0. 0 / 16 \\ -pod-network-cidr= 10. 244. 0. 0 / 16 { \"exec-opts\":[\"native.cgroupdriver=systemd\"] } 最后，会提示节点安装的命令，必须记下来 2 ）启动kubelet 3 ）配置kubectl工具 4 ）安装Calico kubeadm join 192. 168. 66. 101 : 6443 - -token 754 snw. 9 xq 9 cotze 1 ybwnti \\ -discovery-token-ca-cert-hash sha 256 : 3372 ff 6717 ea 5997121213 e 2 c 9 d 63 fa 7 c 8 cdfb 031527 e 17 f 2 e 20254 f 382 ea 03 a systemctl restart kubelet mkdir - p $HOME/.kube sudo cp - i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id - u):$(id - g) $HOME/.kube/config 5 ）等待几分钟，查看所有Pod的状态，确保所有Pod都是Running状态 Slave节点需要完成 1 ）让所有节点让集群环境 使用之前Master节点产生的命令加入集群 2 ）启动kubelet 3 ）回到Master节点查看，如果Status全部为Ready，代表集群环境搭建成功！！！ mkdir k 8 s cd k 8 s wget https://docs.projectcalico.org/v 3. 10 /getting- started/kubernetes/installation/hosted/kubernetes-datastore/calico- networking/ 1. 7 /calico.yaml sed - i 's/ 192. 168. 0. 0 / 10. 244. 0. 0 /g' calico.yam","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"7 、基于Kubernetes/K8S构建Jenkins持续集成平台(下) Jenkins-Master-Slave架构图回顾： ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"安装和配置NFS NFS简介 NFS（Network File System），它最大的功能就是可以通过网络，让不同的机器、不同的操作系统可以 共享彼此的文件。我们可以利用NFS共享Jenkins运行的配置文件、Maven的仓库依赖文件等 NFS安装 kubectl get nodes 查看所有主从节点的状态 kubectl get ns 获取所有namespace资源 kubectl get pods - n {$nameSpace} 获取指定namespace的pod kubectl describe pod的名称 - n {$nameSpace} 查看某个pod的执行过程 kubectl logs - -tail= 1000 pod的名称 | less 查看日志 kubectl create - f xxx.yml 通过配置文件创建一个集群资源对象 kubectl delete - f xxx.yml 通过配置文件删除一个集群资源对象 kubectl delete pod名称 - n {$nameSpace} 通过pod删除集群资源 kubectl get service - n {$nameSpace} 查看pod的service情况 我们把NFS服务器安装在192.168.66.101机器上 1 ）安装NFS服务（在所有K8S的节点都需要安装） 2 ）创建共享目录 3 ）启动服务 4 ）查看NFS共享目录 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"在Kubernetes安装Jenkins-Master 创建NFS client provisioner nfs-client-provisioner 是一个Kubernetes的简易NFS的外部provisioner，本身不提供NFS，需要现有 的NFS服务器提供存储。 1 ）上传nfs-client-provisioner构建文件 其中注意修改deployment.yaml，使用之前配置NFS服务器和目录 yum install - y nfs-utils mkdir - p /opt/nfs/jenkins vi /etc/exports 编写NFS的共享配置 内容如下: /opt/nfs/jenkins *(rw,no_root_squash) *代表对所有IP都开放此目录，rw是读写 systemctl enable nfs 开机启动 systemctl start nfs 启动 showmount - e 192. 168. 66. 101 2 ）构建nfs-client-provisioner的pod资源 3 ）查看pod是否创建成功 安装Jenkins-Master 1 ）上传Jenkins-Master构建文件 其中有两点注意： 第一、在StatefulSet.yaml文件，声明了利用nfs-client-provisioner进行Jenkins-Master文件存储 第二、Service发布方法采用NodePort，会随机产生节点访问端口 cd nfs-client kubectl create - f. 2 ）创建kube-ops的namespace 因为我们把Jenkins-Master的pod放到kube-ops下 3 ）构建Jenkins-Master的pod资源 4 ）查看pod是否创建成功 5 ）查看信息，并访问 查看Pod运行在那个Node上 查看分配的端口 kubectl create namespace kube-ops cd jenkins-master kubectl create - f. kubectl get pods - n kube-ops kubectl describe pods - n kube-ops kubectl get service - n kube-ops 最终访问地址为：http://192.168.66.103:30136 （192.168.66.103为k8s-node1的IP） 安装过程跟之前是一样的！ 6 ）先安装基本的插件 Localization:Chinese Git Pipeline Extended Choice Parameter ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins与Kubernetes整合 安装Kubernetes插件 系统管理-\u003e插件管理-\u003e可选插件 实现Jenkins与Kubernetes整合 系统管理-\u003e系统配置-\u003e云-\u003e新建云-\u003eKubernetes kubernetes地址采用了kube的服务器发现：https://kubernetes.default.svc.cluster.local namespace填kube-ops，然后点击Test Connection，如果出现 Connection test successful 的提 示信息证明 Jenkins 已经可以和 Kubernetes 系统正常通信 Jenkins URL 地址：http://jenkins.kube-ops.svc.cluster.local:8080 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"构建Jenkins-Slave自定义镜像 Jenkins-Master在构建Job的时候，Kubernetes会创建Jenkins-Slave的Pod来完成Job的构建。我们选择 运行Jenkins-Slave的镜像为官方推荐镜像：jenkins/jnlp-slave:latest，但是这个镜像里面并没有Maven 环境，为了方便使用，我们需要自定义一个新的镜像： 准备材料： Dockerfile文件内容如下： FROM jenkins/jnlp-slave:latest MAINTAINER itcast # 切换到 root 账户进行操作 USER root # 安装 maven COPY apache-maven- 3. 6. 2 - bin.tar.gz. RUN tar - zxf apache-maven- 3. 6. 2 - bin.tar.gz \u0026\u0026 \\ mv apache-maven- 3. 6. 2 /usr/local \u0026\u0026 \\ rm - f apache-maven- 3. 6. 2 - bin.tar.gz \u0026\u0026 \\ ln - s /usr/local/apache-maven- 3. 6. 2 /bin/mvn /usr/bin/mvn \u0026\u0026 \\ 构建出一个新镜像：jenkins-slave-maven:latest 然把镜像上传到Harbor的公共库library中 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"测试Jenkins-Slave是否可以创建 1 ）创建一个Jenkins流水线项目 2 ）编写Pipeline，从GItlab拉取代码 ln - s /usr/local/apache-maven- 3. 6. 2 /usr/local/apache-maven \u0026\u0026 \\ mkdir - p /usr/local/apache-maven/repo COPY settings.xml /usr/local/apache-maven/conf/settings.xml USER jenkins docker tag jenkins-slave-maven:latest 192. 168. 66. 102 : 85 /library/jenkins-slave- maven:latest docker push 192. 168. 66. 102 : 85 /library/jenkins-slave-maven:latest def git_address = \"http:// 192. 168. 66. 100 : 82 /itheima_group/tensquare_back_cluster.git\" def git_auth = \" 9 d 9 a 2707 - eab 7 - 4 dc 9 - b 106 - e 52 f 329 cbc 95 \" //创建一个Pod的模板，label为jenkins-slave podTemplate(label: 'jenkins-slave', cloud: 'kubernetes', containers: [ containerTemplate( name: 'jnlp', image: \" 192. 168. 66. 102 : 85 /library/jenkins-slave-maven:latest\" ) ] ) { //引用jenkins-slave的pod模块来构建Jenkins-Slave的pod node(\"jenkins-slave\"){ // 第一步 stage('拉取代码'){ checkout([$class: 'GitSCM', branches: [[name: 'master']], userRemoteConfigs: [[credentialsId: \"${git_auth}\", url: \"${git_address}\"]]]) } } 3 ）查看构建日志 ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+Kubernetes+Docker完成微服务持续集成 拉取代码，构建镜像 1 ）创建NFS共享目录 让所有Jenkins-Slave构建指向NFS的Maven的共享仓库目录 2 ）创建项目，编写构建Pipeline } vi /etc/exports 添加内容： /opt/nfs/jenkins *(rw,no_root_squash) /opt/nfs/maven *(rw,no_root_squash) systemctl restart nfs 重启NFS def git_address = “http:// 192. 168. 66. 100 : 82 /itheima_group/tensquare_back_cluster.git” def git_auth = \" 9 d 9 a 2707 - eab 7 - 4 dc 9 - b 106 - e 52 f 329 cbc 95 \" //构建版本的名称 def tag = “latest” //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 \" //Harbor的项目名称 def harbor_project_name = “tensquare” //Harbor的凭证 def harbor_auth = \" 71 eff 071 - ec 17 - 4219 - bae 1 - 5 d 0093 e 3 d 060 \" podTemplate(label: ‘jenkins-slave’, cloud: ‘kubernetes’, containers: [ containerTemplate( name: ‘jnlp’, image: \" 192. 168. 66. 102 : 85 /library/jenkins-slave-maven:latest\" ), containerTemplate( name: ‘docker’, image: “docker:stable”, ttyEnabled: true, command: ‘cat’ ), ], volumes: [ hostPathVolume(mountPath: ‘/var/run/docker.sock’, hostPath: ‘/var/run/docker.sock’), nfsVolume(mountPath: ‘/usr/local/apache-maven/repo’, serverAddress: ’ 192. 168. 66. 101 ’ , serverPath: ‘/opt/nfs/maven’), ], ) { node(“jenkins-slave”){ // 第一步 stage(‘拉取代码’){ checkout([$class: ‘GitSCM’, branches: [[name: ‘${branch}’]], userRemoteConfigs: [[credentialsId: “${git_auth}”, url: “${git_address}”]]]) } // 第二步 stage(‘代码编译’){ //编译并安装公共工程 sh “mvn - f tensquare_common clean install” } // 第三步 stage(‘构建镜像，部署项目’){ //把选择的项目信息转为数组 def selectedProjects = “${project_name}\".split(’,’) for(int i= 0 ;i\u003cselectedProjects.size();i++){ //取出每个项目的名称和端口 def currentProject = selectedProjects[i]; //项目名称 def currentProjectName = currentProject.split(’@’)[ 0 ] //项目启动端口 def currentProjectPort = currentProject.split(’@’)[ 1 ] //定义镜像名称 注意：在构建过程会发现无法创建仓库目录，是因为NFS共享目录权限不足，需更改权限 还有Docker命令执行权限问题 需要手动上传父工程依赖到NFS的Maven共享仓库目录中 微服务部署到K8S def imageName = \"${currentProjectName}:${tag}\" //编译，构建本地镜像 sh \"mvn - f ${currentProjectName} clean package dockerfile:build\" container('docker') { //给镜像打标签 sh \"docker tag ${imageName} ${harbor_url}/${harbor_project_name}/${imageName}\" //登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId: \"${harbor_auth}\", passwordVariable: 'password', usernameVariable: 'username')]) { //登录 sh \"docker login - u ${username} - p ${password} ${harbor_url}\" //上传镜像 sh \"docker push ${harbor_url}/${harbor_project_name}/${imageName}\" } //删除本地镜像 sh \"docker rmi - f ${imageName}\" sh \"docker rmi - f ${harbor_url}/${harbor_project_name}/${imageName}\" } } } } } chown - R jenkins:jenkins /opt/nfs/maven chmod - R 777 /opt/nfs/maven chmod 777 /var/run/docker.sock 修改每个微服务的application.yml Eureka 其他微服务需要注册到所有Eureka中 1 ）安装Kubernetes Continuous Deploy插件 2 ）修改后的流水线脚本 server: port: ${PORT: 10086 } spring: application: name: eureka eureka: server: # 续期时间，即扫描失效服务的间隔时间（缺省为 60 * 1000 ms） eviction-interval-timer-in-ms: 5000 enable-self-preservation: false use-read-only-response-cache: false client: # eureka client间隔多久去拉取服务注册信息 默认 30 s registry-fetch-interval-seconds: 5 serviceUrl: defaultZone: ${EUREKA_SERVER:http:// 127. 0. 0. 1 :${server.port}/eureka/} instance: # 心跳间隔时间，即发送一次心跳之后，多久在发起下一次（缺省为 30 s） lease-renewal-interval-in-seconds: 5 # 在收到一次心跳之后，等待下一次心跳的空档时间，大于心跳间隔即可，即服务续约到期时间（缺省 为 90 s） lease-expiration-duration-in-seconds: 10 instance-id: ${EUREKA_INSTANCE_HOSTNAME:${spring.application.name}}:${server.port}@${random.l ong( 1000000 , 9999999 )} hostname: ${EUREKA_INSTANCE_HOSTNAME:${spring.application.name}} # Eureka配置 eureka: client: serviceUrl: defaultZone: http://eureka- 0 .eureka: 10086 /eureka/,http://eureka- 1 .eureka: 10086 /eureka/ # Eureka访问地址 instance: preferIpAddress: true 3 ）建立k8s认证凭证 kubeconfig到k8s的Master节点复制 5 ）生成Docker凭证 Docker凭证，用于Kubernetes到Docker私服拉取镜像 6 ）在每个项目下建立deploy.xml Eureka的deply.yml def deploy_image_name = \"${harbor_url}/${harbor_project_name}/${imageName}\" //部署到K 8 S sh \"\"\" sed - i 's#\\$IMAGE_NAME#${deploy_image_name}#' ${currentProjectName}/deploy.yml sed - i 's#\\$SECRET_NAME#${secret_name}#' ${currentProjectName}/deploy.yml \"\"\" ","date":"2021-04-06","objectID":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["数据库"],"content":"一、Nosql概述 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"为什么使用Nosql 1、单机Mysql时代 90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题 数据量增加到一定程度，单机数据库就放不下了 数据的索引（B+ Tree）,一个机器内存也存放不下 访问量变大后（读写混合），一台服务器承受不住。 2、Memcached(缓存) + Mysql + 垂直拆分（读写分离） 网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！ 优化过程经历了以下几个过程： 优化数据库的数据结构和索引(难度大) 文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了 MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。 3、分库分表 + 水平拆分 + Mysql集群 4、如今最近的年代 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。 目前一个基本的互联网项目 为什么要用NoSQL ？ 用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！ 这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"什么是Nosql NoSQL = Not Only SQL（不仅仅是SQL） Not Only Structured Query Language 关系型数据库：列+行，同一个表下数据的结构是一样的。 非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。 NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Nosql特点 方便扩展（数据之间没有关系，很好扩展！） 大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！） 数据类型是多样型的！（不需要事先设计数据库，随取随用） 传统的 RDBMS 和 NoSQL 传统的 RDBMS(关系型数据库) - 结构化组织 - SQL - 数据和关系都存在单独的表中 row col - 操作，数据定义语言 - 严格的一致性 - 基础的事务 - ... Nosql - 不仅仅是数据 - 没有固定的查询语言 - 键值对存储，列存储，文档存储，图形数据库（社交关系） - 最终一致性 - CAP定理和BASE - 高性能，高可用，高扩展 - ... 了解：3V + 3高 大数据时代的3V ：主要是描述问题的 海量Velume 多样Variety 实时Velocity 大数据时代的3高 ： 主要是对程序的要求 高并发 高可扩 高性能 真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"阿里巴巴演进分析 推荐阅读：阿里云的这群疯子https://yq.aliyun.com/articles/653511 # 商品信息 - 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。 # 商品描述、评论(文字居多) - 文档型数据库：MongoDB # 图片 - 分布式文件系统 FastDFS - 淘宝：TFS - Google: GFS - Hadoop: HDFS - 阿里云: oss # 商品关键字 用于搜索 - 搜索引擎：solr,elasticsearch - 阿里：Isearch 多隆 # 商品热门的波段信息 - 内存数据库：Redis，Memcache # 商品交易，外部支付接口 - 第三方应用 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Nosql的四大分类 KV键值对 新浪：Redis 美团：Redis + Tair 阿里、百度：Redis + Memcache 文档型数据库（bson数据格式）： MongoDB(掌握) 基于分布式文件存储的数据库。C++编写，用于处理大量文档。 MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。 ConthDB 列存储数据库 HBase(大数据必学) 分布式文件系统 图关系数据库 用于广告推荐，社交网络 Neo4j、InfoGrid 分类 Examples举例 典型应用场景 数据模型 优点 缺点 键值对（key-value） Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB 内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。 Key 指向 Value 的键值对，通常用hash table来实现 查找速度快 数据无结构化，通常只被当作字符串或者二进制数据 列存储数据库 Cassandra, HBase, Riak 分布式的文件系统 以列簇式存储，将同一列数据存在一起 查找速度快，可扩展性强，更容易进行分布式扩展 功能相对局限 文档型数据库 CouchDB, MongoDb Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容） Key-Value对应的键值对，Value为结构化数据 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 查询性能不高，而且缺乏统一的查询语法。 图形(Graph)数据库 Neo4J, InfoGrid, Infinite Graph 社交网络，推荐系统等。专注于构建关系图谱 图结构 利用图结构相关算法。比如最短路径寻址，N度关系查找等 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"二、Redis入门 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"概述 Redis是什么？ Redis（Remote Dictionary Server )，即远程字典服务。 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis能该干什么？ 内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF） 高效率、用于高速缓冲 发布订阅系统 地图信息分析 计时器、计数器(eg：浏览量) 。。。 特性 多样的数据类型 持久化 集群 事务 … ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"环境搭建 官网：https://redis.io/ 推荐使用Linux服务器学习。 windows版本的Redis已经停更很久了… ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Windows安装 https://github.com/dmajkic/redis 解压安装包 开启redis-server.exe 启动redis-cli.exe测试 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Linux安装 下载安装包！redis-5.0.8.tar.gz 解压Redis的安装包！程序一般放在 /opt 目录下 基本环境安装 yum install gcc-c++ # 然后进入redis目录下执行 make # 然后执行 make install redis默认安装路径 /usr/local/bin 将redis的配置文件复制到 程序安装目录 /usr/local/bin/kconfig下 redis默认不是后台启动的，需要修改配置文件！ 通过制定的配置文件启动redis服务 使用redis-cli连接指定的端口号测试，Redis的默认端口6379 查看redis进程是否开启 关闭Redis服务 shutdown 再次查看进程是否存在 后面我们会使用单机多Redis启动集群测试 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"测试性能 **redis-benchmark：**Redis官方提供的性能测试工具，参数选项如下： 简单测试： # 测试：100个并发连接 100000请求 redis-benchmark -h localhost -p 6379 -c 100 -n 100000 12 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"基础知识 redis默认有16个数据库 默认使用的第0个; 16个数据库为：DB 0~DB 15 默认使用DB 0 ，可以使用select n切换到DB n，dbsize可以查看当前数据库的大小，与key数量相关。 127.0.0.1:6379\u003e config get databases # 命令行查看数据库数量databases 1) \"databases\" 2) \"16\" 127.0.0.1:6379\u003e select 8 # 切换数据库 DB 8 OK 127.0.0.1:6379[8]\u003e dbsize # 查看数据库大小 (integer) 0 # 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。 127.0.0.1:6379\u003e set name sakura OK 127.0.0.1:6379\u003e SELECT 8 OK 127.0.0.1:6379[8]\u003e get name # db8中并不能获取db0中的键值对。 (nil) 127.0.0.1:6379[8]\u003e DBSIZE (integer) 0 127.0.0.1:6379[8]\u003e SELECT 0 OK 127.0.0.1:6379\u003e keys * 1) \"counter:__rand_int__\" 2) \"mylist\" 3) \"name\" 4) \"key:__rand_int__\" 5) \"myset:__rand_int__\" 127.0.0.1:6379\u003e DBSIZE # size和key个数相关 (integer) 5 keys * ：查看当前数据库中所有的key。 flushdb：清空当前数据库中的键值对。 flushall：清空所有数据库的键值对。 Redis是单线程的，Redis是基于内存操作的。 所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。 那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+ Redis为什么单线程还这么快？ 误区1：高性能的服务器一定是多线程的？ 误区2：多线程（CPU上下文会切换！）一定比单线程效率高！ 核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:6","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"三、五大数据类型 Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Redis-key 在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。 下面学习的命令： exists key：判断键是否存在 del key：删除键值对 move key db：将键值对移动到指定数据库 expire key second：设置键值对的过期时间 type key：查看value的数据类型 127.0.0.1:6379\u003e keys * # 查看当前数据库所有key (empty list or set) 127.0.0.1:6379\u003e set name qinjiang # set key OK 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e keys * 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e move age 1 # 将键值对移动到指定数据库 (integer) 1 127.0.0.1:6379\u003e EXISTS age # 判断键是否存在 (integer) 0 # 不存在 127.0.0.1:6379\u003e EXISTS name (integer) 1 # 存在 127.0.0.1:6379\u003e SELECT 1 OK 127.0.0.1:6379[1]\u003e keys * 1) \"age\" 127.0.0.1:6379[1]\u003e del age # 删除键值对 (integer) 1 # 删除个数 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e EXPIRE age 15 # 设置键值对的过期时间 (integer) 1 # 设置成功 开始计数 127.0.0.1:6379\u003e ttl age # 查看key的过期剩余时间 (integer) 13 127.0.0.1:6379\u003e ttl age (integer) 11 127.0.0.1:6379\u003e ttl age (integer) 9 127.0.0.1:6379\u003e ttl age (integer) -2 # -2 表示key过期，-1表示key未设置过期时间 127.0.0.1:6379\u003e get age # 过期的key 会被自动delete (nil) 127.0.0.1:6379\u003e keys * 1) \"name\" 127.0.0.1:6379\u003e type name # 查看value的数据类型 string 关于TTL命令 Redis的key，通过TTL命令返回key的过期时间，一般来说有3种： 当前key没有设置过期时间，所以会返回-1. 当前key有设置过期时间，而且key已经过期，所以会返回-2. 当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间. 关于重命名RENAME和RENAMENX RENAME key newkey修改 key 的名称 RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。 更多命令学习：https://www.redis.net.cn/order/ [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wBVZtGVm-1597890996517)(狂神说 Redis.assets/image-20200813114228439.png)] ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"String(字符串) 普通的set、get直接略过。 命令 描述 示例 APPEND key value 向指定的key的value后追加字符串 127.0.0.1:6379\u003e set msg hello OK 127.0.0.1:6379\u003e append msg \" world\" (integer) 11 127.0.0.1:6379\u003e get msg “hello world” DECR/INCR key 将指定key的value数值进行+1/-1(仅对于数字) 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e incr age (integer) 21 127.0.0.1:6379\u003e decr age (integer) 20 INCRBY/DECRBY key n 按指定的步长对数值进行加减 127.0.0.1:6379\u003e INCRBY age 5 (integer) 25 127.0.0.1:6379\u003e DECRBY age 10 (integer) 15 INCRBYFLOAT key n 为数值加上浮点型数值 127.0.0.1:6379\u003e INCRBYFLOAT age 5.2 “20.2” STRLEN key 获取key保存值的字符串长度 127.0.0.1:6379\u003e get msg “hello world” 127.0.0.1:6379\u003e STRLEN msg (integer) 11 GETRANGE key start end 按起止位置获取字符串（闭区间，起止位置都取） 127.0.0.1:6379\u003e get msg “hello world” 127.0.0.1:6379\u003e GETRANGE msg 3 9 “lo worl” SETRANGE key offset value 用指定的value 替换key中 offset开始的值 127.0.0.1:6379\u003e SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379\u003e get msg “tehello” GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 127.0.0.1:6379\u003e GETSET msg test “hello world” SETNX key value 仅当key不存在时进行set 127.0.0.1:6379\u003e SETNX msg test (integer) 0 127.0.0.1:6379\u003e SETNX name sakura (integer) 1 SETEX key seconds value set 键值对并设置过期时间 127.0.0.1:6379\u003e setex name 10 root OK 127.0.0.1:6379\u003e get name (nil) MSET key1 value1 [key2 value2..] 批量set键值对 127.0.0.1:6379\u003e MSET k1 v1 k2 v2 k3 v3 OK MSETNX key1 value1 [key2 value2..] 批量设置键值对，仅当参数中所有的key都不存在时执行 127.0.0.1:6379\u003e MSETNX k1 v1 k4 v4 (integer) 0 MGET key1 [key2..] 批量获取多个key保存的值 127.0.0.1:6379\u003e MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3” PSETEX key milliseconds value 和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间， getset key value 如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值 String类似的使用场景：value除了是字符串还可以是数字，用途举例： 计数器 统计多单位的数量：uid:123666：follow 0 粉丝数 对象存储缓存 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"List(列表) Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等 正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN 命令 描述 LPUSH/RPUSH key value1[value2..] 从左边/右边向列表中PUSH值(一个或者多个)。 LRANGE key start end 获取list 起止元素==（索引从左往右 递增）== LPUSHX/RPUSHX key value 向已存在的列名中push值（一个或者多个） `LINSERT key BEFORE AFTER pivot value` LLEN key 查看列表长度 LINDEX key index 通过索引获取列表元素 LSET key index value 通过索引为元素设值 LPOP/RPOP key 从最左边/最右边移除值 并返回 RPOPLPUSH source destination 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部 LTRIM key start end 通过下标截取指定范围内的列表 LREM key count value List中是允许value重复的 count \u003e 0：从头部开始搜索 然后删除指定的value 至多删除count个 count \u003c 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。 BLPOP/BRPOP key1[key2] timout 移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOPLPUSH source destination timeout 和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 ---------------------------LPUSH---RPUSH---LRANGE-------------------------------- 127.0.0.1:6379\u003e LPUSH mylist k1 # LPUSH mylist=\u003e{1} (integer) 1 127.0.0.1:6379\u003e LPUSH mylist k2 # LPUSH mylist=\u003e{2,1} (integer) 2 127.0.0.1:6379\u003e RPUSH mylist k3 # RPUSH mylist=\u003e{2,1,3} (integer) 3 127.0.0.1:6379\u003e get mylist # 普通的get是无法获取list值的 (error) WRONGTYPE Operation against a key holding the wrong kind of value 127.0.0.1:6379\u003e LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素 1) \"k2\" 2) \"k1\" 3) \"k3\" 127.0.0.1:6379\u003e LRANGE mylist 0 2 1) \"k2\" 2) \"k1\" 3) \"k3\" 127.0.0.1:6379\u003e LRANGE mylist 0 1 1) \"k2\" 2) \"k1\" 127.0.0.1:6379\u003e LRANGE mylist 0 -1 # 获取全部元素 1) \"k2\" 2) \"k1\" 3) \"k3\" ---------------------------LPUSHX---RPUSHX----------------------------------- 127.0.0.1:6379\u003e LPUSHX list v1 # list不存在 LPUSHX失败 (integer) 0 127.0.0.1:6379\u003e LPUSHX list v1 v2 (integer) 0 127.0.0.1:6379\u003e LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5 (integer) 5 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"k1\" 5) \"k3\" ---------------------------LINSERT--LLEN--LINDEX--LSET---------------------------- 127.0.0.1:6379\u003e LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1 (integer) 6 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"ins_key1\" 5) \"k1\" 6) \"k3\" 127.0.0.1:6379\u003e LLEN mylist # 查看mylist的长度 (integer) 6 127.0.0.1:6379\u003e LINDEX mylist 3 # 获取下标为3的元素 \"ins_key1\" 127.0.0.1:6379\u003e LINDEX mylist 0 \"k5\" 127.0.0.1:6379\u003e LSET mylist 3 k6 # 将下标3的元素 set值为k6 OK 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"k6\" 5) \"k1\" 6) \"k3\" ---------------------------LPOP--RPOP-------------------------- 127.0.0.1:6379\u003e LPOP mylist # 左侧(头部)弹出 \"k5\" 127.0.0.1:6379\u003e RPOP mylist # 右侧(尾部)弹出 \"k3\" ---------------------------RPOPLPUSH-------------------------- 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" 3) \"k6\" 4) \"k1\" 127.0.0.1:6379\u003e RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部 \"k1\" 127.0.0.1:6379\u003e LRANGE newlist 0 -1 1) \"k1\" 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" 3) \"k6\" ---------------------------LTRIM-------------------------- 127.0.0.1:6379\u003e LTRIM mylist 0 1 # 截取mylist中的 0~1部分 OK 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" # 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2 ---------------------------LREM-------------------------- 127.0.0.1:6379\u003e LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2 (integer) 3 # 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2 127.0.0.1:6379\u003e LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2 (integer) 2 # 删除后：mylist: k2,k2,k2,k4,k2,k2 ---------------------------BLPOP--BRPOP-------------------------- mylist: k2,k2,k2,k4,k2,k2 newlist: k1 127.0.0.1:6379\u003e BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选 1) \"newlist\" # 弹出 2) \"k1\" 127.0.0.1:6379\u003e BLPOP newlist mylist 30 1) \"mylist\" # 由于newlist空了 从mylist中弹出 2) \"k2\" 127.0.0.1:6379\u003e BLPOP newlist 30 (30.10s) # 超时了 127.0.0.1:6379\u003e BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。 1) \"newlist\" 2) \"test\" (12.54s) 小结 list实际上是一个链表，before Node after , left, right 都可以插入值 如果key不存在，则创建新的链表 如果key存在，新增内容 如果移除了所有值，空链表，也代表不存在 在两边插入或者改动值，效率最高！修改中间元素，效率相对较低 应用： 消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop） ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Set(集合) Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 命令 描述 SADD key member1[member2..] 向集合中无序增加一个/多个成员 SCARD key 获取集合的成员数 SMEMBERS key 返回集合中所有的成员 SISMEMBER key member 查询member元素是否是集合的成员,结果是无序的 SRANDMEMBER key [count] 随机返回集合中count个成员，count缺省值为1 SPOP key [count] 随机移除并返回集合中count个成员，count缺省值为1 SMOVE source destination member 将source集合的成员member移动到destination集合 SREM key member1[member2..] 移除集合中一个/多个成员 SDIFF key1[key2..] 返回所有集合的差集 key1- key2 - … SDIFFSTORE destination key1[key2..] 在SDIFF的基础上，将结果保存到集合中==(覆盖)==。不能保存到其他类型key噢！ SINTER key1 [key2..] 返回所有集合的交集 SINTERSTORE destination key1[key2..] 在SINTER的基础上，存储结果到集合中。覆盖 SUNION key1 [key2..] 返回所有集合的并集 SUNIONSTORE destination key1 [key2..] 在SUNION的基础上，存储结果到及和张。覆盖 SSCAN KEY [MATCH pattern] [COUNT count] 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分 ---------------SADD--SCARD--SMEMBERS--SISMEMBER-------------------- 127.0.0.1:6379\u003e SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4 (integer) 4 127.0.0.1:6379\u003e SCARD myset # 获取集合的成员数目 (integer) 4 127.0.0.1:6379\u003e smembers myset # 获取集合中所有成员 1) \"m4\" 2) \"m3\" 3) \"m2\" 4) \"m1\" 127.0.0.1:6379\u003e SISMEMBER myset m5 # 查询m5是否是myset的成员 (integer) 0 # 不是，返回0 127.0.0.1:6379\u003e SISMEMBER myset m2 (integer) 1 # 是，返回1 127.0.0.1:6379\u003e SISMEMBER myset m3 (integer) 1 ---------------------SRANDMEMBER--SPOP---------------------------------- 127.0.0.1:6379\u003e SRANDMEMBER myset 3 # 随机返回3个成员 1) \"m2\" 2) \"m3\" 3) \"m4\" 127.0.0.1:6379\u003e SRANDMEMBER myset # 随机返回1个成员 \"m3\" 127.0.0.1:6379\u003e SPOP myset 2 # 随机移除并返回2个成员 1) \"m1\" 2) \"m4\" # 将set还原到{m1,m2,m3,m4} ---------------------SMOVE--SREM---------------------------------------- 127.0.0.1:6379\u003e SMOVE myset newset m3 # 将myset中m3成员移动到newset集合 (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset 1) \"m4\" 2) \"m2\" 3) \"m1\" 127.0.0.1:6379\u003e SMEMBERS newset 1) \"m3\" 127.0.0.1:6379\u003e SREM newset m3 # 从newset中移除m3元素 (integer) 1 127.0.0.1:6379\u003e SMEMBERS newset (empty list or set) # 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算 # setx=\u003e{m1,m2,m4,m6}, sety=\u003e{m2,m5,m6}, setz=\u003e{m1,m3,m6} -----------------------------SDIFF------------------------------------ 127.0.0.1:6379\u003e SDIFF setx sety setz # 等价于setx-sety-setz 1) \"m4\" 127.0.0.1:6379\u003e SDIFF setx sety # setx - sety 1) \"m4\" 2) \"m1\" 127.0.0.1:6379\u003e SDIFF sety setx # sety - setx 1) \"m5\" -------------------------SINTER--------------------------------------- # 共同关注（交集） 127.0.0.1:6379\u003e SINTER setx sety setz # 求 setx、sety、setx的交集 1) \"m6\" 127.0.0.1:6379\u003e SINTER setx sety # 求setx sety的交集 1) \"m2\" 2) \"m6\" -------------------------SUNION--------------------------------------- 127.0.0.1:6379\u003e SUNION setx sety setz # setx sety setz的并集 1) \"m4\" 2) \"m6\" 3) \"m3\" 4) \"m2\" 5) \"m1\" 6) \"m5\" 127.0.0.1:6379\u003e SUNION setx sety # setx sety 并集 1) \"m4\" 2) \"m6\" 3) \"m2\" 4) \"m1\" 5) \"m5\" ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Hash（哈希） Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。 Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。 命令 描述 HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0 HMSET key field1 value1 [field2 value2..] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 HGET key field value 获取存储在哈希表中指定字段的值 HMGET key field1 [field2..] 获取所有给定字段的值 HGETALL key 获取在哈希表key 的所有字段和值 HKEYS key 获取哈希表key中所有的字段 HLEN key 获取哈希表中字段的数量 HVALS key 获取哈希表中所有值 HDEL key field1 [field2..] 删除哈希表key中一个/多个field字段 HINCRBY key field n 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段 HINCRBYFLOAT key field n 为哈希表 key 中的指定字段的浮点数值加上增量 n。 HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。 ------------------------HSET--HMSET--HSETNX---------------- 127.0.0.1:6379\u003e HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura (integer) 1 127.0.0.1:6379\u003e HSET studentx name gyc # 重复设置field进行覆盖，并返回0 (integer) 0 127.0.0.1:6379\u003e HSET studentx age 20 # 设置studentx的age为20 (integer) 1 127.0.0.1:6379\u003e HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886 OK 127.0.0.1:6379\u003e HSETNX studentx name gyc # HSETNX 设置已存在的field (integer) 0 # 失败 127.0.0.1:6379\u003e HSETNX studentx email 12345@qq.com (integer) 1 # 成功 ----------------------HEXISTS-------------------------------- 127.0.0.1:6379\u003e HEXISTS studentx name # name字段在studentx中是否存在 (integer) 1 # 存在 127.0.0.1:6379\u003e HEXISTS studentx addr (integer) 0 # 不存在 -------------------HGET--HMGET--HGETALL----------- 127.0.0.1:6379\u003e HGET studentx name # 获取studentx中name字段的value \"gyc\" 127.0.0.1:6379\u003e HMGET studentx name age tel # 获取studentx中name、age、tel字段的value 1) \"gyc\" 2) \"20\" 3) \"15623667886\" 127.0.0.1:6379\u003e HGETALL studentx # 获取studentx中所有的field及其value 1) \"name\" 2) \"gyc\" 3) \"age\" 4) \"20\" 5) \"sex\" 6) \"1\" 7) \"tel\" 8) \"15623667886\" 9) \"email\" 10) \"12345@qq.com\" --------------------HKEYS--HLEN--HVALS-------------- 127.0.0.1:6379\u003e HKEYS studentx # 查看studentx中所有的field 1) \"name\" 2) \"age\" 3) \"sex\" 4) \"tel\" 5) \"email\" 127.0.0.1:6379\u003e HLEN studentx # 查看studentx中的字段数量 (integer) 5 127.0.0.1:6379\u003e HVALS studentx # 查看studentx中所有的value 1) \"gyc\" 2) \"20\" 3) \"1\" 4) \"15623667886\" 5) \"12345@qq.com\" -------------------------HDEL-------------------------- 127.0.0.1:6379\u003e HDEL studentx sex tel # 删除studentx 中的sex、tel字段 (integer) 2 127.0.0.1:6379\u003e HKEYS studentx 1) \"name\" 2) \"age\" 3) \"email\" -------------HINCRBY--HINCRBYFLOAT------------------------ 127.0.0.1:6379\u003e HINCRBY studentx age 1 # studentx的age字段数值+1 (integer) 21 127.0.0.1:6379\u003e HINCRBY studentx name 1 # 非整数字型字段不可用 (error) ERR hash value is not an integer 127.0.0.1:6379\u003e HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6 \"90.8\" Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Zset（有序集合） 不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。 score相同：按字典顺序排序 有序集合的成员是唯一的,但分数(score)却可以重复。 命令 描述 ZADD key score member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数 ZCARD key 获取有序集合的成员数 ZCOUNT key min max 计算在有序集合中指定区间score的成员数 ZINCRBY key n member 有序集合中对指定成员的分数加上增量 n ZSCORE key member 返回有序集中，成员的分数值 ZRANK key member 返回有序集合中指定成员的索引 ZRANGE key start end 通过索引区间返回有序集合成指定区间内的成员 ZRANGEBYLEX key min max 通过字典区间返回有序集合的成员 ZRANGEBYSCORE key min max 通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()== ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量 ZREM key member1 [member2..] 移除有序集合中一个/多个成员 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员 ZREVRANGE key start end 返回有序集中指定区间内的成员，通过索引，分数从高到底 ZREVRANGEBYSCORRE key max min 返回有序集中指定分数区间内的成员，分数从高到低排序 ZREVRANGEBYLEX key max min 返回有序集中指定字典区间内的成员，按字典顺序倒序 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 ZINTERSTORE destination numkeys key1 [key2 ..] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score ZUNIONSTORE destination numkeys key1 [key2..] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 ZSCAN key cursor [MATCH pattern\\] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值） -------------------ZADD--ZCARD--ZCOUNT-------------- 127.0.0.1:6379\u003e ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2.. (integer) 2 127.0.0.1:6379\u003e ZCARD myzset # 获取有序集合的成员数 (integer) 2 127.0.0.1:6379\u003e ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量 (integer) 1 127.0.0.1:6379\u003e ZCOUNT myzset 0 2 (integer) 2 ----------------ZINCRBY--ZSCORE-------------------------- 127.0.0.1:6379\u003e ZINCRBY myzset 5 m2 # 将成员m2的score +5 \"7\" 127.0.0.1:6379\u003e ZSCORE myzset m1 # 获取成员m1的score \"1\" 127.0.0.1:6379\u003e ZSCORE myzset m2 \"7\" --------------ZRANK--ZRANGE----------------------------------- 127.0.0.1:6379\u003e ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加 (integer) 0 127.0.0.1:6379\u003e ZRANK myzset m2 (integer) 2 127.0.0.1:6379\u003e ZRANGE myzset 0 1 # 获取索引在 0~1的成员 1) \"m1\" 2) \"m3\" 127.0.0.1:6379\u003e ZRANGE myzset 0 -1 # 获取全部成员 1) \"m1\" 2) \"m3\" 3) \"m2\" #testset=\u003e{abc,add,amaze,apple,back,java,redis} score均为0 ------------------ZRANGEBYLEX--------------------------------- 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + # 返回所有成员 1) \"abc\" 2) \"add\" 3) \"amaze\" 4) \"apple\" 5) \"back\" 6) \"java\" 7) \"redis\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录 1) \"abc\" 2) \"add\" 3) \"amaze\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录 1) \"apple\" 2) \"back\" 3) \"java\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员 1) \"abc\" 2) \"add\" 3) \"amaze\" 4) \"apple\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员 1) \"apple\" 2) \"back\" 3) \"java\" -----------------------ZRANGEBYSCORE--------------------- 127.0.0.1:6379\u003e ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员 1) \"m1\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e ZRANGEBYSCORE myzset 1 5 1) \"m1\" 2) \"m3\" --------------------ZLEXCOUNT----------------------------- 127.0.0.1:6379\u003e ZLEXCOUNT testset - + (integer) 7 127.0.0.1:6379\u003e ZLEXCOUNT testset [apple [java (integer) 3 ------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE-------------------------------- 127.0.0.1:6379\u003e ZREM testset abc # 移除成员abc (integer) 1 127.0.0.1:6379\u003e ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员 (integer) 3 127.0.0.1:6379\u003e ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员 (integer) 2 127.0.0.1:6379\u003e ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员 (integer) 2 # testset=\u003e {abc,add,apple,amaze,back,java,redis} score均为0 # myzset=\u003e {(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)} ----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX----------- 127.0.0.1:6379\u003e ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3 1) \"m9\" 2) \"m7\" 3) \"m4\" 4) \"m3\" 127.0.0.1:6379\u003e ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4 1) \"m4\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员 1) \"m4\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:6","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"四、三种特殊数据类型 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Geospatial(地理位置) 使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用 命令 描述 geoadd key longitud(经度) latitude(纬度) member [..] 将具体经纬度的坐标存入一个有序集合 geopos key member [member..] 获取集合中的一个/多个成员坐标 geodist key member1 member2 [unit] 返回两个给定位置之间的距离。默认以米作为单位。 `georadius key longitude latitude radius m km GEORADIUSBYMEMBER key member radius... 功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。 geohash key member1 [member2..] 返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。 有效经纬度 有效的经度从-180度到180度。 有效的纬度从-85.05112878度到85.05112878度。 指定单位的参数 unit 必须是以下单位的其中一个： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 关于GEORADIUS的参数 通过georadius就可以完成 附近的人功能 withcoord:带上坐标 withdist:带上距离，单位与半径单位相同 COUNT n : 只显示前n个(按距离递增排序) ----------------georadius--------------------- 127.0.0.1:6379\u003e GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员 1) 1) \"hangzhou\" 2) \"29.4151\" 3) 1) \"120.20000249147415\" 2) \"30.199999888333501\" 2) 1) \"shanghai\" 2) \"205.3611\" 3) 1) \"121.40000134706497\" 2) \"31.400000253193539\" ------------geohash--------------------------- 127.0.0.1:6379\u003e geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示 1) \"wmrjwbr5250\" 2) \"wtw6ds0y300\" ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Hyperloglog(基数统计) Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。 因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 其底层使用string数据类型 什么是基数？ 数据集中不重复的元素的个数。 应用场景： 网页的访问量（UV）：一个用户多次访问，也只能算作一个人。 传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。 命令 描述 PFADD key element1 [elememt2..] 添加指定元素到 HyperLogLog 中 PFCOUNT key [key] 返回给定 HyperLogLog 的基数估算值。 PFMERGE destkey sourcekey [sourcekey..] 将多个 HyperLogLog 合并为一个 HyperLogLog ----------PFADD--PFCOUNT--------------------- 127.0.0.1:6379\u003e PFADD myelemx a b c d e f g h i j k # 添加元素 (integer) 1 127.0.0.1:6379\u003e type myelemx # hyperloglog底层使用String string 127.0.0.1:6379\u003e PFCOUNT myelemx # 估算myelemx的基数 (integer) 11 127.0.0.1:6379\u003e PFADD myelemy i j k z m c b v p q s (integer) 1 127.0.0.1:6379\u003e PFCOUNT myelemy (integer) 11 ----------------PFMERGE----------------------- 127.0.0.1:6379\u003e PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemz OK 127.0.0.1:6379\u003e PFCOUNT myelemz # 估算基数 (integer) 17 如果允许容错，那么一定可以使用Hyperloglog ! 如果不允许容错，就使用set或者自己的数据类型即可 ！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"BitMaps(位图) 使用位存储，信息状态只有 0 和 1 Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。 应用场景 签到统计、状态统计 命令 描述 setbit key offset value 为指定key的offset位设置值 getbit key offset 获取offset位的值 bitcount key [start end] 统计字符串被设置为1的bit数，也可以指定统计范围按字节 bitop operration destkey key[key..] 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 BITPOS key bit [start] [end] 返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位 ------------setbit--getbit-------------- 127.0.0.1:6379\u003e setbit sign 0 1 # 设置sign的第0位为 1 (integer) 0 127.0.0.1:6379\u003e setbit sign 2 1 # 设置sign的第2位为 1 不设置默认 是0 (integer) 0 127.0.0.1:6379\u003e setbit sign 3 1 (integer) 0 127.0.0.1:6379\u003e setbit sign 5 1 (integer) 0 127.0.0.1:6379\u003e type sign string 127.0.0.1:6379\u003e getbit sign 2 # 获取第2位的数值 (integer) 1 127.0.0.1:6379\u003e getbit sign 3 (integer) 1 127.0.0.1:6379\u003e getbit sign 4 # 未设置默认是0 (integer) 0 -----------bitcount---------------------------- 127.0.0.1:6379\u003e BITCOUNT sign # 统计sign中为1的位数 (integer) 4 bitmaps的底层 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PlszjhS-1597890996519)(D:\\我\\MyBlog\\狂神说 Redis.assets\\image-20200803234336175.png)] 这样设置以后你能get到的值是：\\xA2\\x80，所以bitmaps是一串从左到右的二进制串 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"五、事务 Redis的单条命令是保证原子性的，但是redis事务不能保证原子性 Redis事务本质：一组命令的集合。 —————– 队列 set set set 执行 ——————- 事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。 一次性 顺序性 排他性 Redis事务没有隔离级别的概念 Redis单条命令是保证原子性的，但是事务不保证原子性！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Redis事务操作过程 开启事务（multi） 命令入队 执行事务（exec） 所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。 127.0.0.1:6379\u003e multi # 开启事务 OK 127.0.0.1:6379\u003e set k1 v1 # 命令入队 QUEUED 127.0.0.1:6379\u003e set k2 v2 # .. QUEUED 127.0.0.1:6379\u003e get k1 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e keys * QUEUED 127.0.0.1:6379\u003e exec # 事务执行 1) OK 2) OK 3) \"v1\" 4) OK 5) 1) \"k3\" 2) \"k2\" 3) \"k1\" 取消事务(discurd) 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e DISCARD # 放弃事务 OK 127.0.0.1:6379\u003e EXEC (error) ERR EXEC without MULTI # 当前未开启事务 127.0.0.1:6379\u003e get k1 # 被放弃事务中命令并未执行 (nil) ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"事务错误 代码语法错误（编译时异常）所有的命令都不执行 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e error k1 # 这是一条语法错误命令 (error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e EXEC (error) EXECABORT Transaction discarded because of previous errors. # 执行报错 127.0.0.1:6379\u003e get k1 (nil) # 其他命令并没有被执行 代码逻辑错误 (运行时异常) **其他命令可以正常执行 ** »\u003e 所以不保证事务原子性 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e INCR k1 # 这条命令逻辑错误（对字符串进行增量） QUEUED 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e exec 1) OK 2) OK 3) (error) ERR value is not an integer or out of range # 运行时报错 4) \"v2\" # 其他命令正常执行 # 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。 # 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"监控 悲观锁： 很悲观，认为什么时候都会出现问题，无论做什么都会加锁 乐观锁： 很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据 获取version 更新的时候比较version 使用watch key监控指定数据，相当于乐观锁加锁。 正常执行 127.0.0.1:6379\u003e set money 100 # 设置余额:100 OK 127.0.0.1:6379\u003e set use 0 # 支出使用:0 OK 127.0.0.1:6379\u003e watch money # 监视money (上锁) OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY use 20 QUEUED 127.0.0.1:6379\u003e exec # 监视值没有被中途修改，事务正常执行 1) (integer) 80 2) (integer) 20 测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion） 我们启动另外一个客户端模拟插队线程。 线程1： 127.0.0.1:6379\u003e watch money # money上锁 OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY use 20 QUEUED 127.0.0.1:6379\u003e # 此时事务并没有执行 模拟线程插队，线程2： 127.0.0.1:6379\u003e INCRBY money 500 # 修改了线程一中监视的money (integer) 600 12 回到线程1，执行事务： 127.0.0.1:6379\u003e EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败 (nil) # 没有结果，说明事务执行失败 127.0.0.1:6379\u003e get money # 线程2 修改生效 \"600\" 127.0.0.1:6379\u003e get use # 线程1事务执行失败，数值没有被修改 \"0\" 解锁获取最新值，然后再加锁进行事务。 unwatch进行解锁。 注意：每次提交执行exec后都会自动释放锁，不管是否成功 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"六、Jedis 使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。 导入依赖 \u003c!--导入jredis的包--\u003e \u003cdependency\u003e \u003cgroupId\u003eredis.clients\u003c/groupId\u003e \u003cartifactId\u003ejedis\u003c/artifactId\u003e \u003cversion\u003e3.2.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--fastjson--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.70\u003c/version\u003e \u003c/dependency\u003e 编码测试 连接数据库 修改redis的配置文件 vim /usr/local/bin/myconfig/redis.conf 1 将只绑定本地注释 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4IRUFJ95-1597890996520)(狂神说 Redis.assets/image-20200813161921480.png)] 保护模式改为 no [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oKjIVapw-1597890996521)(狂神说 Redis.assets/image-20200813161939847.png)] 允许后台运行 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c2IMvpZL-1597890996522)(狂神说 Redis.assets/image-20200813161954567.png)] 开放端口6379 firewall-cmd --zone=public --add-port=6379/tcp --permanet 1 重启防火墙服务 systemctl restart firewalld.service 1 阿里云服务器控制台配置安全组 重启redis-server [root@AlibabaECS bin]# redis-server myconfig/redis.conf 1 操作命令 TestPing.java public class TestPing { public static void main(String[] args) { Jedis jedis = new Jedis(\"192.168.xx.xxx\", 6379); String response = jedis.ping(); System.out.println(response); // PONG } } 断开连接 事务 public class TestTX { public static void main(String[] args) { Jedis jedis = new Jedis(\"39.99.xxx.xx\", 6379); JSONObject jsonObject = new JSONObject(); jsonObject.put(\"hello\", \"world\"); jsonObject.put(\"name\", \"kuangshen\"); // 开启事务 Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); // jedis.watch(result) try { multi.set(\"user1\", result); multi.set(\"user2\", result); // 执行事务 multi.exec(); }catch (Exception e){ // 放弃事务 multi.discard(); } finally { // 关闭连接 System.out.println(jedis.get(\"user1\")); System.out.println(jedis.get(\"user2\")); jedis.close(); } } } ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:6:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"七、SpringBoot整合 导入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。 jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式 lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式 我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。 那么就一定还存在一个RedisProperties类 之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。 先看Jedis: @ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的 然后再看Lettuce： 完美生效。 现在我们回到RedisAutoConfiguratio 只有两个简单的Bean RedisTemplate StringRedisTemplate 当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。 在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的 说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties 这是一些基本的配置属性。 还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。 编写配置文件 # 配置redis spring.redis.host=39.99.xxx.xx spring.redis.port=6379 使用RedisTemplate @SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { // redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // opsForValue 操作字符串 类似String // opsForList 操作List 类似List // opsForHah // 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD // 获取连接对象 //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); //connection.flushDb(); //connection.flushAll(); redisTemplate.opsForValue().set(\"mykey\",\"kuangshen\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\")); } } 测试结果 此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出： 这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。 我们转到看那个默认的RedisTemplate内部什么样子： 在最开始就能看到几个关于序列化的参数。 默认的序列化器是采用JDK序列化器 而默认的RedisTemplate中的所有序列化器都是使用这个序列化器： 后续我们定制RedisTemplate就可以对其进行修改。 RedisSerializer提供了多种序列化方案： 直接调用RedisSerializer的静态方法来返回序列化器，然后set 自己new 相应的实现类，然后set 定制RedisTemplate的模板： 我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。 @Configuration public class RedisConfig { @Bean public RedisTemplate\u003cString, Object\u003e redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { // 将template 泛型设置为 \u003cString, Object\u003e RedisTemplate\u003cString, Object\u003e template = new RedisTemplate(); // 连接工厂，不必修改 template.setConnectionFactory(redisConnectionFactory); /* * 序列化设置 */ // key、hash的key 采用 String序列化方式 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // value、hash的value 采用 Jackson 序列化方式 template.setValueSerializer(RedisSerializer.json()); template.setHashValueSerializer(RedisSerializer.json()); template.afterPropertiesSet(); return template; } } 这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oc8kJP08-1597890996523)(狂神说 Redis.assets/image-20200817175638086.png)] ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:7:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"八、自定义Redis工具类 使用RedisTemplate需要频繁调用.opForxxx然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。 工具类参考博客： https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html https://www.cnblogs.com/zhzhlong/p/11434284.html ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:8:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"九、Redis.conf 容量单位不区分大小写，G和GB有区别 可以使用 include 组合多个配置问题 网络配置 日志输出级别 日志输出文件 持久化规则 由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中 持久化方式： RDB AOF RDB文件相关 主从复制 Security模块中进行密码设置 客户端连接相关 maxclients 10000 最大客户端数量 maxmemory \u003cbytes\u003e 最大内存限制 maxmemory-policy noeviction # 内存达到限制值的处理策略 redis 中的默认的过期策略是 volatile-lru 。 设置方式 config set maxmemory-policy volatile-lru 1 maxmemory-policy 六种方式 **1、volatile-lru：**只对设置了过期时间的key进行LRU（默认值） 2、allkeys-lru ： 删除lru算法的key **3、volatile-random：**随机删除即将过期key **4、allkeys-random：**随机删除 5、volatile-ttl ： 删除即将过期的 6、noeviction ： 永不过期，返回错误 AOF相关部分 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:9:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十、持久化—RDB RDB：Redis Databases [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-C0mm1D4A-1597890996524)(狂神说 Redis.assets/image-20200818122236614.png)] ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"什么是RDB 在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ； 默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"工作原理 在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作； Redis 调用forks。同时拥有父进程和子进程。 子进程将数据集写入到一个临时 RDB 文件中。 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。 这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。) ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"触发机制 save的规则满足的情况下，会自动触发rdb原则 执行flushall命令，也会触发我们的rdb原则 退出redis，也会自动产生rdb文件 save 使用 save 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了； 由于 save 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求。 flushall命令 flushall 命令也会触发持久化 ； 触发持久化规则 满足配置条件中的触发条件 ； 可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。 bgsave bgsave 是异步进行，进行持久化的时候，redis 还可以将继续响应客户端请求 ； bgsave和save对比 命令 save bgsave IO类型 同步 异步 阻塞？ 是 是（阻塞发生在fock()，通常非常快） 复杂度 O(n) O(n) 优点 不会消耗额外的内存 不阻塞客户端命令 缺点 阻塞客户端命令 需要fock子进程，消耗内存 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"优缺点 优点： 适合大规模的数据恢复 对数据的完整性要求不高 缺点： 需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。 fork进程的时候，会占用一定的内容空间。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十一、持久化AOF Append Only File 将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z8wr9lBW-1597890996525)(狂神说 Redis.assets/image-20200818123711375.png)] 以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:11:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"什么是AOF 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。 如果要使用AOF，需要修改配置文件： appendonly no yes则表示启用AOF 默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！ 如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件 redis给我们提供了一个工具redis-check-aof --fix 优点和缺点 appendonly yes # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用 appendfilename \"appendonly.aof\" # appendfsync always # 每次修改都会sync 消耗性能 appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据 # appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快 优点 每一次修改都会同步，文件的完整性会更加好 没秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点 相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！ Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:11:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十二、RDB和AOP选择 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:12:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"RDB 和 AOF 对比 RDB AOF 启动优先级 低 高 体积 小 大 恢复速度 快 慢 数据安全性 丢数据 根据策略决定 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:12:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"如何选择使用哪种持久化方式？ 一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。 有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:12:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十三、Redis发布与订阅 Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IBT2pjCa-1597890996526)(狂神说 Redis.assets/image-20200818162849693.png)] 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"命令 命令 描述 PSUBSCRIBE pattern [pattern..] 订阅一个或多个符合给定模式的频道。 PUNSUBSCRIBE pattern [pattern..] 退订一个或多个符合给定模式的频道。 PUBSUB subcommand [argument[argument]] 查看订阅与发布系统状态。 PUBLISH channel message 向指定频道发布消息 SUBSCRIBE channel [channel..] 订阅给定的一个或多个频道。 SUBSCRIBE channel [channel..] 退订一个或多个频道 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"示例 ------------订阅端---------------------- 127.0.0.1:6379\u003e SUBSCRIBE sakura # 订阅sakura频道 Reading messages... (press Ctrl-C to quit) # 等待接收消息 1) \"subscribe\" # 订阅成功的消息 2) \"sakura\" 3) (integer) 1 1) \"message\" # 接收到来自sakura频道的消息 \"hello world\" 2) \"sakura\" 3) \"hello world\" 1) \"message\" # 接收到来自sakura频道的消息 \"hello i am sakura\" 2) \"sakura\" 3) \"hello i am sakura\" --------------消息发布端------------------- 127.0.0.1:6379\u003e PUBLISH sakura \"hello world\" # 发布消息到sakura频道 (integer) 1 127.0.0.1:6379\u003e PUBLISH sakura \"hello i am sakura\" # 发布消息 (integer) 1 -----------------查看活跃的频道------------ 127.0.0.1:6379\u003e PUBSUB channels 1) \"sakura\" ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"原理 每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。 客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缺点 如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。 这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"应用 消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现） 多人在线聊天室。 稍微复杂的场景，我们就会使用消息中间件MQ处理。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十四、Redis主从复制 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。 默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。 故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式 负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。 高可用基石：主从复制还是哨兵和集群能够实施的基础。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"为什么使用集群 单台服务器难以负载大量的请求 单台服务器故障率高，系统崩坏概率大 单台服务器内存容量有限。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"环境配置 我们在讲解配置文件的时候，注意到有一个replication模块 (见Redis.conf中第8条) 查看当前库的信息：info replication 127.0.0.1:6379\u003e info replication # Replication role:master # 角色 connected_slaves:0 # 从机数量 master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息： 端口号 pid文件名 日志文件名 rdb文件名 启动单机多服务集群： ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"一主二从配置 ==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！ 认老大！一主（79）二从（80，81） 使用SLAVEOF host port就可以为从机配置主机了。 然后主机上也能看到从机的状态： 我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"使用规则 从机只能读，不能写，主机可读可写但是多用于写。 127.0.0.1:6381\u003e set name sakura # 从机6381写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6380\u003e set name sakura # 从机6380写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6379\u003e set name sakura OK 127.0.0.1:6379\u003e get name \"sakura\" 当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。 当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。 第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机： 从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机 使用哨兵模式（自动选举） 如果没有老大了，这个时候能不能选择出来一个老大呢？手动！ 如果主机断开了连接，我们可以使用SLAVEOF no one让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:6","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十五、哨兵模式 更多信息参考博客：https://www.jianshu.com/p/06ab9daf921d 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。 单机单个哨兵 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2ENYVAPp-1597890996527)(狂神说 Redis.assets/image-20200818233231154.png)] 哨兵的作用： 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。 多哨兵模式 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ga1RyfVc-1597890996528)(狂神说 Redis.assets/image-20200818233316478.png)] 哨兵的核心配置 sentinel monitor mymaster 127.0.0.1 6379 1 数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。 测试 redis-sentinel xxx/sentinel.conf 成功启动哨兵模式 此时哨兵监视着我们的主机6379，当我们断开主机后： 哨兵模式优缺点 优点： 哨兵集群，基于主从复制模式，所有主从复制的优点，它都有 主从可以切换，故障可以转移，系统的可用性更好 哨兵模式是主从模式的升级，手动到自动，更加健壮 缺点： Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦 实现哨兵模式的配置其实是很麻烦的，里面有很多配置项 哨兵模式的全部配置 完整的哨兵模式配置文件 sentinel.conf # Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379 port 26379 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\".-_\"组成。 # quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了 # sentinel monitor \u003cmaster-name\u003e \u003cip\u003e \u003credis-port\u003e \u003cquorum\u003e sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码 # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass \u003cmaster-name\u003e \u003cpassword\u003e sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 # sentinel down-after-milliseconds \u003cmaster-name\u003e \u003cmilliseconds\u003e sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs \u003cmaster-name\u003e \u003cnumslaves\u003e sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout \u003cmaster-name\u003e \u003cmilliseconds\u003e sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。 #对于脚本的运行结果有以下规则： #若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 #一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本， #这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数， #一个是事件的类型， #一个是事件的描述。 #如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。 #通知脚本 # sentinel notification-script \u003cmaster-name\u003e \u003cscript-path\u003e sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # \u003cmaster-name\u003e \u003crole\u003e \u003cstate\u003e \u003cfrom-ip\u003e \u003cfrom-port\u003e \u003cto-ip\u003e \u003cto-port\u003e # 目前\u003cstate\u003e总是“failover”, # \u003crole\u003e是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的 # 这个脚本应该是通用的，能被多次调用，不是针对性的。 # sentinel client-reconfig-script \u003cmaster-name\u003e \u003cscript-path\u003e sentinel client-reconfig-script mymaster /var/redis/reconfig.sh ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:15:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十六、缓存穿透与雪崩 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缓存穿透（查不到） 概念 在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。 解决方案 布隆过滤器 对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。 缓存空对象 一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缓存击穿（量太大，缓存过期） 概念 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。 解决方案 设置热点数据永不过期 这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。 加互斥锁(分布式锁) 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缓存雪崩 概念 大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。 解决方案 redis高可用 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群 限流降级 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 数据预热 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"Spring5 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:0:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.、Spring ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.1、简介 Spring ——\u003e 春天，为开源软件带来了春天 2002，首次推出了Spring框架的雏形：interface21框架！ Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版 Spring的理念：使用现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！ SSH：Struct2 + Spring + Hibernate（全自动持久化框架）！ SSM：SpringMVC + Spring + MyBatis（半自动持久化框架，可自定义性质更强）！ spring官网： https://spring.io/projects/spring-framework#overview 官方下载： https://repo.spring.io/release/org/springframework/spring/ GitHub： https://github.com/spring-projects/spring-framework Spring Web MVC： spring-webmvc最新版 Spring Web MVC和Spring-JDBC的pom配置文件： \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.2 优点 Spring是一个开源的免费的框架（容器）！ Spring是一个轻量级的、非入侵式的框架！ 控制反转（IoC），面向切面编程（AOP） 支持事务的处理，对框架整合的支持！（几乎市面上所有热门框架都能整合进去）！ === 总结一句话：Spring就是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的框架！ === ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.3 组成 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.4、扩展 现代化的java开发 -\u003e 基于Spring的开发！ Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速开发单个微服务 约定大于配置！ Spring Cloud SpringCloud是基于SpringBoot实现的！ 因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！ ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:4","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"2、IoC（控制反转）理论推导 传统的调用 UserDao package dao; public interface UserDao { void getUser(); } UserDaoImp package dao; public class UserDaoImpl implements UserDao{ public void getUser() { System.out.println(\"默认获取用户数据\"); } } UserSevice package Service; public interface UserService { void getUser(); } UserServiceImp package Service; import dao.UserDao; import dao.UserDaoImpl; public class UserServiceImpl implements UserService{ UserDao userDao = new UserDaoImpl(); public void getUser(){ userDao.getUser(); } } 测试 package holle0; import Service.UserService; import Service.UserServiceImpl; public class MyTest0 { public static void main(String[] args) { // 用户实际调用的是业务层，dao层他们不需要接触 UserService userService = new UserServiceImpl(); userService.getUser(); } } 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！ **改良：**我们使用一个Set接口实现。已经发生了革命性的变化！ //在Service层的实现类(UserServiceImpl)增加一个Set()方法 //利用set动态实现值的注入！ //DAO层并不写死固定调用哪一个UserDao的实现类 //而是通过Service层调用方法设置实现类！ private UserDao userDao; public void setUserDao(UserDao userDao){ this.userDao = userDao; } set() 方法实际上是动态改变了 UserDao userDao 的 初始化部分（new UserDaoImpl()） 测试中加上 ((UserServiceImpl)userService).setUserDao(new UserDaoImpl()); 之前，程序是主动创建对象！控制权在程序猿手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！（主动权在客户手上） 本质上解决了问题，程序员不用再去管理对象的创建 系统的耦合性大大降低，可以更专注在业务的实现上 这是IoC（控制反转）的原型，反转(理解)：主动权交给了用户 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:2:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"IoC本质 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:2:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"3、HolleSpring 在父模块中导入jar包 \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e pojo的Hello.java package pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \"Holle [str=\" + str + \"]\"; } } 在resource里面的xml配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--在Spring中创建对象，在Spring这些都称为bean 类型 变量名 = new 类型(); Holle holle = new Holle(); bean = 对象(holle) id = 变量名(holle) class = new的对象(new Holle();) property 相当于给对象中的属性设值,让str=\"Spring\" --\u003e \u003cbean id=\"hello\" class=\"pojo.Hello\"\u003e \u003cproperty name=\"str\" value=\"Spring\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 测试类MyTest package holle1; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Hello; public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //我们的对象下能在都在spring·中管理了，我们要使用，直接取出来就可以了 Hello holle = (Hello) context.getBean(\"hello\"); System.out.println(holle.toString()); } } 核心用set注入，所以必须要有下面的se()方法 //Hello类 public void setStr(String str) { this.str = str; } 思考： IoC：对象由Spring 来创建，管理，装配！ 弹幕评论里面的理解： 原来这套程序是：你写好菜单买好菜，客人来了自己把菜炒好招待，就相当于你请人吃饭 现在这套程序是：你告诉楼下餐厅，你要哪些菜，客人来的时候，餐厅把做好的你需要的菜送上来 IoC：炒菜这件事，不再由你自己来做，而是委托给了第三方__餐厅来做 此时的区别就是，如果我还需要做其他的菜，我不需要自己搞菜谱买材料再做好，而是告诉餐厅，我要什么菜，什么时候要，你做好送来 . 在前面第一个module试试引入Spring \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"userDaomSql\" class=\"dao.UserDaoMysqlImpl\"\u003e\u003c/bean\u003e \u003cbean id=\"userServiceImpl\" class=\"service.UserServiceImp\"\u003e \u003c!--ref引用spring中已经创建很好的对象--\u003e \u003c!--value是一个具体的值,基本数据类型--\u003e \u003cproperty name=\"userDao\" ref=\"userDaomSql\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 第一个module改良后测试 package holle0; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import service.UserServiceImpl; public class MyTest0 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(\"userServiceImpl\"); userServiceImpl.getUser(); } } 总结： 所有的类都要装配的beans.xml 里面； 所有的bean 都要通过容器去取； 容器里面取得的bean，拿出来就是一个对象，用对象调用方法即可； ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:3:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"4、IoC创建对象的方式 使用无参构造创建对象，默认。 使用有参构造（如下） 下标赋值 index指的是有参构造中参数的下标，下标从0开始; \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"chen\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 类型赋值（不建议使用） \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg type=\"java.lang.String\" value=\"kuang\"/\u003e \u003c/bean\u003e 直接通过参数名（掌握） \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"kuang\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003c!-- 比如参数名是name，则有name=\"具体值\" --\u003e 注册bean之后就对象的初始化了（类似 new 类名()） 弹幕评论： name方式还需要无参构造和set方法,index和type只需要有参构造 就算是new 两个对象，也是只有一个实例（单例模式：全局唯一） User user = (User) context.getBean(\"user\"); User user2 = (User) context.getBean(\"user\"); system.out.println(user == user2)//结果为true 总结：在配置文件加载的时候，容器(\u003c bean\u003e)中管理的对象就已经初始化了 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:4:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5、Spring配置 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5.1、别名 \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"chen\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003calias name=\"user\" alias=\"userLove\"/\u003e \u003c!-- 使用时 User user2 = (User) context.getBean(\"userLove\"); --\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5.2、Bean的配置 \u003c!--id：bean的唯一标识符，也就是相当于我们学的对象名 class：bean对象所对应的会限定名：包名+类型 name：也是别名，而且name可以同时取多个别名 --\u003e \u003cbean id=\"user\" class=\"pojo.User\" name=\"u1 u2,u3;u4\"\u003e \u003cproperty name=\"name\" value=\"chen\"/\u003e \u003c/bean\u003e \u003c!-- 使用时 User user2 = (User) context.getBean(\"u1\"); --\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5.3、import import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个 假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利 用import将所有人的beans.xml合并为一个总的！ 张三(beans.xm1) 李四(beans2.xm1) 王五(beans3.xm1) applicationContext.xml \u003cimport resource=\"beans.xm1\"/\u003e \u003cimport resource=\"beans2.xml\"/\u003e \u003cimport resource=\"beans3.xm1\"/\u003e 使用的时候，直接使用总的配置就可以了 弹幕评论： 按照在总的xml中的导入顺序来进行创建，后导入的会重写先导入的，最终实例化的对象会是后导入xml中的那个 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6、依赖注入（DI） ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.1、构造器注入 第4点有提到 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.2、set方式注入【重点】 依赖注入：set注入！ 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 【环境搭建】 复杂类型 Address类 真实测试对象 Student类 beans.xml 测试 MyTest3 Student类 package pojo; import java.util.*; @Get @Set public class Student { //别忘了写get和set方法（用lombok注解也行） private String name; private Address address; private String[] books; private List\u003cString\u003e hobbies; private Map\u003cString, String\u003e card; private Set\u003cString\u003e game; private Properties infor; private String wife; @Override public String toString() { return \"Student{\" +\"\\n\"+ \"name='\" + name + '\\'' +\"\\n\"+ \", address=\" + address.toString() +\"\\n\"+ \", books=\" + Arrays.toString(books) +\"\\n\"+ \", hobbies=\" + hobbies +\"\\n\"+ \", card=\" + card +\"\\n\"+ \", game=\" + game +\"\\n\"+ \", infor=\" + infor +\"\\n\"+ \", wife='\" + wife + '\\'' +\"\\n\"+ '}'; } } Address类 package pojo; public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"Address{\" + \"address='\" + address + '\\'' + '}'; } } beans.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"address\" class=\"pojo.Address\"\u003e \u003cproperty name=\"address\" value=\"address你好\" /\u003e \u003c/bean\u003e \u003cbean id=\"student\" class=\"pojo.Student\"\u003e \u003c!--第一种，普通值注入 --\u003e \u003cproperty name=\"name\" value=\"name你好\" /\u003e \u003c!--第二种，ref注入 --\u003e \u003cproperty name=\"address\" ref=\"address\" /\u003e \u003c!--数组注入 --\u003e \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e三国\u003c/value\u003e \u003cvalue\u003e西游\u003c/value\u003e \u003cvalue\u003e水浒\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c!--list列表注入 --\u003e \u003cproperty name=\"hobbies\"\u003e \u003clist\u003e \u003cvalue\u003e唱\u003c/value\u003e \u003cvalue\u003e跳\u003c/value\u003e \u003cvalue\u003erap\u003c/value\u003e \u003cvalue\u003e篮球\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!--map键值对注入 --\u003e \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"username\" value=\"root\" /\u003e \u003centry key=\"password\" value=\"root\" /\u003e \u003c/map\u003e \u003c/property\u003e \u003c!--set(可去重)注入 --\u003e \u003cproperty name=\"game\"\u003e \u003cset\u003e \u003cvalue\u003ewangzhe\u003c/value\u003e \u003cvalue\u003elol\u003c/value\u003e \u003cvalue\u003egalname\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003c!--空指针null注入 --\u003e \u003cproperty name=\"wife\"\u003e \u003cnull\u003e\u003c/null\u003e \u003c/property\u003e \u003c!--properties常量注入 --\u003e \u003cproperty name=\"infor\"\u003e \u003cprops\u003e \u003cprop key=\"id\"\u003e20200802\u003c/prop\u003e \u003cprop key=\"name\"\u003ecbh\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e MyTest3 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Student; public class MyTest3 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student stu = (Student) context.getBean(\"student\"); System.out.println(stu.toString()); } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.3、拓展注入 官方文档位置 pojo增加User类 package pojo; public class User { private String name; private int id; public User() { } public User(String name, int id) { super(); this.name = name; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return \"User [name=\" + name + \", id=\" + id + \"]\"; } } 注意： beans 里面加上这下面两行 使用p和c命名空间需要导入xml约束 xmlns:p=“http://www.springframework.org/schema/p” xmlns:c=“http://www.springframework.org/schema/c” ?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--p命名空间注入/set注入，可以直接注入属性的值-》property--\u003e \u003cbean id=\"user\" class=\"pojo.User\" p:name=\"cxk\" p:id=\"20\" \u003e \u003c/bean\u003e \u003c!--c命名空间，通过构造器注入，需要写入有参和无参构造方法-》construct-args--\u003e \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cbh\" c:id=\"22\"\u003e\u003c/bean\u003e \u003c/beans\u003e 测试 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = context.getBean(\"user\",User.class);//确定class对象，就不用再强转了 System.out.println(user.toString()); ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.4、Bean作用域 单例模式（默认） \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"singleton\"\u003e\u003c/bean\u003e 1 弹幕评论：单例模式是把对象放在pool中，需要再取出来，使用的都是同一个对象实例 原型模式: 每次从容器中get的时候，都产生一个新对象！ \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"prototype\"\u003e\u003c/bean\u003e 1 其余的request、session、application这些只能在web开放中使用！ ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:4","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"7、Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文自动寻找，并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显示配置 在java中显示配置 隐式的自动装配bean 【重要】 环境搭建：一个人有两个宠物 byType自动装配：byType会自动查找，和自己对象set方法参数的类型相同的bean 保证所有的class唯一(类为全局唯一) byName自动装配：byName会自动查找，和自己对象set对应的值对应的id 保证所有id唯一，并且和set注入的值一致 \u003c!-- 找不到id和多个相同class --\u003e \u003cbean id=\"cat1\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"cat2\" class=\"pojo.Cat\"/\u003e \u003c!-- 找不到 id=cat，且有两个Cat --\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:7:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"7.1测试：自动装配 pojo的Cat类 public class Cat { public void shut(){ System.out.println(\"miao\"); } } pojo的Dog类 public class Dog { public void shut(){ System.out.println(\"wow\"); } } pojo的People类 package pojo; public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"People{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } } xml配置 -\u003e byType 自动装配 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"cat\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"pojo.Dog\"/\u003e \u003c!--byType会在容器自动查找，和自己对象属性相同的bean 例如，Dog dog; 那么就会查找pojo的Dog类，再进行自动装配 --\u003e \u003cbean id=\"people\" class=\"pojo.People\" autowire=\"byType\"\u003e \u003cproperty name=\"name\" value=\"cbh\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e xml配置 -\u003e byName 自动装配 \u003cbean id=\"cat\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"pojo.Dog\"/\u003e \u003c!--byname会在容器自动查找，和自己对象set方法的set后面的值对应的id 例如:setDog()，取set后面的字符作为id，则要id = dog 才可以进行自动装配 --\u003e \u003cbean id=\"people\" class=\"pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"cbh\"\u003e\u003c/property\u003e \u003c/bean\u003e 弹幕评论：byName只能取到小写，大写取不到 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:7:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"7.2、使用注解实现自动装配 jdk1.5支持的注解，spring2.5支持的注解 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.（翻译：基于注释的配置的引入提出了一个问题，即这种方法是否比XML“更好”） 导入context约束 xmlns:context=“http://www.springframework.org/schema/context\" 配置注解的支持：\u003c context:annotation-config/\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e 7.2.1、@Autowired 默认是byType方式，如果匹配不上，就会byName 在属性上个使用，也可以在set上使用 我们可以不用编写set方法了，前提是自动装配的属性在Spring容器里，且要符合ByName 自动装配 public class People { @Autowired private Cat cat; @Autowired private Dog dog; private String name; } @Nullable 字段标记了这个注解，说明该字段可以为空 public name(@Nullable String name){ } //源码 public @interface Autowired { boolean required() default true; } 如果定义了Autowire的require属性为false，说明这个对象可以为null，否则不允许为空（false表示找不到装配，不抛出异常） 7.2.2、@Autowired+@Qualifier @Autowired不能唯一装配时，需要@Autowired+@Qualifier 如果@Autowired自动装配环境比较复杂。自动装配无法通过一个注解完成的时候，可以使用@Qualifier(value = “dog”)去配合使用，指定一个唯一的id对象 public class People { @Autowired private Cat cat; @Autowired @Qualifier(value = \"dog\") private Dog dog; private String name; } 弹幕评论： 如果xml文件中同一个对象被多个bean使用，Autowired无法按类型找到，可以用@Qualifier指定id查找 7.2.3、@Resource 默认是byName方式，如果匹配不上，就会byType public class People { Resource(name=\"cat\") private Cat cat; Resource(name=\"dog\") private Dog dog; private String name; } 弹幕评论： Autowired是byType，@Autowired+@Qualifier = byType || byName Autowired是先byteType,如果唯一則注入，否则byName查找。resource是先byname,不符合再继续byType 区别： @Resource和@Autowired的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】 @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】 执行顺序不同：@Autowired通过byType的方式实现。@Resource默认通过byname的方式实现 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:7:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8、使用注解开发 在spring4之后，使用注解开发，必须要保证aop包的导入 使用注解需要导入contex的约束 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.1、bean 弹幕评论： 有了\u003c context:component-scan\u003e，另一个\u003c context:annotation-config/\u003e标签可以移除掉，因为已经被包含进去了。 \u003c!--指定要扫描的包，这个包下面的注解才会生效 别只扫一个com.kuang.pojo包--\u003e \u003ccontext:component-scan base-package=\"com.kuang\"/\u003e \u003ccontext:annotation-config/\u003e //@Component 组件 //等价于\u003cbean id=\"user\" classs\"pojo.User\"/\u003e @Component public class User { public String name =\"秦疆\"; } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.2、属性如何注入@value @Component public class User { //相当于\u003cproperty name=\"name\" value=\"kuangshen\"/\u003e @value(\"kuangshen\") public String name; //也可以放在set方法上面 //@value(\"kuangshen\") public void setName(String name) { this.name = name; } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.3、衍生的注解 @Component有几个衍生注解，会按照web开发中，mvc架构中分层。 dao （@Repository） service（@Service） controller（@Controller） 这四个注解的功能是一样的，都是代表将某个类注册到容器中 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.4、自动装配置 @Autowired：默认是byType方式，如果匹配不上，就会byName @Nullable：字段标记了这个注解，说明该字段可以为空 @Resource：默认是byName方式，如果匹配不上，就会byType ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:4","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.5、作用域@scope //原型模式prototype，单例模式singleton //scope(\"prototype\")相当于\u003cbean scope=\"prototype\"\u003e\u003c/bean\u003e @Component @scope(\"prototype\") public class User { //相当于\u003cproperty name=\"name\" value=\"kuangshen\"/\u003e @value(\"kuangshen\") public String name; //也可以放在set方法上面 @value(\"kuangshen\") public void setName(String name) { this.name = name; } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:5","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.6、小结 xml与注解： xml更加万能，维护简单，适用于任何场合 注解，不是自己的类使用不了，维护复杂 最佳实践： xml用来管理bean 注解只用来完成属性的注入 要开启注解支持 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:6","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"9、使用Java的方式配置Spring 不使用Spring的xml配置，完全交给java来做！ Spring的一个子项目，在spring4之后，，，它成为了核心功能 实体类：pojo的User.java //这里这个注解的意思,就是说明这个类被Spring接管了,注册到了容器中 @component public class User { private String name; public String getName() { return name; } //属性注入值 @value(\"QINJIANG') public void setName(String name) { this.name = name; } @Override public String toString() { return \"user{\" + \"name='\" + name + '\\''+ '}'; } } 弹幕评论：要么使用@Bean，要么使用@Component和ComponentScan，两种效果一样 配置文件：config中的kuang.java @Import(KuangConfig2.class)，用@import来包含KuangConfig2.java //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于\u003cbeans\u003e标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -\u003egetUser //这个方法的返同值,就相当于bean 标签中的class 属性 -\u003eUser //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 public class MyTest { public static void main(String[ ] args) { //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); } } 会创建两个相同对象问题的说明： 弹幕总结 - -\u003e @Bean是相当于\u003c bean\u003e标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于\u003cbeans\u003e标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -\u003egetUser //这个方法的返同值,就相当于bean 标签中的class 属性 -\u003eUser //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 public class MyTest { public static void main(String[ ] args) { //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); } } 会创建两个相同对象问题的说明： 弹幕总结 - -\u003e @Bean是相当于\u003c bean\u003e标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:9:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"10、动态代理 代理模式是SpringAOP的底层 分类：动态代理和静态代理 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:10:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"10.1、静态代理 代码步骤： 1、接口 package pojo; public interface Host { public void rent(); } 2、真实角色 package pojo; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要出租房子\"); } } 3、代理角色 package pojo; public class Proxy { public Host host; public Proxy() { } public Proxy(Host host) { super(); this.host = host; } public void rent() { seeHouse(); host.rent(); fee(); sign(); } //看房 public void seeHouse() { System.out.println(\"看房子\"); } //收费 public void fee() { System.out.println(\"收中介费\"); } //合同 public void sign() { System.out.println(\"签合同\"); } } 4、客户端访问代理角色 package holle4_proxy; import pojo.Host; import pojo.HostMaster; import pojo.Proxy; public class My { public static void main(String[] args) { //房东要出租房子 Host host = new HostMaster(); //中介帮房东出租房子，但也收取一定费用（增加一些房东不做的操作） Proxy proxy = new Proxy(host); //看不到房东，但通过代理，还是租到了房子 proxy.rent(); } } 代码翻倍：几十个真实角色就得写几十个代理 AOP横向开发 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:10:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"10.2、动态代理 动态代理和静态角色一样，动态代理底层是反射机制 动态代理类是动态生成的，不是我们直接写好的！ 动态代理(两大类)：基于接口，基于类 基于接口：JDK的动态代理【使用ing】 基于类：cglib java字节码实现：javasisit 了解两个类 1、Proxy：代理 2、InvocationHandler：调用处理程序 实例： 接口 Host.java //接口 package pojo2; public interface Host { public void rent(); } 接口Host实现类 HostMaster.java //接口实现类 package pojo2; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要租房子\"); } } 代理角色的处理程序类 ProxyInvocationHandler.java package pojo2; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; ///用这个类，自动生成代理 public class ProxyInvocationHandler implements InvocationHandler { // Foo f =(Foo) Proxy.NewProxyInstance(Foo. Class.GetClassLoader(), // new Class\u003c?\u003e[] { Foo.Class }, // handler); // 被代理的接口 public HostMaster hostMaster ; public void setHostMaster(HostMaster hostMaster) { this.hostMaster = hostMaster; } // 得到生成的代理类 public Object getProxy() { // newProxyInstance() -\u003e 生成代理对象，就不用再写具体的代理类了 // this.getClass().getClassLoader() -\u003e 找到加载类的位置 // hostMaster.getClass().getInterfaces() -\u003e 代理的具体接口 // this -\u003e 代表了接口InvocationHandler的实现类ProxyInvocationHandler return Proxy.newProxyInstance(this.getClass().getClassLoader(), hostMaster.getClass().getInterfaces(), this); // 处理代理实例并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(hostMaster, args); fee(); return result; } public void seeHouse() { System.out.println(\"看房子\"); } public void fee() { System.out.println(\"收中介费\"); } } 用户类 My2.java package holle4_proxy; import pojo2.Host; import pojo2.Host2; import pojo2.HostMaster; import pojo2.ProxyInvocationHandler; public class My2 { public static void main(String[] args) { //真实角色 HostMaster hostMaster = new HostMaster(); //代理角色，现在没有；用代理角色的处理程序来实现Host接口的调用 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //pih -\u003e HostMaster接口类 -\u003e Host接口 pih.setHostMaster(hostMaster); //获取newProxyInstance动态生成代理类 Host proxy = (Host) pih.getProxy(); proxy.rent(); } } 弹幕评论： 什么时候调用invoke方法的? 代理实例调用方法时invoke方法就会被调用，可以debug试试 改为万能代理类 ///用这个类，自动生代理 public class ProxyInvocationHandler implements InvocationHandler { // 被代理的接口 public Object target; public void setTarget(Object target) { this.target = target; } // 得到生成的代理类 -\u003e 固定的代码 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // 处理代理实例并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(target, args); return result; } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:10:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11、AOP ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11.1、什么是AOP ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11.2、AOP在Spring中的使用 提供声明式事务，允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等… 切面(Aspect)：横切关注点 被模块化的特殊对象。即，它是一个类。（Log类） 通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法。（Log类中的方法） 目标(Target)：被通知对象。（生成的代理类) 代理(Proxy)：向目标对象应用通知之后创建的对象。（生成的代理类） 切入点(PointCut)：切面通知执行的”地点”的定义。（最后两点：在哪个地方执行，比如：method.invoke()） 连接点(JointPoint)：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即AOP在不改变原有代码的情况下，去增加新的功能。（代理） ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11.3、使用Spring实现AOP 导入jar包 \u003c!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e 11.3.1、方法一：使用原生spring接口 springAPI接口实现 applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--注册bean--\u003e \u003cbean id=\"userservice\" class=\"service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"log.AfterLog\"/\u003e \u003c!--方式一，使用原生Spring API接口--\u003e \u003c!--配置aop,还需要导入aop约束--\u003e \u003caop:config\u003e \u003c!--切入点：expression:表达式，execution（要执行的位置）--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* service.UserServiceImpl.*(..))\"/\u003e \u003c!--UserServiceImpl.*(..) -》 UserServiceImpl类下的所以方法(参数)--\u003e \u003c!--执行环绕增加--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/\u003e \u003c!-- 环绕,在id=\"pointcut\"的前后切入 --\u003e \u003c/aop:config\u003e \u003c/beans\u003e execution(返回类型，类名，方法名(参数)) -\u003e execution(* com.service.,(…)) UserService.java package service; public interface UserService { public void add() ; public void delete() ; public void query() ; public void update(); } UserService 的实现类 UserServiceImp.java package service; public class UserServiceImpl implements UserService { public void add() { System.out.println(\"add增\"); } public void delete() { System.out.println(\"delete删\"); } public void update() { System.out.println(\"update改\"); } public void query() { System.out.println(\"query查\"); } } 前置Log.java package log; import org.springframework.aop.MethodBeforeAdvice; import java.lang.reflect.Method; public class Log implements MethodBeforeAdvice { //method：要执行的目标对象的方法 //args：参数 //target：目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); } } 后置AfterLog.java package log; import java.lang.reflect.Method; import org.springframework.aop.AfterReturningAdvice; public class AfterLog implements AfterReturningAdvice { //returnVaule: 返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"方法，返回值是\"+returnValue); } } 测试类MyTest5 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import service.UserService; public class MyTest5 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //注意:动态代理代理的是接口 UserService userService = (UserService) context.getBean(\"userservice\"); userService.add(); } } 11.3.2、方法二：自定义类实现AOP \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--注册bean--\u003e \u003cbean id=\"userservice\" class=\"service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"log.AfterLog\"/\u003e \u003c!-- 方式二，自定义 --\u003e \u003cbean id=\"diy\" class=\"diy.DiyPointcut\"/\u003e \u003caop:config\u003e \u003c!--自定义切面--\u003e \u003caop:aspect ref=\"diy\"\u003e \u003c!--切入点--\u003e \u003caop:pointcut id=\"point\" expression=\"execution(* service.UserServiceImpl.*(..))\"/\u003e \u003caop:before method=\"before\" pointcut-ref=\"point\"/\u003e \u003caop:after method=\"after\" pointcut-ref=\"point\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e \u003c/beans\u003e package diy; public class DiyPointcut { public v","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"12、整合mybatis mybatis-spring官网：https://mybatis.org/spring/zh/ mybatis的配置流程： 编写实体类 编写核心配置文件 编写接口 编写Mapper.xmi 测试 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:12:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"12.1、mybatis-spring-方式一 编写数据源配置 sqISessionFactory sqISessionTemplate（相当于sqISession） 需要给接口加实现类【new】 将自己写的实现类，注入到Spring中 测试！ 先导入jar包 \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--在build中配置resources，来防止资源导出失败的问题--\u003e \u003c!-- Maven解决静态资源过滤问题 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 编写顺序： User -\u003e UserMapper -\u003e UserMapper.xml -\u003e spring-dao.xml -\u003e UserServiceImpl -\u003e applicationContext.xml -\u003e MyTest6 代码步骤： pojo实体类 User package pojo; import lombok.Data; @Data public class User { private int id; private String name; private String pwd; } mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper package mapper; import java.util.List; import pojo.User; public interface UserMapper { public List\u003cUser\u003e getUser(); } UserMapperImpl package mapper; import java.util.List; import org.mybatis.spring.SqlSessionTemplate; import pojo.User; public class UserMapperImpl implements UserMapper{ //我们的所有操作，在原来都使用sqlSession来执行，现在都使用SqlSessionTemplate； private SqlSessionTemplate sqlSessionTemplate; public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) { this.sqlSessionTemplate = sqlSessionTemplate; } public List\u003cUser\u003e getUser() { UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class); return mapper.getUser(); } } UserMapper.xml （狂神给面子才留下来的） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- 绑定接口 --\u003e \u003cmapper namespace=\"mapper.UserMapper\"\u003e \u003cselect id=\"getUser\" resultType=\"pojo.User\"\u003e select * from mybatis.mybatis \u003c/select\u003e \u003c/mapper\u003e resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!--开启日志--\u003e \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\" /\u003e \u003c/settings\u003e \u003c!--可以给实体类起别名 --\u003e \u003ctypeAliases\u003e \u003cpackage name=\"pojo\" /\u003e \u003c/typeAliases\u003e \u003c/configuration\u003e spring-dao.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --\u003e \u003c!--data source --\u003e \u003cbean id=\"datasource\" class=\"org.spr","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:12:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"12.2、mybatis-spring-方式二 UserServiceImpl2 package mapper; import pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; //继承SqlSessionDaoSupport 类 public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper { public List\u003cUser\u003e getUser() { SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者一句话：return getSqlSession().getMapper(UserMapper.class).getUser(); } } spring-dao.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--DataSource:使用Spring的数帮源替换Mybatis的配置 c3p0 dbcp druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --\u003e \u003c!--data source --\u003e \u003cbean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=Asia/Shanghai\"/\u003e \u003cproperty name=\"username\" value=\"root\" /\u003e \u003cproperty name=\"password\" value=\"root\" /\u003e \u003c/bean\u003e \u003c!--sqlSessionFactory--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\" /\u003e \u003c!--绑定 mybatis 配置文件--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/\u003e \u003c/bean\u003e \u003c!-- 方法二：SqlSessionTemplate 可以不写了--\u003e \u003c/beans\u003e applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003cimport resource=\"spring-dao.xml\" /\u003e \u003c!-- 方法二 --\u003e \u003cbean id=\"userMapper2\" class=\"mapper.UserMapperImpl2\"\u003e \u003cproperty name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e 测试 public class MyTest6 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = (UserMapper) context.getBean(\"userMapper2\"); for (User user : userMapper.getUser()) { System.out.println(user); } } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:12:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"13. 声明式事务 把一组业务当成一个业务来做；要么都成功，要么都失败！ 事务在项目开发中，十分的重要，涉及到数据的一致性问题 确保完整性和一致性 事务的ACID原则： 1、原子性 2、隔离性 3、一致性 4、持久性 ACID参考文章：https://www.cnblogs.com/malaikuangren/archive/2012/04/06/2434760.html Spring中的事务管理 声明式事务：AOP 编程式事务：需要再代码中，进行事务管理 声明式事务 先导入jar包 \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--在build中配置resources，来防止资源导出失败的问题--\u003e \u003c!-- Maven解决静态资源过滤问题 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 代码步骤： pojo实体类 User package pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; private String pwd; } mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper package mapper; import java.util.List; import org.apache.ibatis.annotations.Param; import pojo.User; public interface UserMapper { public List\u003cUser\u003e getUser(); public int insertUser(User user); public int delUser(@Param(\"id\") int id); } UserMapperImpl package mapper; import pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper { public List\u003cUser\u003e getUser() { User user = new User(5,\"你好\",\"ok\"); insertUser(user); delUser(5); SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者return getSqlSession().getMapper(UserMapper.class).getUser(); } //插入 public int insertUser(User user) { return getSqlSession().getMapper(UserMapper.class).insertUser(user); } //删除 public int delUser(int id) { return getSqlSession().getMapper(UserMapper.class).delUser(id); } } UserMapper.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- 绑定接口 --\u003e \u003cmapper namespace=\"mapper.UserMapper\"\u003e \u003cselect id=\"getUser\" resultType=\"pojo.User\"\u003e select * from mybatis.mybatis \u003c/select\u003e \u003cinsert id=\"insertUser\" parameterType=\"pojo.User\" \u003e insert into mybatis.mybatis (id,name,pwd) values (#{id},#{name},#{pwd}) \u003c/insert\u003e \u003cdelete id=\"delUser\" parameterType=\"_int\"\u003e deleteAAAAA from mybatis.mybatis where id = #{id} \u003c!-- deleteAAAAA是故意写错的 --\u003e \u003c/delete\u003e \u003c/mapper\u003e resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003c!-- configuration --\u003e \u003cconfiguration\u003e \u003c!--开启日志--\u003e \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGIN","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:13:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["大三上实训笔记"],"content":"大三上学期小米商城实训辅助知识点总结","date":"2021-04-06","objectID":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/","tags":[],"title":"千峰实训","uri":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/"},{"categories":["大三上实训笔记"],"content":"一、实训规划 1.1 项目 项目名称：《小米商城后台管理系统》 项目功能要求： 管理员登录 商品类别管理 商品信息管理 文件上传 分页 1.2 课程规划 时间 内容 Day1 Java语法复习（补充必要的知识点）、数据库复习（MySQL安装配置，SQL） Day2 JDBC数据库编程（DAO\\DTO模式、CRUD操作封装）—-完成项目的数据库设计 Day3 前端（HTML\\CSS复习，JavaScript，前端框架Layui）—-完成项目的页面设计 Day4 Servlet复习，JSP（Java Server Page），JSTL Day5 完成管理员登录功能、商品类别添加功能 Day6 完成商品类别列表、删除类别、修改类别功能 Day7 完成商品添加（文件上传）、商品列表、商品详情 （商品修改、删除商品自行完成） Day8 项目部署、项目验收 1.3 软件的基本结构 如果要去完成一个项目，首先就要了解一个项目的结构，从项目的结构中分析所需的技术，然后补充相应的技术，以完成项目的开发。 软件结构 1.4 软件开发流程 明确项目的需求 项目功能设计 完成数据库设计 完成流程设计 完成UI界面 项目功能实现 编码 运行(功能测试) 项目测试（专业测试人员） 项目交付（项目部署） ","date":"2021-04-06","objectID":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/:1:0","tags":[],"title":"千峰实训","uri":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/"},{"categories":["大三上实训笔记"],"content":"二、Java语言的复习 2.1 Java概述 Java是一种面向对象的服务器编程语言 Java出现于1991年，正式发布于1995年 Java语言的摇篮：SUN Java语言之父：James·Gosling 高斯林 Java语言的技术架构（Java语言可以干什么？） 2002开始占据编程语言排行榜第一 J2ME 传统手机上的软件（嵌入式编程） JavaSE AWT/swing PC桌面程序 （百里挑一） JavaEE 企业级应用（B/S）、互联网应用——解决三高问题 Android-SDK 手机应用（Android） （百里有一） 2.2 编译和解释 编程语言都是由字母、数字、符号组成，然而计算机只能识别机器语言（二进制），因此我们写好的程序源文件在计算机OS上执行必须要经过一个转换的过程，转换的方式有2种：编译和解释 编译 源文件先经过产生一个中间文件（可执行文件），计算机OS执行这个可执行文件 解释 源文件不会提前编译产生中间文件，计算机每次执行程序时都会再次进行动态的转换 Java语言是一种编译解释型语言 Java语言如何实现跨平台： Java源文件经过编译之后产生的字节码文件与操作系统无关，而是面向JVM运行的，因此无论是什么样的OS，只要能够安装JVM，就能执行Java程序 Java语言的编译解释执行过程： 2.3 JDK安装及环境变量配置 2.3.1 下载 64位链接：https://pan.baidu.com/s/1oiBEHPa4i0N94G4Br7agdQ 提取码：052g 32位链接：https://pan.baidu.com/s/1zytJsPyGCkmjp5cJbk6Hiw 提取码：atpm 2.3.2 安装 安装及环境变量配置视频链接：https://pan.baidu.com/s/1oDMk6u4ju9nPorB7-FjfxQ 提取码：zdww 傻瓜式安装 （默认安装在：） 安装目录如下 2.3.3 配置环境变量 配置环境变量，就是将JDK的bin目录路径配置到操作系统，以便于在CMD命令行窗口中输入指令时能够找到JDK的工具文件。 最简洁的配置方式： 2.4 IDE集成开发环境 2.4.1 记事本开发流程 编辑源文件： 编译运行 2.4.2 IDE工具 使用记事本做开发：第一开发效率低；第二没有错误异常提示、错误率高；项目中的多个文件不便于管理。 eclipse IDEA 2.4.3 下载安装IDEA IDEA2019.2+破解链接：https://pan.baidu.com/s/1cBrRz8Mns_yQQwna4QHGzg 提取码：v0z6 傻瓜式安装：选择界面风格（Dark,Light） 2.4.4 IDEA基本使用 代码写在方法中，方法创建在类中，类定义在包中，包创建在项目中 创建项目（基本Java项目） 启动IDEA创建Java项目 2.5 编程规范 代码的质量和优雅型处理考察功能完成情况、还会考察代码编写规范 可读性——让别人看起容易懂、看着舒服 语法规则（法律）：必须遵守的，不遵守代码不能运行 编程规范（道德）：需要遵守但是也可以不遵守 2.5.1 包名的命名规范 包名中所有字符小写 采用域后缀名倒置的形式命名 千锋 www.qfedu.com 湖大 www.hubu.edu.cn 包名结构：域后缀名.单位名称.模块名/项目组代号/项目名.包自己的名字 包名能够体现包的作用（有语义性） 2.5.2 类名的命名规范 见名知意：选取能够表达类的作用的英文单词组成 驼峰式命名：类名首字母大写，如果包含多个单词，每个单词首字母都大写 类名可以包含字母、数字、$和_，但是不能以数字开头 类名可以使用中文，但是不提倡使用 2.6 Java基础知识 2.6.1 基础部分 基础语法：变量、标识符、关键字、运算符、流程控制 面向对象：类与对象、方法定义与方法调用、特征(抽象、封装、继承、多态 ) 异常处理：try、catch、自定义异常 数组：数组定义及创建、数组遍历、排序（冒泡、快排、插入、选择）、二分法查找 常用类：String、Math、Date、DateFormat、Calendar、封装类（8个） 集合：ArrayList 集合家族Collection \\ Map家族 2.6.2 高级部分 IO流 网络编程 多线程 AWT/Swing 2.7 类、属性、方法 2.7.1 类 属性和方法要定义在类中 类的定义语法 [public] class \u003cClassName\u003e{ } []包含的内容表示可有可无 \u003c\u003e包含的内容必须有，但是可以改变 2.7.2 方法 方法，就是能够完成特定功能代码块 [\u003cpublic|protected|private\u003e] [static] \u003creturn_type\u003e \u003cmethodName\u003e([\u003cargsList\u003e]){ } 参数和返回值 package cn.edu.hubu.demo.dao; public class ClassA { /** * 无参数无返回值的方法：打印乘法口诀 */ public void printCFKJ(){ for (int i = 1; i \u003c=9 ; i++) { for (int j = 1; j \u003c=i ; j++) { System.out.print(i+\"*\"+j+\"=\"+i*j + \"\\t\"); } System.out.println(); } } /** * 有参数有返回值的方法：获取一个指定范围内的随机数 */ public int getRandomNum(int a,int b){ double d = Math.random(); // 0.45238947178923478 double d2 = d*(b-a)+a; // d2 [0,b-a) --- [a,b) int num = (int)Math.round(d2); //[a,b] return num; } } 2.7.3 对象创建及方法调用 package cn.edu.hubu.demo.dao; public class ClassB { public static void main(String[] args) { //打印乘法口诀 //调用ClassA中的printCFKJ方法 //1.对象的创建：如果我们要调用某个类中的方法，需要先创建这个类的对象 // 通过new关键字调用构造器创建对象 ClassA a = new ClassA(); //2.通过创建的对象调用类中的方法 a.printCFKJ(); int m = a.getRandomNum(10,30); System.out.println(m); } } Java基础参考视频：https://www.bilibili.com/video/BV1tQ4y1N7oh ","date":"2021-04-06","objectID":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/:2:0","tags":[],"title":"千峰实训","uri":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/"},{"categories":["大三上实训笔记"],"content":"三、数据库设计 SQLServer Oracle (收钱) MySQL 3.1 MySQL的安装和配置 3.1.1 MySQL版本 MySQL 5.x v5.6 v5.7 MySQL 8.x 下载：MySQL5.6链接：https://pan.baidu.com/s/1Sk37sP66WJsnYrIiKxkelg 提取码：3t1m 3.1.2 MySQL安装 傻瓜式安装 端口：3306 设置密码（root）：admin123 3.1.3 安装数据库管理工具——Navicat MySQL是以服务的形式运行在OS中，没有提供可视化的窗口界面，只提供了一个DOS命令窗口用于进行指令操作；为了便于开发过程中对数据库的操作，我们需要安装一个数据库管理的视图工具——DBMS 傻瓜式安装 配置Navicat连接到MySQL数据库 Navicat连接到MySQL数据库 3.2 SQL复习 我们可以通过SQL指令完成对数据库的各种操作：建库建表、数据的增删查改等等 SQL 结构化查询语言——就是一种数据库可以“听懂”的语言 3.2.1 SQL分类 根据SQL语句的作用，我们可以将SQL语句分为四类： DDL 数据定义语言 ——建库、建表、索引、视图、存储过程、触发器 DML 数据操纵语言 ——对数据表中的数据进行增删改操作（insert\\delete\\update） DQL 数据查询语言 ——对数据表中的数据进行查询操作（select） DCL 数据控制语言 ——完成事务管理等操作（begin、commit、rollback） 3.2.2 DDL（建库建表） 数据是存储在数据表中的，数据表是创建在数据库中 数据库管理 -- 创建数据库 createdatabasedb_ytao;-- 使用数据库 usedb_ytao;-- 删除数据库 dropdatabasedb_ytao; 数据表管理 -- 创建数据表 -- 学生信息表：学号、姓名、性别、年龄、手机、QQ、个性签名 -- 字符串 char定长 varchar可变 createtabletb_students(stu_numchar(15)primarykey,stu_namevarchar(20)notnull,stu_genderchar(2)notnull,stu_ageintnotnull,stu_telchar(11)notnullunique,stu_qqvarchar(11)notnullunique,stu_descvarchar(200)); 3.2.3 DML 添加操作 -- 学生信息表中添加一条数据(在表名后的括号中列出字段名) insertintotb_students(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_desc)values('201801010101001','王二狗','男',21,'13030303300','123456','哥只是一个传说');insertintotb_articles(article_id,article_title,article_content)values(12,'Java学习心得','2021.01.09日开始学习Java...'); 删除操作 -- delete from table 会删除数据表中所有的数据，需要通过where来限定删除条件 deletefromtb_articleswherearticle_id=\u003e13; 修改语句 -- 修改学号为201801010101001的学生的名字和年龄 updatetb_studentssetstu_name='王小狗',stu_age=18wherestu_num='201801010101001'; 3.2.4 DQL 查询操作 -- 显示指定列 selectstu_num,stu_name,stu_genderfromtb_students;selectstu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_descfromtb_students;select*fromtb_students;-- 条件筛选查询 select*fromtb_studentswherestu_gender='女';-- order by 对查询结果进行排序 select*fromtb_studentsorderbystu_agedesc-- group by分组查询: select 关键字后的字段只能是被分组字段和聚合函数（count\\sum\\max\\min\\avg） selectstu_gender,count(1)fromtb_studentsgroupbystu_gender;-- having 分组筛选 selectstu_age,count(1)fromtb_studentsgroupbystu_agehavingstu_age\u003e=20;-- 学生信息表有9个学生，4条记录为1页，可以分为3页 -- 第1页 1-4 select*fromtb_studentslimit0,4;-- 第2页 5-8 select*fromtb_studentslimit4,4;-- 第3页 9 select*fromtb_studentslimit8,4;-- 第n页 select*fromtb_studentslimit(n-1)*4,4;-- 每页显示pageSize条，查询第pageNum页 select*fromtb_studentslimit(pageNum-1)*pageSize,pageSize; 3.3 软件开发流程 3.3.1 软件项目的开发流程 软件工程——软件开发生命周期 问题定义：甲方提出项目需求（业务需求） 可行性分析：从技术、经济、社会因素综合评估这个项目能不能做、要不要做 需求分析：需求采集—需求分析 概要设计：项目业务流程、数据库设计、UI设计 详细设计：设计具体功能的实现流程 编码 测试 交付：交项目（项目部署实施）、付款 3.3.2 《小米商城后台管理系统》项目的功能需求 电商系统项目结构 管理员登录 管理员要使用正确的账号和密码进行登录之后才能使用这个管理系统 商品类别管理 通过管理系统，能够动态完成添加商品类别、商品类别列表、修改类别及删除类别等操作 商品管理 通过管理系统，可以动态完成商品发布、商品列表（分页）、修改商品信息、删除商品信息（下架） 用户管理 订单管理 售后服务 3.4 《小米商城后台管理系统》数据库设计 3.4.1.分析数据实体 根据项目的功能确定要存储的数据对象 管理员 用户 类别 商品 购物车 订单 3.4.2 提取实体数据项 根据甲方的业务需求及项目的功能需求分析每个数据实体的属性 管理员（管理员编号/工号，管理员账号，管理员密码，管理员姓名，管理员头像，管理员电话） 用户（用户ID，账号/手机，密码，性别、年龄….） 类别（类别ID，类别名称，类别描述） 商品（商品编号，商品名称，商品图片，商品价格，商品库存，商品说明，图文详情） 购物车（购物车ID，用户ID，商品ID，数量，日期） 订单(订单ID，用户ID，订单日期，订单状态，….） 商品快照表（….） 购物车和订单数据关系 3.4.3 规范实体数据项 使用数据库设计范式检查数据项是否合理——数据库设计三范式 第一范式：数据表中的字段不可再分 傻子都不可能创建出不满足第一范式的表格，目前现有的数据库都不支持如下结构的创建 第一范式反例： 第二范式：不存在非关键字段对关键字段的部分函数依赖 第二范式案例： 第三范式：不存在非关键字段之间的传递依赖 第三范式案例： 3.4.4 绘制实体关系图（E-R） 通过E-R图例，分析实体和实体之间的关系（一对一、一对多、多对一、多对多） 在企业开发中通常是通过PD进行数据库建模 实体关系图 3.4.5 数据表设计（三线图） 3.4.6 建库建表（SQL） 大家根据三线图自行完成 ","date":"2021-04-06","objectID":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/:3:0","tags":[],"title":"千峰实训","uri":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/"},{"categories":["大三上实训笔记"],"content":"四、数据库编程 使用Java代码完成对数据库、数据表中的数据的访问——JDBC 4.1 JDBC的步骤 JDBC操作数据库7个步骤 4.2 JDBC实现：添加操作 案例：使用Java代码向db_ytao数据库的tb_students表中添加一条学生信息 4.2.1 建立数据库连接 将数据库连接驱动文件添加到项目中 选择Java项目名—右键—New Directory—lib 将mysql-connector-java-5.1.47.jar文件拷贝并粘贴到创建的lib文件夹 选择lib中的mysql-connector-java-5.1.47.jar文件—右键—Add as Library–OK 加载驱动 获取连接 创建连接 4.2.2 JDBC操作代码（2-7步） 2021.01.11晚上练习任务 1.复习今天的笔记，掌握软件的开发流程及数据库设计规范，完成小米商城数据表的创建 2.总结JDBC操作步骤，完成学生信息的添加操作（课堂案例） 3.完成学生信息的删除操作（根据输入的学号删除一条学生信息） 4.完成学生信息的修改操作（根据学号修改学生的姓名、性别、…） 4.3 JDBC实现：删除操作 代码如下： package cn.edu.hubu.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.util.Scanner; public class DeleteStudent { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"请输入要删除的学生学号：\"); String stuNum = scanner.nextLine(); try { //如果这句代码需要进行异常处理，将鼠标放在红色提示后面：ALT+ENTER Class.forName(\"com.mysql.jdbc.Driver\"); //数据库连接字符串 String url = \"jdbc:mysql://localhost:3306/db_ytao?characterEncoding=utf-8\"; String username = \"root\"; String password = \"admin123\"; //在IDEA如果调用的方法有返回值，可以在方法调用完成之后，直接.var回车自动定义接收返回值的变量 Connection connection = DriverManager.getConnection(url, username, password); String sql = \"delete from tb_students where stu_num=?\"; PreparedStatement ps = connection.prepareStatement(sql); ps.setString(1,stuNum); int i = ps.executeUpdate(); System.out.println(i\u003e0?\"删除成功！\":\"删除失败！\"); connection.close(); } catch (Exception e) { e.printStackTrace(); } } } 4.4 JDBC操作：修改操作 代码如下 package cn.edu.hubu.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.util.Scanner; public class UpdateStudent { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"请输入要修改的学生学号：\"); String stuNum = scanner.nextLine(); System.out.println(\"请输入新姓名：\"); String stuName = scanner.nextLine(); System.out.println(\"请输入新性别：\"); String stuGender = scanner.nextLine(); System.out.println(\"请输入新年龄：\"); String stuAge = scanner.nextLine(); System.out.println(\"请输入新电话：\"); String stuTel = scanner.nextLine(); System.out.println(\"请输入新QQ：\"); String stuQQ = scanner.nextLine(); System.out.println(\"请输入新签名：\"); String stuDesc = scanner.nextLine(); try { Class.forName(\"com.mysql.jdbc.Driver\"); String url = \"jdbc:mysql://localhost:3306/db_ytao?characterEncoding=utf-8\"; String username = \"root\"; String password = \"admin123\"; Connection connection = DriverManager.getConnection(url, username, password); String sql = \"update tb_students set stu_name=?,stu_gender=?,stu_age=?,stu_tel=?,stu_qq=?,stu_desc=? where stu_num=?\"; PreparedStatement ps = connection.prepareStatement(sql); ps.setString(1,stuName); ps.setString(2,stuGender); ps.setString(3,stuAge); ps.setString(4,stuTel); ps.setString(5,stuQQ); ps.setString(6,stuDesc); ps.setString(7,stuNum); int i = ps.executeUpdate(); System.out.println(i\u003e0?\"修改成功！\":\"修改失败！\"); connection.close(); } catch (Exception e) { e.printStackTrace(); } } } 4.5 DBUtil工具类封装 每一个JDBC操作都必须先创建数据库的连接，我们可以将创建连接的工作单独定义成一个方法来实现，在具体的JDBC操作中只需调用此方法就可以完成创建连接的工作 DBUtil封装 4.6 DAO封装 为了提供数据库JDBC操作的复用性，我们将能够实现特定数据库操作的代码单独定义成一个方法； 我们将对于一张表的不同的JDBC操作的方法定义在同一个类中，这个类我们称之为DAO类； DAO(Data Access Object)数据访问对象 当我们需要对张数据表进行操作的时候，我们只需调用对应DAO类中的方法 4.7 DTO封装 DTO (Data Transfer Object)数据传输对象 /** * DTO类：用来为JDBC操作传递数据的（一个DTO类的对象可以存放数据表中的一条数据） * DTO类的创建规范： * 1.DTO类中属性的个数和类型要与对应的数据表保持一致（Student --- tb_students ） * 2.提供无参构造器：右键---Generate---Constructor---点击select None按钮 * 3.提供全参构造器：右键---Generate---Constructor--- 选择所有属性 ---点击OK按钮 * 4.提供所有属性的get和set方法：右键---Generate---Getter and Setter---选择所有属性 ---点击OK按钮 */ public class Student { private String stuNum; private String stuName; private String stuGender; private int stuAge; private String stuTel; private String stuQQ; private String stuDesc; //无参构造器 //全参构造器 //所有属性的get和set方法 } 4.8 JDBC操作：查询操作 根据ID查询一条记录 //根据学号查询一个学生信息 public Student queryStudent(String stuNum){ Student student = null; try{ //根据学号查询学生信息，将查询到学生信息的7个值存储到student对象中 Connection connection = ","date":"2021-04-06","objectID":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/:4:0","tags":[],"title":"千峰实训","uri":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/"},{"categories":["大三上实训笔记"],"content":"五、网页设计 5.1 B/S 和 C/S 项目架构方式 B/S (Browser-Server) 基于浏览器和服务器的架构模式 C/S (Client-Server) 基于客户端和服务器的架构模式，专用客户端模式（QQ） 5.2 网页设计介绍 网页就是存储在服务器、可以通过网络传输到用户、并通过浏览器展示出特定视图页面的文件 5.2.1 网页文件特点 后缀名为.html或者.htm 可以通过浏览器显示出界面 网页文件基本结构：标签 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"/\u003e \u003ctitle\u003e登录页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 5.2.2 网页三要素 HTML 超文本标记语言，决定了网页的结构（显示的内容） CSS 层叠样式表，决定了网页中视图的显示效果 JavaScript 脚本语言，决定了网页中动态效果及功能 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"/\u003e \u003ctitle\u003e登录页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" style=\"width:100px;height:25px\" value=\"点我呀\" onclick=\"test()\"/\u003e \u003cscript type=\"text/javascript\"\u003e function test(){ alert(\"从前有座山\"); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 5.3 HTML常用标签 5.3.1 显示标签 将文本、图片、声音、视频等在网页中进行显示和播放 \u003c!--文本--\u003e \u003clabel style=\"color:red; font-size:15px; font-family:黑体\"\u003e文本内容\u003c/label\u003e \u003c!--图片--\u003e \u003cimg src=\"img/001.jpg\" width=\"200\" height=\"100\"/\u003e \u003c!--声音--\u003e \u003caudio controls src=\"song/001.mp3\" autoplay loop=\"-1\"\u003e\u003c/audio\u003e \u003c!--视频--\u003e \u003cvideo controls src=\"mv/001.mp4\" autoplay loop=\"-1\"\u003e\u003c/video\u003e 5.3.2 输入标签 在网页中提供输入视图（文本输入框、密码输入框等）以便用户可以在页面中输入数据 \u003c!--文本输入框--\u003e\u003cinput type=\"text\"/\u003e \u003c!--密码输入框--\u003e\u003cinput type=\"password\"/\u003e \u003c!--文件选择框--\u003e\u003cinput type=\"file\"/\u003e \u003c!--单选按钮: 必须提供value属性，必须提供name属性并且同一组选项name属性必须相同--\u003e \u003cinput type=\"radio\" value=\"M\" name=”gender“/\u003e男 \u003cinput type=\"radio\" value=\"F\" name=”gender“/\u003e女 \u003c!--复选框：同单选按钮--\u003e \u003cinput type=\"checkbox\" value=\"t\" name=\"hobby\"/\u003e旅游 \u003c!--普通按钮：默认按钮上没有文字，需要通过value属性指定按钮上的文字--\u003e \u003cinput type=\"button\" value=\"普通按钮\"/\u003e \u003c!--提交按钮--\u003e\u003cinput type=\"submit\"/\u003e \u003c!--重置按钮--\u003e\u003cinput type=\"reset\"/\u003e \u003c!--图片按钮: 作用其实是一个提交按钮，通过src属性指定按钮图片--\u003e \u003cinput type=\"image\" src=\"img/btn.jpg\"/\u003e \u003c!--颜色选择框--\u003e\u003cinput type=\"color\"/\u003e \u003c!--日期输入框--\u003e\u003cinput type=\"date\"/\u003e \u003c!--数字输入框--\u003e\u003cinput type=\"number\"/\u003e \u003c!--下拉菜单：选项option标签必须提供value属性--\u003e \u003cselect\u003e \u003coption value=\"深圳\"\u003e深圳\u003c/option\u003e \u003coption value=\"WH\"\u003e武汉\u003c/option\u003e \u003c/select\u003e \u003c!--文本域:多行输入框--\u003e \u003ctextarea\u003e\u003c/textarea\u003e 5.3.3 布局标签 布局标签，就是对网页中的元素进行排版 \u003c!-- 换行 --\u003e\u003cbr/\u003e \u003c!-- 水平分割线 --\u003e \u003chr/\u003e \u003c!-- 段落 --\u003e\u003cp\u003e\u003c/p\u003e \u003c!-- 字段域 --\u003e \u003cfieldset\u003e \u003clegend\u003e字段域标题\u003c/legend\u003e \u003c/fieldset\u003e \u003c!-- 列表 --\u003e \u003cul\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003c/ul\u003e \u003col\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003c/ol\u003e \u003c!-- 表格 --\u003e \u003ctable\u003e \u003ccaption\u003e表格标题\u003c/caption\u003e \u003ctr\u003e \u003ctd\u003e\u003c/td\u003e \u003ctd\u003e\u003c/td\u003e \u003ctd\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003c/td\u003e \u003ctd\u003e\u003c/td\u003e \u003ctd\u003e\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c!-- div+css: 绝对布局、相对布局、浮动布局 --\u003e \u003cdiv style=\"postition:absolute|relative|float; left:10px ; top:10px\"\u003e \u003c/div\u003e 5.3.4 页面框架 页面框架，实现同一个网页中动态展示多个网页 \u003c!--frameset--\u003e \u003c!--iframe---\u003e 页面框架案例： 2021年1月11日 练习任务 JDBC练习 创建一个图书信息表： tb_books 新建一个Java项目：jdbc-bims 在项目中添加 mysql驱动文件 在项目中创建\"cn.edu.hubu.bims.utils\"包，完成DBUtil类 在项目中创建\"cn.edu.hubu.bims.dto\"包，创建Boot类 在项目中创建\"cn.edu.hubu.bims.dao\"包，创建BookDAO类，完成如下操作： 添加图书信息 根据图书编号删除图书信息 根据图书编号修改图书信息 根据图书编号查询一个图书信息 分页查询图书信息 查询图书信息总记录数 5.4 CSS样式总结 5.4.1 CSS基本语法 几乎所有的HTML标签都可以添加style属性来设置元素的显示样式 \u003cimg src=\"img/01.jpg\" style=\"width:200px;height:100px;\"/\u003e 如果在同一个网页中，有多个HTML标签具有相同的样式，我们可以直接将样式定义在style标签中；在style标签定义样式常用的有三种选择器： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e /*如果我们将样式定义在style标签中，常用的有三种选择器：*/ /*1.标签选择器:使用标签的名字作为样式名称 img{ width:200px; height:100px; } */ /*2.类选择器：对网页中\"class=样式名\"的标签有效*/ .style1{ width:200px; height:100px; } /*3.id选择器：对网页中\"id=样式名\"的标签有效*/ #img2{ border-radius: 10px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cimg src=\"img/01.jpg\" id=\"img2\"/\u003e \u003cimg src=\"img/02.jpg\" /\u003e \u003cimg src=\"img/03.jpg\" /\u003e \u003cimg src=\"img/04.jpg\" class=\"style1\"/\u003e \u003ctextarea class=\"style1\"\u003e\u003c/textarea\u003e \u003c/body\u003e \u003c/html\u003e 在一个HTML标签中的class属性可以引用style中定义的多种样式 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e .style1{ width:200px; height:100px; } .style2{ border-radius: 50px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cimg src=\"img/04.jpg\" class=\"style1 style2\"/\u003e \u003c/body\u003e \u003c/html\u003e 如果一个标签引用多个样式时，在多个样式中出现了样式属性值的冲突——就近一致 如果多个网页中需要使用相同的样式，我们可以把公用的样式单独定义在一个css文件中，然后在需要使用样式的HTML文档中引用这个css文件即可 样式文件 5.4.2 CSS常用样式 盒子模型：尺寸、背景、边框、外边距、内边距、字体、文本 高级样式：2D/3D 过渡 动画 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e /*尺寸样式*/ .sizeStyle{ width:400px; height: 200px; } /*边框样式*/ .bor","date":"2021-04-06","objectID":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/:5:0","tags":[],"title":"千峰实训","uri":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/"},{"categories":["大三上实训笔记"],"content":"六、web服务器 当我们完成了网页的设计之后，如何能够让我们的网页能够被互联网用户访问呢？ 我们需要借助于web服务器软件来提供web项目的网络访问； 6.1 web服务器介绍 web服务器软件：用来管理web项目、能够接收HTTP协议请求的软件 Tomcat访问过程 6.2 安装Tomcat 6.2.1 下载安装JDK Tomcat需要依赖JDK 6.2.2 下载安装Tomcat 下载：http://tomcat.apache.org (群文件下载) 安装：注意如果没有默认加载jre路径，需要手动选择 tomcat安装选择JRE 安装之后，默认在C:\\Program Files\\Apache Software Foundation\\Tomcat 8.5 Tomcat目录结构 6.3 web项目部署 web项目部署：就是将web项目拷贝粘贴到Tomcat的webapps目录 web项目部署 6.4 启动Tomcat 启动服务器 6.5 在浏览器中访问Tomcat中的项目 6.6 云主机 由于我们使用的网络都是非商用IP，因此如果我们把项目部署在本地（自己的计算机），只能同一个局域网内可访问，如何实现互联网访问呢？ 购买商用IP 使用内网穿透（需要本地计算机服务器同时启动） 使用云主机 项目上云 ","date":"2021-04-06","objectID":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/:6:0","tags":[],"title":"千峰实训","uri":"/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD3-1/"},{"categories":["大三上实训笔记"],"content":"大三上学期小米商城后台管理系统实训笔记","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/"},{"categories":["大三上实训笔记"],"content":"《小米商城后台管理系统》 ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/:1:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/"},{"categories":["大三上实训笔记"],"content":"一、需求分析 电商系统项目结构 管理员登录 管理员要使用正确的账号和密码进行登录之后才能使用这个管理系统 商品类别管理 通过管理系统，能够动态完成添加商品类别、商品类别列表、修改类别及删除类别等操作 商品管理 通过管理系统，可以动态完成商品发布、商品列表（分页）、修改商品信息、删除商品信息（下架） 用户管理 订单管理 售后服务 ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/:2:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/"},{"categories":["大三上实训笔记"],"content":"二、项目设计 2.1 数据库设计 2.1.1 分析数据实体 管理员 类别 商品 2.1.2 提取实体数据项 根据甲方的业务需求及项目的功能需求分析每个数据实体的属性 管理员（管理员编号/工号，管理员账号，管理员密码，管理员姓名，管理员头像，管理员电话） 类别（类别ID，类别名称，类别描述） 商品（商品编号，商品名称，商品图片，商品价格，商品库存，商品说明，图文详情）、 2.1.3 规范实体数据项 使用数据库设计范式检查数据项是否合理——数据库设计三范式 第一范式：数据表中的字段不可再分 第二范式：不存在非关键字段对关键字段的部分函数依赖 第三范式：不存在非关键字段之间的传递依赖 2.1.4 绘制实体关系图（E-R） 通过E-R图例，分析实体和实体之间的关系（一对一、一对多、多对一、多对多） 在企业开发中通常是通过PD进行数据库建模 实体关系图 2.1.5 数据表设计（三线图） 2.1.6 建库建表（SQL） 大家根据三线图自行完成 2.2 业务流程设计 项目中业务实现的过程 2.2.1 管理登录业务流程 管理员登录 2.2.2 类别管理业务流程 添加类别 类别列表 修改类别 删除类别 2.2.3 商品管理业务流程 发布商品 商品列表 修改商品 删除商品 商品详情 2.3 UI界面设计 2.3.1 管理员登录 登录页面 login.html 主页面 index.html 2.3.2 类别管理 类别添加页面 type-add.html 类别列表页面 type-list.html 类别修改页面 type-modify.html 提示页面 tips.html 2.3.3 商品管理 暂略 ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/:3:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/"},{"categories":["大三上实训笔记"],"content":"三、编码—数据库编程、UI 3.1 创建项目—web项目 3.1.1 web项目创建 3.1.2 IDEA启动tomcat 启动 如果在启动Tomcat时出现以下错误，请手动打开Tomcat/bin/tomcat8w.exe关闭之前运行的Tomcat 3.1.3 修改项目的访问路径 在IDEA中启动Tomcat，会自动将web项目部署到Tomcat，但是web项目的访问路径默认与web名称时不一致的；我们可以设置项目访问路径 3.1.4 设置项目的默认访问页面 当我们启动Tomcat之后，通过路径http://ip:port/pro_name后面没有指定访问的页面名称，会默认访问index.html,如果没有index.html就寻找index.jsp web/WEB-INF/web.xml 3.2 完成项目业务所需的JDBC操作 完成项目业务流程中所需的数据库操作 3.2.1 向web项目中添加mysql数据库驱动文件 在web/WEB-INF目录下创建lib文件夹，将驱动文件拷贝粘贴到此文件夹，然后Add as Library 目录结构 3.2.2 创建数据库连接工具类DBUtil 创建cn.edu.hubu.xmsc.utils包 在cn.edu.hubu.xmsc.utils包装创建DBUtil类 DBUtil 3.2.3 完成管理登录所需的数据库操作 DTO类 Manager DAO类 ManagerDAO 3.2.4 完成类别管理的数据库操作 DTO类 Type DAO类 TypeDAO 3.3 设计界面并把界面整合到项目中 3.3.1 添加页面到项目的web目录 将在HBuilder中设计完成的HTML文件及其关联的静态资源(css\\js\\img\\fonts)拷贝到Javaweb项目的 web目录 3.3.2 将HTML页面转换成JSP页面 JSP（Java Server Page） 是一种基于web服务器运行的动态网页技术 支持Java代码 必须依赖于web服务器运行，不能使用浏览器直接打开 兼容HTML，在JSP中可以向在HTML文件中一样写HTML/CSS和JS ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/:4:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/"},{"categories":["大三上实训笔记"],"content":"四、编码— 业务(流程)实现 按照设计阶段完成业务流程，完成项目功能的实现 4.1 管理员登录功能 4.1.1 创建LoginServlet Servlet类——指的是继承了javax.servlet.HttpServlet类、实现了HTTP协议、能够接收HTTP请求的类 Servlet类的创建步骤 4.1.2 login.jsp提交数据到LoginServlet类 login.jsp 4.1.3 在LoginServlet类接收并处理请求 LoginServlet 4.1.4 在login.jsp显示提示信息 login.jsp 4.1.5 使用session解决登录认证问题 登录认证问题：如果管理员没有，我们不允许浏览器访问处理login.jsp以外的任何页面 index.jsp LoginServlet 4.1.6 在index.jsp显示当前登录管理员的姓名和头像 当管理员登录成功之后，我们将管理员的信息已经存放到了session中 index.jsp 4.2 类别管理—添加类别 4.2.1 点击添加类别跳转到type-add.jsp index.jsp 4.2.2 创建TypeAddServlet TypeAddServlet 4.2.3 type-add.jsp提交类别信息到TypeAddServlet type-add.jsp 4.2.4 在TypeAddServlet中接收并保存类信息，并跳转到提示页面 TypeAddServlet 4.2.5 在tips页面显示提示信息 因为操作成功和操作失败显示不同的信息，因此在jsp页面中需要实现流程控制—分支语句。 我们可以在JSP页面中使用JSTL实现流程控制（分支、循环） 在JSP页面中使用JSTL标签的准备工作： 下载jstl.jar 和 standard.jar并添加到项目 在需要使用JSTL标签库的JSP页面中引入标签 \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e tips.jsp 4.2.6 类别数据校验 type-add.jsp 4.3 类别管理—类别列表 4.3.1 创建TypeListServlet类 TypeListServlet 4.3.2 在index.jsp点击类别列表跳转到TypeListServlet index.jsp 4.3.3 在TypeListServlet中查询所有类别并传递到type-list.jsp TypeListServlet 4.3.4 在type-list.jsp中显示类别列表信息 因为TypeListServlet传递的是一个Type的集合，因此在type-list.jsp中需要通过JSTL的循环来遍历所有的类别 type-list.jsp 4.4 类别管理—修改类别 4.4.1 创建TypeQueryServlet 因为点击类别列表中的“修改”之后，需要跳转到TypeQueryServlet，因此要先完成TypeQueryServlet的创建 TypeQueryServlet 4.4.2 点击type-list.jsp页面的修改将类别ID传递到TypeQueryServlet type-list.jsp 4.4.3 在TypeQueryServlet接收类别ID、查询并传递到type-modify.jsp TypeQueryServlet 4.4.4 在type-modify.jsp显示类别的原始信息 type-modify.jsp 4.4.5 创建TypeUpdateServlet 4.4.6 在type-modify.jsp完成修改之后提交到TypeUpdateServlet type-modify.jsp 4.4.7 在TypeUpdateServlet接收类别信息并执行修改 TypeUpdateServlet 4.5 类别管理—删除类别 4.5.1 创建TypeDeleteServlet类 4.5.2 在type-list.jsp页面点击删除跳转到TypeDeleteServlet type-list.jsp 4.5.3 在TypeDeleteServlet中接收类别ID并执行删除 TypeDeleteServlet 4.5.4 当点击“删除”之后弹出弹窗确认 type-list.jsp 4.6 商品管理—发布商品 4.6.1 设计goods-add.jsp 步骤略 4.6.2 完成数据库操作 创建DTO类 Goods 创建DAO类 GoodsDAO 4.6.3 创建GoodsListTypeServlet类 4.6.4 在index.jsp页面点击发布商品跳转到 index.jsp 4.6.5. 在GoodsListTypeServlet类中查询类别列表传递到goods-add.jsp GoodsListTypeServlet 4.6.6 在goods-add.jsp中通过JSTL显示类别信息到下拉菜单选项 goods-add.jsp 4.6.7 创建GoodsAddServlet类 4.6.8 在goods-add.jsp点击“立即提交”提交到GoodsAddServlet类 在goods-add.jsp表单中包含了文件，如果提交的form表单中包含文件，需要注意以下几点： form的提交方式必须为 post form表单中的数据默认会压缩传输，如果包了文件就必须设置 enctype=\"multipart/form-data\"声明表达中的数据非压缩传输 goods-add.jsp 4.6.9 在GoodsAddServlet类中接收商品信息 因为表单提交数据采用enctype=\"multipart/form-data\"提交，所以在Servlet中按照原来的方式接收数据就接收不到了，必须在GoodsAddServlet类前添加@MultipartConfig解析非压缩方式提交的数据 上传的文件需要保存在特定的目录——在项目的web目录下创建名为files的文件夹用于保存图片（如果files文件夹是空的，项目部署时不会自动创建此目录，因此建议在files目录下默认放一个文件） GoodsAddServlet 4.7 商品管理—商品列表 4.7.1 设计goods-list.jsp 4.7.2 完成此功能的数据库操作 GoodsDAO 4.7.3 创建GoodsListServlet类 4.7.4 在index.jsp中点击商品列表跳转到GoodsListServlet类 默认显示第一页商品信息，传递默认页码为1 index.jsp 4.7.5 在GoodsListServlet类中接收页码、查询数据 GoodsListServlet 4.7.6 在goods-list.jsp中通过JSTL显示商品信息、分页信息 goods-list.jsp 显示商品数据 goods-list.jsp 显示分页数据 4.8 商品管理—搜索—按类别搜索 4.8.1 完成按类别查询商品的数据库操作 GoodsDAO 4.8.2 在GoodsListServlet中查询所有类别，并传递到goods-list.jsp GoodsListServlet 4.8.3 在商品列表页面显示类别列表 goods-list.jsp 4.8.4 创建GoodsListByTypeServlet类 4.8.5 点击商品类别页面的类别跳转到GoodsListByTypeServlet类 goods-list.jsp 4.8.6 在GoodsListByTypeServlet中接收类别ID和页码进行查询 GoodsListByTypeServlet 4.8.9 按类别查询商品分页问题 GoodsListServlet GoodsListByTypeServlet goods-list.jsp ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/:5:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/"},{"categories":["大三上实训笔记"],"content":"五、项目部署（Linux） 项目开发完成之后，将项目部署到生产环境正式的上线运营 5.1 Linux介绍 5.1.1 优点 用于生产环境的服务器主机通常会选择Linux系统 windows的优点是有比较人性化的可视化操作界面，这个可视化界面会占用大量的系统资源；但是生产环境中服务器主机主要用于web容器（tomcat）的执行，为了最大限度的使用硬件资源，所以我们通常会选择系统开销更小的Linux Linux系统是开源 Linux性能比windows更稳定（宕机概率较低） Linux防火墙组件性能高、保证系统安全 5.1.2 版本 RedHat（效率高、可靠性好） Ubuntu CentOS（基于RedHat源码编译而成，完全开源） 6.x 7.x 5.1.3 如何获取Linux 安装虚拟机，在虚拟机中安装CentOS 购买硬件主机、安装（成本高、商用） 购买云主机 5.2 购买云主机 5.2.1 云主机运营商 阿里云（推荐） https://developer.aliyun.com/adc/student/#ecscolleges-collocation-stu https://dashi.aliyun.com/site/cloud/student 腾讯云 5.3 管理云主机 5.3.1 登录到云主机 登录到阿里云的控制台（使用购买云主机时的账号和密码） https://account.aliyun.com/ 进入到ECS服务器管理界面 点击购买的实例进入到实例的配置页面 5.3.2 云主机系统管理 常规配置 5.3.3 修改云主机密码 设置root用户的登录密码 密码重置完成之后，重启服务器 5.3.4 安全组设置 阿里云主机为了保证系统的安全，提供了访问限制（端口配置） 进入到安全组配置页面 放行 3306端口 放行8080端口 5.4 使用远程工具连接云主机 云主机是远程的主机，需要使用工具进行远程连接，然后通过远程工具进行云主机的操作 5.4.1 xftp xftp是一个远程的文件传输工具，可以将本机上的文件上传到云主机 从群文件下载并安装（傻瓜式安装） 创建连接 将Tomcat和JDK的安装包 上传到 Linux 5.4.2 xshell xshell是一个远程终端，可以通过指令操作远程云主机 从群文件下载并安装（傻瓜式） 如果xftp已经与云主机建立连接，xshell其实是可以不用建立连接的，建议在xshell创建连接 5.5 在Linux系统中安装JDK并配置环境变量 5.5.1 将JDK的安装包上传到Linux系统的usr/local目录 使用xftp上传文件 5.5.2 解压JDK的压缩包 xshell连接到云主机 [root@theo ~]# cd /usr/local [root@theo local]# ls aegis apache-tomcat-8.5.46.tar.gz bin etc games include jdk-8u221-linux-x64.tar.gz lib lib64 libexec sbin share src [root@theo local]# tar -zxvf jdk-8u221-linux-x64.tar.gz 查看解压后的目录结构 [root@theo local]# ls aegis apache-tomcat-8.5.46.tar.gz bin etc games include jdk1.8.0_221 jdk-8u221-linux-x64.tar.gz lib lib64 libexec sbin share src [root@theo local]# cd jdk1.8.0_221/ [root@theo jdk1.8.0_221]# ls bin COPYRIGHT include javafx-src.zip jre lib LICENSE man README.html release src.zip THIRDPARTYLICENSEREADME-JAVAFX.txt THIRDPARTYLICENSEREADME.txt [root@theo jdk1.8.0_221]# cd bin [root@theo bin]# ls appletviewer jar javadoc javapackager jconsole jhat jmc jsadebugd jvisualvm pack200 rmiregistry tnameserv xjc ControlPanel jarsigner javafxpackager java-rmi.cgi jcontrol jinfo jmc.ini jstack keytool policytool schemagen unpack200 extcheck java javah javaws jdb jjs jps jstat native2ascii rmic serialver wsgen idlj javac javap jcmd jdeps jmap jrunscript jstatd orbd rmid servertool wsimport 5.5.3 配置JDK环境变量 进入到/etc目录，找到profile文件 [root@theo bin]# cd /etc [root@theo etc]# ls 编辑这个profile文件，在文件中添加JDK环境变量 [root@theo etc]# vim profile 可以打开文件编辑器，必须输入字母i进入到编辑状态,在最后面添加如下四项配置： export JAVA_HOME=/usr/local/jdk1.8.0_221 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$JAVA_HOME/bin:$PATH 编辑完成之后，点击键盘“Esc”按键退出编辑状态，输入:wq保存并退出编辑器 5.5.4 重新加载配置文件 [root@theo etc]# source /etc/profile [root@theo etc]# java -version java version \"1.8.0_221\" Java(TM) SE Runtime Environment (build 1.8.0_221-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) 5.6 在Linux系统中安装Tomcat 5.6.1 从群文件按下载Tomcat安装包并上传到Linux的/usr/local目录 5.6.2 解压tomcat xshell连接到linux，在xshell中输入以下指令： [root@theo etc]# cd /usr/local [root@theo local]# tar -zxvf apache-tomcat-8.5.46.tar.gz 5.6.3 启动Tomcat [root@theo local]# cd apache-tomcat-8.5.46/ [root@theo apache-tomcat-8.5.46]# cd bin [root@theo bin]# ./startup.sh Using CATALINA_BASE: /usr/local/apache-tomcat-8.5.46 Using CATALINA_HOME: /usr/local/apache-tomcat-8.5.46 Using CATALINA_TMPDIR: /usr/local/apache-tomcat-8.5.46/temp Using JRE_HOME: /usr/local/jdk1.8.0_221/jre Using CLASSPATH: /usr/local/apache-tomcat-8.5.46/bin/bootstrap.jar:/usr/local/apache-tomcat-8.5.46/bin/tomcat-juli.jar Tomcat started. 5.6.4 关闭linux防火墙 # 查看防火墙状态 [root@theo bin]# systemctl status firewalld ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: inactive (dead) Docs: man:firewalld(1) # 关闭防火墙 [root@theo bin]# systemctl stop firewalld # 启动防火墙 [root@theo bin]# systemctl start firewalld 5.6.5 远程访问linux中的tomcat http://47.96.11.185:8080/ 5.6.6 停止Tomcat # 在Linux系统中安装lsof指令（安装一次之后就不用重复安装了） [root@theo bin]# yum install -y lsof # 通过lsof 指令查看8080的进程号 [root@theo bin]# l","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/:6:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/"},{"categories":["大三上实训笔记"],"content":"六、项目开发任务（必须完成） 1.随堂项目功能需要完成 管理员登录 类别管理 添加类别（JS数据校验） 类别列表 删除类别（JS提示） 修改类别 商品管理 发布商品 商品列表+分页 2.扩展功能（自行完成） 管理员登录的表单校验 类别管理 修改类别（JS数据校验） 商品管理 发布商品（JS数据校验） 删除商品 修改商品 商品详情 ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/:7:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F3-1/"},{"categories":null,"content":"PDF文章列表 pdf名称 备注 1、JavaSE：Java入门.pdf 2、JavaSE：基础语法.pdf 3、JavaSE：流程控制.pdf 4、JavaSE：方法.pdf 5、JavaSE：数组.pdf 6、JavaSE：面向对象.pdf 7、JavaSE：异常机制.pdf 8、JavaSE：常用类.pdf 9、JavaSE：集合框架.pdf 10、JavaSE：IO流.pdf 11、JavaSE：多线程.pdf 12、JavaSE：网络编程.pdf 13、JavaSE：Gui编程.pdf 14、JavaSE：注解和反射.pdf 15、MySQL和JDBC.pdf 16、前端：Html5.pdf 18、前端：JavaScript、jQuery.pdf 19、JavaWeb.pdf 20、MyBatis.pdf 21、Spring.pdf 22、SpringMVC.pdf 23、大前端串讲.pdf 24、Vue精讲.pdf 25、SpringBoot入门及原理.pdf 26、SpringBoot操作数据库.pdf 27、SpringBoot开发单体应用.pdf 28、SpringBootWeb开发提升.pdf 29、SpringSecurity权限控制.pdf 31、Shiro.pdf 32、SpringCloudNetflix-H版.pdf 33、JVM探究.pdf 34、JUC精讲.pdf 35、Git.pdf 36、Linux使用.pdf 37、Redis精讲.pdf 38、ElasticSearch.pdf 40、Docker.pdf docker 基础 41、Docker下.pdf compose、swarm java数据结构与算法.pdf Exin DevOps Master WhitePaper_V1.5_CN.pdf DevOps Master 白皮书企业DevOps的成功之路 Devops之基于Jenkins的CI与CD(1).pdf Devops之基于Jenkins的CI与CD Jenkins与Gitlab.pdf Jenkins持续集成从入门到精通.pdf 2021阿里巴巴Java面试手册 剑指OFFER名企面试官精讲典型编程题_第2版 剑指OFFER 机器学习 机器学习 python 学习笔记 python 学习笔记 阿里系Java开发相关 名称 备注 轻松玩转docker.pdf Nacos架构\u0026原理.pdf Elasticsearch全观测技术解析与应用（构建日志、指标、APM统一观测平台）.pdf 技术人的百宝黑皮书.pdf 阿里低代码引擎白皮书.pdf java开发手册嵩山版.pdf java开发手册泰山版.pdf ","date":"2019-08-02","objectID":"/pdflist/:0:0","tags":null,"title":"pdf列表","uri":"/pdflist/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于本站","uri":"/about/"},{"categories":null,"content":"许可协议 更多信息请查看 LICENSE 文件。 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于本站","uri":"/about/"},{"categories":null,"content":" #article-container { display: block; word-wrap: break-word; overflow-wrap: break-word } #article-container a { color: #49b1f5 } #article-container a:hover { text-decoration: underline } #article-container img { margin: 0 auto .8rem } .flink#article-container .friend-list-div .friend-div a .friend-info, .flink#article-container .friend-list-div .friend-div a .friend-name { overflow: hidden; -o-text-overflow: ellipsis; text-overflow: ellipsis; white-space: nowrap } .flink#article-container .friend-list-div { display: initial; overflow: auto; padding: 10px 10px 0; text-align: center; } .flink#article-container .friend-list-div .friend-div { position: relative; float: left; overflow: hidden; margin: 15px 7px; width: calc(100% / 3 - 15px); height: 90px; border-radius: 8px; line-height: 17px; -webkit-transform: translateZ(0); box-shadow: 0 0 5px 5px #f2f2f2; } @media screen and (max-width: 1100px) { .flink#article-container .friend-list-div .friend-div { width: calc(50% - 15px) !important } @media screen and (max-width: 600px) { .flink#article-container .friend-list-div .friend-div { width: calc(100% - 15px) !important } } } .flink#article-container .friend-list-div .friend-div:hover { background: rgba(87, 142, 224, 0.15); } .flink#article-container .friend-list-div .friend-div:hover img { -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -o-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg) } .flink#article-container .friend-list-div .friend-div:before { position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: -1; background: var(--text-bg-hover); content: ''; -webkit-transition: -webkit-transform .3s ease-out; -moz-transition: -moz-transform .3s ease-out; -o-transition: -o-transform .3s ease-out; -ms-transition: -ms-transform .3s ease-out; transition: transform .3s ease-out; -webkit-transform: scale(0); -moz-transform: scale(0); -o-transform: scale(0); -ms-transform: scale(0); transform: scale(0) } .flink#article-container .friend-list-div .friend-div:hover:before, .flink#article-container .friend-list-div .friend-div:focus:before, .flink#article-container .friend-list-div .friend-div:active:before { -webkit-transform: scale(1); -moz-transform: scale(1); -o-transform: scale(1); -ms-transform: scale(1); transform: scale(1) } .flink#article-container .friend-list-div .friend-div a { color: var(--font-color); text-decoration: none } .flink#article-container .friend-list-div .friend-div a img{ float: left; margin: 15px 10px; width: 60px; height: 60px; border-radius: 35px; -webkit-transition: all .3s; -moz-transition: all .3s; -o-transition: all .3s; -ms-transition: all .3s; transition: all .3s } .flink#article-container .friend-list-div .friend-div a .friend-name { display: block; padding: 16px 10px 0 0; height: 40px; font-weight: 700; font-size: 20px } .flink#article-container .friend-list-div .friend-div a .friend-info { display: block; padding: 1px 10px 1px 0; height: 50px; font-size: 13px } nuxt静态页面 nuxt框架，企业产品展示 #article-container { display: block; word-wrap: break-word; overflow-wrap: break-word } #article-container a { color: #49b1f5 } #article-container a:hover { text-decoration: underline } #article-container img { margin: 0 auto .8rem } .flink#article-container .friend-list-div .friend-div a .friend-info, .flink#article-container .friend-list-div .friend-div a .friend-name { overflow: hidden; -o-text-overflow: ellipsis; text-overflow: ellipsis; white-space: nowrap } .flink#article-container .friend-list-div { display: initial; overflow: auto; padding: 10px 10px 0; text-align: center; } .flink#article-container .friend-list-div .friend-div { position: relative; float: left; overflow: hidden; margin: 15px 7px; width: calc(100% / 3 - 15px); height: 90px; border-radius: 8px; line-height: 17px; -webkit-transform: translateZ(0); box-shadow: 0 0 5px 5px #f2f2f2; } @media screen and (max-width: 1100px) { .flink#article-container .friend-list-div .friend-div { width: calc(5","date":"2019-08-02","objectID":"/friend/:0:0","tags":null,"title":"友情链接","uri":"/friend/"}]