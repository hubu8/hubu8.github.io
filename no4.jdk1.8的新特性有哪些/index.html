<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>No4.JDK1.8的新特性有哪些 - Eccentric&#39;s Note</title><meta name="Description" content="本站主要用来收集整理资料、记录笔记，方便自己查询使用。"><meta property="og:title" content="No4.JDK1.8的新特性有哪些" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hubu8.github.io/no4.jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B/" /><meta property="og:image" content="https://hubu8.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-19T13:59:09+08:00" />
<meta property="article:modified_time" content="2023-02-19T13:59:09+08:00" /><meta property="og:site_name" content="My cool site" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://hubu8.github.io/logo.png"/>

<meta name="twitter:title" content="No4.JDK1.8的新特性有哪些"/>
<meta name="twitter:description" content=""/>
<meta name="application-name" content="Eccentric&#39;s Note">
<meta name="apple-mobile-web-app-title" content="Eccentric&#39;s Note"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/header_images/favicon-32x32.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://hubu8.github.io/no4.jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B/" /><link rel="prev" href="https://hubu8.github.io/no3.%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98/" /><link rel="next" href="https://hubu8.github.io/no5.java%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "No4.JDK1.8的新特性有哪些",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/hubu8.github.io\/no4.jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B\/"
        },"genre": "posts","wordcount":  6312 ,
        "url": "https:\/\/hubu8.github.io\/no4.jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B\/","datePublished": "2023-02-19T13:59:09+08:00","dateModified": "2023-02-19T13:59:09+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Eccentric"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Eccentric&#39;s Note">Eccentric&#39;s Note</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/"> 首页 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/posts/"> 归档 </a><a class="menu-item" href="/pdflist/"> pdf </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/hubu8" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Eccentric&#39;s Note">Eccentric&#39;s Note</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/" title="">首页</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/posts/" title="">归档</a><a class="menu-item" href="/pdflist/" title="">pdf</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/hubu8" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">No4.JDK1.8的新特性有哪些</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/hubu8" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Eccentric</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/java%E9%9D%A2%E8%AF%95/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>java面试</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2023-02-19">2023-02-19</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 6312 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 13 分钟&nbsp;<span id="/no4.jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B/" class="leancloud_visitors" data-flag-title="No4.JDK1.8的新特性有哪些">
                        <i class="far fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#一接口的默认方法">一、接口的默认方法</a></li>
        <li><a href="#二lambda-表达式">二、Lambda 表达式</a></li>
        <li><a href="#三函数式接口">三、函数式接口</a></li>
        <li><a href="#四方法与构造函数引用">四、方法与构造函数引用</a></li>
        <li><a href="#五lambda-作用域">五、Lambda 作用域</a></li>
        <li><a href="#六访问局部变量">六、访问局部变量</a></li>
        <li><a href="#七访问对象字段与静态变量">七、访问对象字段与静态变量</a></li>
        <li><a href="#八访问接口的默认方法">八、访问接口的默认方法</a></li>
        <li><a href="#九date-api">九、Date API</a></li>
        <li><a href="#十annotation-注解">十、Annotation 注解</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h3 id="一接口的默认方法">一、接口的默认方法</h3>
<p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下：</p>
<p>代码如下:</p>
<p>interface Formula { double calculate(int a);</p>
<p>default double sqrt(int a) { return Math.sqrt(a); } }</p>
<p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。</p>
<p>代码如下:</p>
<p>Formula formula = new Formula() { @Override public double calculate(int a) { return sqrt(a * 100); } };</p>
<p>formula.calculate(100); // 100.0 formula.sqrt(16); // 4.0</p>
<p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。</p>
<p>译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。</p>
<h3 id="二lambda-表达式">二、Lambda 表达式</h3>
<p>首先看看在老版本的Java中是如何排列字符串的：</p>
<p>代码如下:</p>
<p>List<String> names = Arrays.asList(&ldquo;peterF&rdquo;, &ldquo;anna&rdquo;, &ldquo;mike&rdquo;, &ldquo;xenia&rdquo;);</p>
<p>Collections.sort(names, new Comparator<String>() { @Override public int compare(String a, String b) { return b.compareTo(a); } });</p>
<p>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</p>
<p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p>
<p>代码如下:</p>
<p>Collections.sort(names, (String a, String b) -&gt; { return b.compareTo(a); });</p>
<p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：</p>
<p>代码如下:</p>
<p>Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</p>
<p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：</p>
<p>代码如下:</p>
<p>Collections.sort(names, (a, b) -&gt; b.compareTo(a));</p>
<p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：</p>
<h3 id="三函数式接口">三、函数式接口</h3>
<p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p>
<p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p>
<p>示例如下：</p>
<p>代码如下:</p>
<p>@FunctionalInterface interface Converter&lt;F, T&gt; { T convert(F from); } Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from); Integer converted = converter.convert(&ldquo;123&rdquo;); System.out.println(converted); // 123</p>
<p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。</p>
<p>译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。</p>
<h3 id="四方法与构造函数引用">四、方法与构造函数引用</h3>
<p>前一节中的代码还可以通过静态方法引用来表示：</p>
<p>代码如下:</p>
<p>Converter&lt;String, Integer&gt; converter = Integer::valueOf; Integer converted = converter.convert(&ldquo;123&rdquo;); System.out.println(converted); // 123</p>
<p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p>
<p>代码如下:</p>
<p>converter = something::startsWith; String converted = converter.convert(&ldquo;Java&rdquo;); System.out.println(converted); // &ldquo;J&rdquo;</p>
<p>接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：</p>
<p>代码如下:</p>
<p>class Person { String firstName; String lastName;</p>
<p>Person() {}</p>
<p>Person(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } }</p>
<p>接下来我们指定一个用来创建Person对象的对象工厂接口：</p>
<p>代码如下:</p>
<p>interface PersonFactory<P extends Person> { P create(String firstName, String lastName); }</p>
<p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p>
<p>代码如下:</p>
<p>PersonFactory<Person> personFactory = Person::new; Person person = personFactory.create(&ldquo;Peter&rdquo;, &ldquo;Parker&rdquo;);</p>
<p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>
<h3 id="五lambda-作用域">五、Lambda 作用域</h3>
<p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p>
<h3 id="六访问局部变量">六、访问局部变量</h3>
<p>我们可以直接在lambda表达式中访问外层的局部变量：</p>
<p>代码如下:</p>
<p>final int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);</p>
<p>stringConverter.convert(2); // 3</p>
<p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：</p>
<p>代码如下:</p>
<p>int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);</p>
<p>stringConverter.convert(2); // 3</p>
<p>不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：</p>
<p>代码如下:</p>
<p>int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); num = 3;</p>
<p>在lambda表达式中试图修改num同样是不允许的。</p>
<h3 id="七访问对象字段与静态变量">七、访问对象字段与静态变量</h3>
<p>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p>
<p>代码如下:</p>
<p>class Lambda4 { static int outerStaticNum; int outerNum;</p>
<p>void testScopes() { Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; { outerNum = 23; return String.valueOf(from); };</p>
<p>Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; { outerStaticNum = 72; return String.valueOf(from); }; } }</p>
<h3 id="八访问接口的默认方法">八、访问接口的默认方法</h3>
<p>还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。 Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：</p>
<p>代码如下:</p>
<p>Formula formula = (a) -&gt; sqrt( a * 100); Built-in Functional Interfaces</p>
<p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。 Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p>
<p>*<em>Predicate***<em>接口</em></em></p>
<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p>
<p>代码如下:</p>
<p>Predicate<String> predicate = (s) -&gt; s.length() &gt; 0;</p>
<p>predicate.test(&ldquo;foo&rdquo;); // true predicate.negate().test(&ldquo;foo&rdquo;); // false</p>
<p>Predicate<Boolean> nonNull = Objects::nonNull; Predicate<Boolean> isNull = Objects::isNull;</p>
<p>Predicate<String> isEmpty = String::isEmpty; Predicate<String> isNotEmpty = isEmpty.negate();</p>
<p><strong>Function</strong> <strong>接口</strong></p>
<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>
<p>代码如下:</p>
<p>Function&lt;String, Integer&gt; toInteger = Integer::valueOf; Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</p>
<p>backToString.apply(&ldquo;123&rdquo;); // &ldquo;123&rdquo;</p>
<p><strong>Supplier</strong> <strong>接口</strong> Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数</p>
<p>代码如下:</p>
<p>Supplier<Person> personSupplier = Person::new; personSupplier.get(); // new Person</p>
<p><strong>Consumer</strong> <strong>接口</strong> Consumer 接口表示执行在单个参数上的操作。</p>
<p>代码如下:</p>
<p>Consumer<Person> greeter = (p) -&gt; System.out.println(&ldquo;Hello, &quot; + p.firstName); greeter.accept(new Person(&ldquo;Luke&rdquo;, &ldquo;Skywalker&rdquo;));</p>
<p><strong>Comparator</strong> <strong>接口</strong> Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p>
<p>代码如下:</p>
<p>Comparator<Person> comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</p>
<p>Person p1 = new Person(&ldquo;John&rdquo;, &ldquo;Doe&rdquo;); Person p2 = new Person(&ldquo;Alice&rdquo;, &ldquo;Wonderland&rdquo;);</p>
<p>comparator.compare(p1, p2); // &gt; 0 comparator.reversed().compare(p1, p2); // &lt; 0</p>
<p><strong>Optional</strong> <strong>接口</strong></p>
<p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p>
<p>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。</p>
<p>代码如下:</p>
<p>Optional<String> optional = Optional.of(&ldquo;bam&rdquo;);</p>
<p>optional.isPresent(); // true optional.get(); // &ldquo;bam&rdquo; optional.orElse(&ldquo;fallback&rdquo;); // &ldquo;bam&rdquo;</p>
<p>optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // &ldquo;b&rdquo;</p>
<p><strong>Stream</strong> <strong>接口</strong></p>
<p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p>
<p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p>
<p>代码如下:</p>
<p>List<String> stringCollection = new ArrayList&lt;&gt;(); stringCollection.add(&ldquo;ddd2&rdquo;); stringCollection.add(&ldquo;aaa2&rdquo;); stringCollection.add(&ldquo;bbb1&rdquo;); stringCollection.add(&ldquo;aaa1&rdquo;); stringCollection.add(&ldquo;bbb3&rdquo;); stringCollection.add(&ldquo;ccc&rdquo;); stringCollection.add(&ldquo;bbb2&rdquo;); stringCollection.add(&ldquo;ddd1&rdquo;);</p>
<p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作：</p>
<p><strong>Filter</strong> <strong>过滤</strong></p>
<p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p>
<p>代码如下:</p>
<p>stringCollection .stream() .filter((s) -&gt; s.startsWith(&ldquo;a&rdquo;)) .forEach(System.out::println);</p>
<p>// &ldquo;aaa2&rdquo;, &ldquo;aaa1&rdquo;</p>
<p><strong>Sort</strong> <strong>排序</strong></p>
<p>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。</p>
<p>代码如下:</p>
<p>stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith(&ldquo;a&rdquo;)) .forEach(System.out::println);</p>
<p>// &ldquo;aaa1&rdquo;, &ldquo;aaa2&rdquo;</p>
<p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：</p>
<p>代码如下:</p>
<p>System.out.println(stringCollection); // ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</p>
<p><strong>Map</strong> <strong>映射</strong> 中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p>
<p>代码如下:</p>
<p>stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println);</p>
<p>// &ldquo;DDD2&rdquo;, &ldquo;DDD1&rdquo;, &ldquo;CCC&rdquo;, &ldquo;BBB3&rdquo;, &ldquo;BBB2&rdquo;, &ldquo;AAA2&rdquo;, &ldquo;AAA1&rdquo;</p>
<p><strong>Match</strong> <strong>匹配</strong></p>
<p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。</p>
<p>代码如下:</p>
<p>boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith(&ldquo;a&rdquo;));</p>
<p>System.out.println(anyStartsWithA); // true</p>
<p>boolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith(&ldquo;a&rdquo;));</p>
<p>System.out.println(allStartsWithA); // false</p>
<p>boolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith(&ldquo;z&rdquo;));</p>
<p>System.out.println(noneStartsWithZ); // true</p>
<p><strong>Count</strong> <strong>计数</strong> 计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。</p>
<p>代码如下:</p>
<p>long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith(&ldquo;b&rdquo;)) .count();</p>
<p>System.out.println(startsWithB); // 3</p>
<p><strong>Reduce</strong> <strong>规约</strong></p>
<p>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：</p>
<p>代码如下:</p>
<p>Optional<String> reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + &ldquo;#&rdquo; + s2);</p>
<p>reduced.ifPresent(System.out::println); // &ldquo;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&rdquo;</p>
<p>*<em>并行***<em>Streams</em></em></p>
<p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p>
<p>下面的例子展示了是如何通过并行Stream来提升性能：</p>
<p>首先我们创建一个没有重复元素的大表：</p>
<p>代码如下:</p>
<p>int max = 1000000; List<String> values = new ArrayList&lt;&gt;(max); for (int i = 0; i &lt; max; i++) { UUID uuid = UUID.randomUUID(); values.add(uuid.toString()); }</p>
<p>然后我们计算一下排序这个Stream要耗时多久， 串行排序：</p>
<p>代码如下:</p>
<p>long t0 = System.nanoTime();</p>
<p>long count = values.stream().sorted().count(); System.out.println(count);</p>
<p>long t1 = System.nanoTime();</p>
<p>long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0); System.out.println(String.format(&ldquo;sequential sort took: %d ms&rdquo;, millis));</p>
<p>// 串行耗时: 899 ms 并行排序：</p>
<p>代码如下:</p>
<p>long t0 = System.nanoTime();</p>
<p>long count = values.parallelStream().sorted().count(); System.out.println(count);</p>
<p>long t1 = System.nanoTime();</p>
<p>long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0); System.out.println(String.format(&ldquo;parallel sort took: %d ms&rdquo;, millis));</p>
<p>// 并行排序耗时: 472 ms 上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。</p>
<p><strong>Map</strong></p>
<p>前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。</p>
<p>代码如下:</p>
<p>Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</p>
<p>for (int i = 0; i &lt; 10; i++) { map.putIfAbsent(i, &ldquo;val&rdquo; + i); }</p>
<p>map.forEach((id, val) -&gt; System.out.println(val)); 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。</p>
<p>下面的例子展示了map上的其他有用的函数：</p>
<p>代码如下:</p>
<p>map.computeIfPresent(3, (num, val) -&gt; val + num); map.get(3); // val33</p>
<p>map.computeIfPresent(9, (num, val) -&gt; null); map.containsKey(9); // false</p>
<p>map.computeIfAbsent(23, num -&gt; &ldquo;val&rdquo; + num); map.containsKey(23); // true</p>
<p>map.computeIfAbsent(3, num -&gt; &ldquo;bam&rdquo;); map.get(3); // val33</p>
<p>接下来展示如何在Map里删除一个键值全都匹配的项：</p>
<p>代码如下:</p>
<p>map.remove(3, &ldquo;val3&rdquo;); map.get(3); // val33</p>
<p>map.remove(3, &ldquo;val33&rdquo;); map.get(3); // null</p>
<p>另外一个有用的方法：</p>
<p>代码如下:</p>
<p>map.getOrDefault(42, &ldquo;not found&rdquo;); // not found</p>
<p>对Map的元素做合并也变得很容易了：</p>
<p>代码如下:</p>
<p>map.merge(9, &ldquo;val9&rdquo;, (value, newValue) -&gt; value.concat(newValue)); map.get(9); // val9</p>
<p>map.merge(9, &ldquo;concat&rdquo;, (value, newValue) -&gt; value.concat(newValue)); map.get(9); // val9concat</p>
<p>Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p>
<h3 id="九date-api">九、Date API</h3>
<p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p>
<p><strong>Clock</strong> <strong>时钟</strong></p>
<p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p>
<p>代码如下:</p>
<p>Clock clock = Clock.systemDefaultZone(); long millis = clock.millis();</p>
<p>Instant instant = clock.instant(); Date legacyDate = Date.from(instant); // legacy java.util.Date</p>
<p><strong>Timezones</strong> <strong>时区</strong></p>
<p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。</p>
<p>代码如下:</p>
<p>System.out.println(ZoneId.getAvailableZoneIds()); // prints all available timezone ids</p>
<p>ZoneId zone1 = ZoneId.of(&ldquo;Europe/Berlin&rdquo;); ZoneId zone2 = ZoneId.of(&ldquo;Brazil/East&rdquo;); System.out.println(zone1.getRules()); System.out.println(zone2.getRules());</p>
<p>// ZoneRules[currentStandardOffset=+01:00] // ZoneRules[currentStandardOffset=-03:00]</p>
<p><strong>LocalTime</strong> <strong>本地时间</strong></p>
<p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>
<p>代码如下:</p>
<p>LocalTime now1 = LocalTime.now(zone1); LocalTime now2 = LocalTime.now(zone2);</p>
<p>System.out.println(now1.isBefore(now2)); // false</p>
<p>long hoursBetween = ChronoUnit.HOURS.between(now1, now2); long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</p>
<p>System.out.println(hoursBetween); // -3 System.out.println(minutesBetween); // -239</p>
<p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。</p>
<p>代码如下:</p>
<p>LocalTime late = LocalTime.of(23, 59, 59); System.out.println(late); // 23:59:59</p>
<p>DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);</p>
<p>LocalTime leetTime = LocalTime.parse(&ldquo;13:37&rdquo;, germanFormatter); System.out.println(leetTime); // 13:37</p>
<p><strong>LocalDate</strong> <strong>本地日期</strong></p>
<p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p>
<p>代码如下:</p>
<p>LocalDate today = LocalDate.now(); LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS); LocalDate yesterday = tomorrow.minusDays(2);</p>
<p>LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4); DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</p>
<p>System.out.println(dayOfWeek); // FRIDAY 从字符串解析一个LocalDate类型和解析LocalTime一样简单：</p>
<p>代码如下:</p>
<p>DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN);</p>
<p>LocalDate xmas = LocalDate.parse(&ldquo;24.12.2014&rdquo;, germanFormatter); System.out.println(xmas); // 2014-12-24</p>
<p><strong>LocalDateTime</strong> <strong>本地日期时间</strong></p>
<p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p>
<p>代码如下:</p>
<p>LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);</p>
<p>DayOfWeek dayOfWeek = sylvester.getDayOfWeek(); System.out.println(dayOfWeek); // WEDNESDAY</p>
<p>Month month = sylvester.getMonth(); System.out.println(month); // DECEMBER</p>
<p>long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY); System.out.println(minuteOfDay); // 1439</p>
<p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。</p>
<p>代码如下:</p>
<p>Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant();</p>
<p>Date legacyDate = Date.from(instant); System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014</p>
<p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p>
<p>代码如下:</p>
<p>DateTimeFormatter formatter = DateTimeFormatter .ofPattern(&ldquo;MMM dd, yyyy - HH:mm&rdquo;);</p>
<p>LocalDateTime parsed = LocalDateTime.parse(&ldquo;Nov 03, 2014 - 07:13&rdquo;, formatter); String string = formatter.format(parsed); System.out.println(string); // Nov 03, 2014 - 07:13</p>
<p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。</p>
<h3 id="十annotation-注解">十、Annotation 注解</h3>
<p>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。 首先定义一个包装类Hints注解用来放置一组具体的Hint注解：</p>
<p>代码如下:</p>
<p>@interface Hints { Hint[] value(); }</p>
<p>@Repeatable(Hints.class) @interface Hint { String value(); }</p>
<p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。</p>
<p>例 1: 使用包装类当容器来存多个注解（老方法）</p>
<p>代码如下:</p>
<p>@Hints({@Hint(&ldquo;hint1&rdquo;), @Hint(&ldquo;hint2&rdquo;)}) class Person {}</p>
<p>例 2：使用多重注解（新方法）</p>
<p>代码如下:</p>
<p>@Hint(&ldquo;hint1&rdquo;) @Hint(&ldquo;hint2&rdquo;) class Person {}</p>
<p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息：</p>
<p>代码如下:</p>
<p>Hint hint = Person.class.getAnnotation(Hint.class); System.out.println(hint); // null</p>
<p>Hints hints1 = Person.class.getAnnotation(Hints.class); System.out.println(hints1.value().length); // 2</p>
<p>Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class); System.out.println(hints2.length); // 2</p>
<p>即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。 另外Java 8的注解还增加到两种新的target上了：</p>
<p>代码如下:</p>
<p>@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE}) @interface MyAnnotation {}</p>
<p>关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。</p></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2023-02-19</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"><span>
                            <a class="link-to-markdown" href="/no4.jdk1.8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B/index.md" target="_blank">阅读原始文档</a>
                        </span></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/no3.%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E6%9C%89%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98/" class="prev" rel="prev" title="No3.高并发中的集合有哪些问题"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>No3.高并发中的集合有哪些问题</a>
            <a href="/no5.java%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" class="next" rel="next" title="No5.Java中抽象类和接口有什么区别">No5.Java中抽象类和接口有什么区别<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line"><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="http://jerry-cdn.b0.upaiyun.com/hit-kounter/hit-kounter-lc-0.2.0.js"></script><span data-hk-page="current"> - </span></div><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.99.1">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2021 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/hubu8" target="_blank">Eccentric</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><script type="text/javascript" src="/lib/valine/Valine.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/algoliasearch/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"valine":{"appId":"rTeTnudkYwu3cz5ejsdiKdFm-gzGzoHsz","appKey":"SfE7A8tmPKu2F6Pf5LMUewa4","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@14.0.0/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-cn","meta":["nick","mail"],"pageSize":10,"placeholder":"在这里留下足迹吧!","recordIP":true,"visitor":true}},"search":{"algoliaAppID":"CTZ67PPVA3","algoliaIndex":"hugo","algoliaSearchKey":"e41367b9d69db67ea65d45a33d7ae089","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
