[{"categories":["运维","Java后端","数据库","算法","前端","设计模式"],"content":"模式动机 软件系统：一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变，它们之间将产生联动 观察者模式： ​ 定义了对象之间一种一对多的依赖关系，让一个对象的改变能够影响其他对象发生改变的对象称为观察目标， ​ 被通知的对象称为观察者 ​ 一个观察目标可以对应多个观察者 ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":[],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["运维","Java后端","数据库","算法","前端","设计模式"],"content":"模式定义 观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式 观察者模式是一种对象行为型模式 ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":[],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["运维","Java后端","数据库","算法","前端","设计模式"],"content":"模式分析 有时候在具体观察者类ConcreteObserver中需要使用到具体目标类ConcreteSubject中的状态（属性），会存在关联或依赖关系 如果在具体层之间具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违背了开闭原则，但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响 ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":[],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["运维","Java后端","数据库","算法","前端","设计模式"],"content":"优点 可以实现表示层和数据逻辑层的分离 在观察目标和观察者之间建立一个抽象的耦合 支持广播通信，简化了一对多系统设计的难度 符合开闭原则，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便 ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":[],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["运维","Java后端","数据库","算法","前端","设计模式"],"content":"缺点 将所有的观察者都通知到会花费很多时间 如果存在循环依赖时可能导致系统崩溃 没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化 ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:5:0","tags":[],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["运维","Java后端","数据库","算法","前端","设计模式"],"content":"应用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用 一个对象的改变将导致一个或多个其他对象发生改变，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁 需要在系统中创建一个触发链 ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:6:0","tags":[],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["运维","Java后端","数据库","算法","前端","设计模式"],"content":"实例： 假设猫是老鼠和狗的观察目标，老鼠和狗是观察者，猫叫老鼠跑，狗也跟着叫，使用观察者模式描述该过程。 抽象目标类 import java.util.ArrayList; public abstract class Subject { protected ArrayList observers=new ArrayList(); //观察者集合 protected String subjectState; //观察目标自身的状态 public String getSubjectState() { return subjectState; } public void setSubjectState(String subjectState) { this.subjectState = subjectState; } public abstract void attach(Observer obs); //添加一个观察者 public abstract void detach(Observer obs); //删除一个观察者 public void notifyObservers() //通知所有观察者 { for(Object obs:observers) { ((Observer)obs).update(this); } } } 具体目标类 public class ConcreteSubject extends Subject { @Override public void attach(Observer obs) { //添加观察者 // TODO Auto-generated method stub observers.add(obs); } @Override public void detach(Observer obs) { //删除观察者 // TODO Auto-generated method stub observers.remove(obs); } } 抽象观察者类： //抽象观察者 public interface Observer { //更新观察者当前自身的状态 public void update(Subject subject); } 具体观察者1类： public class ConcreteObserver1 implements Observer { private String observerState=\"\"; @Override public void update(Subject subject) { // TODO Auto-generated method stub observerState=subject.getSubjectState(); System.out.println(\"观察者1当前状态：\"+observerState); } } 抽象观察者2类： public class ConcreteObserver2 implements Observer { private String observerState=\"\"; @Override public void update(Subject subject) { // TODO Auto-generated method stub observerState=subject.getSubjectState(); System.out.println(\"观察者2当前状态：\"+observerState); } } 客户端类： public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Subject cs=new ConcreteSubject(); cs.setSubjectState(\"状态1\"); ConcreteObserver1 obs1=new ConcreteObserver1(); ConcreteObserver2 obs2=new ConcreteObserver2(); cs.attach(obs1); cs.attach(obs2); System.out.println(\"观察目标初始状态：\"+cs.getSubjectState()); System.out.println(\"其它观察者的状态：\"); cs.notifyObservers(); System.out.println(\"-------------------\"); cs.setSubjectState(\"状态2\"); System.out.println(\"观察目标更新后状态：\"+cs.getSubjectState()); System.out.println(\"其它观察者更新后的状态：\"); cs.notifyObservers(); System.out.println(\"-------------------\"); cs.detach(obs2); cs.setSubjectState(\"状态3\"); System.out.println(\"观察目标更新后状态：\"+cs.getSubjectState()); System.out.println(\"其它观察者更新后的状态：\"); cs.notifyObservers(); } } ","date":"2021-05-28","objectID":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:7:0","tags":[],"title":"观察者模式","uri":"/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["java"],"content":"Java如何开启线程？怎么保证线程安全？ 线程与进程的区别：进程是操作系统进行资源分配的最小单元，线程是操作系统进行任务分配的最小单元，线程隶属于进程。 如何开启线程？ 基础Thread类，重写run方法(start方法开启线程内部调用run、如果直接调用run就是方法的调用，不会开启线程) 实现Runable接口，实现run方法() 实现Callable接口，实现call方法，通过FutureTask创建一个线程，获取到线程的返回结果， 通过线程池开启线程 如何保证线程安全？（多个线程对同一个资源进行操作）加锁 JVM提供的锁，也就是Synchronized关键字， JDK提供的各种锁LOCK ","date":"2021-05-25","objectID":"/java%E5%B9%B6%E5%8F%91/:1:0","tags":["面试"],"title":"Java并发","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":["java"],"content":"Volatile与Synchronized有什么区别？Volatile能不能保证线程安全？DCL（Double Check Lock）单例为什么要加Volatile？ DCL: Synchronized关键字用来加锁，Volatile只是保持变量的线程可见性，通常适用于一个线程写，多个线程读的场景 不能。Volatile只能保证线程可见性，不能保证原子性， Volatile防止指令重排（Integer i=8 1、分配内存，2、对象初始化、3、建立指针）防止高并发状态下，指令重排造成线程安全问题。 ","date":"2021-05-25","objectID":"/java%E5%B9%B6%E5%8F%91/:1:1","tags":["面试"],"title":"Java并发","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":["java"],"content":"java线程锁机制是怎样的，偏向锁、轻量级锁、重量级锁有什么区别？锁机制是如何升级的？ Java的锁机制就是在对象的Markword中记录一个锁的状态，偏向锁、轻量级锁、重量级锁对应不同的锁标志位状态 Java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。 ","date":"2021-05-25","objectID":"/java%E5%B9%B6%E5%8F%91/:1:2","tags":["面试"],"title":"Java并发","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":["java"],"content":"谈谈你对AQS的理解，AQS如何实现可重入锁？ AQS（AbstractQueueSynchronizer）是一个Java线程同步的框架，是JDK中许多锁工具的核心实现框架。 在AQS中，维护了一个信号量state和一个线程组成的双向链表队列，其中，这个线程队列是用来给线程排队的，state就是一个信号量，用来控制线程排队或者放行的。在不同的场景下有不同的定义 。 在可重入锁这个场景下，state就用来表示加锁的次数，0表示无锁，每加一次锁，state+1，释放锁-1 ","date":"2021-05-25","objectID":"/java%E5%B9%B6%E5%8F%91/:1:3","tags":["面试"],"title":"Java并发","uri":"/java%E5%B9%B6%E5%8F%91/"},{"categories":["nginx"],"content":"第一步：Nginx的ssl模块安装 在配置ssl证书之前，要确保你的nginx已经安装了ssl模块，一般情况下自己安装的nginx都是不存在ssl模块的。 这里先检查下自己是否存在ssl模块： 进入到你的nginx安装目录下面，我的目录是在（/usr/local/nginx），如果你的nginx安装步骤和上面的文章一致的话，那你的目录和我应该是一致的 进入到目录的sbin目录下，输入 #注意这里是大写的V，小写的只显示版本号 ./nginx -V 如果出现 (configure arguments: –with-http_ssl_module), 则已安装（下面的步骤可以跳过，直接进行第二步）。 一般情况下都是不存在ssl模块的，接下来进入到你的解压缩后的nginx目录，注意这里不是nginx安装目录，是解压缩后的目录，我的是在（/root/nginx），进入目录后，输入 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 接下来执行 make #切记不要执行make install，否则会重新安装nginx 上述操作执行完成以后，你的目录下会出现objs文件夹，文件夹内存在nginx文件，如图： 接下来使用新的nginx文件替换掉之前安装目录sbin下的nginx，注意这里的替换的时候可以先将之前的文件备份下，停掉nginx服务 ./nginx -s stop #停止nginx服务 #替换之前的nginx cp /root/nginx/objs/nginx /usr/local/nginx/sbin 成功之后，进入到nginx安装目录下，查看ssl时候成功 #注意这里是大写的V，小写的只显示版本号 ./nginx -V #可以看到这里出现了configure arguments: --with-http_ssl_module 证明已经安装成功 提示：这里替换后在执行 -V命令如果提示权限不足，先给这个nginx文件提升下权限 我是用的是finalshell连接工具，直接右键就可以修改权限了，当然，也可以通过指令修改，如下： chmod 111 nginx ","date":"2021-05-20","objectID":"/https%E9%85%8D%E7%BD%AE/:1:0","tags":[],"title":"Https配置","uri":"/https%E9%85%8D%E7%BD%AE/"},{"categories":["nginx"],"content":"第二步：配置ssl证书 解压缩下载好的证书（证书一般是pem文件和key文件，这里名字可以随便改） 将下载好的证书上上传到服务器，我将证书放在了root目录下的card文件夹 #在root目录下创建card文件夹 cd /root mkdir card ","date":"2021-05-20","objectID":"/https%E9%85%8D%E7%BD%AE/:2:0","tags":[],"title":"Https配置","uri":"/https%E9%85%8D%E7%BD%AE/"},{"categories":["nginx"],"content":"第三步：进行nginx.conf配置 进入nginx.conf文件下 cd /usr/locla/nginx/conf #修改nginx.conf文件 vim nginx.conf 打开之后文件内容如图 可以将没用的东西都删除掉，删除的时候注意，括号要对应起来。 然后进行配置，输入： user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; server { #监听443端口 listen 443 ssl; #你的域名 server_name wchat.eccentric.top; #ssl证书的pem文件路径 ssl_certificate /etc/nginx/cart/5663981_wchat.eccentric.top.pem; #ssl证书的key文件路径 ssl_certificate_key /etc/nginx/cart/5663981_wchat.eccentric.top.key; location / { proxy_pass http://120.77.216.116:9981; } } server { listen 80; server_name wchat.eccentric.top; #将请求转成https rewrite ^(.*)$ https://$host$1 permanent; } } 注意：这里需要在安全组中开放443端口。 ","date":"2021-05-20","objectID":"/https%E9%85%8D%E7%BD%AE/:3:0","tags":[],"title":"Https配置","uri":"/https%E9%85%8D%E7%BD%AE/"},{"categories":["nginx"],"content":"第四步：重启nginx ok，如果上述步骤都完成了，没有问题，接下来只需要重启nginx服务即可。 进入sbin目录下，输入 ./nginx -s reload ./nginx -s stop ./nginx ps： docker安装nginx配置反向代理，一定要映射80和443端口； 服务器安全组开放80和443端口； docker或者nginx配置完要重启 ","date":"2021-05-20","objectID":"/https%E9%85%8D%E7%BD%AE/:4:0","tags":[],"title":"Https配置","uri":"/https%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"nginx启动报错 docker run --name postNginx -v /work/html:/usr/share/nginx/html -v /work/nginx:/etc/nginx nginx 2021/05/19 14:46:05 [emerg] 1#1: open() “/etc/nginx/nginx.conf” failed (2: No such file or directory) nginx: [emerg] open() “/etc/nginx/nginx.conf” failed (2: No such file or directory) 意思是没有找到/etc/nginx/nginx.conf文件， 第一种解决办法： docker run --name=mynginx -p 80:80 -p 443:443 \\ --restart=always \\ -v /work/nginx/nginx.conf:/etc/nginx/nginx.conf \\ -v /work/nginx/conf.d:/etc/nginx/conf.d \\ -v /work/nginx/www:/usr/share/nginx/html \\ -v /work/nginx/logs:/var/log/nginx -v /work/nginx/cart:/etc/nginx/cart \\ -d nginx 第二种解决办法： ​ 都提示了是没有权限造成的，那就排查下权限。看看宿主机本地的nginx.conf对other用户是否有读权限，再排查下该配置文件的所有父级目录是否有访问权限。或者像一楼说的用docker run --privileged=true启动容器，这样就是使用root用户权限了。 ","date":"2021-05-19","objectID":"/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/:0:1","tags":["docker 掉坑"],"title":"日常掉坑","uri":"/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/"},{"categories":["运维"],"content":"nginx代理转发错误 connect() failed (111: Connection refused) while connecting to upstream, client: 202.114.144.231, server: 111.47.28.118, request: \"POST /prd-api/authorization-server/oauth/token?username=admin\u0026password=password\u0026grant_type=password\u0026scope=read HTTP/1.1\", upstream: \"http://111.47.28.118:7181/authorization-server/oauth/token?username=admin\u0026password=password\u0026grant_type=password\u0026scope=read\", host: \"111.47.28.118:7191\", referrer: \"http://111.47.28.118:7191/\" 202.114.144.231 - test_client [10/Jun/2021:09:53:55 +0000] \"POST /prd-api/authorization-server/oauth/token?username=admin\u0026password=password\u0026grant_type=password\u0026scope=read HTTP/1.1\" 502 494 \"http://111.47.28.118:7191/\" \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.77 Safari/537.36 Edg/91.0.864.41\" \"-\" 目前nginx配置文件 server { listen 80; listen [::]:80; server_name 111.47.28.118; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/nginx/html/AAMS; index index.html index.htm; } location /prd-api { rewrite ^/prd-api/(.*)$ /$1 break; proxy_pass http://111.47.28.118:7181; proxy_set_header Authorization $http_authorization; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } nginx.conf配置： user nginx; worker_processes auto; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; underscores_in_headers on; add_header Access-Control-Allow-Headers Authorization; include /etc/nginx/conf.d/*.conf; } 解决：","date":"2021-05-19","objectID":"/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/:0:2","tags":["docker 掉坑"],"title":"日常掉坑","uri":"/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/"},{"categories":["数据库"],"content":"JPA 基本查询 Spring Data JPA提供的一个查询规范，查询语句关键字，简单的SQL可根据方法命名来即可，省略了写sql语句 关键字 方法命名 sql where字句 And findByNameAndPwd where name= ? and pwd =? Or findByNameOrSex where name= ? or sex=? Is,Equals findById,findByIdEquals where id= ? Between findByIdBetween where id between ? and ? LessThan findByIdLessThan where id \u003c ? LessThanEquals findByIdLessThanEquals where id \u003c= ? GreaterThan findByIdGreaterThan where id \u003e ? GreaterThanEquals findByIdGreaterThanEquals where id \u003e = ? After findByIdAfter where id \u003e ? Before findByIdBefore where id \u003c ? IsNull findByNameIsNull where name is null isNotNull,NotNull findByNameNotNull where name is not null Like findByNameLike where name like ? NotLike findByNameNotLike where name not like ? StartingWith findByNameStartingWith where name like ‘?%’ EndingWith findByNameEndingWith where name like ‘%?’ Containing findByNameContaining where name like ‘%?%’ OrderBy findByIdOrderByXDesc where id=? order by x desc Not findByNameNot where name \u003c\u003e ? In findByIdIn(Collection\u003c?\u003e c) where id in (?) NotIn findByIdNotIn(Collection\u003c?\u003e c) where id not in (?) True findByAaaTue where aaa = true False findByAaaFalse where aaa = false IgnoreCase findByNameIgnoreCase where UPPER(name)=UPPER(?) ","date":"2021-05-15","objectID":"/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/:1:0","tags":["JPA"],"title":"JPA实现动态SQL","uri":"/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/"},{"categories":["数据库"],"content":"JPA 多条件查询（参数为空判断）语句 工作中遇到一个多条件查询的需求，需要根据名字，性别，年龄以及序号查询数据，名字需要模糊查询，参数有可能为空。 @Query(value = \"select * from people where if(?1 !='',name like concat('%',?1,'%'),1=1) and if(?2 !='',sex=?2,1=1)\"+ \" and if(IFNULL(?3,'') !='',age=?3,1=1) and if(IFNULL(?4,'') !='',num=?4,1=1) \",nativeQuery = true) List\u003cPeople\u003e find(String name,String sex,Integer age,Integer num); 同理： @Query(value = \"select * from post_timer where if(IFNULL(?1,'') !='',is_send=?1,1=1) and if(IFNULL(?2,'') !='',typa=?2,1=1) and if(IFNULL(?3,'') !='',status=?3,1=1) and if(?4 !='',content like concat('%',?4,'%'),1=1) \"+ \"order by create_time DESC limit ?5,?6\",nativeQuery = true) List\u003cPostTimer\u003e findlike(Integer isSend,Integer typa,Integer status,String likeString,Integer page,Integer limit); @Query(value = \"select count(*) from post_timer where if(IFNULL(?1,'') !='',is_send=?1,1=1) and if(IFNULL(?2,'') !='',typa=?2,1=1) and if(IFNULL(?3,'') !='',status=?3,1=1) and if(?4 !='',content like concat('%',?4,'%'),1=1) \",nativeQuery = true) Integer countlike(Integer isSend,Integer typa,Integer status,String likeString); PS： nativeQuery = true 的含义是使用原生SQL，即注解中的SQL语句会生效，false的话就不会生效。 SQL语句中 ?1、?2、?3、?4 的意思是代表方法中的第几个参数。 SQL中模糊查询的写法为 like concat('%', ?1, ‘%') if(?1 !='',name like concat('%’,?1,'%'),1=1) 代表传入的参数name如果不为\"\"（Spring类型空是\"“而不是null）将参数传入name，如果为空时显示1=1 代表参数为真，对查询结果不产生作用。IF 的语法满足mysql的基本语法，IF(expr1,expr2,expr3)， 如果 expr1 为真(expr1 \u003c\u003e 0 以及 expr1 \u003c\u003e NULL)，那么 IF() 返回 expr2，否则返回expr3 if(IFNULL(?3,'') !='',age=?3,1=1) 表示如果传入的年龄是null，则替换成空字符串，然后判断是否为空，不为空则将参数传入age，否则忽略不对查询结果产生影响。IFNULL 是mysql中的一个函数，这个函数一般用来替换 NULL 值的。IFNULL(value1,value2)，判断value1是否为null，如果为null则用value2替换。 **参数定义时，定义数值，应使用Integer，**如果用int定义，当入参为NULL时，程序会报空指针错误。原因是JAVA 中 int 是值类型，非对象，不可以设置为 NULL，integer 是对象类型，可以设置为NULL ","date":"2021-05-15","objectID":"/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/:2:0","tags":["JPA"],"title":"JPA实现动态SQL","uri":"/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/"},{"categories":["前端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 官方示例在此！！！官方示例在此！！！官方示例在此！！！ 这主要是基于uni-app开发的，所以，请多看uni-app文档，了解一些标签、属性，可以更好的使用该组件 目录 [TOC] ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:0:0","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"交互组件 ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:0","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Bar操作条 底部操作条 我们可以使用Bar操作条自定义小程序底部的tabBar，就拿官方示例代码来说吧。 当我们要自定义tabBar的时候，pages.json文件中的tabBar配置就不写了，直接在首页上代码，pages.json文件中的pages数组中第一项表示应用启动页，即首页。示例中通过变量PageCur来切换不同tabBar页面，控制tabBar图标文字的样式切换。 底部操作条包括底部的tabBar和商场小程序加入购物车的操作条，底部操作条中cu-bar和tabbar是必备的class，foot则设置该操作条固定在页面底部。 \u003ctemplate\u003e \u003cview\u003e \u003cbasics v-if=\"PageCur=='basics'\"\u003e\u003c/basics\u003e \u003ccomponents v-if=\"PageCur=='component'\"\u003e\u003c/components\u003e \u003cplugin v-if=\"PageCur=='plugin'\"\u003e\u003c/plugin\u003e \u003cview class=\"cu-bar tabbar bg-white shadow foot\"\u003e \u003cview class=\"action\" @click=\"NavChange\" data-cur=\"basics\"\u003e \u003cview class='cuIcon-cu-image'\u003e \u003cimage :src=\"'/static/tabbar/basics' + [PageCur=='basics'?'_cur':''] + '.png'\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview :class=\"PageCur=='basics'?'text-green':'text-gray'\"\u003e元素\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\" @click=\"NavChange\" data-cur=\"component\"\u003e \u003cview class='cuIcon-cu-image'\u003e \u003cimage :src=\"'/static/tabbar/component' + [PageCur == 'component'?'_cur':''] + '.png'\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview :class=\"PageCur=='component'?'text-green':'text-gray'\"\u003e组件\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\" @click=\"NavChange\" data-cur=\"plugin\"\u003e \u003cview class='cuIcon-cu-image'\u003e \u003cimage :src=\"'/static/tabbar/plugin' + [PageCur == 'plugin'?'_cur':''] + '.png'\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview :class=\"PageCur=='plugin'?'text-green':'text-gray'\"\u003e扩展\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { PageCur: 'basics' } }, methods: { NavChange: function(e) { this.PageCur = e.currentTarget.dataset.cur } } } \u003c/script\u003e 操作条中的图标，可以是自定义引入的图片，也可以是这个组件中的图标，加角标就是上一章在基础元素中介绍的标签组件cu-tag、badge，背景颜色以及文字图标颜色都可以添加相应的颜色class进行自定义 \u003cview class=\"cu-bar tabbar bg-white\"\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cu-image\"\u003e \u003cimage src=\"/static/tabbar/basics_cur.png\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"text-green\"\u003e元素\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cu-image\"\u003e \u003cimage src=\"/static/tabbar/component.png\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"text-gray\"\u003e组件\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cu-image\"\u003e \u003cimage src=\"/static/tabbar/plugin.png\"\u003e\u003c/image\u003e \u003cview class=\"cu-tag badge\"\u003e99\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray\"\u003e扩展\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cu-image\"\u003e \u003cimage src=\"/static/tabbar/about.png\"\u003e\u003c/image\u003e \u003cview class=\"cu-tag badge\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray\"\u003e关于\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-bar tabbar margin-bottom-xl bg-black\"\u003e \u003cview class=\"action text-orange\"\u003e \u003cview class=\"cuIcon-homefill\"\u003e\u003c/view\u003e 首页 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-similar\"\u003e\u003c/view\u003e 分类 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-recharge\"\u003e\u003c/view\u003e 积分 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-cart\"\u003e \u003cview class=\"cu-tag badge\"\u003e99\u003c/view\u003e \u003c/view\u003e 购物车 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-my\"\u003e \u003cview class=\"cu-tag badge\"\u003e\u003c/view\u003e \u003c/view\u003e 我的 \u003c/view\u003e \u003c/view\u003e  这种操作条就是中间设置了一个midButton，只需在中间的view上添加class add-action，其他设置同上，不赘述 \u003cview class=\"cu-bar tabbar margin-bottom-xl bg-white\"\u003e \u003cview class=\"action text-green\"\u003e \u003cview class=\"cuIcon-homefill\"\u003e\u003c/view\u003e 首页 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-similar\"\u003e\u003c/view\u003e 分类 \u003c/view\u003e \u003cview class=\"action text-gray add-action\"\u003e \u003cbutton class=\"cu-btn cuIcon-add bg-green shadow\"\u003e\u003c/button\u003e 发布 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-cart\"\u003e \u003cview class=\"cu-tag badge\"\u003e99\u003c/view\u003e \u003c/view\u003e 购物车 \u003c/view\u003e \u003cview class=\"action text-gray\"\u003e \u003cview class=\"cuIcon-my\"\u003e \u003cview class=\"cu-tag badge\"\u003e\u003c/view\u003e \u003c/view\u003e 我的 \u003c/view\u003e \u003c/view\u003e 加入购物车的操作条增加了shop类名，但是我不清楚，加不加shop有什么区别，我删了他，样式好像也没变，有大佬懂得望指教。submit类名用于加入购物车和立即购买等操作，样式可以撑开占满。  \u003cview class=\"cu-bar bg-white tabbar border shop\"\u003e \u003cbutton class=\"action\" open-type=\"contact\"\u003e \u003cview class=\"cuIcon-service text-green\"\u003e \u003cview class=\"cu-tag badge\"\u003e\u003c/view\u003e \u003c/view\u003e 客服 \u003c/button\u003e \u003cview class=\"action text-orange\"\u003e \u003cview class=\"cuIcon-favorfill\"\u003e\u003c/view\u003e 已收藏 \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cart\"\u003e \u003cview class=\"cu-tag badge\"\u003e99\u003c/view\u003e \u003c/view\u003e 购物车 \u003c/view\u003e \u003cview class=\"bg-red submit\"\u003e立即订购\u003c/view\u003e \u003c/view\u003e 这种样式就是把","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:1","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Nav导航栏 nav导航栏是结合uni-app的scroll-view标签设计出来的，使用的时候一些属性可以参考一下uni-app的文档https://uniapp.dcloud.io/component/scroll-view，类名nav和cu-item是必选值 默认 不知道咋解释，看代码很简单，就是通过index值进行切换每个tab，及其字体边框样式，我就不赘述了 \u003cscroll-view scroll-x class=\"bg-white nav\" scroll-with-animation :scroll-left=\"scrollLeft\"\u003e \u003cview class=\"cu-item\" :class=\"index==TabCur?'text-green cur':''\" v-for=\"(item,index) in 10\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/scroll-view\u003e \u003cscript\u003e export default { data() { return { TabCur: 0, scrollLeft: 0 }; }, methods: { tabSelect(e) { this.TabCur = e.currentTarget.dataset.id; this.scrollLeft = (e.currentTarget.dataset.id - 1) * 60 } } } \u003c/script\u003e 居中 通过text-center居中 \u003cscroll-view scroll-x class=\"bg-white nav text-center\"\u003e \u003cview class=\"cu-item\" :class=\"index==TabCur?'text-blue cur':''\" v-for=\"(item,index) in 3\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/scroll-view\u003e 平分 设置flex和flex-sub实现弹性布局，flex-sub就是css属性flex:1，将弹性盒子内子元素按照1:1:1:1来分配空间   \u003cscroll-view scroll-x class=\"bg-white nav\"\u003e \u003cview class=\"flex text-center\"\u003e \u003cview class=\"cu-item flex-sub\" :class=\"index==TabCur?'text-orange cur':''\" v-for=\"(item,index) in 4\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/view\u003e \u003c/scroll-view\u003e 背景  bg-{{color}}，参考背景色   \u003cscroll-view scroll-x class=\"bg-red nav text-center\"\u003e \u003cview class=\"cu-item\" :class=\"index==TabCur?'text-white cur':''\" v-for=\"(item,index) in 3\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/scroll-view\u003e 图标  cuIcon-{{icon}}，参考图标   \u003cscroll-view scroll-x class=\"bg-green nav text-center\"\u003e \u003cview class=\"cu-item\" :class=\"0==TabCur?'text-white cur':''\" @tap=\"tabSelect\" data-id=\"0\"\u003e \u003ctext class=\"cuIcon-camerafill\"\u003e\u003c/text\u003e 数码 \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"1==TabCur?'text-white cur':''\" @tap=\"tabSelect\" data-id=\"1\"\u003e \u003ctext class=\"cuIcon-upstagefill\"\u003e\u003c/text\u003e 排行榜 \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"2==TabCur?'text-white cur':''\" @tap=\"tabSelect\" data-id=\"2\"\u003e \u003ctext class=\"cuIcon-clothesfill\"\u003e\u003c/text\u003e 皮肤 \u003c/view\u003e \u003c/scroll-view\u003e 导航栏相关class class说明可选值nav导航栏必选值——cu-item导航栏子元素——flexflex布局——flex-subflex:1，平分——text-center居中—— ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:2","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"List列表 cu-list和cu-item配合使用 宫格列表 宫格列表就是列表结合grid布局设计出的样式，通过col-{{number}}设置每行的个数，number取值1~5，默认有边框，可以加类名no-border去除边框 \u003cview class=\"cu-list grid\" :class=\"['col-' + gridCol,gridBorder?'':'no-border']\"\u003e \u003cview class=\"cu-item\" v-for=\"(item,index) in cuIconList\" :key=\"index\" v-if=\"index\u003cgridCol*2\"\u003e \u003cview :class=\"['cuIcon-' + item.cuIcon,'text-' + item.color]\"\u003e \u003cview class=\"cu-tag badge\" v-if=\"item.badge!=0\"\u003e \u003cblock v-if=\"item.badge!=1\"\u003e{{item.badge\u003e99?'99+':item.badge}}\u003c/block\u003e \u003c/view\u003e \u003c/view\u003e \u003ctext\u003e{{item.name}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e data() { return { cuIconList: [{cuIcon: 'cardboardfill',color: 'red',badge: 120,name: 'VR'}, {cuIcon: 'recordfill',color: 'orange',badge: 1,name: '录像'}, {cuIcon: 'picfill',color: 'yellow',badge: 0,name: '图像'}, {cuIcon: 'noticefill',color: 'olive',badge: 22,name: '通知'}, {cuIcon: 'upstagefill',color: 'cyan',badge: 0,name: '排行榜' }, {cuIcon: 'clothesfill',color: 'blue',badge: 0,name: '皮肤'}, {cuIcon: 'discoverfill',color: 'purple',badge: 0,name: '发现'}, {cuIcon: 'questionfill',color: 'mauve',badge: 0,name: '帮助'}, {cuIcon: 'commandfill',color: 'purple',badge: 0,name: '问答'}, {cuIcon: 'brandfill',color: 'mauve',badge: 0,name: '版权'}], gridCol: 3, gridBorder: false }; }, 菜单列表 菜单列表就是列表结合类名menu设计出的样式，可以通过sm-border设置每一行的短边框，通过card-menu将列表设置成卡片样式，通过在列表子元素上添加arrow设置箭头，变化样式效果可以由以下两图对比 \u003cview class=\"cu-list menu\" :class=\"[menuBorder?'sm-border':'',menuCard?'card-menu margin-top':'']\"\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-circlefill text-grey\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e图标 + 标题\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003cimage src=\"/static/logo.png\" class=\"png\" mode=\"aspectFit\"\u003e\u003c/image\u003e \u003ctext class=\"text-grey\"\u003e图片 + 标题\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cbutton class=\"cu-btn content\" open-type=\"contact\"\u003e \u003ctext class=\"cuIcon-btn text-olive\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003eOpen-type 按钮\u003c/text\u003e \u003c/button\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cnavigator class=\"content\" hover-class=\"none\" url=\"../list/list\" open-type=\"redirect\"\u003e \u003ctext class=\"cuIcon-discoverfill text-orange\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003eNavigator 跳转\u003c/text\u003e \u003c/navigator\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-emojiflashfill text-pink\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e头像组\u003c/text\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cu-avatar-group\"\u003e \u003cview class=\"cu-avatar round sm\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar round sm\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81005.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar round sm\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big25002.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar round sm\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big91012.jpg);\"\u003e\u003c/view\u003e \u003c/view\u003e \u003ctext class=\"text-grey text-sm\"\u003e4 人\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-btn text-green\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e按钮\u003c/text\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn round bg-green shadow\"\u003e \u003ctext class=\"cuIcon-upload\"\u003e\u003c/text\u003e 上传\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-tagfill text-red margin-right-xs\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e标签\u003c/text\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cu-tag round bg-orange light\"\u003e音乐\u003c/view\u003e \u003cview class=\"cu-tag round bg-olive light\"\u003e电影\u003c/view\u003e \u003cview class=\"cu-tag round bg-blue light\"\u003e旅行\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-warn text-green\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e文本\u003c/text\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"text-grey text-sm\"\u003e小目标还没有实现！\u003c/","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:3","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Card卡片 cu-card卡片必选值 案例类卡片 cu-card和case结合，在配合子元素的cu-item类名，写出案例类的样式，内部其他样式可以根据其他类名自行设置，cu-item自带margin:30px;可以通过类名no-card去除 \u003cview class=\"cu-card case\" :class=\"isCard?'no-card':''\"\u003e \u003cview class=\"cu-item shadow\"\u003e \u003cview class=\"image\"\u003e \u003cimage src=\"https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg\" mode=\"widthFix\"\u003e\u003c/image\u003e \u003cview class=\"cu-tag bg-blue\"\u003e史诗\u003c/view\u003e \u003cview class=\"cu-bar bg-shadeBottom\"\u003e \u003ctext class=\"text-cut\"\u003e我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。\u003c/text\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-list menu-avatar\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content flex-sub\"\u003e \u003cview class=\"text-grey\"\u003e正义天使 凯尔\u003c/view\u003e \u003cview class=\"text-gray text-sm flex justify-between\"\u003e 十天前 \u003cview class=\"text-gray text-sm\"\u003e \u003ctext class=\"cuIcon-attentionfill margin-lr-xs\"\u003e\u003c/text\u003e 10 \u003ctext class=\"cuIcon-appreciatefill margin-lr-xs\"\u003e\u003c/text\u003e 20 \u003ctext class=\"cuIcon-messagefill margin-lr-xs\"\u003e\u003c/text\u003e 30 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 动态类卡片 该样式类似于QQ动态，由cu-card和dynamic结合，再配合子元素cu-item编写而成，动态下方的评论需要添加类名comment \u003cview class=\"cu-card dynamic\" :class=\"isCard?'no-card':''\"\u003e \u003cview class=\"cu-item shadow\"\u003e \u003cview class=\"cu-list menu-avatar\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content flex-sub\"\u003e \u003cview\u003e凯尔\u003c/view\u003e \u003cview class=\"text-gray text-sm flex justify-between\"\u003e 2019年12月3日 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-content\"\u003e 折磨生出苦难，苦难又会加剧折磨，凡间这无穷的循环，将有我来终结！ \u003c/view\u003e \u003cview class=\"grid flex-sub padding-lr\" :class=\"isCard?'col-3 grid-square':'col-1'\"\u003e \u003cview class=\"bg-img \" :class=\"isCard?'':'only-img'\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\" v-for=\"(item,index) in isCard?9:1\" :key=\"index\"\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray text-sm text-right padding\"\u003e \u003ctext class=\"cuIcon-attentionfill margin-lr-xs\"\u003e\u003c/text\u003e 10 \u003ctext class=\"cuIcon-appreciatefill margin-lr-xs\"\u003e\u003c/text\u003e 20 \u003ctext class=\"cuIcon-messagefill margin-lr-xs\"\u003e\u003c/text\u003e 30 \u003c/view\u003e \u003cview class=\"cu-list menu-avatar comment solids-top\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/img/champion/Morgana.png);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e莫甘娜\u003c/view\u003e \u003cview class=\"text-gray text-content text-df\"\u003e 凯尔，你被自己的光芒变的盲目。 \u003c/view\u003e \u003cview class=\"bg-grey padding-sm radius margin-top-sm text-sm\"\u003e \u003cview class=\"flex\"\u003e \u003cview\u003e凯尔：\u003c/view\u003e \u003cview class=\"flex-sub\"\u003e妹妹，你在帮他们给黑暗找借口吗?\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"margin-top-sm flex justify-between\"\u003e \u003cview class=\"text-gray text-df\"\u003e2018年12月4日\u003c/view\u003e \u003cview\u003e \u003ctext class=\"cuIcon-appreciatefill text-red\"\u003e\u003c/text\u003e \u003ctext class=\"cuIcon-messagefill text-gray margin-left-sm\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 文章类卡片  该卡片由cu-card和article结合，再配合子元素cu-item \u003cview class=\"cu-card article\" :class=\"isCard?'no-card':''\"\u003e \u003cview class=\"cu-item shadow\"\u003e \u003cview class=\"title\"\u003e\u003cview class=\"text-cut\"\u003e无意者 烈火焚身;以正义的烈火拔出黑暗。我有自己的正义，见证至高的烈火吧。\u003c/view\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cimage src=\"https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg\" mode=\"aspectFill\"\u003e\u003c/image\u003e \u003cview class=\"desc\"\u003e \u003cview class=\"text-content\"\u003e 折磨生出苦难，苦难又会加剧折磨，凡间这无穷的循环，将有我来终结！真正的恩典因不完整而美丽，因情感而真诚，因脆弱而自由！\u003c/view\u003e \u003cview\u003e \u003cview class=\"cu-tag bg-red light sm round\"\u003e正义天使\u003c/view\u003e \u003cview class=\"cu-tag bg-green light sm round\"\u003e史诗\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 卡片相关class class说明可选值cu-card卡片必选值——case案例类卡片——dynamic动态类卡片——article文章类卡片——comment评论——no-card配合cu-card，去除子元素cu-item的margin和border——desc纵向的flex布局—— ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:4","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Form表单 input输入框 form表单是用form标签包裹，每一个子元素添加类名cu-form-group，行内自定义，title类名用于设置每行的文字说明，如果想统一宽度，像示例一样，需要自定义宽度 \u003cform\u003e \u003cview class=\"cu-form-group margin-top\"\u003e \u003cview class=\"title\"\u003e邮件\u003c/view\u003e \u003cinput placeholder=\"两字短标题\" name=\"input\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e输入框\u003c/view\u003e \u003cinput placeholder=\"三字标题\" name=\"input\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e收货地址\u003c/view\u003e \u003cinput placeholder=\"统一标题的宽度\" name=\"input\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e收货地址\u003c/view\u003e \u003cinput placeholder=\"输入框带个图标\" name=\"input\"\u003e\u003c/input\u003e \u003ctext class='cuIcon-locationfill text-orange'\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e验证码\u003c/view\u003e \u003cinput placeholder=\"输入框带个按钮\" name=\"input\"\u003e\u003c/input\u003e \u003cbutton class='cu-btn bg-green shadow'\u003e验证码\u003c/button\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e手机号码\u003c/view\u003e \u003cinput placeholder=\"输入框带标签\" name=\"input\"\u003e\u003c/input\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class='cu-tag bg-blue '\u003e+86\u003c/view\u003e \u003cview class=\"cu-tag line-blue\"\u003e中国大陆\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/form\u003e \u003cstyle\u003e .cu-form-group .title { min-width: calc(4em + 15px); } \u003c/style\u003e picker选择器  对于表单中从底部谈起的选择器，写法与上述简单的input相同，而选择器picker的使用，建议查看官方文档 \u003cform\u003e \u003cview class=\"cu-form-group margin-top\"\u003e \u003cview class=\"title\"\u003e普通选择\u003c/view\u003e \u003cpicker @change=\"PickerChange\" :value=\"index\" :range=\"picker\"\u003e \u003cview class=\"picker\"\u003e {{index\u003e-1?picker[index]:'禁止换行，超出容器部分会以 ... 方式截断'}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003c!-- #ifndef MP-ALIPAY --\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e多列选择\u003c/view\u003e \u003cpicker mode=\"multiSelector\" @change=\"MultiChange\" @columnchange=\"MultiColumnChange\" :value=\"multiIndex\" :range=\"multiArray\"\u003e \u003cview class=\"picker\"\u003e {{multiArray[0][multiIndex[0]]}}，{{multiArray[1][multiIndex[1]]}}，{{multiArray[2][multiIndex[2]]}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003c!-- #endif --\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e时间选择\u003c/view\u003e \u003cpicker mode=\"time\" :value=\"time\" start=\"09:01\" end=\"21:01\" @change=\"TimeChange\"\u003e \u003cview class=\"picker\"\u003e {{time}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e日期选择\u003c/view\u003e \u003cpicker mode=\"date\" :value=\"date\" start=\"2015-09-01\" end=\"2020-09-01\" @change=\"DateChange\"\u003e \u003cview class=\"picker\"\u003e {{date}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003c!-- #ifndef H5 || APP-PLUS || MP-ALIPAY --\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e地址选择\u003c/view\u003e \u003cpicker mode=\"region\" @change=\"RegionChange\" :value=\"region\"\u003e \u003cview class=\"picker\"\u003e {{region[0]}}，{{region[1]}}，{{region[2]}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003c!-- #endif --\u003e \u003c/form\u003e switch开关 对于开关的样式，参考switch官方文档，需要注意的阿里小程序的不同，我没有用阿里测试，我测的是微信小程序，在微信小程序上，switch的color属性不生效，想要更改开关颜色，可以用颜色类名，直接写颜色就可以，颜色的取值可以参考上一章背景色 \u003cform\u003e \u003cview class=\"cu-form-group margin-top\"\u003e \u003cview class=\"title\"\u003e开关选择\u003c/view\u003e \u003cswitch @change=\"SwitchA\" :class=\"switchA?'checked':''\" :checked=\"switchA?true:false\"\u003e\u003c/switch\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e定义颜色\u003c/view\u003e \u003c!-- #ifdef MP-ALIPAY --\u003e \u003cswitch class='red' @change=\"SwitchB\" :class=\"switchB?'checked':''\" :checked=\"switchB?true:false\" color=\"#e54d42\"\u003e\u003c/switch\u003e \u003c!-- #endif --\u003e \u003c!-- #ifndef MP-ALIPAY --\u003e \u003cswitch class='red' @change=\"SwitchB\" :class=\"switchB?'checked':''\" :checked=\"switchB?true:false\"\u003e\u003c/switch\u003e \u003c!-- #endif --\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e定义图标\u003c/view\u003e \u003cswitch class='switch-sex' @change=\"SwitchC\" :class=\"switchC?'checked':''\" :checked=\"switchC?true:false\"\u003e\u003c/switch\u003e \u003c/view\u003e \u003c!-- #ifndef MP-ALIPAY --\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e方形开关\u003c/view\u003e \u003cswitch class='orange radius' @change=\"SwitchD\" :class=\"switchD?'checked':''\" :checked=\"switchD?true:false\"\u003e\u003c/switch\u003e \u003c/view\u003e \u003c!-- #endif --\u003e \u003c/form\u003e radio单选框 radio官方文档先奉上，更改颜色同上，使用提供的颜色类名即可，其默认样式是圆形全色中间有个√，可以通过类名radio更改形状为镂空中间一个点 \u003cform\u003e \u003cradio-group class=\"block\" @change=\"RadioChange\"\u003e \u003cview class=\"cu-form-group margin-top\"\u003e \u003cview class=\"title\"\u003e单选操作(radio)\u003c/view\u003e \u003cradio :class=\"radio=='A'?'checked':''\" :checked=\"radio=='A'?true:false\" value=\"A\"\u003e\u003c/radio\u003e \u003c/view\u003e \u003c!-- #ifndef MP-ALIPAY --\u003e \u003cview class=\"cu","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:5","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"TimeLine时间轴 默认 时间轴默认结构如下代码，由cu-timeline包裹cu-time和cu-item，在item内编写内容，由content包裹 \u003cview class=\"cu-timeline\"\u003e \u003cview class=\"cu-time\"\u003e06-17\u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"content\"\u003e \u003ctext\u003e01:30\u003c/text\u003e 【喵星】 MX-12138 已揽收，准备发往银河系 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 多彩时间轴 这个与默认的基本格式相同，只是自定义了内容框颜色和图标，结合基础元素的样式，你可以写个彩虹 \u003cview class=\"cu-timeline\"\u003e \u003cview class=\"cu-time\"\u003e昨天\u003c/view\u003e \u003cview class=\"cu-item cur cuIcon-noticefill\"\u003e \u003cview class=\"content bg-green shadow-blur\"\u003e \u003ctext\u003e22:22\u003c/text\u003e 【广州市】快件已到达地球 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-red cuIcon-attentionforbidfill\"\u003e \u003cview class=\"content bg-red shadow-blur\"\u003e 这是第一次，我家的铲屎官走了这么久。久到足足有三天！！ \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-grey cuIcon-evaluate_fill\"\u003e \u003cview class=\"content bg-grey shadow-blur\"\u003e 这是第一次，我家的铲屎官走了这么久。 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-blue\"\u003e \u003cview class=\"bg-blue content\"\u003e \u003ctext\u003e20:00\u003c/text\u003e 【月球】快件已到达月球，准备发往地球 \u003c/view\u003e \u003cview class=\"bg-cyan content\"\u003e \u003ctext\u003e10:00\u003c/text\u003e 【银河系】快件已到达银河系，准备发往月球 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 自定义 上一个是简单的修改了颜色图标，这一个则是稍微复杂一点，结合之前的标签、列表等，丰富了内容 \u003cview class=\"cu-timeline\"\u003e \u003cview class=\"cu-time\"\u003e06-17\u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"content\"\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class=\"cu-tag bg-cyan\"\u003e上午\u003c/view\u003e \u003cview class=\"cu-tag line-cyan\"\u003e10:00\u003c/view\u003e \u003c/view\u003e \u003cview class=\"margin-top\"\u003e这是第一次，我家的铲屎官走了这么久。久到足足有三天！！ 在听到他的脚步声响在楼梯间的那一刻，我简直想要破门而出，对着他狠狠地吼上10分钟，然后再看心情要不要他进门。\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-blue\"\u003e \u003cview class=\"bg-blue shadow-blur content\"\u003e \u003cview class=\"cu-list menu-avatar radius\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e文晓港\u003c/view\u003e \u003cview class=\"text-gray text-sm\"\u003e \u003ctext class=\"cuIcon-infofill text-red\"\u003e\u003c/text\u003e 消息未送达\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cu-tag round bg-grey sm\"\u003e5\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\"\u003e \u003cview class=\"cu-tag badge\"\u003e99+\u003c/view\u003e \u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e文晓港 \u003cview class=\"cu-tag round orange sm\"\u003eSVIP\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray text-sm\"\u003e \u003ctext class=\"cuIcon-redpacket_fill text-red\"\u003e\u003c/text\u003e 收到红包\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003ctext class=\"cuIcon-notice_forbid_fill text-gray\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 时间轴相关class class说明可选值cu-timeline时间轴必选值——cu-time时间——cu-item子元素——content内容信息—— ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:6","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Chat聊天 cu-chat聊天必选值 基本样式 聊天的外部大框架是cu-chat，cu-item包裹某人的聊天信息，self表示右侧自己的聊天样式，main包含聊天内容，date表示消息时间，cu-info表示提示词 \u003cview class=\"cu-chat\"\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cview class=\"content bg-green shadow\"\u003e \u003ctext\u003e喵喵喵！喵喵喵！喵喵喵！喵喵！喵喵！！喵！喵喵喵！\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big107000.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"date\"\u003e2018年3月23日 13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-info round\"\u003e对方撤回一条消息!\u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big143004.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"main\"\u003e \u003cview class=\"content shadow\"\u003e \u003ctext\u003e喵喵喵！喵喵喵！\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"date \"\u003e 13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-info\"\u003e \u003ctext class=\"cuIcon-roundclosefill text-red \"\u003e\u003c/text\u003e 对方拒绝了你的消息 \u003c/view\u003e \u003cview class=\"cu-info\"\u003e 对方开启了好友验证，你还不是他(她)的好友。请先发送好友验证请求，对方验证通过后，才能聊天。 \u003ctext class=\"text-blue\"\u003e发送好友验证\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 其他聊天内容 聊天内容除了语句，还有图片，语音消息，地理位置消息等 ，main包含的聊天内容不止是消息框里的，还有消息框旁边的提示图标文字等，消息框里的内容由content包裹 \u003cview class=\"cu-chat\"\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cimage src=\"https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg\" class=\"radius\" mode=\"widthFix\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big107000.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"date\"\u003e 13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cview class=\"action text-bold text-grey\"\u003e 3\" \u003c/view\u003e \u003cview class=\"content shadow\"\u003e \u003ctext class=\"cuIcon-sound text-xxl padding-right-xl\"\u003e \u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big107000.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"date\"\u003e13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-locationfill text-orange text-xxl\"\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class=\"content shadow\"\u003e 喵星球，喵喵市 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big107000.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"date\"\u003e13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big143004.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"main\"\u003e \u003cview class=\"content shadow\"\u003e @#$^\u0026** \u003c/view\u003e \u003cview class=\"action text-grey\"\u003e \u003ctext class=\"cuIcon-warnfill text-red text-xxl\"\u003e\u003c/text\u003e \u003ctext class=\"text-sm margin-left-sm\"\u003e翻译错误\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"date\"\u003e13:23\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 发送框 发送框就是之前的操作条，相关内容看最上面操作条的讲解   \u003cview class=\"cu-bar foot input\" :style=\"[{bottom:InputBottom+'px'}]\"\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-sound text-grey\"\u003e\u003c/text\u003e \u003c/view\u003e \u003cinput class=\"solid-bottom\" :adjust-position=\"false\" :focus=\"false\" maxlength=\"300\" cursor-spacing=\"10\" @focus=\"InputFocus\" @blur=\"InputBlur\"\u003e\u003c/input\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-emojifill text-grey\"\u003e\u003c/text\u003e \u003c/view\u003e \u003cbutton class=\"cu-btn bg-green shadow\"\u003e发送\u003c/button\u003e \u003c/view\u003e 聊天相关class class说明可选值cu-chat聊天必选值——cu-item子元素——self右侧本人的聊天样式——main聊天内容——content消息框内容——date消息日期——cu-info提示词—— ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:7","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Swiper轮播图 全屏限高轮播 这是最常见的轮播图，添加类名screen-swiper，宽度为全屏，高度自定义，请直接参考swiper官方文档，可以通过类名square-dot和round-dot定义小圆点样式   \u003ctemplate\u003e \u003cview\u003e \u003cswiper class=\"screen-swiper\" :class=\"dotStyle?'square-dot':'round-dot'\" :indicator-dots=\"true\" :circular=\"true\" :autoplay=\"true\" interval=\"5000\" duration=\"500\"\u003e \u003cswiper-item v-for=\"(item,index) in swiperList\" :key=\"index\"\u003e \u003cimage :src=\"item.url\" mode=\"aspectFill\" v-if=\"item.type=='image'\"\u003e\u003c/image\u003e \u003cvideo :src=\"item.url\" autoplay loop muted :show-play-btn=\"false\" :controls=\"false\" objectFit=\"cover\" v-if=\"item.type=='video'\"\u003e\u003c/video\u003e \u003c/swiper-item\u003e \u003c/swiper\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { swiperList: [{ id: 0, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big84000.jpg' }, { id: 1, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big37006.jpg', }, { id: 2, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big39000.jpg' }, { id: 3, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg' }], dotStyle: true }; } } \u003c/script\u003e 卡片式轮播 在swiper标签上添加类名card-swiper，在swiper-item标签内的子元素上添加类名swiper-item，示例中cardSwiper函数的主要作用是切换类名cur，cur的作用是实现轮播图片中间大，两边小的效果，就是transform的scale()   \u003cswiper class=\"card-swiper\" :class=\"dotStyle?'square-dot':'round-dot'\" :indicator-dots=\"true\" :circular=\"true\" :autoplay=\"true\" interval=\"5000\" duration=\"500\" @change=\"cardSwiper\" indicator-color=\"#8799a3\" indicator-active-color=\"#0081ff\"\u003e \u003cswiper-item v-for=\"(item,index) in swiperList\" :key=\"index\" :class=\"cardCur==index?'cur':''\"\u003e \u003cview class=\"swiper-item\"\u003e \u003cimage :src=\"item.url\" mode=\"aspectFill\" v-if=\"item.type=='image'\"\u003e\u003c/image\u003e \u003cvideo :src=\"item.url\" autoplay loop muted :show-play-btn=\"false\" :controls=\"false\" objectFit=\"cover\" v-if=\"item.type=='video'\"\u003e\u003c/video\u003e \u003c/view\u003e \u003c/swiper-item\u003e \u003c/swiper\u003e cardSwiper(e) { this.cardCur = e.detail.current }, 堆叠式轮播 堆叠轮播是原生写的，注意类名tower-swiper、tower-item以及swiper-item的配合使用，这主要是通过层级的高低来显示图片的，使用时需要配合js和css。（这种轮播图初始化展示效果如图二，需要触动一下才会展示如图一的效果，可以通过在onload()函数中给变量direction赋值解决） \u003ctemplate\u003e \u003cview\u003e \u003cview class=\"tower-swiper\" @touchmove=\"TowerMove\" @touchstart=\"TowerStart\" @touchend=\"TowerEnd\"\u003e \u003cview class=\"tower-item\" :class=\"item.zIndex==1?'none':''\" v-for=\"(item,index) in swiperList\" :key=\"index\" :style=\"[{'--index': item.zIndex,'--left':item.mLeft}]\" :data-direction=\"direction\"\u003e \u003cview class=\"swiper-item\"\u003e \u003cimage :src=\"item.url\" mode=\"aspectFill\" v-if=\"item.type=='image'\"\u003e\u003c/image\u003e \u003cvideo :src=\"item.url\" autoplay loop muted :show-play-btn=\"false\" :controls=\"false\" objectFit=\"cover\" v-if=\"item.type=='video'\"\u003e\u003c/video\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { swiperList: [{ id: 0, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big84000.jpg' }, { id: 1, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big37006.jpg', }, { id: 2, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big39000.jpg' }, { id: 3, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg' }, { id: 4, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big25011.jpg' }, { id: 5, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big21016.jpg' }, { id: 6, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big99008.jpg' }], towerStart: 0, direction: '' }; }, onLoad() { this.TowerSwiper('swiperList'); this.direction = 'left'; // 初始化towerSwiper 传已有的数组名即可 }, methods: { // 初始化towerSwiper TowerSwiper(name) { let list = this[name]; console.log(list) for (let i = 0; i \u003c list.length; i++) { list[i].zIndex = parseInt(list.length / 2) + 1 - Math.abs(i - parseInt(list.length / 2)) list[i].mLeft = i - parseInt(list.length / 2) } this.swiperList = list }, // towerSwiper触摸开始 TowerStart(e) { console.log(e) this.towerStart = e.touches[0].pageX }, // towerSwiper计算方向 TowerMove(e) { this.direction = e.touches[0].pageX - this.tow","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:8","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Modal模态框 cu-modal和cu-dialog为模态框必选值，所有模态框的大体框架都是cu-modal包裹cu-dialog，cu-dialog内部填充操作部分和信息展示部分，操作部分可以用cu-bar操作条来布局，信息展示就直接写。弹框的显示隐藏是通过添加或移除类名show来实现的，示例中隐藏弹框是绑定tap调用hideModal事件，hideModal函数内执行的语句就是将变量modalName赋值为null，从而移除类名show，你想让用户点击哪里隐藏弹框，就可以把hideModal事件绑定在哪里（比如设置点击遮罩层隐藏弹框，就把hideModal事件绑定在有类名cu-modal的标签上） 普通窗口 普通窗口就是cu-modal包裹cu-dialog，只做信息的展示，没有交互效果    \u003cview class=\"cu-modal\" :class=\"modalName=='Modal'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"content\"\u003eModal标题\u003c/view\u003e \u003cview class=\"action\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-close text-red\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 底部窗口 cu-modal结合bottom-modal实现底部弹窗    \u003cview class=\"cu-modal bottom-modal\" :class=\"modalName=='bottomModal'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white\"\u003e \u003cview class=\"action text-green\"\u003e确定\u003c/view\u003e \u003cview class=\"action text-blue\" @tap=\"hideModal\"\u003e取消\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 对话窗口 对话窗口相较于普通窗口底部多了一些用户交互的操作    //示例一 \u003cview class=\"cu-modal\" :class=\"modalName=='DialogModal1'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"content\"\u003eModal标题\u003c/view\u003e \u003cview class=\"action\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-close text-red\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn line-green text-green\" @tap=\"hideModal\"\u003e取消\u003c/button\u003e \u003cbutton class=\"cu-btn bg-green margin-left\" @tap=\"hideModal\"\u003e确定\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e //示例二 \u003cview class=\"cu-modal\" :class=\"modalName=='DialogModal2'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"content\"\u003eModal标题\u003c/view\u003e \u003cview class=\"action\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-close text-red\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003cview class=\"cu-bar bg-white\"\u003e \u003cview class=\"action margin-0 flex-sub text-green \" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-moneybag\"\u003e\u003c/text\u003e微信支付\u003c/view\u003e \u003cview class=\"action margin-0 flex-sub text-green solid-left\" @tap=\"hideModal\"\u003e取消\u003c/view\u003e \u003cview class=\"action margin-0 flex-sub solid-left\" @tap=\"hideModal\"\u003e确定\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 图片窗口 图片窗口用于图片的展示，也可自定义操作    \u003cview class=\"cu-modal\" :class=\"modalName=='Image'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"bg-img\" style=\"background-image: url('https://ossweb-img.qq.com/images/lol/web201310/skin/big91012.jpg');height:200px;\"\u003e \u003cview class=\"cu-bar justify-end text-white\"\u003e \u003cview class=\"action\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-close \"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-bar bg-white\"\u003e \u003cview class=\"action margin-0 flex-sub solid-left\" @tap=\"hideModal\"\u003e我知道了\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 单选窗口 单选窗口是普通窗口内部结合radio标签编写的    \u003cview class=\"cu-modal\" :class=\"modalName=='RadioModal'?'show':''\" @tap=\"hideModal\"\u003e \u003cview class=\"cu-dialog\" @tap.stop=\"\"\u003e \u003cradio-group class=\"block\" @change=\"RadioChange\"\u003e \u003cview class=\"cu-list menu text-left\"\u003e \u003cview class=\"cu-item\" v-for=\"(item,index) in 5\" :key=\"index\"\u003e \u003clabel class=\"flex justify-between align-center flex-sub\"\u003e \u003cview class=\"flex-sub\"\u003eItem {{index +1}}\u003c/view\u003e \u003cradio class=\"round\" :class=\"radio=='radio' + index?'checked':''\" :checked=\"radio=='radio' + index?true:false\" :value=\"'radio' + index\"\u003e\u003c/radio\u003e \u003c/label\u003e \u003c/view\u003e \u003c/view\u003e \u003c/radio-group\u003e \u003c/view\u003e \u003c/view\u003e 多选窗口 多选窗口的内容是配合grid布局自定义的   \u003cview class=\"cu-modal bottom-modal\" :class=\"modalName=='ChooseModal'?'show':''\" @tap=\"hideModal\"\u003e \u003cview class=\"cu-dialog\" @tap.stop=\"\"\u003e \u003cview class=\"cu-bar bg-white\"\u003e \u003cview class=\"action text-blue\" @tap=\"hideModal\"\u003e取消\u003c/view\u003e \u003cview class=\"action text-green\" @tap=\"hideModal\"\u003e确定\u003c/view\u003e \u003c/view\u003e \u003cview class=\"grid col-3 padding-sm\"\u003e \u003cview v-for=\"(item,index) in checkbox\" class=\"padding-xs\" :key=\"index\"\u003e \u003cbutton class=\"cu-btn orange lg block\" :class=\"item.checked?'bg-orange':'line-orange'\" @tap=\"ChooseCheckbox\" :data-value=\"item.value\"\u003e {{item.name}}","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:9","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Steps步骤条 cu-steps步骤条必选值  默认  cu-steps和cu-item配合使用   \u003cview class=\"bg-white padding\"\u003e \u003cview class=\"cu-steps\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003ebasics?'':'text-red'\" v-for=\"(item,index) in basicsList\" :key=\"index\"\u003e \u003ctext :class=\"'cuIcon-' + item.cuIcon\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cscript\u003e export default { data() { return { basicsList: [{cuIcon: 'usefullfill',name: '开始'}, {cuIcon: 'radioboxfill',name: '等待'}, {cuIcon: 'roundclosefill',name: '错误'}, {cuIcon: 'roundcheckfill',name: '完成' }], basics: 0 }; }, methods: { BasicsSteps() { this.basics= this.basics == this.basicsList.length - 1 ? 0 : this.basics + 1 } } } \u003c/script\u003e  步骤条的颜色和图标都可以自定义 \u003cview class=\"bg-white padding margin-top-xs\"\u003e \u003cview class=\"cu-steps\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003ebasics?'':'text-orange'\" v-for=\"(item,index) in basicsList\" :key=\"index\"\u003e \u003ctext :class=\"index\u003ebasics?'cuIcon-title':'cuIcon-' + item.cuIcon\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 步骤之间的连接默认是横线，也可以通过类名steps-arrow换成箭头 \u003cview class=\"bg-white padding margin-top-xs\"\u003e \u003cview class=\"cu-steps steps-arrow\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003ebasics?'':'text-blue'\" v-for=\"(item,index) in basicsList\" :key=\"index\"\u003e \u003ctext :class=\"'cuIcon-' + item.cuIcon\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 数字完成 通过类名num可以设置默认图标为数字，已完成且正确的图标为勾，已完成但错误的图标由类名err定义   \u003cview class=\"bg-white padding\"\u003e \u003cview class=\"cu-steps\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003enum?'':'text-blue'\" v-for=\"(item,index) in numList\" :key=\"index\"\u003e \u003ctext class=\"num\" :class=\"index==2?'err':''\" :data-index=\"index + 1\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 多级显示 多级显示需要配合scroll-view标签使用 ，并增加类名steps-bottom   \u003cscroll-view scroll-x class=\"bg-white padding response cu-steps steps-bottom\" :scroll-into-view=\"'scroll-' + scroll\" scroll-with-animation\u003e \u003cview class=\"cu-item padding-lr-xl\" :class=\"index\u003escroll?'':'text-blue'\" v-for=\"(item,index) in 10\" :key=\"index\" :id=\"'scroll-' + index\"\u003e Level {{index + 1}} \u003ctext class=\"num\" :data-index=\"index + 1\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/scroll-view\u003e \u003cscript\u003e export default { data() { return { scroll: 0 }; }, methods: { ScrollSteps() { this.scroll= this.scroll == 9 ? 0 : this.scroll + 1 } } } \u003c/script\u003e 步骤条相关class class说明可选值cu-steps步骤条必选值——cu-item步骤条子元素——num数字步骤条未完成图标——err错误图标——steps-arrow步骤条连接箭头——steps-bottom配合多级步骤条使用（图标在下，文字在上，放在其他步骤条样式会错乱）—— ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:10","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"扩展插件  交互组件就到此为止了，不足之处请多多指教，便于我及时更正，承接上一篇基础元素的博客，扩展插件部分我们就在再另写一篇，ColorUI组件库简易教程之扩展插件 ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:2:0","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 按照惯例，在此奉上官方示例！！！ 目录 [TOC] ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:0:0","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["前端"],"content":"扩展插件  ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:0","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["前端"],"content":"索引列表 索引列表主要由scroll-view标签实现，类名为indexes，具体js逻辑请看源码，有些我没看懂，希望看懂的大佬教教我 \u003ctemplate\u003e \u003cview\u003e \u003cview class=\"cu-bar bg-white search fixed\"\u003e \u003cview class=\"search-form round\"\u003e \u003ctext class=\"cuIcon-search\"\u003e\u003c/text\u003e \u003cinput type=\"text\" placeholder=\"输入搜索的关键词\" confirm-type=\"search\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn bg-gradual-green shadow-blur round\"\u003e搜索\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003cscroll-view scroll-y class=\"indexes\" :scroll-into-view=\"'indexes-'+ listCurID\" :style=\"[{height:'calc(100vh - 50px)'}]\" :scroll-with-animation=\"true\" :enable-back-to-top=\"true\"\u003e \u003cblock v-for=\"(item,index) in list\" :key=\"index\"\u003e \u003c!-- 这个'indexItem-' + item.name类名，整个colorUI，我也没找到它的作用，删了也没发现什么影响--\u003e \u003cview :class=\"'indexItem-' + item.name\" :id=\"'indexes-' + item.name\" :data-index=\"item.name\"\u003e \u003cview class=\"padding\"\u003e{{item.name}}\u003c/view\u003e \u003cview class=\"cu-list menu-avatar no-padding\"\u003e \u003cview class=\"cu-item\" v-for=\"(items,sub) in 2\" :key=\"sub\"\u003e \u003cview class=\"cu-avatar round lg\"\u003e{{item.name}}\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e{{item.name}}\u003ctext class=\"text-abc\"\u003e{{list[sub].name}}\u003c/text\u003e君\u003c/view\u003e \u003cview class=\"text-gray text-sm\"\u003e 有{{sub+2}}个主子需要伺候 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/block\u003e \u003c/scroll-view\u003e \u003cview class=\"indexBar\" :style=\"[{height:'calc(100vh - 50px)'}]\"\u003e \u003cview class=\"indexBar-box\" @touchstart=\"tStart\" @touchend=\"tEnd\" @touchmove.stop=\"tMove\"\u003e \u003cview class=\"indexBar-item\" v-for=\"(item,index) in list\" :key=\"index\" :id=\"index\" @touchstart=\"getCur\" @touchend=\"setCur\"\u003e {{item.name}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c!--选择显示--\u003e \u003cview v-show=\"!hidden\" class=\"indexToast\"\u003e {{listCur}} \u003c/view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { StatusBar: this.StatusBar, CustomBar: this.CustomBar, hidden: true, listCurID: '', list: [], listCur: '', }; }, onLoad() { let list = [{}]; for (let i = 0; i \u003c 26; i++) { list[i] = {}; list[i].name = String.fromCharCode(65 + i); } this.list = list; this.listCur = list[0]; }, onReady() { let that = this; //这两句大概知道什么意思，但是emmm,这个boxTop和barTop具体是什么数值，不是很理解 uni.createSelectorQuery().select('.indexBar-box').boundingClientRect(function(res) { that.boxTop = res.top }).exec(); uni.createSelectorQuery().select('.indexes').boundingClientRect(function(res) { that.barTop = res.top }).exec() }, methods: { //获取文字信息 getCur(e) { this.hidden = false; this.listCur = this.list[e.target.id].name; }, setCur(e) { this.hidden = true; this.listCur = this.listCur }, //滑动选择Item tMove(e) { console.log(this.boxTop) let y = e.touches[0].clientY, offsettop = this.boxTop, that = this; //判断选择区域,只有在选择区才会生效 if (y \u003e offsettop) { // 这个num计算结果怎么就是字母列表的下标呢，我没想明白，望大佬指教 let num = parseInt((y - offsettop) / 20); this.listCur = that.list[num].name }; }, //触发全部开始选择 tStart() { this.hidden = false }, //触发结束选择 tEnd() { this.hidden = true; this.listCurID = this.listCur }, //源码中有这个函数，但是这个页面中根本没有用到，删了没影响，我也不明白作者为什么写这个 indexSelect(e) { let that = this; let barHeight = this.barHeight; let list = this.list; let scrollY = Math.ceil(list.length * e.detail.y / barHeight); for (let i = 0; i \u003c list.length; i++) { if (scrollY \u003c i + 1) { that.listCur = list[i].name; that.movableY = i * 20 return false } } } } } \u003c/script\u003e \u003cstyle\u003e page { padding-top: 100upx; } .indexes { position: relative; } .indexBar { position: fixed; right: 0px; bottom: 0px; padding: 20upx 20upx 20upx 60upx; display: flex; align-items: center; } .indexBar .indexBar-box { width: 40upx; height: auto; background: #fff; display: flex; flex-direction: column; box-shadow: 0 0 20upx rgba(0, 0, 0, 0.1); border-radius: 10upx; } .indexBar-item { flex: 1; width: 40upx; height: 40upx; display: flex; align-items: center; justify-content: center; font-size: 24upx; color: #888; } movable-view.indexBar-item { width: 40upx; height: 40upx; z-index: 9; position: relative; } movable-view.indexBar-item::before { content: \"\"; display: block; position: absolute; left: 0; top: 10upx; height: 20upx; width: 4upx; background-color: #f37b1d; } .indexToast { position: fixed; top: 0; right: 80upx; bottom: 0; bac","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:1","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["前端"],"content":"微动画 微动画我没办法截图展示出来这种动态效果，我就直接给出class了，想要看效果，可以去官方示例去看，这里有几个gif动画，我可以给个图和代码，看一下 \u003cview class=\"margin radius bg-gradual-green shadow-blur\"\u003e \u003c!-- 这个动图显示不出来，不知道是不是路径问题，还是源文件没了 --\u003e \u003cimage src=\"https://image.weilanwl.com/gif/wave.gif\" mode=\"scaleToFill\" class=\"gif-black response\" style=\"height:100upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"margin flex\"\u003e \u003cview class=\"bg-black flex-sub margin-right radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-black.gif\" mode=\"aspectFit\" class=\"gif-black response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"bg-white flex-sub radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-white.gif\" mode=\"aspectFit\" class=\"gif-white response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"margin flex\"\u003e \u003cview class=\"bg-gradual-blue flex-sub margin-right radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/rhomb-black.gif\" mode=\"aspectFit\" class=\"gif-black response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"bg-white flex-sub radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/rhomb-white.gif\" mode=\"aspectFit\" class=\"gif-white response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"margin flex\"\u003e \u003cview class=\"bg-white flex-sub margin-right radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-1.gif\" mode=\"aspectFit\" class=\"gif-white response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"bg-black flex-sub radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-2.gif\" mode=\"aspectFit\" class=\"gif-black response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003c/view\u003e 微动画相关class class说明可选值animation-{{options}}动画效果fade / scale-up / scale-down / slide-top / slide-bottom / slide-left / slide-right / shakeanimation-reverse反向动画，配合上面的动画效果使用  ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:2","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["前端"],"content":"全屏抽屉  全屏抽屉效果主要分为三个部分，主要有三个类名，第一个类名DrawerPage，就是第一张图总体外部包裹的类名；第二个类名DrawerClose，用来包裹打开抽屉之后关闭部分，如图二红框框出来的部分；第三个类名DrawerWindow，就是打开的抽屉部分了   \u003ctemplate\u003e \u003cview class=\"bg-gradual-blue\"\u003e //全屏主体页面 \u003cscroll-view scroll-y class=\"DrawerPage\" :class=\"modalName=='viewModal'?'show':''\"\u003e \u003ccu-custom bgColor=\"bg-gradual-blue\" :isBack=\"true\"\u003e\u003cblock slot=\"backText\"\u003e返回\u003c/block\u003e \u003cblock slot=\"content\"\u003e全屏抽屉\u003c/block\u003e \u003c/cu-custom\u003e \u003cview class='padding margin text-center'\u003e \u003cview class='cu-btn bg-green lg block shadow radius margin-xl' @tap=\"showModal\" data-target=\"viewModal\"\u003e 打开抽屉 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-list menu card-menu margin-top-xl margin-bottom-xl shadow-lg\"\u003e \u003cview class=\"cu-item arrow\" v-for=\"(item,index) in 20\" :key=\"index\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-github text-grey\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e{{index +1}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class='padding margin text-center'\u003e \u003cview class='cu-btn bg-green lg block shadow radius margin-xl' @tap=\"showModal\" data-target=\"viewModal\"\u003e 打开抽屉 \u003c/view\u003e \u003c/view\u003e \u003c/scroll-view\u003e //关闭部分 \u003cview class=\"DrawerClose\" :class=\"modalName=='viewModal'?'show':''\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-pullright\"\u003e\u003c/text\u003e \u003c/view\u003e //抽屉部分 \u003cscroll-view scroll-y class=\"DrawerWindow\" :class=\"modalName=='viewModal'?'show':''\"\u003e \u003cview class=\"cu-list menu card-menu margin-top-xl margin-bottom-xl shadow-lg\"\u003e \u003cview class=\"cu-item arrow\" v-for=\"(item,index) in 20\" :key=\"index\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-github text-grey\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e{{index +1}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/scroll-view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { modalName:null }; }, methods: { showModal(e) { console.log(e) this.modalName = e.currentTarget.dataset.target }, hideModal(e) { this.modalName = null }, //这个函数没用到，我也不知道为什么源码作者写了 tabSelect(e) { this.TabCur = e.currentTarget.dataset.id; this.scrollLeft = (e.currentTarget.dataset.id - 1) * 60 } }, } \u003c/script\u003e \u003cstyle\u003e page { background-image: var(--gradualBlue); width: 100vw; overflow: hidden; } .DrawerPage { position: fixed; width: 100vw; height: 100vh; left: 0vw; background-color: #f1f1f1; transition: all 0.4s; } .DrawerPage.show { transform: scale(0.9, 0.9); left: 85vw; box-shadow: 0 0 60upx rgba(0, 0, 0, 0.2); transform-origin: 0; } .DrawerWindow { position: absolute; width: 85vw; height: 100vh; left: 0; top: 0; transform: scale(0.9, 0.9) translateX(-100%); opacity: 0; pointer-events: none; transition: all 0.4s; padding: 100upx 0; } .DrawerWindow.show { transform: scale(1, 1) translateX(0%); opacity: 1; pointer-events: all; } .DrawerClose { position: absolute; width: 40vw; height: 100vh; right: 0; top: 0; color: transparent; padding-bottom: 30upx; display: flex; align-items: flex-end; justify-content: center; background-image: linear-gradient(90deg, rgba(0, 0, 0, 0.01), rgba(0, 0, 0, 0.6)); letter-spacing: 5px; font-size: 50upx; opacity: 0; pointer-events: none; transition: all 0.4s; } .DrawerClose.show { opacity: 1; pointer-events: all; width: 15vw; color: #fff; } .DrawerPage .cu-bar.tabbar .action button.cuIcon { width: 64upx; height: 64upx; line-height: 64upx; margin: 0; display: inline-block; } .DrawerPage .cu-bar.tabbar .action .cu-avatar { margin: 0; } .DrawerPage .nav { flex: 1; } .DrawerPage .nav .cu-item.cur { border-bottom: 0; position: relative; } .DrawerPage .nav .cu-item.cur::after { content: \"\"; width: 10upx; height: 10upx; background-color: currentColor; position: absolute; bottom: 10upx; border-radius: 10upx; left: 0; right: 0; margin: auto; } .DrawerPage .cu-bar.tabbar .action { flex: initial; } \u003c/style\u003e ","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:3","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["前端"],"content":"垂直导航 垂直导航主要有两个scroll-view标签实现，分别是左侧的导航栏部分和右侧的内容部分，左侧导航栏部分使用类名VerticalBox，右侧内容部分使用类名VerticalMain  \u003ctemplate\u003e \u003cview\u003e \u003cview class=\"fixed\"\u003e \u003ccu-custom :isBack=\"true\" bgColor=\"bg-shadeTop text-white\"\u003e \u003cblock slot=\"backText\"\u003e返回\u003c/block\u003e \u003cblock slot=\"content\"\u003e垂直导航\u003c/block\u003e \u003c/cu-custom\u003e \u003c/view\u003e \u003cswiper class=\"screen-swiper round-dot\" :indicator-dots=\"true\" :circular=\"true\" :autoplay=\"true\" interval=\"5000\" duration=\"500\"\u003e \u003cswiper-item v-for=\"(item,index) in 4\" :key=\"index\"\u003e \u003cimage :src=\"'https://ossweb-img.qq.com/images/lol/web201310/skin/big3900'+index+ '.jpg'\" mode=\"aspectFill\"\u003e\u003c/image\u003e \u003c/swiper-item\u003e \u003c/swiper\u003e \u003cview class=\"VerticalBox\"\u003e \u003cscroll-view class=\"VerticalNav nav\" scroll-y scroll-with-animation :scroll-top=\"verticalNavTop\" style=\"height:calc(100vh - 375upx)\"\u003e \u003cview class=\"cu-item\" :class=\"index==tabCur?'text-green cur':''\" v-for=\"(item,index) in list\" :key=\"index\" @tap=\"TabSelect\" :data-id=\"index\"\u003e Tab-{{item.name}} \u003c/view\u003e \u003c/scroll-view\u003e \u003cscroll-view class=\"VerticalMain\" scroll-y scroll-with-animation style=\"height:calc(100vh - 375upx)\" :scroll-into-view=\"'main-'+mainCur\" @scroll=\"VerticalMain\"\u003e \u003cview class=\"padding-top padding-lr\" v-for=\"(item,index) in list\" :key=\"index\" :id=\"'main-'+index\"\u003e \u003cview class=\"cu-bar solid-bottom bg-white\"\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-title text-green\"\u003e\u003c/text\u003e Tab-{{item.name}}\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-list menu-avatar\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e凯尔\u003c/view\u003e \u003cview class=\"text-gray text-sm flex\"\u003e \u003ctext class=\"text-cut\"\u003e \u003ctext class=\"cuIcon-infofill text-red margin-right-xs\"\u003e\u003c/text\u003e 我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。 \u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cu-tag round bg-grey sm\"\u003e5\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/img/champion/Taric.png);\"\u003e \u003cview class=\"cu-tag badge\"\u003e99+\u003c/view\u003e \u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e \u003ctext class=\"text-cut\"\u003e瓦洛兰之盾-塔里克\u003c/text\u003e \u003cview class=\"cu-tag round bg-orange sm\"\u003e战士\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray text-sm flex\"\u003e \u003ctext class=\"text-cut\"\u003e 塔里克是保护者星灵，用超乎寻常的力量守护着符文之地的生命、仁爱以及万物之美。塔里克由于渎职而被放逐，离开了祖国德玛西亚，前去攀登巨神峰寻找救赎，但他找到的却是来自星界的更高层的召唤。现在的塔里克与古代巨神族的神力相融合，以瓦洛兰之盾的身份，永不疲倦地警惕着阴险狡诈的虚空腐化之力。 \u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cuIcon-notice_forbid_fill text-gray\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item \"\u003e \u003cview class=\"cu-avatar radius lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/img/champion/Morgana.png);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-pink\"\u003e\u003ctext class=\"text-cut\"\u003e莫甘娜\u003c/text\u003e\u003c/view\u003e \u003cview class=\"text-gray text-sm flex\"\u003e \u003ctext class=\"text-cut\"\u003e凯尔，你被自己的光芒变的盲目！\u003c/text\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cu-tag round bg-red sm\"\u003e5\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item grayscale\"\u003e \u003cview class=\"cu-avatar radius lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81007.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview\u003e\u003ctext class=\"text-cut\"\u003e伊泽瑞尔\u003c/text\u003e \u003cview class=\"cu-tag round bg-orange sm\"\u003e断开连接...\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray text-sm flex\"\u003e \u003ctext class=\"text-cut\"\u003e 等我回来一个打十个\u003c/text\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cu-tag round bg-red sm\"\u003e5\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item cur\"\u003e \u003cview class=\"cu-avatar radius lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81020.jpg);\"\u003e \u003cview class=\"cu-tag badge\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview\u003e \u003ctext class=\"text-cut\"\u003e瓦罗兰大陆-睡衣守护者-新手保护营\u003c/text\u003e \u003cview class=\"cu-tag round bg-orange sm\"\u003e6人\u003c/view\u003e \u003c/view\u003e \u003cview class=\"text","date":"2021-05-12","objectID":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/:1:4","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/colorui%E7%BB%84%E4%BB%B6%E5%BA%93%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%B9%8B%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6/"},{"categories":["前端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 本教程配合官方示例食用更佳！！！ 目录 [TOC] 前言 ColorUI是一个css库！！！在你引入样式后可以根据class来调用组件  快速上手 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:0:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用UniApp开发 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"开始 下载源码解压获得/Colorui-UniApp文件夹，复制目录下的 /colorui 文件夹到你的项目根目录 App.vue 引入关键Css main.css icon.css \u003cstyle\u003e @import \"colorui/main.css\"; @import \"colorui/icon.css\"; @import \"app.css\"; /* 你的项目css */ .... \u003c/style\u003e ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:1","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用自定义导航栏 导航栏作为常用组件有做简单封装，当然你也可以直接复制代码结构自己修改，达到个性化目的。 App.vue 获得系统信息 onLaunch: function() { uni.getSystemInfo({ success: function(e) { // #ifndef MP Vue.prototype.StatusBar = e.statusBarHeight; if (e.platform == 'android') { Vue.prototype.CustomBar = e.statusBarHeight + 50; } else { Vue.prototype.CustomBar = e.statusBarHeight + 45; }; // #endif // #ifdef MP-WEIXIN Vue.prototype.StatusBar = e.statusBarHeight; let custom = wx.getMenuButtonBoundingClientRect(); Vue.prototype.Custom = custom; Vue.prototype.CustomBar = custom.bottom + custom.top - e.statusBarHeight; // #endif // #ifdef MP-ALIPAY Vue.prototype.StatusBar = e.statusBarHeight; Vue.prototype.CustomBar = e.statusBarHeight + e.titleBarHeight; // #endif } }) }, pages.json 配置取消系统导航栏 \"globalStyle\": { \"navigationStyle\": \"custom\" }, 复制代码结构可以直接使用，注意全局变量的获取。 使用封装,在main.js 引入 cu-custom 组件。 import cuCustom from './colorui/components/cu-custom.vue' Vue.component('cu-custom',cuCustom) page.vue 页面可以直接调用了 \u003ccu-custom bgColor=\"bg-gradual-blue\" :isBack=\"true\"\u003e \u003cblock slot=\"backText\"\u003e返回\u003c/block\u003e \u003cblock slot=\"content\"\u003e导航栏\u003c/block\u003e \u003c/cu-custom\u003e 参数作用类型默认值bgColor背景颜色类名String''isBack是否开启返回BooleanfalsebgImage背景图片路径String''slot块作用backText返回时的文字content中间区域right右侧区域(小程序端可使用范围很窄！) ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:2","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用原生小程序开发 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"从现有项目开始 下载源码解压获得/demo，复制目录下的 /colorui 文件夹到你的项目根目录 App.wxss 引入关键Css main.wxss icon.wxss @import \"colorui/main.wxss\"; @import \"colorui/icon.wxss\"; @import \"app.css\"; /* 你的项目css */ .... ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:1","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"从新项目开始 下载源码解压获得/template，复制/template并重命名为你的项目，导入到小程序开发工具既可以开始你的新项目了 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:2","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用自定义导航栏 导航栏作为常用组件有做简单封装，当然你也可以直接复制代码结构自己修改，达到个性化目的。 App.js 获得系统信息 onLaunch: function() { wx.getSystemInfo({ success: e =\u003e { this.globalData.StatusBar = e.statusBarHeight; let custom = wx.getMenuButtonBoundingClientRect(); this.globalData.Custom = custom; this.globalData.CustomBar = custom.bottom + custom.top - e.statusBarHeight; } }) }, App.json 配置取消系统导航栏,并全局引入组件 \"window\": { \"navigationStyle\": \"custom\" }, \"usingComponents\": { \"cu-custom\":\"/colorui/components/cu-custom\" } page.wxml 页面可以直接调用了 \u003ccu-custom bgColor=\"bg-gradual-pink\" isBack=\"{{true}}\"\u003e \u003cview slot=\"backText\"\u003e返回\u003c/view\u003e \u003cview slot=\"content\"\u003e导航栏\u003c/view\u003e \u003c/cu-custom\u003e 参数作用类型默认值bgColor背景颜色类名String''isBack是否开启返回BooleanfalseisCustom是否开启左侧胶囊BooleanfalsebgImage背景图片路径String''slot块作用backText返回时的文字content中间区域right右侧区域(小程序端可使用范围很窄！) 组件 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:3","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"基础元素 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"layout布局 Flex布局 父级添加class名flex 固定尺寸 通过添加class名basic-{{options}}来设置分栏大小，options可以取五个值，分别为xs、sm、df、lg、xl \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"flex flex-wrap\"\u003e \u003cview class=\"basis-xs bg-grey margin-xs padding-sm radius\"\u003exs(20%)\u003c/view\u003e \u003cview class=\"basis-df\"\u003e\u003c/view\u003e \u003cview class=\"basis-sm bg-grey margin-xs padding-sm radius\"\u003esm(40%)\u003c/view\u003e \u003cview class=\"basis-df\"\u003e\u003c/view\u003e \u003cview class=\"basis-df bg-grey margin-xs padding-sm radius\"\u003edf(50%)\u003c/view\u003e \u003cview class=\"basis-lg bg-grey margin-xs padding-sm radius\"\u003elg(60%)\u003c/view\u003e \u003cview class=\"basis-xl bg-grey margin-xs padding-sm radius\"\u003exl(80%)\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 比例布局 通过添加class名flex-{{options}}来设置分栏大小，options可以取值sub、twice、treble，分别代表占比1，2，3 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003cview class=\"flex-twice bg-grey padding-sm margin-xs radius\"\u003e2\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003cview class=\"flex-twice bg-grey padding-sm margin-xs radius\"\u003e2\u003c/view\u003e \u003cview class=\"flex-treble bg-grey padding-sm margin-xs radius\"\u003e3\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 水平对齐（justify） 通过添加class名justify-{{options}}来设置盒子水平对齐方式，options可以取值start、end、center、between、around，效果可以参考flex布局布局中的容器属性justify-content（Flex布局教程） \u003cview class=\"bg-white\"\u003e \u003cview class=\"flex solid-bottom padding justify-start\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003estart\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003estart\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding justify-end\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003eend\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003eend\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding justify-center\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003ecenter\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003ecenter\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding justify-between\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003ebetween\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003ebetween\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding justify-around\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003earound\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003earound\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 垂直对齐（align） 通过添加class名align-{{options}}来设置盒子垂直对齐方式，options可以取值start、end、center，效果可以参考flex布局布局中的容器属性align-item（Flex布局教程） \u003cview class=\"bg-white\"\u003e \u003cview class=\"flex solid-bottom padding align-start\"\u003e \u003cview class=\"bg-grey padding-lg margin-xs radius\"\u003eColorUi\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003estart\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding align-end\"\u003e \u003cview class=\"bg-grey padding-lg margin-xs radius\"\u003eColorUi\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003eend\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding align-center\"\u003e \u003cview class=\"bg-grey padding-lg margin-xs radius\"\u003eColorUi\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003ecenter\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e Grid布局 父级添加class名grid 等分列 通过添加class名col-{{options}}来实现栅格布局，options可以取值1、2、3、4、5 \u003cview class=\"bg-white padding\"\u003e \u003cview class=\"grid margin-bottom text-center\" v-for=\"(item,index) in 5\" :key=\"index\" :class=\"'col-' + (index+1)\"\u003e \u003cview class=\"padding\" :class=\"indexs%2==0?'bg-cyan':'bg-blue'\" v-for=\"(item,indexs) in (index+1)\" :key=\"indexs\"\u003e{{index+1}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 等高 通过添加class名grid-square设置盒子内容等高，添加col-{{options}}来设置分栏个数，options可以取值1、2、3、4、5，将盒子等分 \u003cview class=\"bg-white padding\"\u003e \u003cview class=\"grid col-4 grid-square\"\u003e \u003cview class=\"bg-img\" v-for=\"(item,index) in avatar\" :key=\"index\" :style=\"[{ backgroundImage:'url(' + avatar[index] + ')' }]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e ---------------------------------------------------------------------------------------- data() { return { avatar: ['https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:1","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Background背景  颜色背景 深色   通过添加class名bg-{{options}}设置背景   \u003cview class=\"grid col-3 padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cview class=\"padding radius text-center shadow-blur\" :class=\"'bg-' + item.name\"\u003e \u003cview class=\"text-lg\"\u003e{{item.title}}\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e{{item.name}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 浅色  通过添加class名bg-{{options}}设置背景颜色，添加class名light表示相应的浅色 \u003cview class=\"grid col-3 bg-white padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"index\u003c12\"\u003e \u003cview class=\"padding radius text-center light\" :class=\"'bg-' + item.name\"\u003e \u003cview class=\"text-lg\"\u003e{{item.title}}\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e{{item.name}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e  渐变 通过添加class名bg-gradual-{{options}}设置渐变背景颜色 \u003cview class=\"grid col-2 padding-sm\"\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-red padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e魅红\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#f43f3b - #ec008c\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-orange padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e鎏金\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#ff9700 - #ed1c24\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-green padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e翠柳\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#39b54a - #8dc63f\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-blue padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e靛青\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#0081ff - #1cbbb4\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-purple padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e惑紫\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#9000ff - #5e00ff\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-pink padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e霞彩\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#ec008c - #6739b6\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 图片背景 透明背景（文字层） 通过bg-img设置图片背景，bg-mask设置透明遮罩层 \u003cview class=\"bg-img bg-mask flex align-center\" style=\"background-image: url('https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg');height: 414upx;\"\u003e \u003cview class=\"padding-xl text-white\"\u003e \u003cview class=\"padding-xs text-xxl text-bold\"\u003e 钢铁之翼 \u003c/view\u003e \u003cview class=\"padding-xs text-lg\"\u003e Only the guilty need fear me. \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e  通过bg-shadeTop设置遮罩层上阴影，bg-shadeBottom设置遮罩层下阴影 \u003cview class=\"grid col-2\"\u003e \u003cview class=\"bg-img padding-bottom-xl\" style=\"background-image: url('https://ossweb-img.qq.com/images/lol/web201310/skin/big10007.jpg');height: 207upx;\"\u003e \u003cview class=\"bg-shadeTop padding padding-bottom-xl\"\u003e 上面开始 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"bg-img padding-top-xl flex align-end\" style=\"background-image: url('https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg');height: 207upx;\"\u003e \u003cview class=\"bg-shadeBottom padding padding-top-xl flex-sub\"\u003e 下面开始 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 背景相关class class说明可选值bg-{{options}}设置背景色red/orange/yellow/olive/green/cyan/blue/purple/mauve/pink/ brown/grey/gray/black/white light浅色背景，配合bg-{{options}}使用，取值前12个——bg-gradual-{{options}}渐变色背景red/orange/green/blue/purple/pinkbg-img图片背景——bg-mask遮罩层——bg-shadeTop遮罩层上阴影——bg-shadeBottom遮罩层下阴影——shadow-blur外阴影—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:2","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Text文字 文字大小 通过添加class名text-{{size}}设置文字大小，size取值xs、sm、df、lg、xl、xxl、sl、xsl 文字颜色 通过添加class名text-{{color}}设置文字颜色，color取值red、orange、yellow、olive、green、cyan、blue、purple、mauve、brown、grey、gray、black、white \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cview class=\"text-center\" :class=\"'text-' + item.name\"\u003e {{item.title}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 文字阴影 通过添加class名text-shadow设置文字阴影 \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cview class=\"text-center text-shadow\" :class=\"'text-' + item.name\"\u003e \u003cview class=\"cuIcon-ellipse text-xxl\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 文字截断 通过添加class名text-cut设置文字长度溢出显示省略号 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"text-cut padding bg-grey radius\" style=\"width:220px\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003c/view\u003e 文字对齐 通过添加class名text-{{position}}设置文字长度溢出显示省略号，position取值left、center、right \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"text-left padding\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003cview class=\"text-center padding\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003cview class=\"text-right padding\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003c/view\u003e  特殊文字 通过添加class名text-price表示价格，会显示￥符号，text-Abc设置英文首字母大写，text-ABC设置英文大写，text-abc设置英文小写 \u003cview class=\"padding text-center\"\u003e \u003cview class=\"padding-lr bg-white\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-price\"\u003e80.00\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e价格文本，利用伪元素添加\"¥\"符号\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-lr bg-white margin-top\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-Abc\"\u003ecolor Ui\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e英文单词首字母大写\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-lr bg-white margin-top\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-ABC\"\u003ecolor Ui\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e全部字母大写\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-lr bg-white margin-top\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-abc\"\u003ecolor Ui\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e全部字母小写\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 文字相关class ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:3","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Icon图标 通过添加class名cuIcon-{{iconName}}，直接设置图标 ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:4","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Button按钮 按钮必选class cu-btn 按钮形状 通过添加class名设置按钮不同形状，默认只需要添加cu-btn，round为圆角，cuIcon为圆形用来包裹图标 \u003cview class=\"padding flex flex-wrap justify-between align-center bg-white\"\u003e \u003cbutton class=\"cu-btn\"\u003e默认\u003c/button\u003e \u003cbutton class=\"cu-btn round\"\u003e圆角\u003c/button\u003e \u003cbutton class=\"cu-btn cuIcon\"\u003e \u003ctext class=\"cuIcon-goodsfill\"\u003e\u003c/text\u003e \u003c/button\u003e \u003c/view\u003e 按钮尺寸 sm小尺寸，lg大尺寸 \u003cview class=\"padding flex flex-wrap justify-between align-center bg-white\"\u003e \u003cbutton class=\"cu-btn round sm\"\u003e小尺寸\u003c/button\u003e \u003cbutton class=\"cu-btn round\"\u003e默认\u003c/button\u003e \u003cbutton class=\"cu-btn round lg\"\u003e大尺寸\u003c/button\u003e \u003c/view\u003e 按钮颜色 添加背景class名就可以，用法参考背景组件的介绍   \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"margin-tb-sm text-center\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cbutton class=\"cu-btn round\" :class=\"'bg-' + item.name \"\u003e{{item.title}}\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e 幽灵按钮 通过line-{{color}}或者lines-{{color}}设置镂空的幽灵按钮 \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"margin-tb-sm text-center\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='white'\"\u003e \u003cbutton class=\"cu-btn round\" :class=\"'line-' + item.name\"\u003e{{item.title}}\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e 禁用按钮 添加disabled禁用按钮 \u003cview class=\"padding\"\u003e \u003cbutton class=\"cu-btn block bg-blue margin-tb-sm lg\" disabled type=\"\"\u003e无效状态\u003c/button\u003e \u003cbutton class=\"cu-btn block line-blue margin-tb-sm lg\" disabled\u003e无效状态\u003c/button\u003e \u003c/view\u003e 自定义图标按钮 可以直接在button标签class内添加图标名，或者在text等其他标签内添加class，其他标签要包裹在button标签内 \u003cview class=\"padding-xl\"\u003e \u003cbutton class=\"cu-btn block line-orange lg cuIcon-upload\"\u003e\u003ctext class=\"cuIcon-upload\"\u003e\u003c/text\u003e 图标\u003c/button\u003e \u003cbutton class=\"cu-btn block bg-blue margin-tb-sm lg\"\u003e\u003ctext class=\"cuIcon-loading2 cuIconfont-spin\"\u003e\u003c/text\u003e 加载\u003c/button\u003e \u003cbutton class=\"cu-btn block bg-black margin-tb-sm lg\" loading\u003e 原生加载\u003c/button\u003e \u003c/view\u003e 按钮相关class class说明可选值cu-btn按钮必选值——round圆角按钮——cuIcon圆形——sm小尺寸按钮——lg大尺寸按钮——line-{{color}}幽灵按钮，细边框参考背景色lines-{{color}}幽灵按钮，粗边框参考背景色disabled禁用—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:5","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Tag标签 标签必选class cu-tag  标签形状 通过添加class名设置标签不同形状，默认只需要添加cu-tag，round为椭圆，radius为圆角 \u003cview class=\"padding bg-white solid-bottom\"\u003e \u003cview class='cu-tag'\u003e默认\u003c/view\u003e \u003cview class='cu-tag round'\u003e椭圆\u003c/view\u003e \u003cview class='cu-tag radius'\u003e圆角\u003c/view\u003e \u003c/view\u003e  标签尺寸 sm小尺寸 \u003cview class=\"padding bg-white\"\u003e \u003cview class='cu-tag radius sm'\u003e小尺寸\u003c/view\u003e \u003cview class='cu-tag radius'\u003e普通尺寸\u003c/view\u003e \u003c/view\u003e  标签颜色 添加背景class名就可以，用法参考背景组件的介绍 \u003cview class='padding-sm flex flex-wrap'\u003e \u003cview class=\"padding-xs\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='gray'\"\u003e \u003cview class='cu-tag' :class=\"'bg-' + item.name\"\u003e{{item.title}}\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xs\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='gray' \u0026\u0026 item.name!='black' \u0026\u0026 item.name!='white'\"\u003e \u003cview class='cu-tag light' :class=\"'bg-' + item.name\"\u003e{{item.title}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 幽灵标签 通过line-{{color}}设置镂空的幽灵按钮 \u003cview class='padding-sm flex flex-wrap'\u003e \u003cview class=\"padding-xs\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='white'\"\u003e \u003cview class='cu-tag' :class=\"'line-' + item.name\"\u003e{{item.title}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 胶囊样式 通过cu-capsule设置为胶囊样式，内部设置自己想要的样式 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-capsule\"\u003e \u003cview class='cu-tag bg-red'\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-red\"\u003e12\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule round\"\u003e \u003cview class='cu-tag bg-blue '\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-blue\"\u003e23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule round\"\u003e \u003cview class='cu-tag bg-blue '\u003e说明\u003c/view\u003e \u003cview class=\"cu-tag line-blue\"\u003e123\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class='cu-tag bg-grey '\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-grey\"\u003e23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class='cu-tag bg-brown sm'\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-brown sm\"\u003e23\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 数字标签  通过badge设置角标   \u003cview class=\"padding flex justify-between align-center\"\u003e \u003cview class='cu-avatar xl radius'\u003e港\u003cview class=\"cu-tag badge\"\u003e99+\u003c/view\u003e\u003c/view\u003e \u003cview class='cu-avatar xl radius' style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg)\"\u003e \u003cview class='cu-tag badge'\u003e9\u003c/view\u003e \u003c/view\u003e \u003cview class='cu-avatar xl radius'\u003e \u003cview class='cu-tag badge'\u003e99\u003c/view\u003e \u003ctext class='cuIcon-people'\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class='cu-avatar xl radius'\u003e \u003cview class='cu-tag badge'\u003e99+\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 标签相关class class说明可选值cu-tag标签必选值——round椭圆——radius圆角——sm小尺寸标签——line-{{color}}幽灵标签参考背景色cu-capsule胶囊标签——badge数字角标—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:6","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Avatar头像 头像必选class cu-avatar 头像形状 通过round和radius设置头像形状 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar round\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg)\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar radius margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81005.jpg);\"\u003e\u003c/view\u003e \u003c/view\u003e 头像尺寸 通过sm 、lg、xl设置不同大小的头像 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar sm round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg)\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81005.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar lg round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big25002.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar xl round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big99008.jpg);\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar sm round margin-left bg-red\"\u003e 蔚\u003c/view\u003e \u003cview class=\"cu-avatar round margin-left bg-red\"\u003e蓝\u003c/view\u003e \u003cview class=\"cu-avatar lg round margin-left bg-red\"\u003e\u003ctext\u003ewl\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-avatar xl round margin-left bg-red\"\u003e \u003ctext class=\"avatar-text\"\u003e网络\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 内嵌文字 头像内部不仅仅是图片，也可以是自定义文字和图标等 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar radius\"\u003e \u003ctext class=\"cuIcon-people\"\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius margin-left\"\u003e \u003ctext\u003e港\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e  头像颜色 设置背景色即可 \u003cview class=\"padding-sm\"\u003e \u003cview class=\"cu-avatar round lg margin-xs\" :class=\"'bg-' + item.name\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003ctext class=\"avatar-text\"\u003e{{item.name}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 头像组 设置了cu-avatar外部的盒子添加cu-avatar-group的class \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar-group\"\u003e \u003cview class=\"cu-avatar round lg\" v-for=\"(item,index) in avatar\" :key=\"index\" :style=\"[{ backgroundImage:'url(' + avatar[index] + ')' }]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 头像标签 在头像标签内部添加数字标签的角标即可 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar round lg margin-left\" v-for=\"(item,index) in avatar\" :key=\"index\" :style=\"[{ backgroundImage:'url(' + avatar[index] + ')' }]\"\u003e \u003cview class=\"cu-tag badge\" :class=\"index%2==0?'cuIcon-female bg-pink':'cuIcon-male bg-blue'\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 头像相关class class说明可选值cu-avatar头像必选值——cu-avatar-group头像组，包裹cu-avatar——round圆形——radius圆角——sm小尺寸头像——lg大尺寸头像——xl超大尺寸头像—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:7","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Progress进度条  进度条必须值为cu-progress 进度条形状 进度条默认为方形，radius为圆角，round为圆形；代码中loading只是一个变量，初始值为false，页面初始化时赋值为true，即给进度条赋值，使进度条有一个动画效果。 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress\"\u003e \u003cview class=\"bg-red\" style=\"width:61.8%\"\u003e61.8%\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress radius margin-top\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e61.8%\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round margin-top\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e61.8%\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条尺寸 sm为小尺寸，xs为超小尺寸  \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress round\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round margin-top sm\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round margin-top xs\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条颜色 添加背景色即可 \u003cview class=\"padding\" :class=\"color=='white'?'bg-grey':'bg-white'\"\u003e \u003cview class=\"cu-progress round\"\u003e \u003cview :class=\"'bg-' + color\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条条纹 添加striped设置条纹样式，active设置条纹动态效果 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress round sm striped active\" \u003e \u003cview class=\"bg-green\" :style=\"[{ width:loading?'60%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round sm margin-top-sm striped\" \u003e \u003cview class=\"bg-black\" :style=\"[{ width:loading?'40%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条比例 在给定class为cu-progress的标签内按需放置元素并进行分段设计即可 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress radius striped active\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'30%':''}]\"\u003e30%\u003c/view\u003e \u003cview class=\"bg-olive\" :style=\"[{ width:loading?'45%':''}]\"\u003e45%\u003c/view\u003e \u003cview class=\"bg-cyan\" :style=\"[{ width:loading?'25%':''}]\"\u003e25%\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条布局 结合布局、图标等内容，可根据个人所需可以设置不同进度显示的样式 \u003cview class=\"padding bg-white \"\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"cu-progress round\"\u003e \u003cview class=\"bg-green\" :style=\"[{ width:loading?'100%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003ctext class=\"cuIcon-roundcheckfill text-green margin-left-sm\"\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class=\"flex margin-top\"\u003e \u003cview class=\"cu-progress round\"\u003e \u003cview class=\"bg-green\" :style=\"[{ width:loading?'80%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003ctext class=\"margin-left\"\u003e80%\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 进度条相关class class说明可选值cu-progress进度条必选值——radius圆角——round 圆形——sm小尺寸——xs超小尺寸——striped条纹——active 结合striped使用，设置动态条纹效果—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:8","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Border\u0026Shadow边框阴影  默认shadow是根据背景色设置的阴影，shadow-lg为长阴影，但是我肉眼没看出来二者的区别，真是在下愚钝，shadow-warp为翘边阴影（在下愚钝，它翘一点？？？），shadow-blur根据背景图片设置的阴影，有点意思，挺好。关于边框border没什么好展开的，直接看下面表格class说明就好。 \u003cview class=\"padding text-center\"\u003e \u003cview class=\"padding-xl radius shadow bg-white\"\u003e默认阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow bg-gradual-red margin-top\"\u003e根据背景颜色而改变的阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow shadow-lg bg-white margin-top\"\u003e长阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow shadow-lg bg-blue margin-top\"\u003e长阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow-warp bg-white margin-top\"\u003e翘边阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow-blur bg-red margin-top bg-img\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big91005.jpg);\"\u003e \u003cview\u003e根据背景图而改变的阴影\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 边框阴影相关class class说明可选值solid/solids实线四周边框，solid为细边框 ，solids为粗边框——solid/solids-{{options}}不同方向的边框(上下左右)top/right/bottom/leftshadow默认阴影（根据背景色变化）——shadow-lg长阴影——shadow-wrap翘边阴影——shadow-blur根据背景图片变化的阴影  ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:9","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Loading加载 加载必选值cu-load 加载状态 loading正在加载中，over加载完成，erro加载失败 \u003cview class=\"cu-load bg-blue loading\"\u003e\u003c/view\u003e \u003cview class=\"cu-load bg-blue over\"\u003e\u003c/view\u003e \u003cview class=\"cu-load bg-red erro\"\u003e\u003c/view\u003e 弹框加载 设置按钮，弹出弹框，显示加载状态，弹框模板设置load-modal \u003cview class=\"cu-bar bg-white margin-top\"\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-title text-blue\"\u003e\u003c/text\u003e弹框加载 \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn bg-green shadow\" @tap=\"LoadModal\"\u003e 点我 \u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-load load-modal\" v-if=\"loadModal\"\u003e \u003cimage src=\"/static/logo.png\" mode=\"aspectFit\"\u003e\u003c/image\u003e \u003cview class=\"gray-text\"\u003e加载中...\u003c/view\u003e \u003c/view\u003e \u003cscript\u003e export default { data() { return { loadModal: false }; }, methods: { LoadModal(e) { this.loadModal = true; setTimeout(() =\u003e { this.loadModal = false; }, 2000) } } } \u003c/script\u003e 进度条加载 设置进度条加载时需要添加load-progress，变量loadProgress为加载进度条的进度，load-progress-bar代表加载中进度条样式，load-progress-spinner代表加载中旋转的圆圈样式 \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn bg-green shadow\" @tap=\"LoadProgress\"\u003e 点我 \u003c/button\u003e \u003c/view\u003e \u003cview class=\"load-progress\" :class=\"loadProgress!=0?'show':'hide'\" style=\"top:100px\"\u003e \u003cview class=\"load-progress-bar bg-green\" :style=\"[{transform: 'translate3d(-' + (100-loadProgress) + '%, 0px, 0px)'}]\"\u003e\u003c/view\u003e \u003cview class=\"load-progress-spinner text-green\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cscript\u003e export default{ data(){ return{ loadProgress:0 } }, methods:{ LoadProgress(e) { this.loadProgress = this.loadProgress + 3; if (this.loadProgress \u003c 100) { setTimeout(() =\u003e { this.LoadProgress(); }, 100) } else { this.loadProgress = 0; } } } } \u003c/script\u003e 加载相关class class说明可选值cu-load加载必选值（除了进度条加载）——loading加载中——over加载完成——erro加载失败——load-modal弹框加载——load-progress设置进度条加载——load-progress-bar进度条加载样式——load-progress-spinner旋转加载样式——hide隐藏——show显示—— ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:10","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"交互组件 这篇博客太长了，交互组件的介绍就另写一篇吧，ColorUI组件库简易教程之交互组件 这只是个人的理解写的，有什么不足，望大佬指教，及时更正！ ","date":"2021-05-12","objectID":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:4:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/%E5%B0%8F%E7%A8%8B%E5%BA%8Fcolorui%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["Java后端"],"content":"Stanford Nlp是一个比较牛叉的自然语言处理工具，其很多模型都是基于深度学习方法进行训练得到的，准确率比起原来的很多工具有了很大程度的提高。近年来很多开源项目也用到了其中的一些方法。 最近重拾这个工具做点语义分析的工作，但是发现中文资料比较少，入门比较困难，所以整理一下自己的使用方法，希望对有需要的童鞋能够有点帮助。 本文主要是讲如何在Java工程中调用Stanford NLP的API。 ","date":"2021-05-09","objectID":"/stanford-corenlp/:0:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"一、环境准备（导入依赖） ","date":"2021-05-09","objectID":"/stanford-corenlp/:1:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"1、pom原始导入 \u003cproperties\u003e \u003ccorenlp.version\u003e4.0.0\u003c/corenlp.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e${corenlp.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e${corenlp.version}\u003c/version\u003e \u003cclassifier\u003emodels\u003c/classifier\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e${corenlp.version}\u003c/version\u003e \u003cclassifier\u003emodels-chinese\u003c/classifier\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 如果上述方法pom不能导入可以选择第二种方法，把jar包下载到本地，然后本地导入 ","date":"2021-05-09","objectID":"/stanford-corenlp/:1:1","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"2、本地导入 下载地址主要下载两个文件 在resources目录下新建lib包，将一下三个文件导入： pom文件导入本地Jar \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e4.2.1\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/stanford-corenlp-4.2.1.jar\u003c/systemPath\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e4.2.1\u003c/version\u003e \u003cclassifier\u003emodels-chinese\u003c/classifier\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/stanford-corenlp-4.2.1-models-chinese.jar\u003c/systemPath\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.ejml\u003c/groupId\u003e \u003cartifactId\u003eejml\u003c/artifactId\u003e \u003cversion\u003e0.39\u003c/version\u003e \u003c!-- \u003cclassifier\u003emodels\u003c/classifier\u003e--\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/ejml-core-0.39.jar\u003c/systemPath\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e4.2.1\u003c/version\u003e \u003cclassifier\u003emodels\u003c/classifier\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/stanford-corenlp-4.2.1-models.jar\u003c/systemPath\u003e \u003c/dependency\u003e ","date":"2021-05-09","objectID":"/stanford-corenlp/:1:2","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"二、分词 package com.jd.posttimer.Util.SegmentationUtil; import edu.stanford.nlp.ling.CoreAnnotations; import edu.stanford.nlp.ling.CoreLabel; import edu.stanford.nlp.pipeline.Annotation; import edu.stanford.nlp.pipeline.StanfordCoreNLP; import edu.stanford.nlp.util.CoreMap; import edu.stanford.nlp.util.StringUtils; import java.util.ArrayList; import java.util.List; import java.util.Properties; /** * * Created by dd on 2017/6/8. * * 斯坦福NLP 包，中文分词和英文分词 * */ public class Segmentation { public List segInCh(String text) { //载入properties 文件 // StanfordCoreNLP pipline = new StanfordCoreNLP(\"StanfordCoreNLP-chinese.properties\"); //1.2 自定义功能 （1） // Properties properties = new Properties(); // properties.put(\"annotators\", \"tokenize, ssplit, pos, lemma, ner, parse, dcoref\"); // properties.setProperty(\"annotators\", \"tokenize, ssplit, pos, lemma, ner, parse, dcoref\"); // properties.setProperty(\"coref.algorithm\", \"neural\"); // properties.setProperty(\"add-modules \",\"java.se.ee\"); // properties.setProperty(\"ner.useSUTime\", \"false\"); // StanfordCoreNLP pipline = new StanfordCoreNLP(properties); // 自定义功能(2) 自己在项目中建一个properties 文件，然后在文件中设置模型属性，可以参考1中的配置文件 String[] args = new String[]{\"-props\", \"classpath:/properies/StanfordCoreNLP-chinese.properties\"}; Properties properties = StringUtils.argsToProperties(args); StanfordCoreNLP pipline = new StanfordCoreNLP(properties); //自定义功能(3) // StanfordCoreNLP pipline = new StanfordCoreNLP(PropertiesUtils.asProperties( // \"annotators\",\"tokenize,ssplit\", // \"ssplit.isOneSentence\", \"true\", // \"tokenize.language\", \"zh\", // \"segment.model\", \"edu/stanford/nlp/models/segmenter/chinese/ctb.gz\", // \"segment.sighanCorporaDict\", \"edu/stanford/nlp/models/segmenter/chinese\", // \"segment.serDictionary\", \"edu/stanford/nlp/models/segmenter/chinese/dict-chris6.ser.gz\", // \"segment.sighanPostProcessing\", \"true\" // )); //创建一个解析器，传入的是需要解析的文本 Annotation annotation = new Annotation(text); //解析 pipline.annotate(annotation); //根据标点符号，进行句子的切分，每一个句子被转化为一个CoreMap的数据结构，保存了句子的信息() List\u003cCoreMap\u003e sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class); //从CoreMap 中取出CoreLabel List ,打印 System.out.println(\"word\\tpos\\tlemma\\tner\"); List\u003cString\u003e list=new ArrayList(); for (CoreMap sentence : sentences) { for (CoreLabel token : sentence.get(CoreAnnotations.TokensAnnotation.class)) { // \"tokenize, ssplit, pos, lemma, ner, parse, dcoref\", String word = token.get(CoreAnnotations.TextAnnotation.class); // String pos = token.get(CoreAnnotations.PartOfSpeechAnnotation.class); // String ne = token.get(CoreAnnotations.NamedEntityTagAnnotation.class); // String lemma = token.get(CoreAnnotations.LemmaAnnotation.class); // System.out.println(word+\"\\t\"+pos+\"\\t\"+lemma+\"\\t\"+ne); list.add(word); System.out.println(word); } } return list; } } 代码中一共定义了3中配置模型属性的方法，第一种、第三种需要自己写，容易出错，第二种jar包中有默认的配置文件，只需要做部分修改就可以用，但是jar包里的文件只读，所以需要复制出来 2021-05-09 08:31:41.066 INFO 12596 --- [nio-9981-exec-1] e.stanford.nlp.pipeline.StanfordCoreNLP : Adding annotator coref 2021-05-09 08:31:41.107 ERROR 12596 --- [nio-9981-exec-1] e.stanford.nlp.pipeline.CorefAnnotator : Error creating CorefAnnotator...terminating pipeline construction! 2021-05-09 08:31:41.108 ERROR 12596 --- [nio-9981-exec-1] e.stanford.nlp.pipeline.CorefAnnotator : java.lang.RuntimeException: Error initializing coref system edu.stanford.nlp.coref.CorefSystem.\u003cinit\u003e(CorefSystem.java:44) ... Caused by: class edu.stanford.nlp.io.RuntimeIOException: java.io.IOException: Unable to open \"edu/stanford/nlp/models/dcoref/demonyms.txt\" as class path, filename or URL ... 默认配置文件的bug,模型配置了coref（同义词分辨）但是没有找到，想到还有一个modles没有用到，导入进来 pS：该代码的思想是将text字符串交给Stanford CoreNLP处理，StanfordCoreNLP的各个组件（annotator）按“tokenize（分词）, ssplit（断句）, pos（词性标注）, lemma（词元化）, ner（命名实体识别）, parse（语法分析）, dcoref（同义词分辨）”顺序进行处理。 ","date":"2021-05-09","objectID":"/stanford-corenlp/:2:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"1、工具类调用service 工具类为了调用service方法： package com.jd.posttimer.Util; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.BeansException; import org.springframework.beans.factory.DisposableBean; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; @Slf4j public class BeanUtil implements ApplicationContextAware, DisposableBean { private static ApplicationContext applicationContext = null; /** * 从静态变量applicationContext中取得Bean, 自动转型为所赋值对象的类型. */ public static \u003cT\u003e T getBean(Class\u003cT\u003e requiredType) { if(applicationContext==null){ throw new IllegalStateException(\"applicaitonContext属性未注入, 请在SpringBoot启动类中注册BeanUtil.\"); } return applicationContext.getBean(requiredType); } @Override public void destroy() { applicationContext = null; } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { if (BeanUtil.applicationContext != null) { log.warn(\"BeanUtil中的ApplicationContext被覆盖, 原有ApplicationContext为:\" + BeanUtil.applicationContext); } BeanUtil.applicationContext = applicationContext; } } 主类注入 @Bean public BeanUtil beanUtil() { return new BeanUtil(); } 调用 private static LiuMessageService service; private static RedisUtils redisUtils; @Override public void run(){ service= BeanUtil.getBean(LiuMessageService.class); redisUtils=BeanUtil.getBean(RedisUtils.class); getWordCloud(); } ","date":"2021-05-09","objectID":"/stanford-corenlp/:2:1","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"2、调用分词生成词云 词云依赖： \u003cdependency\u003e \u003cgroupId\u003ecom.kennycason\u003c/groupId\u003e \u003cartifactId\u003ekumo-core\u003c/artifactId\u003e \u003cversion\u003e1.13\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.kennycason\u003c/groupId\u003e \u003cartifactId\u003ekumo-tokenizers\u003c/artifactId\u003e \u003cversion\u003e1.12\u003c/version\u003e \u003c/dependency\u003e 生成词云，保存到redis,不等待结果，返回的是上一次的结果 @GetMapping(\"wordscloud\") public String getWordCloud() throws IOException { WordsCloud wordsCloud=new WordsCloud(); wordsCloud.start(); System.out.println(\"wordscloud\"); return redisUtils.get(\"words_cloud\"); } WordsCloud词云类 package com.jd.posttimer.Util.wordscloud; import com.jd.posttimer.Util.BeanUtil; import com.jd.posttimer.Util.Redis.RedisUtils; import com.jd.posttimer.Util.SegmentationUtil.Segmentation; import com.jd.posttimer.entity.LiuMessage; import com.jd.posttimer.service.PostEmailSer.LiuMessageService; import com.kennycason.kumo.CollisionMode; import com.kennycason.kumo.WordCloud; import com.kennycason.kumo.WordFrequency; import com.kennycason.kumo.bg.CircleBackground; import com.kennycason.kumo.font.KumoFont; import com.kennycason.kumo.font.scale.SqrtFontScalar; import com.kennycason.kumo.nlp.FrequencyAnalyzer; import com.kennycason.kumo.nlp.tokenizers.ChineseWordTokenizer; import com.kennycason.kumo.palette.LinearGradientColorPalette; import org.apache.tomcat.util.codec.binary.Base64; import java.awt.*; import java.io.ByteArrayOutputStream; import java.io.OutputStream; import java.util.ArrayList; import java.util.List; import java.util.Random; //@Component public class WordsCloud extends Thread{ // private LiuMessageService liuMessageService; private static LiuMessageService service; private static RedisUtils redisUtils; @Override public void run(){ service= BeanUtil.getBean(LiuMessageService.class); redisUtils=BeanUtil.getBean(RedisUtils.class); getWordCloud(); } public void getWordCloud(){ FrequencyAnalyzer frequencyAnalyzer = new FrequencyAnalyzer(); frequencyAnalyzer.setWordFrequenciesToReturn(600); frequencyAnalyzer.setMinWordLength(2); // 引入中文解析器 frequencyAnalyzer.setWordTokenizer(new ChineseWordTokenizer()); List\u003cLiuMessage\u003e messages = service.findAllByStatus(1); System.out.println(messages.toString()); String words=\"\"; for (LiuMessage liu:messages) { words+=liu.getMessage(); } Segmentation segmentation=new Segmentation(); List\u003cString\u003e list = segmentation.segInCh(words); System.out.println(\"list:\"+list.toString()); //加入分词并随机生成权重，每次生成得图片都不一样,图片基数大可以这么玩 List\u003cWordFrequency\u003e wordFrequencyList=new ArrayList\u003c\u003e(); for ( String liu : list){ wordFrequencyList.add(new WordFrequency(liu,new Random().nextInt(list.size()))); } // 原文链接：https://blog.csdn.net/b644ROfP20z37485O35M/article/details/97583505 // final List\u003cWordFrequency\u003e wordFrequencyList = frequencyAnalyzer.load(words); // 设置图片分辨率 Dimension dimension = new Dimension(500, 500); // 此处的设置采用内置常量即可，生成词云对象 WordCloud wordCloud = new WordCloud(dimension, CollisionMode.PIXEL_PERFECT); java.awt.Font font = new java.awt.Font(\"STSong-Light\", 2, 18); wordCloud.setKumoFont(new KumoFont(font)); wordCloud.setPadding(2); // wordCloud.setColorPalette(new ColorPalette(new Color(237, 25, 65), // new Color(242, 101, 34), new Color(132, 85, 56), // new Color(138, 93, 25),new Color(127, 117, 34), // new Color(92, 122, 41),new Color(29, 149, 63), // new Color(0, 125, 101),new Color(101, 194, 148))); wordCloud.setColorPalette(new LinearGradientColorPalette(Color.RED, Color.BLUE, Color.GREEN, 30, 30)); wordCloud.setBackground(new CircleBackground(200)); wordCloud.setFontScalar(new SqrtFontScalar(10, 40)); wordCloud.setBackgroundColor(new Color(255, 255, 255)); // 生成词云 wordCloud.build(wordFrequencyList); OutputStream output = new ByteArrayOutputStream(); wordCloud.writeToStream(\"png\", output); byte[] outputByte = ((ByteArrayOutputStream)output).toByteArray(); redisUtils.getAndSet(\"words_cloud\", Base64.encodeBase64String(outputByte)); } } 什么是异步调用 对象controller中的方法调用对象\"wordscloud\"的方法，程序并不需要等待对象a的方法返回结果值，直接继续往下走。 为什么不同步？ 由于模型的构建复杂性，生成一个模型并返回结果需要40+秒，如果模型复杂度增加，还会增加响应时间，影响客户端体验。 ","date":"2021-05-09","objectID":"/stanford-corenlp/:2:2","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["Java后端"],"content":"三、前端结果显示 后端传的数据是base64编码后的字符串，怎么显示在前端？ uni.request({ url: config.baseUrl + '/liu/wordscloud', method: 'GET', success: res =\u003e { console.log(typeof(res.data)) this.imageHerf='data:image/jpeg;base64,'+res.data }, fail: (res) =\u003e { console.log(\"词云失败结果\") console.log(res) } }) \u003cview\u003e \u003cvan-image class=\"code text-right\" width=\"100%\" height=\"250px\" fit=\"cover\" mode=\"\" :src=\"imageHerf.replace(/[\\r\\n]/g,'')\" /\u003e \u003c/view\u003e ","date":"2021-05-09","objectID":"/stanford-corenlp/:3:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/stanford-corenlp/"},{"categories":["设计模式"],"content":"模式动机 **蜡笔：**颜色和型号两个不同的变化维度（即两个不同的变化原因）耦合在一起，无论是对颜色进行扩展还是对型号进行扩展都势必会影响另一个维度 **毛笔：**颜色和型号实现了分离，增加新的颜色或者型号对另一方没有任何影响 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:1:0","tags":[],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式 用抽象关联取代了传统的多层继承 将类之间的静态继承关系转换为动态的对象组合关系 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:2:0","tags":[],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:3:0","tags":[],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 模拟毛笔：实例说明 •现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5=15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5=8个类就可以实现15支蜡笔的功能。本实例使用桥接模式来模拟毛笔的使用过程。 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:4:0","tags":[],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码 package com.bridge; public interface Color { public void paint(String penType); } package com.bridge; public class Blue implements Color { @Override public void paint(String penType) { // TODO Auto-generated method stub System.out.println(\"使用\"+penType+\"涂蓝色\"); } } package com.bridge; public abstract class Pen { protected Color color; public void setColor(Color color) { this.color = color; } public abstract void draw(); } package com.bridge; public class SmallPen extends Pen { @Override public void draw() { // TODO Auto-generated method stub System.out.println(\"准备用小号毛笔画画：\"); color.paint(\"小号毛笔\"); } } package com.bridge; import java.io.File; import javax.xml.parsers.*; import org.w3c.dom.*; public class XMLUtil { public static Object getBean(String args) { try { //创建DOM文档对象 DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder builder=dFactory.newDocumentBuilder(); Document doc=builder.parse(new File(\"src/com/bridge/config.xml\")); //获取包含类名的文本节点 NodeList nl=doc.getElementsByTagName(\"className\"); Node classNode=null; //nl.item(0).getFirstChild(); String cName=null; //classNode.getNodeValue(); if(args.equals(\"color\")) { classNode=nl.item(0).getFirstChild(); } else if(args.equals(\"pen\")) { classNode=nl.item(1).getFirstChild(); } cName=classNode.getNodeValue(); //通过类名生成实例对象并返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; } catch(Exception ex) { ex.printStackTrace(); return null; } } } \u003c?xml version=\"1.0\"?\u003e \u003cconfig\u003e \u003cclassName\u003ecom.bridge.Green\u003c/className\u003e \u003cclassName\u003ecom.bridge.BigPen\u003c/className\u003e \u003c/config\u003e package com.bridge; public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Color color=(Color)XMLUtil.getBean(\"color\"); Pen pen=(Pen)XMLUtil.getBean(\"pen\"); pen.setColor(color); pen.draw(); } } ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:4:1","tags":[],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 分离抽象接口及其实现部分 可以取代多层继承方案，极大地减少了子类的个数 提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，不需要修改原有系统，符合开闭原则 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:5:0","tags":[],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就要针对抽象层进行设计与编程 正确识别出系统中两个独立变化的维度并不是一件容易的事情 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:6:0","tags":[],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系 抽象部分和实现部分可以以继承的方式独立扩展而互不影响 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展 不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统 ","date":"2021-05-05","objectID":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:7:0","tags":[],"title":"桥接模式","uri":"/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 在树形目录结构中，包含文件和文件夹两类不同的元素 在文件夹中可以包含文件，还可以继续包含子文件夹 在文件中不能再包含子文件或者子文件夹 文件夹 \u003c–\u003e容器(Container) 文件 \u003c–\u003e叶子(Leaf) 如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象？ à 组合模式 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:1:0","tags":[],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 组合模式(Composite Pattern)：组合多个对象形成树形结构以表示“部分-整体”的结构层次。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。 对象结构型模式 将对象组织到树形结构中，可以用来描述整体与部分的关系 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:2:0","tags":[],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 模式代码实例 package com.composite; public interface Component { //如果是叶子结点，则打印它的名称； //如果是容器结点，则打印它的名称，并利用foreach语句调用每个子结点的operation方法 public void operation(); //添加一个子节点 public void add(Component c); //删除一个子节点 public void remove(Component c); //获取一个子结点 public Component getChild(int i); } package com.composite; public class Leaf implements Component { public String leafname; public Leaf(String leafname) { this.leafname = leafname; } @Override public void operation() { // TODO Auto-generated method stub System.out.println(\"当前结点是叶子结点，叶子名称是 \"+leafname); } @Override public void add(Component c) { // TODO Auto-generated method stub System.out.println(\"叶子结点不能执行add方法\"); } @Override public void remove(Component c) { // TODO Auto-generated method stub System.out.println(\"叶子结点不能执行remove方法\"); } @Override public Component getChild(int i) { // TODO Auto-generated method stub System.out.println(\"叶子结点不能执行getChild方法\"); return null; } } package com.composite; import java.util.ArrayList; public class Composite implements Component { private String compositename; private ArrayList list=new ArrayList(); public Composite(String compositename) { this.compositename = compositename; } @Override public void operation() { // TODO Auto-generated method stub System.out.println(\"当前结点是容器结点，容器名称是 \"+compositename); for(Object child:list) { Component c=(Component)child; c.operation(); } } @Override public void add(Component c) { // TODO Auto-generated method stub list.add(c); System.out.println(\"添加了一个子节点\"); } @Override public void remove(Component c) { // TODO Auto-generated method stub list.remove(c); System.out.println(\"删除了一个子节点\"); } @Override public Component getChild(int i) { // TODO Auto-generated method stub Component c=(Component)list.get(i); return c; } } package com.composite; public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Component root=new Composite(\"C1-1\"); Component C21=new Composite(\"C2-1\"); Component L22=new Leaf(\"L2-2\"); Component C23=new Composite(\"C2-3\"); root.add(C21); root.add(L22); root.add(C23); Component C31=new Composite(\"C3-1\"); Component L32=new Leaf(\"L3-2\"); C21.add(C31); C21.add(L32); Component C33=new Composite(\"C3-3\"); Component C34=new Composite(\"C3-4\"); C23.add(C33); C23.add(C34); Component L41=new Leaf(\"L4-1\"); Component L42=new Leaf(\"L4-2\"); C31.add(L41); C31.add(L42); Component L43=new Leaf(\"L4-3\"); C33.add(L43); Component L44=new Leaf(\"L4-4\"); C34.add(L44); root.operation(); } } ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:3:0","tags":[],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 透明组合模式 抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()，以及getChild()等方法 在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象 缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的 安全组合模式 抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法 对于叶子对象，客户端不可能调用到这些方法 缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:4:0","tags":[],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控制 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码 增加新的容器构件和叶子构件都很方便，符合开闭原则 为树形结构的面向对象实现提供了一种灵活的解决方案 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:5:0","tags":[],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 在增加新构件时很难对容器中的构件类型进行限制 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:6:0","tags":[],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们 在一个使用面向对象语言开发的系统中需要处理一个树形结构 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:7:0","tags":[],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"实例 在水果盘(Plate)中有一些水果，如苹果(Apple)、香蕉(Banana)、梨子(Pear)，当然大水果盘中还可以有小水果盘，现需要对盘中的水果进行遍历（吃），当然如果对一个水果盘执行“吃”方法，实际上就是吃其中的水果。使用组合模式模拟该场景 ","date":"2021-05-05","objectID":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:8:0","tags":[],"title":"组合模式","uri":"/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 通过引入一个新的对象（如小图片和远程代理对象）来实现对真实对象的操作，或者将新的对象作为真实对象的一个替身 引入代理对象来间接访问一个对象 代理模式 ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:1:0","tags":[],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用 对象结构型模式 代理对象可以在客户端和目标对象之间起到中介的作用 通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外的新服务 ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:2:0","tags":[],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 代理模式代码实例 ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:3:0","tags":[],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使(Ambassador) 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果 智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等 ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:4:0","tags":[],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性 远程代理：可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率 虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销 缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间 保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限 ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:5:0","tags":[],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢（例如保护代理） 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂（例如远程代理） ","date":"2021-05-05","objectID":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:6:0","tags":[],"title":"代理模式","uri":"/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["前端"],"content":"count-code-line ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:0:0","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"特性 支持计算代码行数和代码字符数 丰富的配置文件，支持匹配任意规则的文件或文件夹 支持生成计算结果的json 支持全局安装命令行使用 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:1:0","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"安装 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:2:0","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"1.1 全局安装 npm i count-code-line -g ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:2:1","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"1.2 本地安装 npm i count-code-line -D 1.2 本地安装 npm i count-code-line -D 1 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:2:2","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"使用 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:0","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"2.1 全局安装使用 在任意项目内打开命令行工具，运行一下命令即可 count-code-line 运行成功会在根目录下输出 count.output.json 文件 运行成功会在根目录下输出 count.output.json 文件 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:1","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"2.2 本地安装使用 在 package.json 文件中 的scripts属性中加入如下配置 ... \"scripts\": { ... \"count\": \"count-code-line\" }, ... 然后在根目录下运行 npm run count 运行成功会在根目录下输出 count.output.json 文件 运行成功会在根目录下输出 count.output.json 文件 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:2","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"2.3 nodejs 引用 const count = require('count-code-line'); count(); ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:3","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"配置文件 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:0","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"3.1 默认配置文件及配置项 count-code-line 支持自定义配置文件，以下是默认配置 module.exports = { includes: [], // 需要包含的目录及文件 默认全部包含 excludes: [], // 需要排除的目录及文件 默认全部移除 defaultExcludes: [ // 默认排除的目录及文件 '.git', '.vscode', 'node_modules', 'package.json', 'package-lock.json', 'yarn-lock.json', 'count.output.json', ], defaultExcludesFileType: [ // 默认排除的文件类型 '.zip', '.rar', '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.mp3', '.wma', '.wav', '.mp4', '.flv', '.mov', '.avi', '.wmv', '.rmvb ', '.ogg', '.avi', '.ppt', '.pptx', '.doc','.docx','.xls','.xlsx','.psd','.ttf','.fon','.exe','.msi', ], output: 'count.output.json', // 默认的输出结果文件 outputTrace: '', // 配置输出 trace 结果的文件，默认不输出 encodings: [ // 支持的文件编码，对于不支持的文件将忽略 'ascii', 'utf8', 'utf-8', 'unicode' ] }; ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:1","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"3.2 自定义配置文件 在项目根目录下新建 count.config.js 文件 写入上述配置覆盖默认配置即可 3.2 自定义配置文件 在项目根目录下新建 count.config.js 文件 写入上述配置覆盖默认配置即可 对于为空的配置项，将使用默认配置 ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:2","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"3.3 目录匹配规则 includes excludes 等配置项均支持模糊匹配，匹配规则如下 ‘a’ 将匹配 根目录下 a 文件夹内的所有文件及文件夹；正则： new RegExp(^/a/.*) ‘a/a.js’ 仅匹配指定文件 ‘a/’ 仅匹配 a 文件夹内的所有子文件； 正则： new RegExp(^/a/([^/])$) ‘a/**/.js’ 匹配 a 文件夹内的所有以 .js 为后缀的文件； 正则： new RegExp(^/a/([^/]).js$) ‘a/.js’ 仅匹配 a 文件夹内的所有以 .js 为后缀的子文件； 正则： new RegExp(^/a/([^/]).js$) ","date":"2021-05-04","objectID":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:3","tags":[],"title":"统计代码行","uri":"/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["设计模式"],"content":"模式动机 如何确保一个类只有一个实例并且这个实例易于被访问？ 让类自身负责创建和保存它的唯一实例，并保证不能创建其他实例，并且提供一个访问该实例的方法 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个： 某个类只能有一个实例 必须自行创建这个实例 必须自行向整个系统提供这个实例 单例模式是一种对象创建型模式 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 单例模式的实现 私有构造函数 静态私有成员变量（自身类型） 静态公有的工厂方法 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"饿汉式单例类(Eager Singleton) 代码实现： public class EagerSingleton { private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton(){ } public static EagerSingleton getInstance() { return instance; } } ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:1","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"懒汉式单例类 延时加载： public class LazySingleton { private static LazySingletom instance = null; private IazySingleton( i} public static LazySingleton getInstanceO { if (instance == null){ instance = new LazMSingleton(); } return instance; } } 多个线程同时访问将导致创建多个单例对象!怎么办? instance = new LazMSingleton(); 需要较长时间 synchronized锁方法： public class LazySingleton { private static LazySingletom instance = null; private IazySingleton( i} synchronized public static LazySingleton getInstanceO { if (instance == null){ instance = new LazMSingleton(); } return instance; } } synchronized锁代码段 if (instance == null){ synchronized(LazMSingleton.class){ instance = new LazMSingleton(); } } return instance; ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:2","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Double-Check Locking双重检查锁定 public class LazySingleton { private volatile static LazySingletom instance = null; private IazySingleton( i} public static LazySingleton getInstanceO { //第一重判断 if (instance == null){ //锁定代码块 synchronized(LazMSingleton.class){ //第二重判断 if(instance == null){ instance = new LazMSingleton(); } } } return instance; } } ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:3","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"饿汉式单例类与懒汉式单例类的比较 饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长 懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响 //Initialization on Demand Holder public class Singleton { private Singleton() { } //静态内部类 private static class HolderClass { private final static Singleton instance = new Singleton(); } public static Singleton getInstance() { return HolderClass.instance; } public static void main(String args[]) { Singleton s1, s2; s1 = Singleton.getInstance(); s2 = Singleton.getInstance(); System.out.println(s1 == s2); } } 控制台输出true ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式实例 在操作系统中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。 自定义异常类 public class PrintSpoolerException extends Exception { public PrintSpoolerException(String message){ super(message); } } 单例类 public class PrintSpoolerSingleton { private static PrintSpoolerSingleton instance=null; private PrintSpoolerSingleton(){} public static PrintSpoolerSingleton getInstance() throws PrintSpoolerException { if(instance==null){ System.out.println(\"创建打印池\"); instance=new PrintSpoolerSingleton(); } else{ throw new PrintSpoolerException(\"打印池正在工作中\"); } return instance; } public void manageJobs(){ System.out.println(\"管理打印任务\"); } } 客户端类： public class Client { public static void main(String args[]){ PrintSpoolerSingleton ps1,ps2; try{ ps1=PrintSpoolerSingleton.getInstance(); ps1.manageJobs(); }catch (PrintSpoolerException e){ System.out.println(e.getMessage()); } System.out.println(\"----------------\"); try{ ps2=PrintSpoolerSingleton.getInstance(); ps2.manageJobs(); }catch (PrintSpoolerException e){ System.out.println(e.getMessage()); } } } 结果： 创建打印池 管理打印任务 ---------------- 打印池正在工作中 Process finished with exit code 0 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:6:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 提供了对唯一实例的受控访问 可以节约系统资源，提高系统的性能 允许可变数目的实例（多例类） ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:7:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 扩展困难（缺少抽象层） 单例类的职责过重 由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:8:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例 ","date":"2021-05-02","objectID":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:9:0","tags":["单例模式"],"title":"单例模式","uri":"/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 复制一个对象，从而克隆出多个与原型对象一模一样的对象——原型模式 有些对象的创建过程较为复杂，而且需要频繁创建 通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 原型模式(Prototype Pattern)：原型模式是一种对象创建型模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。 原型模式允许通过一个原型对象创建一个或多个同类型的其他对象，而无须知道任何创建的细节 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份 在Java中可以直接使用Object提供的clone()方法来实现对象的克隆（浅克隆） 能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制 如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常 浅克隆(Shallow Clone)：当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制 深克隆(Deep Clone)：除了对象本身被复制外，对象所包含的所有成员变量也将被复制 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率 扩展性较好 简化创建结构，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品 可以使用深克隆的方式保存对象的状态，以便在需要的时候使用，可辅助实现撤销操作 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 创建新对象成本较大，新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改 系统要保存对象的状态，而对象的状态变化很小 需要避免使用分层次的工厂类来创建分层次的对象 ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:6:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用实例 1.在某OA系统中，用户可以创建工作周报，由于某些岗位每周工作存在重复性，因此可以通过复制原有工作周报并进行局部修改来快速新建工作周报。现使用原型模式来实现该功能，绘制类图并编程实现。周报内容包括姓名、日期、内容。 代码： //工作周报：具体原型类 class WeekLog implements Cloneable{ private String name; private String date; private String content; /* Getter and Setter */ public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDate() { return date; } public void setDate(String date) { this.date = date; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } //克隆方法clone,此处使用Java语言提供的浅克隆机制 public Object clone(){ Object obj = null; try { obj = super.clone(); return obj; }catch (CloneNotSupportedException e){ System.out.println(\"不能复制\"); return null; } } } client: class Client{ public static void main(String[] args) { WeekLog log_previous = new WeekLog(); log_previous.setName(\"张三\"); log_previous.setDate(\"2021年第13周\"); log_previous.setContent(\"这周工作很忙，每天加班！\"); System.out.println(\"****周报****\"); System.out.println(log_previous.getDate()); System.out.println(log_previous.getName()); System.out.println(log_previous.getContent()); System.out.println(\"-----------------------------\"); WeekLog log_now; log_now = (WeekLog) log_previous.clone(); log_now.setDate(\"2021年第14周\"); log_now.setContent(\"清闲的一周！\"); System.out.println(\"****周报****\"); System.out.println(log_now.getDate()); System.out.println(log_now.getName()); System.out.println(log_now.getContent()); } } 结果： ","date":"2021-04-30","objectID":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:7:0","tags":["原型模式"],"title":"原型模式","uri":"/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 现实生活： 不兼容：生活用电220V ßà 笔记电脑20V 引入 AC Adapter（交流电适配器） 软件开发： 存在不兼容的结构，例如方法名不一致 引入适配器模式 ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。 适配器模式既可以作为类结构型模式，也可以作为对象结构型模式 定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合 类适配模式 对象适配模式： ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 典型的类适配器示例代码： public class Adapter extends Adaptee implements Target {public void request() { super.specificRequest(); } 典型的对象适配器示例代码 public class Adapter extends Target { private Adaptee adaptee;//维持一个对适配者对象的引用 public Adapter(Adaptee adaptee){ this.adaptee=adaptee; } public void request() { adaptee.specificRequest();//转发调用 } } ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构 增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用 灵活性和扩展性非常好 类适配器模式：置换一些适配者的方法很方便 对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类 ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:4:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 类适配器模式： (1) 一次最多只能适配一个适配者类，不能同时适配多个适配者 ​ (2) 适配者类不能为最终类 ​ (3) 目标抽象类只能为接口，不能为类 对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦 ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:5:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码 创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作 ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:6:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用实例 4-2.现有一个接口DataOperation定义了排序方法sort(int[])和查找方法search(int[],int)，已知类QuickSort的quickSort(int[])方法实现了快速排序算法，类BinarySearch的binarySearch(int[],int)方法实现了二分查找算法。现使用适配器模式设计一个系统，在不修改源代码的情况下，将QuickSort和类BinarySearch的方法适配到接口DataOperation中，绘制类图并实现。 代码： public interface DataOperation { public void sort(int data[]);//排序方法 public void search(int[] list,int key);//查找方法 } public class QuickSort { //快速排序 public void quickSort(int data[]) { java.util.Arrays.sort(data); //直接调用排序方法 print(data); } //数组输出 public void print(int data[]) { for(int x=0;x\u003cdata.length;x++) { System.out.print(data[x]+\"、\"); } } } public class BinarySearch { // 二分查找 public void binarySearch(int[] list,int key) { // 调用java.util.Arrays的binarySearch二分查找方法 System.out.print(java.util.Arrays.binarySearch(list, key)); } } public class DataAdapter implements DataOperation { private QuickSort quicksort; // 定义适配者QuickSort的对象 private BinarySearch binarysearch; // 定义适配者 BinarySearch的对象 // 构造函数初始化适配者对象 public DataAdapter() { quicksort = new QuickSort(); // 实例化QuickSort对象 binarysearch = new BinarySearch(); // 实例化 BinarySearch对象 } @Override public void sort(int data[]) { // 建立连接实现快速排序 quicksort.quickSort(data);// 通过对象调用实现快速排序的功能 } @Override public void search(int[] list, int key) { // 建立连接实现二分查找 binarysearch.binarySearch(list, key);// 通过对象调用实现二分查找的功能 } } public class Client { public static void main(String[] args) { // TODO 自动生成的方法存根 //定义一个数组 int data[]=new int[] {2,4,1,5,3,8,6,7}; DataOperation operation; //定义接口对象 operation=new DataAdapter(); // 实例化接口对象向上转型 System.out.println(\"排序前的数组：\"); for(int i=0;i\u003cdata.length;i++) { System.out.print(data[i]+\"、\"); } System.out.println(\"\\n\\n排序后的数组\"); operation.sort(data);//调用排序 //查找数据4所在的下表 System.out.println(\"\\n\\n输出数字4所在的索引:\"); operation.search(data,4);//调用查找 } } 结果： ","date":"2021-04-30","objectID":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:7:0","tags":["适配器模式"],"title":"适配器模式","uri":"/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["hugo"],"content":"域名解析设置 注册购买后，进入控制台-域名-域名列表-解析，增加一下三条记录： 记录类型选A 记录值就是ip地址，github提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，你还可以ping 部署在github上的地址。主机记录设置为@，线路就默认就行了。 记录类型选CNAME 记录值就是你的github博客地址。主机记录设置为www，线路就默认就行了。 ","date":"2021-04-28","objectID":"/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/:1:0","tags":[],"title":"域名绑定","uri":"/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"categories":["hugo"],"content":"Github Pages绑定域名 在仓库根目录下新建CNAME文件， 此时pages setting界面会自动绑定域名 之后就可以正常访问了： ","date":"2021-04-28","objectID":"/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/:2:0","tags":[],"title":"域名绑定","uri":"/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"categories":["红客"],"content":"下载站点 工具：Fiddler 1、打开Fiddler工具，开启Https代理： 2、登录账户，会有50个币，点击页面下载发现Fiddler中并没有拿到下载接口，所以用50币先下载一个能够下载的，先拿到接口： 只能拿到相对路由，手动下载，拿到接口： 接口： https://kuangstudy.oss-cn-beijing.aliyuncs.com/download/note/JavaScript_hvtser8u0.rar?Expires=1618756583\u0026OSSAccessKeyId=LTAI4G9FmSQ5cVvkR2ZVjSYi\u0026Signature=LuaKA5VVvNrPAYERGfvrwC7%2BeXQ%3D 只用把其中的下载路径换一下就OK了 ","date":"2021-04-18","objectID":"/kuangdownload/:0:0","tags":[],"title":"KuangDownload","uri":"/kuangdownload/"},{"categories":["数据库"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 1、初识MySQL JavaEE：企业级Java开发 Web 前端（页面：展示：数据） 后台 （连接点：连接数据库JDBC,连接前端（控制视图跳转，给前端传递数据）） 数据库（存数据，Txt,Excel,Word） 只会写代码，学好数据库，基本混饭吃： 操作系统，数据结构与算法！当一个不错的程序猿！ 离散数学，数字电路，体系结构，编译原理。+实战经验，优秀程序猿 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"1.1为什么学数据库 1、岗位需求 2、现在的世界，大数据时代，得数据者得天下 3、被迫需求：存数据 4、数据库是所有软件体系中最核心的存在 DBA ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"1.2 什么是数据库 数据库：(DB,DataBase) 概念:数据仓库，软件，安装在操作系统之（windows,Linux。mac）上的！SQL,可以存储大量的数据，500万! 作用:存储数据，管理数据 Excel ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"1.3 数据库分类 关系型数据库：(SQL) MySQL, Oracle, sql Server, DB2, SQLite 通过表和表之间，行和列之间的关系进行数据的存储 非关系型数据库：(NoSQL) Not Only SQL Redis, MongDB 非关系型数据库，对象存储，通过对象自身的属性来决定。 **DBMS(数据库管理系统) ** 数据库的管理软件，科学有效的管理我们的数据，维护和获取 MySQL ，数据管理系统！ ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"1.4 MySQL简介 MySQL是一个**关系型数据库管理系统** 前世： 瑞典MySQL AB 公司 今身： 属于 Oracle 旗下产品 MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 开源的数据库软件 体积小，速度快，总体拥有成本低，招人成本比较低。 中小型网站，或者大型网站，集群 官网： https://www.mysql.com/ ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"1.5连接数据库 命令行连接！ `mysql -u root -p123456 --连接数据库 update mysql.user set authentication_string=password('123456') where user='root' and Host='localhost'; --修改密码 flush privileges;--刷新权限 -------------------------------------------------- --所有语句使用;结尾-- show databases;--查看所有的数据库 mysql\u003e use school--切换数据库， use 数据库名 Database changed -- show tables;--查看数据库中所有的表 describe student;--显示数据库中所有的表的信息 create database westos;--创建一个数据库 exit;--退出连接 --单行注释（sql本来注释） /* 多行注释 */` 2、操作数据库 操作数据库》操作数据库中的表》操作数据库中表的数据 MySQL不区分大小写 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.1操作数据库 1.创建数据库 `CREATE DATABASE IF NOT EXISTS westos;` 2.删除数据库 `DROP DATABASE IF EXISTS westos` 3.使用数据库 `-- ``,如果你的表名或者字段名是一个特殊字符，需要带`` USE 'school'` 4.产看数据库 `SHOW DATABASES--查看所有数据库` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.2数据库的列类型 数值 tinyint 十分小的数据 1个字节 smallint 较小的数据 2个字节 mediumint 中等大小 3个字节 int 标准的整数 4个字节（常用） bigint 较大的数据 8个字节 float 浮点数 4个字节 double 浮点数 8个字节 （精度问题） decimal 字符串形式的浮点数,金融计算的时候，一般用 字符串 char 字符串固定大小 0-255 varchar 可变字符串 0-65535（常用） tinytext 微型文本 2^8-1 text 文本串 2^16-1 (保存大文本) 时间日期 java.util.Date date YYYY-MM-DD，日期 time HH:mm:ss 时间格式 datetime YYYY-MM-DD HH:mm:ss 最常用的时间格式 timestamp 时间戳 1970.1.1到现在的毫秒数 year 年份表示 null 没有值，未知 注意，不要使用null进行运算，结果为null ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.3数据库的字段类型（重点） unsigened: 无符号的整数 声明该列不能声明负数 zerofill: 0填充的 10的长度 1 – 0000000001 不足位数用0 填充 自增： 通常理解为自增，自动在上一条记录的基础上+1 通常用来设计唯一的主键 index,必须是整数类似 可以自定义设置主键自增的起始值和步长 非空 NULL not Null 假设设置为 not null，如何不给他赋值，就会报错 NULL 如果不填写，默认为NULL 默认： 设置默认的值！ ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.4 创建数据库表 ``--目标:创建一个schoo1数据库 --创建学生表(列,字段)使用SQL 创建 --学号int 登录密码varchar(20)姓名,性别varchar(2),出生日期(datatime)，家庭住址，emai1--注意点，使用英文()，表的名称和字段尽量使用括起来 -- AUTO_ INCREMENT 自增 --字符串使用单引号括起来! --所有的语句后面加，(英文的)，最后一个不用加 -- PRIMARY KEY 主键，一般- 一个表只有一个唯一 -的主键! CREATE DATABASE school CREATE TABLE IF NOT EXISTS `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` VARCHAR(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别', `birthday` DATETIME DEFAULT NULL COMMENT '出生日期', `address` VARCHAR(100) DEFAULT NULL COMMENT '家庭住址', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8`` 格式 ``CREATE TABLE [IF NOT EXISTS] `表名`（ `字段名` 列类型[属性][索引][注释], `字段名` 列类型[属性][索引][注释], ... `字段名` 列类型[属性][索引][注释] ）[表类型][表的字符集设置][注释]`` 常用命令 `SHOW CREATE DATABASE school -- 查看创建数据库的语句 SHOW CREATE TABLE student -- 查看student数据表的定义语句 DESC student -- 显示表的结构` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.5数据表的类型 `-- 关于数据库引擎 /* INNODB 默认使用 MYISAM 早些年使用 */` MYISAMINNODB事务支持不支持支持数据行锁定不支持支持外键约束不支持支持全文索引支持不支持表空间的大小较小较大，约为MYISAM的两倍 常规使用操作： MYISAM 节约空间，速度较快， INNODB 安全性高，事务处理，多表多用户操作 在物理空间存在的位置 所有的数据库文件都存在data目录下，一个文件夹就对应一个数据库 本质还是文件的存储 MySQL 引擎在物理文件上的区别 innoDB 在数据库表中，只有一个*.frm文件，以及上级目录下的ibdata1文件 MYISAM 对应的文件 *.frm - 表结构的定义文件 *. MYD -数据文件 *.MYI 索引文件 设置数据库字符集编码 `CHARTSET=UTF8` 不设置的话，会是mysql默认的字符集编码-（不支持中文） 可以在my.ini中配置默认的编码 `character-set-server=utf8` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"2.6修改删除表 修改 `-- 修改表名 ALTER TABLE 旧表面 AS 新表名 ALTER TABLE student RENAME AS student1 -- 增加表的字段 ALTER TABLE 表名 ADD 字段名 列属性 ALTER TABLE student1 ADD age INT(11) -- 修改表的字段（重命名，修改约束） ALTER TABLE student1 MODIFY age VARCHAR(11) -- 修改约束 ALTER TABLE student1 CHANGE age age1 INT(1) -- 字段重命名 -- 删除表的字段 ALTER TABLE student1 DROP age1` 删除 `-- 删除表 DROP TABLE IF EXISTS student1` 所有的创建和删除操作尽量加上判断，以免报错 注意点： `` 字段名，使用这个包裹 注释 – /**/ sql 关键字大小写不敏感，建议写小写 所有的符号全部用英文 3、MySQL数据管理 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"3.1外键（了解） 方式一：在创建表的时候，增加约束（麻烦，比较复杂） ``CREATE TABLE `grade`( `gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT '年级id', `gradename` VARCHAR(50) NOT NULL COMMENT '年级名称', PRIMARY KEY (`gradeid`) )ENGINE=INNODB DEFAULT CHARSET=utf8 -- 学生表的 gradeid 字段 要去引用年级表的gradeid -- 定义外键KEY -- 给这个外键添加约束（执行引用） references 引用 CREATE TABLE IF NOT EXISTS `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` VARCHAR(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别', `birthday` DATETIME DEFAULT NULL COMMENT '出生日期', `gradeid` INT(10) NOT NULL COMMENT '学生年级', `address` VARCHAR(100) DEFAULT NULL COMMENT '家庭住址', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (`id`), KEY `FK_gardeid` (`gradeid`), CONSTRAINT `FK_gardeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (gradeid) )ENGINE=INNODB DEFAULT CHARSET=utf8`` 删除有外键关系的表的时候，必须先删除引用的表（从表），再删除被引用的表（主表） 方式二： 创建表成功后添加外键 ``CREATE TABLE `grade`( `gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT '年级id', `gradename` VARCHAR(50) NOT NULL COMMENT '年级名称', PRIMARY KEY (`gradeid`) )ENGINE=INNODB DEFAULT CHARSET=utf8 -- 学生表的 gradeid 字段 要去引用年级表的gradeid -- 定义外键KEY -- 给这个外键添加约束（执行引用） references 引用 CREATE TABLE IF NOT EXISTS `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` VARCHAR(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别', `birthday` DATETIME DEFAULT NULL COMMENT '出生日期', `gradeid` INT(10) NOT NULL COMMENT '学生年级', `address` VARCHAR(100) DEFAULT NULL COMMENT '家庭住址', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8 -- 创建表的时候没有外键关系 ALTER TABLE `student` ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade`(`gradeid`); -- ALTER TABLE`表` ADD CONSTRAINT 约束名 FOREIGN KEY（作为外键的列） 引用到哪个表的哪个字段`` 以上的操作都是物理外键，数据库级别外键，不建议使用。（避免数据库过多造成困扰） 最佳实践 数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段） 我们想使用多张表的数据，想使用外键（程序去实现） ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"3.2 DML语言（全记住） 数据库意义：数据存储，数据管理 DML语言：数据操作语言 Insert update delete ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"3.3添加 insert ``-- 插入语句（添加） -- nsert into 表名（[字段一], [字段二]）values('值1'),('值2') INSERT INTO `grade` (`gradename`) VALUES('大四') -- 由于主键自增我们可以省略（如何不写表的字段，他会一一匹配） INSERT INTO `grade` VALUES('大三') INSERT INTO `grade` (`gradeid`,`gradename`) VALUES ('大三','null') -- 一般写插入语句，我们一定要数据和字段一一对应。 -- 插入多个字段 INSERT INTO `grade`(`gradename`) VALUES ('大二'),('大一'); INSERT INTO `student`(`name`) VALUES ('张三') INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES ('张三','aaaaa','男') INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES ('李四','aaaaa','男'),('王五','23232','女')`` 语法：– insert into 表名（[字段一], [字段二]）values(‘值1’),(‘值2’) 注意事项： 1.字段和字段之间用逗号分开 2.字段可以省略，但是后面的值必须一一对应 3.可以同时插入多条数据，VALUES后面的值需要使用，隔开即可 ``INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES ('李四','aaaaa','男'),('王五','23232','女')`` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:14:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"3.4 修改 update 修改谁（条件） set 原来的值=新值 ``-- 修改学员名字 UPDATE `student` SET `name`='囷' WHERE id =1; -- 不指定条件的情况下，会改动所有表 UPDATE `student` SET `name`='233' -- 语法； -- UPDATE 表名 set column_name,[] = value where 条件`` 条件：where 子句 运算符 id 等于 某个值，大于某个值，在某个区间内修改 操作符返回布尔值 操作符含义范围结果=等于5=6false!= \u003c\u003e不等于5！=6true\u003e大于\u003c小于\u003e=\u003c=between and在某个范围内，闭合区间and\u0026\u00265\u003e1and1\u003e2falseor||5\u003e1or1\u003e2true 注意： column_name 是数据库的列，带上`` 条件，是筛选的条件，如果没有指定，则会修改所有的列 value 是一个具体的值，也可以是一个变量 多个设置的属性之间，使用英文逗号隔开 ``UPDATE `student` SET `birthday`=CURRENT_TIME where `name`='李四' AND SEX = '男'`` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:15:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"3.5 删除 delete 命令 语法 delete from 表名 [where 条件] ``-- 删除数据 (避免这样写) DELETE FROM `student` -- 删除指定 DELETE FROM `student` where id= 1`` TRUNCATE 命令 作用：完全清空一个数据库，表的结构和索引不会变 delete 和 TRUNCATE 区别 相同点： 都能删除数据，都不会删除表结构 不同： TRUNCATE 重新设置自增列 计数器会归零 TRUNCATE 不会影响事务 ``-- 测试delete 和 truncate 区别 CREATE TABLE `test`( `id` INT(4) NOT NULL AUTO_INCREMENT, `coll` VARCHAR(20) NOT NULL, PRIMARY KEY (`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `test`(`coll`) VALUES('1'),('2'),('3') DELETE FROM `test` -- 不会影响自增 TRUNCATE TABLE `test` -- 自增会归零`` 了解即可：delete删除的问题 重启数据库，现象 innoDB 自增列会从1开始（存在内存当中，断电即失） MyISAM 继续从上一个自增量开始（存在文件中，不会丢失） 4、DQL查询数据（最重点） ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:16:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.1DQL (Data Query Language) :数据查询语言 所有的查询操作都用它 Select 简单的查询，复杂的查询它都能做 数据库中最核心的语言 使用频率最高的语言 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:17:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.2指定查询字段 ``-- 查询 SELECT 字段 FROM 表 -- 查询指定字段 such as SELECT `StudentNo`,`StudentName` FROM student -- 别名，给结果起一个名字 AS 可以给字段起别名 也可以给表起别名 SELECT `StudentNo` AS 学号,`StudentName`AS 学生姓名 FROM student AS S -- 函数 Concat(a,b) SELECT CONCAT('姓名：',StudentName) AS 新名字 FROM student`` 语法： SELECT 字段 ... FROM 表 有时候，列名字不是那么见名知意。我们起别名 AS 字段名 AS 别名 表名 AS 别名 去重 作用：去除select语句查询出来的结果中重复的语句，重复的语句只显示一条 ``-- 查询一下有哪些同学参加了考试，成绩 SELECT * FROM result -- 查询全部的考试成绩 -- 查询有哪些同学参加了考试 SELECT `studentNo` FROM result -- 发现重复数据，去重 SELECT DISTINCT `studentNo` FROM result`` 数据库的列（表达式） ``SELECT VERSION() --查询系统版本（函数） SELECT 100*3-1 AS 计算结果 -- 用来计算（表达式） SELECT @@auto_increment_increment --查询自增的步长（变量） -- 学员考试成绩+1 分 查看 SELECT `StudentNo`,`StudentResult`+1 AS '提分后' FROM result`` 数据库中的表达式： 文本值，列，Null , 函数，计算表达式，系统变量… select 表达式 from 表 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:18:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.3where 条件子句 作用：检索数据中符合条件的值 逻辑运算符 运算符语法结果and \u0026\u0026a and b a\u0026\u0026b逻辑与or ||a or b a||b逻辑或Not !=not a !a逻辑非 尽量使用英文 ``-- 查询考试成绩在95分到100分之间 SELECT `StduentNo`,`StudentResult` FROM result WHERE StudentResult \u003e=95 AND StudentResult\u003c=100 -- 模糊查询（区间） SELECT `StduentNo`,`StudentResult` FROM result WHERE StudentResult BETWEEN 95 AND 100 -- 除了1000号学生之外的同学成绩 SELECT `StduentNo`,`StudentResult` FROM result WHERE NOT StudentNo = 1000`` 模糊查询：比较运算符 运算符语法描述I S NULLa is null如果操作符为null 结果为真IS NOT NULLa is not null如果操作符为not null 结果为真BETWEENa between b and c若a在b 和c之间则为真LIKEa like bSQL匹配，如果a 匹配到b 则为真INa in (a1,a2,a3…)假设a 在 a1,a2,a3其中的某一个中，为真 ``-- 查询姓刘的同学 -- like结合 %（代表0到任意字符） _(一个字符) SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentName LIKE '刘%'; -- 查询姓刘的同学，名字后只有一个字 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentName LIKE '刘_'; -- 查询姓刘的同学，名字后只有两个字 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentName LIKE '刘__'; -- 查询名字中间有嘉字的同学 %嘉% SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentName LIKE '%嘉%'; ===================IN(具体的一个或者多个值)=========================== -- 查询1001 1002 1003 学员信息 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentNo = 1001 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentNo = 1002 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentNo = 1003 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentNo IN (1001,1002,1003); -- 查询在北京的学生 SELECT `StudentNo`,`StudentName` FROM `student` WHERE `Address` IN('安徽','河南洛阳'); ===================NULL NOT NULL=================================== -- 查询地址为空的学生 null '' SELECT `StudentNo`,`StudentName` FROM `student` WHERE address=''OR address IS NULL -- 查询有出生日期的同学 不为空 SELECT `StudentNo`,`StudentName` FROM `student` WHERE `BornDate` IS NOT NULL;`` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:19:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.4 联表查询 JOIN 对比 `======================联表查询 join ============================== -- 查询参加考试的同学 （学号，姓名，考试编号，分数） SELECT * FROM student SELECT * FROM result /* 1. 分析需求，分析查询的字段来自哪些表 2.确定使用哪种连接查询？7种 确定交叉点（这两个表中哪个数据是相同的） 判断的条件： 学生表中 studentNo = 成绩表中 studentNo */ -- JION（表） ON （判断的条件）连接查询 -- where 等值查询 SELECT studentNo,studentName,SubjectNo,StudentResult FROM student AS s INNER JOIN result AS r WHERE s.studentNo=r.studentNo --Right Join SELECT s.studentNo,studentName,SubjectNo,StudentResult FROM student AS s RIGHT JOIN result AS r ON s.studentNo = r.studentNo --LEFT Join SELECT s.studentNo,studentName,SubjectNo,StudentResult FROM student AS s LEFT JOIN result AS r ON s.studentNo = r.studentNo` 操作描述Inner join如果表中至少有一个匹配，就返回行left join即使左表中没有匹配，也会从左表中返回所有的值right jion即使右表中没有匹配，也会从右表中返回所有的值 ``-- 查询考的同学 SELECT s.studentNo,studentName,SubjectNo,StudentResult FROM student AS s LEFT JOIN result AS r ON s.studentNo = r.studentNo WHERE StudentResult IS NULL -- 查询了参加考试同学的信息：学号：学生姓名：科目名：分数 SELECT s.`studentNo`,`studentName`,`SubjectName`,`studentResult` FROM student s RIGHT JOIN result r ON r.studentNo=s.studentNo INNER JOIN `subject` sub ON r.SubjectNo=sub.SubjectNo -- 我要查询哪些数据 SELECT .... -- 从哪几个表中查 FROM 表 xxx JOIN 连接的表 ON 交叉条件 -- 假设存在一中多张表查询，先查询两章表，然后再慢慢增加 --FROM a LEFT JOIN b 左为准 --FROM a RIGHT JOIN b 右为准`` 自连接 自己的表跟自己的表连接，核心：一张表拆为两张一样的表 父类 categoryidcategoryName2信息技术3软件开发5美术设计 子类 pidcategoryidcategoryName34数据库28办公信息36web开发57ps技术 操作：查询父类对应子类关系 父类子类信息技术办公信息软件开发数据库软件开发web开发美术设计ps技术 ``-- 查询父子信息 SELECT a.`categroryName` AS `父栏目`,b.`categroryName` AS `子栏目` FROM `catgroy` AS a,`catgroy` AS b WHERE a.`categoryid`=b.`pid` `` ``-- 查询学员所属的年级（学号，学生的姓名，年级） SELECT studentNo,studentName,gradeName FROM student s INNER JOIN `grade` g ON s.`GradeId`=g.`GradeId` `` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:20:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.5分页和排序 `============================分页 limit 和排序order by================= -- 排序： 升序ASC 降序 DESC SELECT xx FROM xx JOIN xx WHERE xx ORDER BY xx ASC || DESC` 分页 ``-- 为什么要分页 -- 缓解数据库压力，给人的体验更好 -- 分页，每页显示五条数据 -- 语法： limit 当前页，页面的大小 -- limit 0,5 1-5 -- limit 1,5 1-5 -- limit 6,5 SELECT s.`StudentNo`,`StudentName`,`SubjectName`,`StudentResult` FROM student s INNER JOIN `result` r ON s.`StudentNo`=r.`StudentNo` INNER JOIN `subject` sub ON r.`subjectNo`=sub.`subjectNo` WHERE subjectName='数据结构-1' ORDER BY StudentResult ASC LIMIT 0,5 -- 第一页 limit 0,5 -- 第二页 limit 5,5 -- 第三页 limit 10,5 -- 第N页 limit 5*（n-1）,5`` 语法 limit(查询起始下标，pagesize) ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:21:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.6 子查询 where (这个值是计算出来的) 本质：在where语句中嵌套一个子查询语句 ``-- ===========================where========================= -- 1.查询 数据库结构-1的所有考试结构（学号，科目编号，成绩） 降序 -- 方式一： 连接查询 SELECT `StudentNo`,r.`SubjectName`,`StudentResult` FROM `result` r INNER JOIN `subject` sub ON r.SubjectNo = sun.SubjectNo WHERE subjectName = '数据库结构-1' ORDER BY StudentResult DESC -- 方式二：使用子查询(由里及外) SELECT `StudentNo`,r.`SubjectName`,`StudentResult` FROM `result` WHERE StudentNo=( SELECT SubjectNo FROM `subject` WHERE SubjectName = '数据库结构-1' ) ORDER BY StudentResult DESC -- 分数不少于80分的学生的学号和姓名 SELECT DISTINCT s.`StudentNo`,`StudentName` FROM student s INNER JOIN result r ON r.StudentNo = s.StudentNo WHERE StudentResult\u003e=80 -- 在这个基础上 增加一个科目 ，高等数学-2 SELECT DISTINCT s.`StudentNo`,`StudentName` FROM student s INNER JOIN result r ON r.StudentNo = s.StudentNo WHERE StudentResult\u003e=80 AND `SubjectNo`=( SELECT Subject FROM `subject` WHERE SubjectName='高等数学-2' ) -- 查询课程为 高等数学-2 且分数不小于80分的同学的学号和姓名 SELECT s.`StudentNo`,`StudentName` FROM student s INNER JOIN result r ON s.StudentNo = r.StudentNo INNER JOIN `subject` sub ON r.`SubjectName`='高等数学-2' WHERE `SubjectaName`='高等数学-2' AND StudentResult \u003e=80 -- 再改造 (由里即外) SELECT `StudentNo`,`StudentName` FROM student WHERE StudentNo IN( SELECT StudentNo result WHERE StudentResult \u003e80 AND SubjectNo =( SELECT SubjectNo FROM `subject` WHERE `SubjectaName`='高等数学-2' ) )`` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:22:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"4.7 分组 ``-- 查询不同课程的平均分，最高分，最低分，平均分大于80 -- 核心：（根据不同的课程分组） SELECT `SubjectName`,AVG(StudentResult),MAX(StudentResult) FROM result r INNER JOIN `Subject` sub ON r.SubjectNo=sub.SubjectNo GROUP BY r.SubjectNo -- 通过什么字段来分组 HAVING AVG(StudentResult)\u003e80`` 5、MySQL函数 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:23:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"5.1 常用函数 `-- 数学运算 SELECT ABS(-8) -- 绝对值 SELECT CEILING(9.4) -- 向上取整 SELECT FLOOR(9.4) -- 向下取整 SELECT RAND() -- 返回0-1随机数 SELECT SIGN(-10) -- 判断一个数的符号 0-0 负数返回-1 正数返回1 -- 字符串函数 SELECT CHAR_LENGTH('2323232') -- 返回字符串长度 SELECT CONCAT('我','233') -- 拼接字符串 SELECT INSERT('java',1,2,'cccc') -- 从某个位置开始替换某个长度 SELECT UPPER('abc') SELECT LOWER('ABC') SELECT REPLACE('坚持就能成功','坚持','努力') -- 查询姓 周 的同学 ，改成邹 SELECT REPLACE(studentname,'周','邹') FROM student WHERE studentname LIKE '周%' -- 时间跟日期函数（记住） SELECT CURRENT_DATE() -- 获取当前日期 SELECT CURDATE() -- 获取当前日期 SELECT NOW() -- 获取当前日期 SELECT LOCATIME() -- 本地时间 SELECT SYSDATE() -- 系统时间 SELECT YEAR(NOW()) SELECT MONTH(NOW()) SELECT DAY(NOW()) SELECT HOUR(NOW()) SELECT MINUTE(NOW()) SELECT SECOND(NOW()) -- 系统 SELECT SYSTEM_USER() SELECT USER() SELECT VERSION()` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:24:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"5.2 聚合函数（常用） 函数名称描述COUNT()计数SUM()求和AVG()平均值MAX()最大值MIN()最小值… ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:25:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"5.3 数据库级别MD5加密（拓展） 什么是MD5 主要增强算法复杂度不可逆性。 MD5不可逆，具体的MD5是一样的 MD5破解原理，背后有一个字典，MD5加密后的值，加密前的值 ``CREATE TABLE `testmd5`( `id` INT(4) NOT NULL, `name` VARCHAR(20) NOT NULL, `pwd` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`) )ENGINE=INNODB DEFAULT CHARSET=UTF8 -- 明文密码 INSERT INTO testmd5 VALUES(1,'张三','123456'),(2,'李四','123456'),(3,'王五','123456') -- 加密 UPDATE testmd5 SET pwd=MD5(pwd) WHERE id =1 UPDATE testmd5 SET pwd=MD5(pwd) WHERE id !=1 -- 加密全部 -- 插入时加密 INSERT INTO testmd5 VALUES(4,'小明',MD5('123456')) INSERT INTO testmd5 VALUES(5,'红',MD5('123456')) -- 如何校验，将用户传递过来的密码，进行MD5加密，然后对比加密后的值 SELECT * FROM testmd5 WHERE `name`='红' AND pwd=MD5('123456')`` 6、事务 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:26:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"6.1 什么是事务 要么都成功，要么都失败 SQL执行， A给B转账 A 1000–\u003e 200 B200 SQL 执行， B收到A的钱 A800 — B400 将一组SQL放在一个批次中执行 事务原则 ： ACID原则 原子性，一致性，隔离性，持久性 （脏读，幻读…） 原子性（Atomicity） 要么都成功，要么都失败 一致性（Consistency） 事务前后的数据完整性要保持一致 持久性（Durability）–事务提交 事务一旦提交就不可逆转，被持久化到数据库中 隔离性 事务产生多并发时，互不干扰 隔离产生的问题 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:27:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"脏读： 指一个事务读取了另外一个事务未提交的数据。 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:28:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"不可重复读： 在一个事务内读取表中的某一行数据，多次读取结果不同。（这个不一定是错误，只是某些场合不对） ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:29:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"虚读(幻读) 是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。 （一般是行影响，多了一行） 执行事务 `-- mysql 自动开启事务提交 SET autocommit=0 -- 关闭 SET autocommit=1 -- 开启（默认的） -- 手动处理事务 SET autocommit =0 -- 关闭自动提交 -- 事务开启 START TRANSACTION -- 标记一个事务的开始，从这个之后的SQP都在同一个事务内 INSERT XX INSERT XX -- 提交 ： 持久化(成功) COMMIT -- 回滚： 回到原来的样子（失败） ROLLBACK -- 事务结束 SET autocommit = 1 -- 开启自动提交 -- 了解 SAVEPOINT 保存点名称 -- 设置一个事务的保存点 ROLLBACK TO SAVEPOINT 保存点名 -- 回滚到保存点 RELEASE SAVEPOINT 保存点 -- 删除保存点` [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DfVvNLP7-1594142971424)(C:\\Users\\53424\\AppData\\Roaming\\Typora\\typora-user-images\\1594012051660.png)] 模拟场景 ``CREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci USE shop CREATE TABLE `account`( `id` INT(3) NOT NULL AUTO_INCREMENT, `name` VARCHAR(30) NOT NULL, `money` DECIMAL(9,2) NOT NULL, PRIMARY KEY (`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO account(`name`,`money`) VALUES('A',2000),('B',10000) -- 模拟转账：事务 SET autocommit = 0; -- 关闭自动提交 START TRANSACTION -- 开启事务（一组事务） UPDATE account SET money = money-500 WHERE `name` = 'A' -- A 转账给B UPDATE account SET money = money+500 WHERE `name` = 'B' -- B 收到钱 COMMIT ; -- 提交事务 ROLLBACK ; -- 回滚 SET autocommit=1 -- 恢复默认值`` 7、索引 MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:30:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"7.1索引的分类 在一个表中，主键索引只能有一个，唯一索引可以有多个 主键索引 （PRIMARY KEY） 唯一的标识，主键不可重复，只能有一个列作为主键 唯一索引 （UNIQUE KEY） 避免重复的列出现，唯一索引可以重复，多个列都可以标识唯一索引 常规索引（KEY/INDEX） 默认的，index,key关键字来设置 全文索引（FULLTEXT） 在特点的数据库引擎下才有，MyISAM 快速定位数据 `-- 索引的使用 -- 1.在创建表的时候给字段增加索引 -- 2.创建完毕后，增加索引 -- 显示所有的索引信息 SHOW INDEX FROM 表 -- 增加一个索引 ALTER TABLE 表 ADD FULLTEXT INDEX 索引名（字段名） -- EXPLAIN 分析sql执行状况 EXPLAIN SELECT * FROM student -- 非全文索引` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:31:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"7.2 测试索引 ``CREATE TABLE `app_user` ( `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT, `name` VARCHAR(50) DEFAULT '', `email` VARCHAR(50) NOT NULL, `phone` VARCHAR(20) DEFAULT '', `gender` TINYINT(4) UNSIGNED DEFAULT '0', `password` VARCHAR(100) NOT NULL DEFAULT '', `age` TINYINT(4) DEFAULT NULL, `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP, `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 -- 插入100万数据 DELIMITER $$ -- 写函数之前必写 CREATE FUNCTION mock_data() RETURNS INT BEGIN DECLARE num INT DEFAULT 1000000; DECLARE i INT DEFAULT 0; WHILE i\u003cnum DO -- 插入语句 INSERT INTO app_user(`name`,`email`,`phone`,`gender`,`password`,`age`) VALUE(CONCAT('用户',i),'534240118@qq.com',FLOOR (CONCAT('18',RAND()*9999999)),FLOOR (RAND()*2), UUID(),FLOOR (RAND()*100)); SET i = i+1; END WHILE; RETURN i; END; INSERT INTO app_user(`name`,`email`,`phone`,`gender`,`password`,`age`) VALUE(CONCAT('用户',i),'534240118@qq.com',FLOOR (CONCAT('18',RAND()*9999999)),FLOOR (RAND()*2), UUID(),FLOOR (RAND()*100)) SELECT mock_data(); SELECT * FROM app_user WHERE `name`='用户9999' -- 接近半秒 EXPLAIN SELECT * FROM app_user WHERE `name`='用户9999' -- 查询99999条记录 -- id _ 表名_字段名 -- create index on 字段 CREATE INDEX id_app_user_name ON app_user(`name`); -- 0.001 s EXPLAIN SELECT * FROM app_user WHERE `name`='用户9999' -- 查询一条记录`` 索引在小数据的时候，用处不大，但是在大数据的时候，区别十分明显 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:32:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"7.3 索引原则 索引不是越多越好 不要对经常变动的数据加索引 小数据量的表不需要加索引 索引一般加在常用来查询的字段上 索引的数据结构 Hash 类型的索引 Btree: 默认innodb 的数据结构 阅读： http://blog.codinglabs.org/articles/theory-of-mysql-index.html 8、权限管理和备份 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:33:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"8.1用户管理 SQLyog 可视化管理 SQL命令操作 用户表：mysql.user 本质：对这张表进行，增删改查 `-- 创建用户 CREATE USER 用户名 IDENTIFIED BY '密码' CREATE USER sanjin IDENTIFIED BY '123456' -- 修改密码（修改当前密码） SET PASSWORD = PASSWORD('111111') -- 修改密码（修改指定用户密码） SET PASSWORD FOR sanjin = PASSWORD('111111') -- 重命名 rename user 原名字 to 新名字 RENAME USER sanjin TO sanjin2 -- 用户授权 ALL PRIVILEGES 全部的权限 库，表 -- ALL PRIVILEGES 除了给别人授权，其他都能干 GRANT ALL PRIVILEGES ON *.* TO sanjin2 -- 查询权限 SHOW GRANTS FOR sanjin2 -- 查看指定用户的权限 SHOW GRANTS FOR root@localhost -- 撤销权限 REVOKE 哪些权限，在哪个库撤销，给谁撤销 REVOKE ALL PRIVILEGES ON *.* FROM sanjin2 -- 删除用户 DROP USER sanjin2` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:34:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"8.2 MySQL备份 为什么备份： 保证重要数据不丢失 数据转移 MySQL数据库备份的方式 直接拷贝物理文件 在SQLyog这种可视化工具中手动导出 在想要导出的表或者库中，右键选择备份和导出 9、规范数据库设计 当数据库比较复杂的时候，我们就需要设计了 糟糕的数据库设计： 数据冗余，浪费空间 数据库插入和删除都会麻烦，异常【屏蔽使用物理外键】 程序的性能差 良好的数据库设计： 节省内存空间 保证数据库的完整性 方便我们开发系统 软件开发中，关于数据库的设计 分析需求：分析业务和需要处理的数据库的需求 概要设计：设计关系图 E-R图 设计数据库的步骤（个人博客） 收集信息，分析需求 用户表（用户登录注销，用户的个人信息，写博客，创建分类） 分类表（文章分类，谁创建的） 文章表（文章的信息） 友链表（友链信息） 自定义表（系统信息，某个关键的字，或者某些主字段） 说说表（发表心情…id ,content ,time） 标识实体（把需求落地到每个字段） 标识实体之间的关系 写博客 user–\u003eblog 创建分类 user–\u003ecategory 关注 user–\u003euser 友链–\u003elinks 评论 user–\u003euser ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:35:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"9.2三大范式 为什么需要数据规范化？ 信息重复 更新异常 插入异常 删除异常 无法正常显示异常 删除异常 丢失有效的信息 三大范式 第一范式（1NF） 原子性：保证每一列不可再分 第二范式（2NF） 前提：满足第一范式 每张表只描述一件事情 第三范式（3NF） 前提：满足第一范式和第二范式 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 （规范数据库的设计） 规范性和性能的问题 关联查询的表，不得超过三张表 考虑商业化的需求和目标（成本和用户体验） 数据库的性能更加重要 再规范性能的问题的时候，需要适当的考虑一下，规范性 故意给某些表加一些冗余的字段（从多表，变成单表） 故意增加一些计算列（从大数据量降低为小数据量的查询：索引） 10、JDBC(重点) ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:36:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.1 数据库驱动 驱动：声卡，显卡，数据库 我们的程序会通过数据库驱动，和数据库打交道！ ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:37:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.2 JDBC SUN 公司为了简化开发人员的（对数据库的统一）操作，提供了一个(Java操作数据库的)规范，JDBC 这些规范的实现由具体的厂商去做 对于开发人员来说，我们只需要掌握JDBC的接口操作即可 java.sql javax.sql 还需要导入数据库驱动包 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:38:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.3 第一个JDBC程序 创建测试数据库 ``CREATE DATABASE jdbcStudy CHARACTER SET utf8 COLLATE utf8_general_ci; USE jdbcStudy; CREATE TABLE `users`( id INT PRIMARY KEY, NAME VARCHAR(40), PASSWORD VARCHAR(40), email VARCHAR(60), birthday DATE ); INSERT INTO `users`(id,NAME,PASSWORD,email,birthday) VALUES(1,'zhansan','123456','zs@sina.com','1980-12-04'), (2,'lisi','123456','lisi@sina.com','1981-12-04'), (3,'wangwu','123456','wangwu@sina.com','1979-12-04')`` 1.创建一个普通项目 2.导入数据库驱动 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-12VBmers-1594142971429)(C:\\Users\\53424\\AppData\\Roaming\\Typora\\typora-user-images\\1594046904540.png)] 3.编写测试代码 `package com.kuang.lesson01; //我的第一个JDBC程序 import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class JdbcFirstDemo { public static void main(String[] args) throws Exception { //1. 加载驱动 Class.forName(\"com.mysql.jdbc.Driver\");//固定写法 //2. 用户信息和url //useUnicode=true\u0026characterEncoding=utf8\u0026\u0026useSSL=true String url =\"jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true\u0026characterEncoding=utf8\u0026\u0026useSSL=false\"; String name = \"root\"; String password = \"123456\"; //3. 连接成功，返回数据库对象 connection代表数据库 Connection connection= DriverManager.getConnection(url,name,password); //4. 执行SQL的对象 statement 执行SQL的对象 Statement statement = connection.createStatement(); //5. 执行SQL的对象 去执行SQL 可能存在结果，查看返回结果 String sql=\"SELECT * FROM users\"; ResultSet resultSet = statement.executeQuery(sql);//返回的结果集,结果集中封装了我们全部查询的结果 while(resultSet.next()){ System.out.println(\"id+\"+resultSet.getObject(\"id\")); System.out.println(\"name+\"+resultSet.getObject(\"NAME\")); System.out.println(\"password+\"+resultSet.getObject(\"PASSWORD\")); System.out.println(\"email+\"+resultSet.getObject(\"email\")); System.out.println(\"birthday+\"+resultSet.getObject(\"birthday\")); } //6. 释放连接 resultSet.close(); statement.close(); connection.close(); } }` 步骤总结： 1.加载驱动 2.连接数据库 DriverManager 3.获取执行SQL的对象 Statement 4.获得返回的结果集 5.释放连接 DriverManager `//DriverManager.registerDriver(new com.mysql.jdbc.Driver()); Class.forName(\"com.mysql.jdbc.Driver\");//固定写法 Connection connection= DriverManager.getConnection(url,name,password); //connection代表数据库 //数据库设置自动提交 //事务提交 //事务回滚 connection.rollback(); connection.commit(); connection.setAutoCommit();` URL `String url =\"jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true\u0026characterEncoding=utf8\u0026\u0026useSSL=false\"; //mysql 默认3306 //协议://主机地址:端口号/数据库名？参数1\u0026参数2\u0026参数3 //Oracle 1521 //jdbc:oralce:thin:@localhost:1521:sid` statement 执行SQL的对象 pPrepareStatement 执行SQL的对象 `String sql=\"SELECT * FROM users\";//编写Sql statement.executeQuery(); statement.execute(); statement.executeUpdate();//更新，插入，删除，返回一个受影响的行数` ResultSet 查询的结果集，封装了所以的查询结果 获得指定的数据类型 `ResultSet resultSet = statement.executeQuery(sql);//返回的结果集,结果集中封装了我们全部查询的结果 resultSet.getObject();//在不知道列类型下使用 resultSet.getString();//如果知道则指定使用 resultSet.getInt();` 遍历,指针 `resultSet.next(); //移动到下一个 resultSet.afterLast();//移动到最后 resultSet.beforeFirst();//移动到最前面 resultSet.previous();//移动到前一行 resultSet.absolute(row);//移动到指定行` 释放内存 `//6. 释放连接 resultSet.close(); statement.close(); connection.close();//耗资源` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:39:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.4statement对象 Jdbc中的statement对象用于向数据库发送SQL语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可。 Statement对象的executeUpdate方法，用于向数据库发送增、删、改的sq|语句， executeUpdate执行完后， 将会返回一个整数(即增删改语句导致了数据库几行数据发生了变化)。 Statement.executeQuery方法用于向数据库发生查询语句，executeQuery方法返回代表查询结果的ResultSet对象。 CRUD操作-create 使用executeUpdate(String sql)方法完成数据添加操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"insert into user(...) values(...)\"; int num = statement.executeUpdate(sql); if(num\u003e0){ System.out.println(\"插入成功\"); }` CRUD操作-delete 使用executeUpdate(String sql)方法完成数据删除操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"delete from user where id =1\"; int num = statement.executeUpdate(sql); if(num\u003e0){ System.out.println(\"删除成功\"); }` CURD操作-update 使用executeUpdate(String sql)方法完成数据修改操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"update user set name ='' where name = ''\"; int num = statement.executeUpdate(sql); if(num\u003e0){ System.out.println(\"修改成功\"); }` CURD操作-read 使用executeUpdate(String sql)方法完成数据查询操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"select * from user where id =1\"; ResultSet rs= statement.executeQuery(sql); if(rs.next()){ System.out.println(\"\"); }` 代码实现 1.提取工具类 `package com.kuang.lesson02.utils; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Properties; public class JdbcUtils { private static String driver = null; private static String url = null; private static String username = null; private static String password = null; static { try{ InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(\"db.properties\"); Properties properties = new Properties(); properties.load(in); driver=properties.getProperty(\"driver\"); url=properties.getProperty(\"url\"); user); password=properties.getProperty(\"password\"); //1.驱动只用加载一次 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } //2.获取连接 public static Connection getConnection() throws Exception{ return DriverManager.getConnection(url, username, password); } //3.释放资源 public static void release(Connection conn, Statement st, ResultSet rs) throws SQLException { if(rs!=null){ rs.close(); } if (st!=null){ st.close(); } if(conn!=null){ conn.close(); } } }` 2.编写增删改的方法，exectueUpdate ``package com.kuang.lesson02.utils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.Statement; import static com.kuang.lesson02.utils.JdbcUtils.*; public class TestInnsert { public static void main(String[] args){ Connection conn =null; Statement st = null; ResultSet rs =null; try { conn = getConnection();//获取连接 st = conn.createStatement();//获取SQL执行对象 String sql = \"INSERT INTO users(id,`NAME`,`PASSWORD`,`email`,`birthday`)\" + \"VALUES(5,'sanjin','123456','233223@qq.com','2020-01-01')\"; int i = st.executeUpdate(sql); if(i\u003e0){ System.out.println(\"插入成功\"); } JdbcUtils.release(conn,st,rs); } catch (Exception e) { e.printStackTrace(); } } }`` 3.查询 executeQuery `package com.kuang.lesson02.utils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import static com.kuang.lesson02.utils.JdbcUtils.*; public class TestInnsert { public static void main(String[] args) throws SQLException { Connection conn =null; Statement st = null; ResultSet rs =null; try { conn = getConnection();//获取连接 st = conn.createStatement();//获取SQL执行对象 String sql = \"select * from users\"; rs=st.executeQuery(sql);//查询完毕返回结果集 while (rs.next()){ System.out.println(rs.getString(\"NAME\")); } JdbcUtils.release(conn,st,rs); } catch (Exception e) { e.printStackTrace(); }finally { JdbcUtils.release(conn,st,rs); } } }` SQL注入问题 sql存在漏洞，会被攻击导致数据泄露 SQL会被拼接 or ``package com.kuang.lesson02.utils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import static com.kuang.lesson02.utils.JdbcUtils.getConnection; public class SQL注入 { public st","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:40:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.5 PreparedStatement对象 PreparedStatement 可以防止SQL注入 ，效率更高。 新增 删除 查询 ``package com.kuang.lesson03; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class Test { public static void main(String[] args) { Connection connection= null; PreparedStatement pstm=null; try { connection = JdbcUtils.getConnection(); //区别 //使用问好占位符代替参数 String sql = \"insert into users(id,`NAME`) values(?,?)\"; pstm = connection.prepareStatement(sql);//预编译sql，先写sql然后不执行 //手动赋值 pstm.setInt(1,8); pstm.setString(2,\"SANJIN\"); //执行 int i = pstm.executeUpdate(); if (i\u003e0){ System.out.println(\"插入成功\"); } } catch (Exception e) { e.printStackTrace(); }finally { try { JdbcUtils.release(connection,pstm,null); } catch (SQLException throwables) { throwables.printStackTrace(); } } } }`` 防止SQL注入本质，传递字符 带有“ ”，转义字符会被转义 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:41:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.6 使用IDEA连接数据库 连接成功后，可以选择数据库 双击数据库 更新数据 编写sql代码的地方 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:42:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.7 JDBC事务 要么都成功，要么都失败 ACID原则 原子性：要么全部完成，要么都不完成 一致性：结果总数不变 隔离性：多个进程互不干扰 持久性：一旦提交不可逆，持久化到数据库了 隔离性的问题： 脏读： 一个事务读取了另一个没有提交的事务 不可重复读：在同一个事务内，重复读取表中的数据，表发生了改变 虚读（幻读）：在一个事务内，读取到了别人插入的数据，导致前后读出来的结果不一致 代码实现 开启事务conn.setAutoCommit(false); 一组业务执行完毕，提交事务 可以在catch语句中显示的定义回滚，但是默认失败会回滚 `package com.kuang.lesson04; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class Action { public static void main(String[] args) { Connection conn =null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); //关闭数据库的自动提交功能， 开启事务 conn.setAutoCommit(false); //自动开启事务 String sql = \"update account set money = money-500 where id = 1\"; ps =conn.prepareStatement(sql); ps.executeUpdate(); String sql2 = \"update account set money = money-500 where id = 2\"; ps=conn.prepareStatement(sql2); ps.executeUpdate(); //业务完毕，提交事务 conn.commit(); System.out.println(\"操作成功\"); } catch (Exception e) { try { //如果失败，则默认回滚 conn.rollback();//如果失败，回滚 } catch (SQLException throwables) { throwables.printStackTrace(); } e.printStackTrace(); }finally { try { JdbcUtils.release(conn,ps,rs); } catch (SQLException throwables) { throwables.printStackTrace(); } } } }` ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:43:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"10.8数据库连接池 数据库连接–执行完毕–释放 连接–释放 十分浪费资源 池化技术： 准备一些预先的资源，过来就连接预先准备好的 常用连接数 100 最少连接数：100 最大连接数 ： 120 业务最高承载上限 排队等待， 等待超时：100ms 编写连接池，实现一个接口 DateSource 开源数据源实现(拿来即用) DBCP C3P0 Druid: 阿里巴巴 使用了这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码了 DBCP 需要用到的jar包 dbcp.ar C3P0 结论 无论使用什么数据源，本质是不变的，DateSource接口不会变，方法就不会变 ","date":"2021-04-17","objectID":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:44:0","tags":["MySQL"],"title":"MySQL","uri":"/simpread-mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:0","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1. 微服务概述 1.1 什么是微服务？ **什么是微服务？**微服务(Microservice Architecture) 是近几年流行的一种架构思想，关于它的概念很难一言以蔽之。 究竟什么是微服务呢？我们在此引用ThoughtWorks 公司的首席科学家 Martin Fowler 于2014年提出的一段话： 原文：https://martinfowler.com/articles/microservices.html 汉化：https://www.cnblogs.com/liuning8023/p/4493156.html 就目前而言，对于微服务，业界并没有一个统一的，标准的定义。 但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，它体长将单一的应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(HTTP)互相沟通，每个服务都围绕着具体的业务进行构建，并且能狗被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(Maven)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。 再来从技术维度角度理解下： 微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。 1.2 微服务与微服务架构 微服务 强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。 IDEA 工具里面使用Maven开发的一个个独立的小Moudel，它具体是使用SpringBoot开发的一个小模块，专业的事情交给专业的模块来做，一个模块就做着一件事情。 强调的是一个个的个体，每个个体完成一个具体的任务或者功能。 微服务架构 一种新的架构形式，Martin Fowler 于2014年提出。 微服务架构是一种架构模式，它体长将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制**(如HTTP)**互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具**(如Maven)**对其进行构建。 1.3 微服务优缺点 优点 单一职责原则； 每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求； 开发简单，开发效率高，一个服务可能就是专一的只干一件事； 微服务能够被小团队单独开发，这个团队只需2-5个开发人员组成； 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的； 微服务能使用不同的语言开发； 易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins，Hudson，bamboo； 微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值； 微服务允许利用和融合最新技术； 微服务只是业务逻辑的代码，不会和HTML，CSS，或其他的界面混合; 每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库； 缺点 开发人员要处理分布式系统的复杂性； 多服务运维难度，随着服务的增加，运维的压力也在增大； 系统部署依赖问题； 服务间通信成本问题； 数据一致性问题； 系统集成测试问题； 性能和监控问题； 1.4 微服务技术栈有那些？ 微服务技术条目落地技术服务开发SpringBoot、Spring、SpringMVC等服务配置与管理Netfix公司的Archaius、阿里的Diamond等服务注册与发现Eureka、Consul、Zookeeper等服务调用Rest、PRC、gRPC服务熔断器Hystrix、Envoy等负载均衡Ribbon、Nginx等服务接口调用(客户端调用服务的简化工具)Fegin等消息队列Kafka、RabbitMQ、ActiveMQ等服务配置中心管理SpringCloudConfig、Chef等服务路由(API网关)Zuul等服务监控Zabbix、Nagios、Metrics、Specatator等全链路追踪Zipkin、Brave、Dapper等数据流操作开发包SpringCloud Stream(封装与Redis，Rabbit，Kafka等发送接收消息)时间消息总栈SpringCloud Bus服务部署Docker、OpenStack、Kubernetes等 1.5 为什么选择SpringCloud作为微服务架构 选型依据 整体解决方案和框架成熟度 社区热度 可维护性 学习曲线 当前各大IT公司用的微服务架构有那些？ 阿里：dubbo+HFS 京东：JFS 新浪：Motan 当当网：DubboX … 各微服务框架对比 功能点/服务框架Netflix/SpringCloudMotangRPCThriftDubbo/DubboX功能定位完整的微服务框架RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册发现RPC框架RPC框架服务框架支持Rest是，Ribbon支持多种可拔插的序列号选择否否否否支持RPC否是(Hession2)是是是支持多语言是(Rest形式)否是是否负载均衡是(服务端zuul+客户端Ribbon)，zuul-服务，动态路由，云端负载均衡Eureka（针对中间层服务器）是(客户端)否否是(客户端)配置服务Netfix Archaius，Spring Cloud Config Server 集中配置是(Zookeeper提供)否否否服务调用链监控是(zuul)，zuul提供边缘服务，API网关否否否否高可用/容错是(服务端Hystrix+客户端Ribbon)是(客户端)否否是(客户端)典型应用案例NetflixSinaGoogleFacebook社区活跃程度高一般高一般2017年后重新开始维护，之前中断了5年学习难度中等低高高低文档丰富程度高一般一般一般高其他Spring Cloud Bus为我们的应用程序带来了更多管理端点支持降级Netflix内部在开发集成gRPCIDL定义实践的公司比较多 ","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:1","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"2. SpringCloud入门概述 2.1 SpringCloud是什么？ Spring官网：https://spring.io/ Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry. 翻译： Spring Cloud为开发人员提供了快速构建分布式系统中的一些常见模式的工具(例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导人选举、分布式会话、集群状态)。分布式系统的协调导致了锅炉板模式，而使用Spring Cloud开发人员可以快速建立实现这些模式的服务和应用程序。它们在任何分布式环境中都能很好地工作，包括开发人员自己的笔记本电脑、裸金属数据中心和云计算等托管平台。 2.2 SpringCloud和SpringBoot的关系 SpringBoot专注于开苏方便的开发单个个体微服务； SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、为代理、事件总栈、全局锁、决策竞选、分布式会话等等集成服务； SpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系； SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架； 2.3 Dubbo 和 SpringCloud技术选型 1. 分布式+服务治理Dubbo 目前成熟的互联网架构，应用服务化拆分+消息中间件 2. Dubbo 和 SpringCloud对比 可以看一下社区活跃度： https://github.com/dubbo https://github.com/spring-cloud 对比结果： DubboSpringCloud服务注册中心ZookeeperSpring Cloud Netfilx Eureka服务调用方式RPCREST API服务监控Dubbo-monitorSpring Boot Admin断路器不完善Spring Cloud Netfilx Hystrix服务网关无Spring Cloud Netfilx Zuul分布式配置无Spring Cloud Config服务跟踪无Spring Cloud Sleuth消息总栈无Spring Cloud Bus数据流无Spring Cloud Stream批量任务无Spring Cloud Task 最大区别：Spring Cloud 抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式 严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这个优点在当下强调快速演化的微服务环境下，显得更加合适。 品牌机和组装机的区别 社区支持与更新力度的区别 总结： 二者解决的问题域不一样：Dubbo的定位是一款RPC框架，而SpringCloud的目标是微服务架构下的一站式解决方案。 2.4 SpringCloud能干嘛？ Distributed/versioned configuration 分布式/版本控制配置 Service registration and discovery 服务注册与发现 Routing 路由 Service-to-service calls 服务到服务的调用 Load balancing 负载均衡配置 Circuit Breakers 断路器 Distributed messaging 分布式消息管理 … 2.5 SpringCloud下载 官网：http://projects.spring.io/spring-cloud/ 版本号有点特别： SpringCloud没有采用数字编号的方式命名版本号，而是采用了伦敦地铁站的名称，同时根据字母表的顺序来对应版本时间顺序，比如最早的Realse版本：Angel，第二个Realse版本：Brixton，然后是Camden、Dalston、Edgware，目前最新的是Hoxton SR4 CURRENT GA通用稳定版。 自学参考书： SpringCloud Netflix 中文文档：https://springcloud.cc/spring-cloud-netflix.html SpringCloud 中文API文档(官方文档翻译版)：https://springcloud.cc/spring-cloud-dalston.html SpringCloud中国社区：http://springcloud.cn/ SpringCloud中文网：https://springcloud.cc ","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:2","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"3. SpringCloud Rest学习环境搭建：服务提供者 3.1 介绍 我们会使用一个Dept部门模块做一个微服务通用案例Consumer消费者(Client)通过REST调用Provider提供者(Server)提供的服务。 回顾Spring，SpringMVC，Mybatis等以往学习的知识。 Maven的分包分模块架构复习。 `一个简单的Maven模块结构是这样的： -- app-parent: 一个父项目(app-parent)聚合了很多子项目(app-util\\app-dao\\app-web...) |-- pom.xml | |-- app-core ||---- pom.xml | |-- app-web ||---- pom.xml ......` 一个父工程带着多个Moudule子模块 MicroServiceCloud父工程(Project)下初次带着3个子模块(Module) microservicecloud-api 【封装的整体entity/接口/公共配置等】 microservicecloud-consumer-dept-80 【服务提供者】 microservicecloud-provider-dept-8001 【服务消费者】 3.2 SpringCloud版本选择 大版本说明 SpringBootSpringCloud关系1.2.xAngel版本(天使)兼容SpringBoot1.2x1.3.xBrixton版本(布里克斯顿)兼容SpringBoot1.3x，也兼容SpringBoot1.4x1.4.xCamden版本(卡姆登)兼容SpringBoot1.4x，也兼容SpringBoot1.5x1.5.xDalston版本(多尔斯顿)兼容SpringBoot1.5x，不兼容SpringBoot2.0x1.5.xEdgware版本(埃奇韦尔)兼容SpringBoot1.5x，不兼容SpringBoot2.0x2.0.xFinchley版本(芬奇利)兼容SpringBoot2.0x，不兼容SpringBoot1.5x2.1.xGreenwich版本(格林威治) 实际开发版本关系 spring-boot-starter-parentspring-cloud-dependencles版本号发布日期版本号发布日期1.5.2.RELEASE2017-03Dalston.RC12017-x1.5.9.RELEASE2017-11Edgware.RELEASE2017-111.5.16.RELEASE2018-04Edgware.SR52018-101.5.20.RELEASE2018-09Edgware.SR52018-102.0.2.RELEASE2018-05Fomchiey.BULD-SNAPSHOT2018-x2.0.6.RELEASE2018-10Fomchiey-SR22018-102.1.4.RELEASE2019-04Greenwich.SR12019-03 使用后两个 3.3 创建父工程 新建父工程项目springcloud，切记Packageing是pom模式 主要是定义POM文件，将后续各个子模块公用的jar包等统一提取出来，类似一个抽象父类 pom.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.haust\u003c/groupId\u003e \u003cartifactId\u003espringcloud\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cmodules\u003e \u003cmodule\u003espringcloud-api\u003c/module\u003e \u003cmodule\u003espringcloud-provider-dept-8001\u003c/module\u003e \u003cmodule\u003espringcloud-consumer-dept-80\u003c/module\u003e \u003cmodule\u003espringcloud-eureka-7001\u003c/module\u003e \u003cmodule\u003espringcloud-eureka-70002\u003c/module\u003e \u003cmodule\u003espringcloud-eureka-7003\u003c/module\u003e \u003cmodule\u003espringcloud-provider-dept-8002\u003c/module\u003e \u003cmodule\u003espringcloud-provider-dept-8003\u003c/module\u003e \u003cmodule\u003espringcloud-consumer-dept-feign\u003c/module\u003e \u003cmodule\u003espringcloud-provider-dept-hystrix-8001\u003c/module\u003e \u003cmodule\u003espringcloud-consumer-hystrix-dashboard\u003c/module\u003e \u003cmodule\u003espringcloud-zuul-9527\u003c/module\u003e \u003cmodule\u003espringcloud-config-server-3344\u003c/module\u003e \u003cmodule\u003espringcloud-config-client-3355\u003c/module\u003e \u003cmodule\u003espringcloud-config-eureka-7001\u003c/module\u003e \u003cmodule\u003espringcloud-config-dept-8001\u003c/module\u003e \u003c/modules\u003e \u003c!--打包方式 pom--\u003e \u003cpackaging\u003epom\u003c/packaging\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cmaven.compiler.source\u003e1.8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e1.8\u003c/maven.compiler.target\u003e \u003cjunit.version\u003e4.12\u003c/junit.version\u003e \u003clog4j.version\u003e1.2.17\u003c/log4j.version\u003e \u003clombok.version\u003e1.16.18\u003c/lombok.version\u003e \u003c/properties\u003e \u003cdependencyManagement\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-alibaba-dependencies\u003c/artifactId\u003e \u003cversion\u003e0.2.0.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--springCloud的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-dependencies\u003c/artifactId\u003e \u003cversion\u003eGreenwich.SR1\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--SpringBoot--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.1.4.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--数据库--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e1.1.10\u003c/version\u003e \u003c/dependency\u003e \u003c!--SpringBoot 启动器--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--日志测试~--\u003e \u003cdependency\u003e \u003cgroupId\u003ech.qos.lo","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:3","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"4. Eureka服务注册与发现 4.1 什么是Eureka Netflix在涉及Eureka时，遵循的就是API原则. Eureka是Netflix的有个子模块，也是核心模块之一。Eureka是基于REST的服务，用于定位服务，以实现云端中间件层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心，比如Zookeeper. 4.2 原理理解 Eureka基本的架构 Springcloud 封装了Netflix公司开发的Eureka模块来实现服务注册与发现 (对比Zookeeper). Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心. 而系统中的其他微服务，使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，Springcloud 的一些其他模块 (比如Zuul) 就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑. 和Dubbo架构对比. Eureka 包含两个组件：Eureka Server 和 Eureka Client. Eureka Server 提供服务注册，各个节点启动后，回在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会储存所有课用服务节点的信息，服务节点的信息可以在界面中直观的看到. Eureka Client 是一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳 (默认周期为30秒) 。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除掉 (默认周期为90s). 三大角色 Eureka Server：提供服务的注册与发现 Service Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能狗找到 Service Consumer：服务消费方，从Eureka中获取注册服务列表，从而找到消费服务 目前工程状况 4.3 构建步骤 1. eureka-server springcloud-eureka-7001 模块建立 pom.xml 配置 `\u003c!--导包~--\u003e \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --\u003e \u003c!--导入Eureka Server依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-eureka-server\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!--热部署工具--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e` application.yml `server: port: 7001 #Eureka配置 eureka: instance: hostname: localhost #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---\u003ehttp://localhost:7001/eureka/ defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/` 源码中Eureka的默认端口以及访问路径: 主启动类 `//启动之后，访问 http://localhost:7001/ @SpringBootApplication @EnableEurekaServer //EnableEurekaServer 表示是 Eureka服务端的启动类，可以接受别人注册进来~ public class EurekaServer_7001 { public static void main(String[] args) { SpringApplication.run(EurekaServer_7001.class,args); } }` 启动成功后访问 http://localhost:7001/ 得到以下页面 2. eureka-client 调整之前创建的springlouc-provider-dept-8001 导入Eureca依赖 `\u003c!--Eureka依赖--\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-eureka\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e` application中新增Eureca配置 `# Eureka配置：配置服务注册中心地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/` 为主启动类添加@EnableEurekaClient注解 `@SpringBootApplication @EnableEurekaClient //EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务 public class DeptProvider_8001 { public static void main(String[] args) { SpringApplication.run(DeptProvider_8001.class,args); } }` 先启动7001服务端后启动8001客户端进行测试，然后访问监控页http://localhost:7001/ 产看结果如图，成功 修改Eureka上的默认描述信息 `# Eureka配置：配置服务注册中心地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ instance: instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息` 结果如图： 如果此时停掉springcloud-provider-dept-8001 等30s后 监控会开启保护机制 配置关于服务加载的监控信息 pom.xml中添加依赖 `\u003c!--actuator完善监控信息--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e` application.yml中添加配置 `#info配置 info: app.name: haust-springcloud #项目的名称 company.name: com.haust #公司的名称` 此时刷新监控页，点击进入跳转新页面显示如下内容： 3. EureKa自我保护机制：好死不如赖活着 一句话总结就是：某时刻某一个微服务不可用，eureka不会立即清理，依旧会对该微服务的信息进行保存！ 默认情况下，当eureka server在一定时间内没有收到实例的心跳，便会把该实例从注册表中删除（默认是90秒），但是，如果短时间内丢失大量的实例心跳，便会触发eureka server的自我保护机制，比如在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启（因为在开发过程中不会修改eureka注册中心），当一分钟内收到的心跳数大量减少时，会触发该保护机制。可以在eureka管理界面看到Renews threshold和Renews(last min)，当后者（最后一分钟收到的心跳数）小于前者（心跳阈值）的时候，触发保护机制，会出现红色的警告：**EMERGENCY!EUREKA MAY BE INCORRECTLY CLAIMI","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:4","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5. Ribbon：负载均衡(基于客户端) 5.1 负载均衡以及Ribbon Ribbon是什么？ Spring Cloud Ribbon 是基于Netflix Ribbon 实现的一套客户端负载均衡的工具。 简单的说，Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 的客户端组件提供一系列完整的配置项，如：连接超时、重试等。简单的说，就是在配置文件中列出 LoadBalancer (简称LB：负载均衡) 后面所有的及其，Ribbon 会自动的帮助你基于某种规则 (如简单轮询，随机连接等等) 去连接这些机器。我们也容易使用 Ribbon 实现自定义的负载均衡算法！ Ribbon能干嘛？ LB，即负载均衡 (LoadBalancer) ，在微服务或分布式集群中经常用的一种应用。 负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高用)。 常见的负载均衡软件有 Nginx、Lvs 等等。 Dubbo、SpringCloud 中均给我们提供了负载均衡，SpringCloud 的负载均衡算法可以自定义。 负载均衡简单分类： 集中式LB 即在服务的提供方和消费方之间使用独立的LB设施，如Nginx，由该设施负责把访问请求通过某种策略转发至服务的提供方！ 进程式LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。 Ribbon 就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址！ 5.2 集成Ribbon springcloud-consumer-dept-80向pom.xml中添加Ribbon和Eureka依赖 `\u003c!--Ribbon--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-ribbon\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!--Eureka: Ribbon需要从Eureka服务中心获取要拿什么--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-eureka\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e` 在application.yml文件中配置Eureka `# Eureka配置 eureka: client: register-with-eureka: false # 不向 Eureka注册自己 service-url: # 从三个注册中心中随机取一个去访问 defaultZone: http://eureka700fxgfj1.com:7001/eureka/,http://eureka700fxgfj2.com:70002/eureka/,http://eureka700fxgfj3.com:7003/eureka/` 主启动类加上@EnableEurekaClient注解，开启Eureka `//Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号 @SpringBootApplication @EnableEurekaClient //开启Eureka 客户端 public class DeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_80.class, args); } }` 自定义Spring配置类：ConfigBean.java 配置负载均衡实现RestTemplate `@Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml @LoadBalanced //配置负载均衡实现RestTemplate @Bean public RestTemplate getRestTemplate() { return new RestTemplate(); } }` 修改conroller：DeptConsumerController.java `//Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 //private static final String REST_URL_PREFIX = \"http://localhost:8001\"; private static final String REST_URL_PREFIX = \"http://SPRINGCLOUD-PROVIDER-DEPT\";` 5.3 使用Ribbon实现负载均衡 流程图： 1.新建两个服务提供者Moudle：springcloud-provider-dept-8003、springcloud-provider-dept-8002 2.参照springcloud-provider-dept-8001 依次为另外两个Moudle添加pom.xml依赖 、resourece下的mybatis和application.yml配置，Java代码 3.启动所有服务测试(根据自身电脑配置决定启动服务的个数)，访问http://eureka700fxgfj1.com:70002/查看结果 测试访问http://localhost/consumer/dept/list 这时候随机访问的是服务提供者8003 再次访问http://localhost/consumer/dept/list这时候随机的是服务提供者8001 以上这种每次访问http://localhost/consumer/dept/list随机访问集群中某个服务提供者，这种情况叫做轮询，轮询算法在SpringCloud中可以自定义。 如何切换或者自定义规则呢？ 在springcloud-provider-dept-80模块下的ConfigBean中进行配置，切换使用不同的规则 `@Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml /** * IRule: * RoundRobinRule 轮询 * RandomRule 随机 * AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~ * RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试 */ @LoadBalanced //配置负载均衡实现RestTemplate @Bean public RestTemplate getRestTemplate() { return new RestTemplate(); } @Bean public IRule myRule(){ return new RandomRule();//使用随机规则 } }` 也可以自定义规则，在myRule包下自定义一个配置类MyRule.java，注意：该包不要和主启动类所在的包同级，要跟启动类所在包同级： MyRule.java `/** * @Auther: csp1999 * @Date: 2020/05/19/11:58 * @Description: 自定义规则 */ @Configuration public class MyRule { @Bean public IRule myRule(){ return new MyRandomRule();//默认是轮询RandomRule,现在自定义为自己的 } }` 主启动类开启负载均衡并指定自定义的MyRule配置类 `//Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号 @SpringBootApplication @EnableEurekaClient //在微服务启动的时候就能加载自定义的Ribbon类(自定义的规则会覆盖原有默认的规则) @RibbonClient(name = \"SPRINGCLOUD-PROVIDER-DEPT\",configuration = MyRule.class)//开启负载均衡,并指定自定义的规则 public class DeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_80.class, args); } }` 自定义的规则(这里我们参考Ribbon中默认的规则代码自己稍微改动)：MyRandomRule.java `public class MyRandomRule extends AbstractLoadBalancerRule { /** * 每个服务访问5次则换下一个服务(总共3个服务) * \u003cp\u003e * total=0,默认=0,如果=5","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:5","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.Feign：负载均衡(基于服务端) 6.1 Feign简介 Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Ribbon和Eureka，可以使用Feigin提供负载均衡的http客户端 只需要创建一个接口，然后添加注解即可~ Feign，主要是社区版，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法 微服务名字 【ribbon】 接口和注解 【feign】 Feign能干什么？ Feign旨在使编写Java Http客户端变得更容易 前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一个客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解)，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon 时，自动封装服务调用客户端的开发量。 Feign默认集成了Ribbon 利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。 6.2 Feign的使用步骤 创建springcloud-consumer-fdept-feign模块 拷贝springcloud-consumer-dept-80模块下的pom.xml，resource，以及java代码到springcloud-consumer-feign模块，并添加feign依赖。 `\u003c!--Feign的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-feign\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e` 通过Ribbon实现：—原来的controller：DeptConsumerController.java `package com.haust.springcloud.controller; import com.haust.springcloud.pojo.Dept; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import java.util.List; /** * @Auther: csp1999 * @Date: 2020/05/17/22:44 * @Description: */ @RestController public class DeptConsumerController { // 理解：消费者，不应该有service层~ // RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中 // (url, 实体：Map ,Class\u003cT\u003e responseType) @Autowired private RestTemplate restTemplate; //提供多种便捷访问远程http服务的方法，简单的Restful服务模板~ //Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 //private static final String REST_URL_PREFIX = \"http://localhost:8001\"; private static final String REST_URL_PREFIX = \"http://SPRINGCLOUD-PROVIDER-DEPT\"; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept) { return restTemplate.postForObject(REST_URL_PREFIX + \"/dept/add\", dept, Boolean.class); } @RequestMapping(\"/consumer/dept/get/{id}\") public Dept get(@PathVariable(\"id\") Long id) { return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/get/\" + id, Dept.class); } @RequestMapping(\"/consumer/dept/list\") public List\u003cDept\u003e list() { return restTemplate.getForObject(REST_URL_PREFIX + \"/dept/list\", List.class); } }` 通过Feign实现：—改造后controller：DeptConsumerController.java `@RestController public class DeptConsumerController { @Autowired private DeptClientService deptClientService = null; @RequestMapping(\"/consumer/dept/add\") public boolean add(Dept dept) { return this.deptClientService.addDept(dept); } @RequestMapping(\"/consumer/dept/get/{id}\") public Dept get(@PathVariable(\"id\") Long id) { return this.deptClientService.queryById(id); } @RequestMapping(\"/consumer/dept/list\") public List\u003cDept\u003e list() { return this.deptClientService.queryAll(); } }` Feign和Ribbon二者对比，前者显现出面向接口编程特点，代码看起来更清爽 主配置类 `@SpringBootApplication @EnableEurekaClient //feign客户端注解,并指定要扫描的包以及配置接口DeptClientService @EnableFeignClients(basePackages = {\"com.haust.springcloud\"}) //扫描所有自己的包,让所有注解也能生效 @ComponentScan(\"com.haust.springcloud\") public class FeignDeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(FeignDeptConsumer_80.class, args); } }` 改造springcloud-api模块 pom.xml添加feign依赖 `\u003c!--Feign的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-feign\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e` 新建service包，并新建DeptClientService.java接口， `//@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务 @FeignClient(value = \"SPRINGCLOUD-PROVIDER-DEPT\") public interface DeptClientService { @GetMapping(\"/dept/get/{id}\") public Dept queryById(@PathVariable(\"id\") Long id); @GetMapping(\"/dept/list\") public Dept queryAll(); @GetMap","date":"2021-04-17","objectID":"/simpread-springcloud%E7%AC%94%E8%AE%B0/:0:6","tags":["SpringCloud"],"title":"SpringCloud","uri":"/simpread-springcloud%E7%AC%94%E8%AE%B0/"},{"categories":["算法"],"content":"问题一：一个骰子怎么产生1/7的概率 问题等价于：一个骰子6个面均匀，现在有7个互斥事件，怎么扔能使7个事件均匀分布 答：一个骰子掷两次，共36种等概率的结果。 令其中的35种对应1-7，剩下的一种对应『再掷两次』。 比如：第一个骰子不为6时，第二个骰子掷出几就输出几（1-6，每种有五个可能）。第一个骰子为6，且第二个骰子不为6，输出7（有五个可能）。两个骰子都是6，重掷。于是1-7的概率都是5/36。而且永远掷6的概率是0，一定会在有限次内得到输出。 设第一次的投掷点数为x，第二次的投掷点数为y，则有f(x,y) = (x - 1) * 6 + y。 f(x,y)的取值范围是1~36，按照上述规则，可以达到题目要求 ","date":"2021-04-17","objectID":"/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7/:1:0","tags":[],"title":"骰子等概率1-7与数组","uri":"/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7/"},{"categories":["算法"],"content":"问题二：找出数组中出现次数超过一半的数 现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。 提示：出现次数超过一半的数一定只有一个 **方法一：**创建一个unordered_map，key为数组中的数，value为此数出现的次数。遍历一遍数组，用unordered_map统计每个数出现的次数，并用两个值存储目前出现次数最多的数和对应出现的次数。 这个解法是最简单的，我们来分析一下时间复杂度和空间复杂度,由于这个map底层实现使用hash算法来实现的，故时间复杂度可以为O（n），那么空间复杂度呢？很明显也是O(n)的。 public class HalfTimes { public static void main(String args[]){ int array[]={0,1,2,3,4,1,2,1,1,1,1,0,1,0,1,2,1,1,1,1}; int i = solution1(array); System.out.printf(\"数组中出现次数超过一半的数为：\"+i); } public static int solution1(int arrray[]){ Map\u003cInteger,Integer\u003e unordered_map=new HashMap\u003c\u003e(); for(int item:arrray){ if(unordered_map.containsKey(item)){ Integer value=unordered_map.get(item)+1; unordered_map.replace(item,value); }else{ unordered_map.put(item,1); } } Integer num=0; Integer times=arrray.length/2; for(Integer key:unordered_map.keySet()){ if(unordered_map.get(key)\u003etimes){ num=key; times=unordered_map.get(key); } } return num; } } 那能不能把空间复杂度降下来呢？ **方法二：**使用两个变量A和B，其中A存储某个数组中的数，B用来计数。开始时将B初始化为0。 遍历数组，如果B=0，则令A等于当前数，令B等于1；如果当前数与A相同，则B=B+1；如果当前数与A不同，则令B=B-1。遍历结束时，A中的数就是要找的数。为什么呢？因为题目中说了，那个元素一定是占了数组元素个数的一半以上，所以说，当我们每次删除两个不同的数，剩下存储A的值就是我们要求的结果值。 这个算法的时间复杂度是O(n)，空间复杂度为O(1)。 public static int solution2(int array[]){ int a=0; int b=0; for(int item:array){ if(b==0){ a=item; b=1; }else if(a==item){ b++; }else{ b--; } } return a; } {0,1,2,3,4,1,2,1,1,1,1,0,1,0,1,2,1,1,1,1}; 一共20个数，最多的数为1，共12个，其他数8个 必存在才正确 item a b 0 0 1 1 0 0 2 2 1 3 2 0 4 4 1 1 4 0 2 2 1 1 2 0 1 1 1 1 1 2 1 1 3 0 1 2 1 1 3 0 1 2 1 1 3 2 1 2 1 1 3 1 1 4 1 1 5 1 1 6 ","date":"2021-04-17","objectID":"/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7/:2:0","tags":[],"title":"骰子等概率1-7与数组","uri":"/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7/"},{"categories":["设计模式"],"content":"问题一：抽象工厂模式 某系统为了改进数据库操作的性能，自定义数据库连接对象Connection和语句对象Statement,可针对不同类型的数据库提供不同的连接对象和语句对象，如提供Oracle或MySQL专用连接类和语句类，而且用户可以通过配置文件等方式根据实际需要动态更换系统数据库。使用抽象工厂模式设计该系统。要求绘制类图并编程实现。 类图 代码实现： 抽象Connection接口： public interface Connection { } 具体实现类： public class OracleConnection implements Connection { } public class MySQLConnection implements Connection { } 抽象Statement接口： public interface Statement { } 具体实现类： public class MySQLStatement implements Statement { } public class OracleStatement implements Statement { } 抽象工厂类接口： public interface Factory { Connection createConnecttion(); Statement createStatement(); } 具体工厂实现类： public class MySQLFactory implements Factory { @Override public Connection createConnecttion() { System.out.println(\"正在创建MySQLConnection\"); return new MySQLConnection(); } @Override public Statement createStatement() { System.out.println(\"正在创建MySQLStatement\"); return new MySQLStatement(); } } public class OracleFactory implements Factory { @Override public Connection createConnecttion() { System.out.println(\"正在创建OracleConnection\"); return new OracleConnection(); } @Override public Statement createStatement() { System.out.println(\"正在创建OracleStatement\"); return new OracleStatement(); } } 辅助代码： public class XMLUtil { public static Object getType(){ try{ DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder(); Document document; document= documentBuilder.parse(new File(\"config.xml\")); NodeList nodeList=document.getElementsByTagName(\"type\"); Node classNode=nodeList.item(0).getFirstChild(); String string=classNode.getNodeValue().trim(); Class c=Class.forName(\"cn.hubu.www.\"+string); Object obj=c.newInstance(); return obj; }catch (Exception e) { e.printStackTrace(); return null; } } } client客户端： public class Client { public static void main(String args[]) { try { Connection connection; Statement statement; Factory factory= (Factory) XMLUtil.getType(); connection=factory.createConnecttion(); System.out.println(connection.getClass()); statement = factory.createStatement(); System.out.println(statement.getClass()); } catch (Exception e) { e.printStackTrace(); } } } 运行结果： 正在创建MySQLConnection class cn.hubu.www.MySQLConnection 正在创建MySQLStatement class cn.hubu.www.MySQLStatement ","date":"2021-04-16","objectID":"/%E5%AE%9E%E9%AA%8C%E4%B8%89-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:1","tags":[],"title":"实验三---抽象工厂模式、建造者模式","uri":"/%E5%AE%9E%E9%AA%8C%E4%B8%89-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"问题二：建造者模式 建造者模式实验：某游戏软件中人物角色包括多种类型，不同类型的人物角色，其性别、脸型、服装、发型等外部特性有所差异，使用建造者模式创建人物角色对象，要求绘制类图并编程实现。 代码如下： 人物角色GameRole类： public class GameRole { private String gender; private String face; private String cloth; private String hair; @Override public String toString() { return \"GameRole{\" + \"gender='\" + gender + '\\'' + \", face='\" + face + '\\'' + \", cloth='\" + cloth + '\\'' + \", hair='\" + hair + '\\'' + '}'; } public String getGender() { return this.gender; } public void setGender(String gender) { this.gender = gender; } public String getFace() { return face; } public void setFace(String face) { this.face = face; } public String getCloth() { return cloth; } public void setCloth(String cloth) { this.cloth = cloth; } public String getHair() { return hair; } public void setHair(String hair) { this.hair = hair; } } 抽象建造者类： public abstract class GameRoleBuilder { protected GameRole gameRole=new GameRole(); public abstract void buildGender(); public abstract void buildFace(); public abstract void builCloth(); public abstract void buildHair(); public GameRole getGameRole(){ return this.gameRole; } } 具体建造者类SubGameRoleBuilderA： public class SubGameRoleBuilderA extends GameRoleBuilder { @Override public void buildGender() { gameRole.setGender(\"男\"); } @Override public void buildFace() { gameRole.setFace(\"英俊帅气\"); } @Override public void builCloth() { gameRole.setCloth(\"李宁服饰\"); } @Override public void buildHair() { gameRole.setHair(\"黑色\"); } } 具体建造者类SubGameRoleBuilderB： public class SubGameRoleBuilderB extends GameRoleBuilder { @Override public void buildGender() { gameRole.setGender(\"女\"); } @Override public void buildFace() { gameRole.setFace(\"瓜子脸\"); } @Override public void builCloth() { gameRole.setCloth(\"JK\"); } @Override public void buildHair() { gameRole.setHair(\"黄色\"); } } 指挥者Director类： public class Director { private GameRoleBuilder gameRoleBuilder; public void setGameRoleBuilder(GameRoleBuilder gameRoleBuilder){ this.gameRoleBuilder=gameRoleBuilder; } public GameRole construct(){ gameRoleBuilder.buildGender(); gameRoleBuilder.buildFace(); gameRoleBuilder.builCloth(); gameRoleBuilder.buildHair(); return gameRoleBuilder.getGameRole(); } } 辅助代码与之前类似、、、、、 客户端： public class Client { public static void main(String args[]) { try { GameRoleBuilder gameRoleBuilder= (GameRoleBuilder) XMLUtil.getType(); Director director=new Director(); director.setGameRoleBuilder(gameRoleBuilder); GameRole gameRole=director.construct(); System.out.println(gameRole.toString()); } catch (Exception e) { e.printStackTrace(); } } } 运行结果： GameRole{gender='女', face='瓜子脸', cloth='JK', hair='黄色'} Process finished with exit code 0 ","date":"2021-04-16","objectID":"/%E5%AE%9E%E9%AA%8C%E4%B8%89-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:2","tags":[],"title":"实验三---抽象工厂模式、建造者模式","uri":"/%E5%AE%9E%E9%AA%8C%E4%B8%89-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"区别： ​ 抽象工厂模式比建造者模式的尺度要大，它关注产品整体，而建造者模式关注构建过程，因此建造者模式可以很容易地构建出一个崭新的产品，只要导演类能够提供具体的工艺流程。也正因为如此，两者的应用场景截然不同，如果希望屏蔽对象的创建过程，只提供一个封装良好的对象，则可以选择抽象工厂方法模式。而建造者模式可以用在构件的装配方面，如通过装配不同的组件或者相同组件的不同顺序，可以产生出一个新的对象，它可以产生一个非常灵活的架构，方便地扩展和维护系统。 ","date":"2021-04-16","objectID":"/%E5%AE%9E%E9%AA%8C%E4%B8%89-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:3","tags":[],"title":"实验三---抽象工厂模式、建造者模式","uri":"/%E5%AE%9E%E9%AA%8C%E4%B8%89-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["Windows"],"content":"最近新装的系统发现开机出现了两个引导，一个Windows10，一个Windows，但是只有第一个可以用，第二个用不了，那留着有什么用呢？果断删掉或禁用 Win+R输入msconfig，看到系统配置引导界面果然有两个引导，尝试删除一个，因为Windows10可用，就把第二个删除： 发现系统不让删除，不知道什么鬼畜操作，不让删除那就另寻捷径！！！ 打开此电脑属性，选择高级系统设置，选择高级，启动和故障恢复设置，取消勾选显示操作系统事件列表 设置完成后进入系统就直接进入默认的操作系统，而不会出现选择列表了哦 ","date":"2021-04-16","objectID":"/windows%E5%8F%8C%E5%BC%95%E5%AF%BC%E5%85%B3%E9%97%AD/:0:0","tags":["双引导解决"],"title":"Windows双引导关闭","uri":"/windows%E5%8F%8C%E5%BC%95%E5%AF%BC%E5%85%B3%E9%97%AD/"},{"categories":["设计模式"],"content":"模式动机 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 将客户端与包含多个部件的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可 关注如何逐步创建一个复杂的对象，不同的建造者定义了不同的创建过程 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 建造者模式可以用于描述KFC如何创建套餐：套餐是一个复杂对象，它一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。 产品类Meal： public class Meal { private String food; private String drink; public String getFood() { return food; } public void setFood(String food) { this.food = food; } public String getDrink() { return drink; } public void setDrink(String drink) { this.drink = drink; } } 抽象建造者类MealBuilder: public abstract class MealBuilder { protected Meal meal=new Meal(); public abstract void buildFood(); public abstract void buildDrink(); public Meal getMeal(){ return this.meal; } } 具体建造者类（A套餐） public class SubMealBuilderA extends MealBuilder { @Override public void buildFood() { meal.setFood(\"一个鸡腿\"); } @Override public void buildDrink() { meal.setDrink(\"一杯可乐\"); } } 具体建造者类（B套餐） public class SubMealBuilderB extends MealBuilder { @Override public void buildFood() { meal.setFood(\"一个鸡肉卷\"); } @Override public void buildDrink() { meal.setDrink(\"一杯果汁\"); } } 指挥者类（KFCWaiter） public class KFCWaiter { private MealBuilder mealBuilder; public void setMealBuilder(MealBuilder mealBuilder){ this.mealBuilder=mealBuilder; } public Meal construct(){ mealBuilder.buildFood(); mealBuilder.buildDrink(); return mealBuilder.getMeal(); } } 辅助代码与前面类似。。。。。。 客户端类： public class Client { public static void main(String args[]) { try { MealBuilder mealBuilder= (MealBuilder) XMLUtilTV.getType(); KFCWaiter kfcWaiter=new KFCWaiter(); kfcWaiter.setMealBuilder(mealBuilder); Meal meal = kfcWaiter.construct(); System.out.println(\"套餐组成\"); System.out.println(meal.getFood()); System.out.println(meal.getDrink()); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，符合开闭原则 可以更加精细地控制产品的创建过程 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:5:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，不适合使用建造者模式，因此其使用范围受到一定的限制 如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:6:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量 需要生成的产品对象的属性相互依赖，需要指定其生成顺序 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品 ","date":"2021-04-16","objectID":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:7:0","tags":["建造者模式"],"title":"建造者模式","uri":"/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 **产品等级结构：**产品等级结构即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 **产品族：**在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 一个电器工厂可以产生多种类型的电器，如海尔工厂可以生产海尔电视机、海尔空调等，TCL工厂可以生产TCL电视机、TCL空调等，相同品牌的电器构成一个产品族，而相同类型的电器构成了一个产品等级结构，现使用抽象工厂模式模拟该场景。 抽象产品接口： public interface TV { public void play(); } 具体产品类： public class HairTV implements TV { @Override public void play() { System.out.println(\"海尔电视播放中、、、、、\"); } } public class HisenseTV implements TV { @Override public void play() { System.out.println(\"海信电视播放中、、、\"); } } 抽象工厂类： public interface Factory { TV produceTV(); AirCondition produceAC(); } 具体工厂类: public class HairFactory implements Factory { @Override public TV produceTV() { System.out.println(\"海尔工厂生产海尔电视机。\"); return new HairTV(); } @Override public AirCondition produceAC() { System.out.println(\"海尔工厂生产海尔空调。\"); return new HairAirCondition(); } } public class HisenseFactory implements Factory { @Override public TV produceTV() { System.out.println(\"海信电视机工厂生产海信电视机。\"); return new HisenseTV(); } @Override public AirCondition produceAC() { System.out.println(\"海信没有空调\"); return null; } } public class TCLFactory implements Factory { @Override public TV produceTV() { System.out.println(\"TCL工厂类正在生产电视\"); return new TCLTV(); } @Override public AirCondition produceAC() { System.out.println(\"CL工厂类正在生产空调\"); return new TCLAirCondition(); } } 产品族抽象类： public interface AirCondition { void changeTemp(); } 具体实现类： public class TCLAirCondition implements AirCondition { @Override public void changeTemp() { System.out.println(\"TC课堂正在调节温度\"); } } public class HairAirCondition implements AirCondition { @Override public void changeTemp() { System.out.println(\"海尔空调正在调节温度\"); } } 辅助工具类： public class XMLUtilTV { public static Object getType(){ try{ DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder(); Document document; document= documentBuilder.parse(new File(\"config.xml\")); NodeList nodeList=document.getElementsByTagName(\"type\"); Node classNode=nodeList.item(0).getFirstChild(); String string=classNode.getNodeValue().trim(); System.out.println(string); Class c=Class.forName(\"io.hubu8.com.\"+string); Object obj=c.newInstance(); return obj; }catch (Exception e) { e.printStackTrace(); return null; } } } xml文件： \u003c?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u003e \u003cconfig\u003e \u003ctype\u003eHairFactory\u003c/type\u003e \u003c/config\u003e 客户端： public class Client { public static void main(String args[]) { try { TV tv; AirCondition airCondition; Factory factory=(Factory) XMLUtilTV.getType(); tv=factory.produceTV(); tv.play(); airCondition=factory.produceAC(); airCondition.changeTemp(); } catch (Exception e) { e.printStackTrace(); } } } TCLFactory TCL工厂类正在生产电视 TCL电视正在播放中、、、 CL工厂类正在生产空调 TC课堂正在调节温度 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 隔离了具体类的生成，使得客户端并不需要知道什么被创建 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 增加新的产品族很方便，无须修改已有系统，符合开闭原则 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:5:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:6:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节 系统中有多于一个的产品族，但每次只使用其中某一产品族 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来 产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构 ","date":"2021-04-16","objectID":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:7:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:1:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 工厂方法模式(Factory Method Pattern)简称工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。 在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:2:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 工厂方法模式是简单工厂模式的进一步抽象和推广 工厂方法模式保持了简单工厂模式的优点，并克服了它的缺点 核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给其子类去完成 可以允许系统在不修改工厂角色的情况下引进新产品 增加具体产品–\u003e增加具体工厂，符合“开闭原则” ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:3:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 将原有的电视机工厂进行分割，为每种品牌的电视机提供一个子工厂，海尔工厂专门负责生产海尔电视机，海信工厂专门负责生产海信电视机，如果需要生产TCL电视机或创维电视机，只需要对应增加一个新的TCL工厂或创维工厂即可，原有的工厂无须做任何修改，使得整个系统具有更加的灵活性和可扩展性。 抽象产品接口： public interface TV { public void play(); } 具体产品类： public class HairTV implements TV { @Override public void play() { System.out.println(\"海尔电视播放中、、、、、\"); } } public class HisenseTV implements TV { @Override public void play() { System.out.println(\"海信电视播放中、、、\"); } } 抽象工厂类： public interface TVFactory { public TV produceTV(); } 具体工厂类: public class HisenseTVFactory implements TVFactory { @Override public TV produceTV() { System.out.println(\"海信电视机工厂生产海信电视机。\"); return new HisenseTV(); } } public class HairTVFactory implements TVFactory { @Override public TV produceTV() { System.out.println(\"海尔电视机工厂生产海尔电视机。\"); return new HairTV(); } } 辅助工具类： public class XMLUtilTV { public static Object getType(){ try{ DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder(); Document document; document= documentBuilder.parse(new File(\"config.xml\")); NodeList nodeList=document.getElementsByTagName(\"type\"); Node classNode=nodeList.item(0).getFirstChild(); String string=classNode.getNodeValue().trim(); System.out.println(string); Class c=Class.forName(\"io.hubu8.com.\"+string); Object obj=c.newInstance(); return obj; }catch (Exception e) { e.printStackTrace(); return null; } } } xml文件： \u003c?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u003e \u003cconfig\u003e \u003ctype\u003eHairTVFactory\u003c/type\u003e \u003c/config\u003e 客户端： public class Client { public static void main(String args[]) { try { TV tv; TVFactory factory=(TVFactory) XMLUtilTV.getType(); System.out.println(factory); tv=factory.produceTV(); tv.play(); } catch (Exception e) { e.printStackTrace(); } } } HisenseTVFactory io.hubu8.com.HisenseTVFactory@1540e19d 海信电视机工厂生产海信电视机。 海信电视播放中、、、 如果需要新增一种类型的电视，只需要新增一个具体产品类和一个具体工厂类： public class TCLTV implements TV { @Override public void play() { System.out.println(\"TCL电视正在播放中、、、\"); } } public class TCLTVFactory implements TVFactory { @Override public TV produceTV() { System.out.println(\"TCL电视工厂类正在生产\"); return new TCLTV(); } } ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:4:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节 能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部 在系统中加入新产品时，完全符合开闭原则 ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:5:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销 增加了系统的抽象性和理解难度 ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:6:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 客户端不知道它所需要的对象的类（客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建） 抽象工厂类通过其子类来指定创建哪个对象 闹眼子呢？ java.lang.ClassNotFoundException: HisenseTVFactory at java.net.URLClassLoader.findClass(URLClassLoader.java:382) at java.lang.ClassLoader.loadClass(ClassLoader.java:418) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355) at java.lang.ClassLoader.loadClass(ClassLoader.java:351) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:264) at io.hubu8.com.XMLUtilTV.getType(XMLUtilTV.java:24) at io.hubu8.com.Client.main(Client.java:8) null java.lang.NullPointerException at io.hubu8.com.Client.main(Client.java:11) Process finished with exit code 0 需要在类名前面加上包名： Class c=Class.forName(\"io.hubu8.com.\"+string); ","date":"2021-04-16","objectID":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:7:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 只需要告知水果名称就可以得到相应的水果： ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式 在简单工厂模式中，可以根据参数的不同返回不同类的实例 简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过工厂类类名直接调用，只需要传入一个简单的参数即可，无须知道对象的创建细节 可以将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码 问题：工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 某电视机厂专为各知名电视机品牌代工生产各类电视机，当需要海尔牌电视机时只需要在调用该工厂的工厂方法时传入参数“Haier”，需要海信电视机时只需要传入参数“Hisense”，工厂可以根据传入的不同参数返回不同品牌的电视机。现使用简单工厂模式来模拟该电视机工厂的生产过程。 抽象产品接口： public interface TV { public void play(); } 具体产品类： public class HairTV implements TV { @Override public void play() { System.out.println(\"海尔电视播放中、、、、、\"); } } public class HisenseTV implements TV { @Override public void play() { System.out.println(\"海信电视播放中、、、\"); } } 工厂类： public class TVFactory { public static TV produceTV(String type) throws Exception { if(type.equalsIgnoreCase(\"Hair\")){ return new HairTV(); }else if(type.equalsIgnoreCase(\"Hisense\")){ return new HisenseTV(); }else{ throw new Exception(\"对不起，不支持的电视类型\"); } } } 客户端： public class Client { public static void main(String args[]) { TV tv; try { tv=TVFactory.produceTV(\"Hair\"); tv.play(); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:5:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 实现了对象创建和使用的分离 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:6:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响 增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度 系统扩展困难，一旦添加新产品不得不修改工厂逻辑 由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构，工厂类不能得到很好地扩展 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:7:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数 ","date":"2021-04-16","objectID":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:8:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"01 工厂方法 追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。 消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:1","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"02 建造者模式 MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。 建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:2","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"03 抽象工厂 请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。 工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:3","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"04 原型模式 跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要） 原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:4","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"05 单态模式 俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事) 单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:5","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"06 适配器模式 在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我) 适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:6","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"07 桥梁模式 早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了。 桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:7","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"08 合成模式 Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？ 合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:8","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"09 装饰模式 Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？ 装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:9","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"10 门面模式 我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。 门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:10","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"11 享元模式 每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。 享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。 将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:11","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"12 代理模式 跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。 代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。 客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:12","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"13 责任链模式 晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！ 责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:13","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"14 命令模式 俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。” 命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:14","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"15 解释器模式 俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。 解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。 在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:15","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"16 迭代模式 我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？” 迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。 迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:16","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"17 调停者模式 四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。 当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:17","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"18 备忘录模式 同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。 备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:18","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"19 观察者模式 想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。 观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:19","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"20 状态模式 跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。 状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。 状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:20","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"21 策略模式 跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。 策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:21","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"22 模板方法模式 看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)； 模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:22","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"23 访问者模式 情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了； 访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。 访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 ","date":"2021-04-16","objectID":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:23","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["运维"],"content":"单个微服务部署应用环境： Java：8 python3(pymysql、pandas、numpy、sklearn) ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:1:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"主代码功能： ​ 利用Java与前端交互，Java调用python文件以线程的方式在本地执行，Java也有一个python的依赖，但是可定制读不高，python库支持不完全。 ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:2:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"解决思路： ​ Java利用Process运行外部运行python命令以绝对路径运行py文件，做到java的jar包与python文件解耦，同时，python文件中用到的MySQL环境参数以环境变量获得。 ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:3:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"Java代码： @GetMapping(\"/associRule\") @ApiOperation(\"使用关联规则推荐比赛\") public String test(String uid){ Process proc; String line = null; try { String[] args1 = new String[] { \"python\", \"/data/comp_reco_AssociRule.py\",uid}; //python.exe处为你系统中python的安装位置；python.py为想要执行的python文件位置；test为想要传的参数 //proc = Runtime.getRuntime().exec(\"python.exe python.py \");// 执行py文件 不传参数 proc=Runtime.getRuntime().exec(args1); //用输入输出流来截取结果 BufferedReader in = new BufferedReader(new InputStreamReader(proc.getInputStream(),\"gbk\")); String temp=null; while ((temp = in.readLine()) != null) { line+=temp; } in.close(); proc.waitFor(); } catch (IOException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } return line; } ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:4:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"python部分代码： # 主要展示获取环境变量 if __name__ == \"__main__\": import os hostserver=os.environ.get('DATASOURCE_HOST') username=os.environ.get('DATASOURCE_USERNAME') pwd=os.environ.get('DATASOURCE_PASSWORD') import pandas as pd import pymysql conn = pymysql.connect(host=hostserver, port=3306, user=username, passwd=pwd,charset=\"utf8\") ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:5:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"dockerfile: docker环境要求，Java与python环境，挂载必要的目录，各部分解耦，方便修改代码： #Dockerfile_comp_rec# NOTE: this docker file is used to build runtime environment.# The project is a python app which contains a java jar lib.FROMpython:3MAINTAINERyangpf \u003ccherishpf@163.com\u003e# COPY ./requirements.txt /usr/local/src/requirements.txtRUN set -eux; \\ apt-get update; \\ apt-get install -y --no-install-recommends \\ bzip2 \\ unzip \\ xz-utils \\ \\ # utilities for keeping Debian and OpenJDK CA certificates in sync ca-certificates p11-kit \\ # \\ # java.lang.UnsatisfiedLinkError: /usr/local/openjdk-11/lib/libfontmanager.so: libfreetype.so.6: cannot open shared object file: No such file or directory# java.lang.NoClassDefFoundError: Could not initialize class sun.awt.X11FontManager# https://github.com/docker-library/openjdk/pull/235#issuecomment-424466077 fontconfig libfreetype6 \\ ; \\ rm -rf /var/lib/apt/lists/*# Default to UTF-8 file.encodingENV LANG C.UTF-8ENV JAVA_HOME /usr/local/openjdk-8ENV PATH $JAVA_HOME/bin:$PATH# backwards compatibility shimRUN { echo '#/bin/sh'; echo 'echo \"$JAVA_HOME\"'; } \u003e /usr/local/bin/docker-java-home \u0026\u0026 chmod +x /usr/local/bin/docker-java-home \u0026\u0026 [ \"$JAVA_HOME\" = \"$(docker-java-home)\" ]# https://adoptopenjdk.net/upstream.html# \u003e# \u003e What are these binaries?# \u003e# \u003e These binaries are built by Red Hat on their infrastructure on behalf of the OpenJDK jdk8u and jdk11u projects. The binaries are created from the unmodified source code at OpenJDK. Although no formal support agreement is provided, please report any bugs you may find to https://bugs.java.com/.# \u003eENV JAVA_VERSION 8u252ENV JAVA_BASE_URL https://github.com/AdoptOpenJDK/openjdk8-upstream-binaries/releases/download/jdk8u252-b09/OpenJDK8U-jre_ENV JAVA_URL_VERSION 8u252b09# https://github.com/docker-library/openjdk/issues/320#issuecomment-494050246# \u003e# \u003e I am the OpenJDK 8 and 11 Updates OpenJDK project lead.# \u003e ...# \u003e While it is true that the OpenJDK Governing Board has not sanctioned those releases, they (or rather we, since I am a member) didn't sanction Oracle's OpenJDK releases either. As far as I am aware, the lead of an OpenJDK project is entitled to release binary builds, and there is clearly a need for them.# \u003eRUN set -eux; \\ \\ dpkgArch=\"$(dpkg --print-architecture)\"; \\ case \"$dpkgArch\" in \\ amd64) upstreamArch='x64' ;; \\ arm64) upstreamArch='aarch64' ;; \\ *) echo \u003e\u00262 \"error: unsupported architecture: $dpkgArch\" ;; \\ esac; \\ \\ wget -O openjdk.tgz.asc \"${JAVA_BASE_URL}${upstreamArch}_linux_${JAVA_URL_VERSION}.tar.gz.sign\"; \\ wget -O openjdk.tgz \"${JAVA_BASE_URL}${upstreamArch}_linux_${JAVA_URL_VERSION}.tar.gz\" --progress=dot:giga; \\ \\ export GNUPGHOME=\"$(mktemp -d)\"; \\ # TODO find a good link for users to verify this key is right (https://mail.openjdk.java.net/pipermail/jdk-updates-dev/2019-April/000951.html is one of the only mentions of it I can find); perhaps a note added to https://adoptopenjdk.net/upstream.html would make sense?# no-self-sigs-only: https://salsa.debian.org/debian/gnupg2/commit/c93ca04a53569916308b369c8b218dad5ae8fe07 gpg --batch --keyserver ha.pool.sks-keyservers.net --keyserver-options no-self-sigs-only --recv-keys CA5F11C6CE22644D42C6AC4492EF8D39DC13168F; \\ # also verify that key was signed by Andrew Haley (the OpenJDK 8 and 11 Updates OpenJDK project lead)# (https://github.com/docker-library/openjdk/pull/322#discussion_r286839190) gpg --batch --keyserver ha.pool.sks-keyservers.net --recv-keys EAC843EBD3EFDB98CC772FADA5CD6035332FA671; \\ gpg --batch --list-sigs --keyid-format 0xLONG CA5F11C6CE22644D42C6AC4492EF8D39DC13168F \\ | tee /dev/stderr \\ | grep '0xA5CD6035332FA671' \\ | grep 'Andrew Haley'; \\ gpg --batch --verify openjdk.tgz.asc openjdk.tgz; \\ gpgconf --kill all; \\ rm -rf \"$GNUPGHOME\"; \\ \\ mkdir -p \"$JAVA_HOME\"; \\ tar --extract \\ --file openjdk.tgz \\ --directory \"$JAVA_HOME\" \\ --strip-components 1 \\ --no-same-owner \\ ; \\ rm openjdk.tgz*; \\ \\ # TODO strip \"demo\" and \"man\" folders? \\ # update \"cacerts\" bundle to use Debian's CA certificates (and make s","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:6:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"compose脚本，需要加入微服务网络，环境文件： version:'3'networks:dockercompose_sc-net:external:trueservices:#人员信息服务comp_rec:build:context:./Dockerfilesdockerfile:Dockerfile_comp_reccontainer_name:sc-comp_recrestart:alwaysnetworks:- \"dockercompose_sc-net\"ports:- 5000:9007volumes:- \"/home/hubu/dockerfiles/comp_rec:/data\"command:[\"java\",\"-jar\",\"/data/comp_rec.jar\"]env_file:.env ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:7:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":".env文件（主要存代码中用到的变量，以环境变量进入容器） DATASOURCE_DBTYPE=sc-mysql DATASOURCE_HOST=mysql DATASOURCE_PORT=3306 DATASOURCE_USERNAME=root DATASOURCE_PASSWORD=root123 DATASOURCE_DRIVER=com.mysql.jdbc.Driver ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:8:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"启动停止单个服务命令： docker-compose -f docker-compose_comp_rec.yml up -d docker-compose -f docker-compose_comp_rec.yml down 接口测试： ","date":"2021-04-15","objectID":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:9:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["Windows"],"content":"1 config.toml 配置 首先我们配置好 config.toml 的 algolia 的配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"hugo\" appID = \"CTZ67PPVA3\" searchKey = \"你的搜索密钥\" ","date":"2021-04-13","objectID":"/git_algolia_sh/:1:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2 Algolia 配置 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.1 登录 Algolia 官网 ，注册账号，创建 Application 名为 “test01”作为举例，默认选择 “FREE” 即可，这里自定义名称 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:1","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.2 我这里选择香港作为存储地区 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:2","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.3 创建index，要与config.toml 的配置 index 一样 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:3","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.4 将 API Keys 里面补充到 config.toml 里面 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:4","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3 使用 atomic-algolia 来完成自动更新索引 ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.1 首先安装 npm，这里不介绍 ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:1","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.2 安装 atomic-algolia npm -g install atomic-algolia --save ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:2","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.3 创建 .env 文件存放 algolia 配置 ALGOLIA_APP_ID=\"CTZ67PPVA3\" ALGOLIA_ADMIN_KEY=\"你的超级管理员密钥，上传json\" ALGOLIA_INDEX_NAME=\"hugo\" ALGOLIA_INDEX_FILE=\"public/index.json\" ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:3","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.4 修改根目录下的 package.json 文件（没有就新建），在 scripts 下添加 \"algolia\": \"atomic-algolia\" { \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" } } ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:4","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.5 上传索引的命令 你可以本地执行 npm run algolia 查看运行效果 ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:5","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"4 定制化脚本 #!/bin/sh # If a command fails then the deploy stops set -e start_local_hugo_server(){ hugo server --disableFastRender } update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia ！！！\\033[0m\\n\" sleep 10 } pushMyBlogHugo(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/hubu8/hubu8\"\\033[0m\\n\" git pull # Add changes to git. git add . # Commit changes. msg=\"change MyBlogHugo site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/hubu8/hubu8.github.io\"\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public pwd git pull # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push sleep 10 } case $1 in 1) start_local_hugo_server ;; 2) pushMyBlogHugo $* ;; 3) push_public $* ;; 4) update_algolia ;; 5) hugo serve -e production ;; 6) hugo server --source=themes/LoveIt/exampleSite ;; esac 脚本解析： sh deploy.sh 1：启动 hugo 作为本地调试使用，实时将文章的内容更新到站点，不需要重启也能边修改边观看效果。 sh deploy.sh 2：将 MyHugoBlog 上传到 Github 存储库。 sh deploy.sh 3：将 public 静态文件站点上传到Github Pages 存储库。 sh deploy.sh 4：更新 algolia 的索引. sh deploy.sh 5：主要是用来调试 cdn，评论系统等，所以要用 production 变量来启动。 sh deploy.sh 6：查看官方例子，方便调试。 仓库代码检验： algolia 的索引: ","date":"2021-04-13","objectID":"/git_algolia_sh/:4:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"应用场景： 搭建hugo静态博客时，只需要上传public目录下的静态资源，但是为了源文件不丢失，也想把根目录上传到另一个仓库备份。但是这样就有了两个仓库，每次推送代码需要push两次，比较麻烦 蠢人有蠢人的办法，写一个批处理脚本，在脚本中在两个目录push: echo \"Start submitting code to the local repository\" echo \"The current directory is:%cd%\" git add . echo; echo \"Commit the changes to the local repository\" set now=%date% %time% echo %now% git commit -m \"%now%\" echo; echo \"Commit the changes to the remote git server\" git push echo; echo \"Batch execution complete!\" echo; hugo cd public echo \"Start submitting code to the local repository\" echo \"The current directory is:%cd%\" git add . echo; echo \"Commit the changes to the local repository\" set now=%date% %time% echo %now% git commit -m \"%now%\" echo; echo \"Commit the changes to the remote git server\" git push echo; echo \"Batch execution complete!\" echo; echo. \u0026 pause 最后按任意键退出。 ","date":"2021-04-13","objectID":"/git_bat/:0:0","tags":["bat批处理脚本"],"title":"Git_bat","uri":"/git_bat/"},{"categories":["nginx"],"content":"nginx 项目最初上线的时候并发量小、用户使用少，所以在低并发的情况下，一个Jar包、一个tomcat服务器就够了 但是用户多了，并发量就增大了，这时候一台服务器就不能满足需求，于是可以横向扩展服务器，这时候几个项目启动在不同的服务器上，由于session不共享，就需要一个代理服务器，通过代理服务器请求转发： 我们希望这个代理服务器可以帮助我们接受用户请求，然后按照规则转发在不同服务器上，这个过程用户是无感知的，用户并不知道哪台服务器在返回结果，还希望它可以按照服务器性能提供不同的权重选择 ","date":"2021-04-12","objectID":"/nginx/:1:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"什么是nginx Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 在高连接并发的情况下，Nginx是Apache服务器不错的替代品。 nginx相对于apache的优点： 轻量级，同样起web 服务，比apache 占用更少的内存及资源 ，抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能，高度模块化的设计，编写模块相对简单 ，社区活跃，各种高性能模块出品迅速。 官方数据统计表明能够支持50000个并发量。 ","date":"2021-04-12","objectID":"/nginx/:2:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"nginx作用 http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。 ","date":"2021-04-12","objectID":"/nginx/:3:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"正向代理： 例如我们用的VPN，相当于一个中介跳转；正向代理代理的是客户端，反向代理代理的是服务器。 ","date":"2021-04-12","objectID":"/nginx/:3:1","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"反向代理： ","date":"2021-04-12","objectID":"/nginx/:3:2","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"负载均衡： nginx提供两种负载均衡策略：内置策略和扩展策略；内置策略为轮询、加权轮询，ip hash;扩展策略就是天马行空，任意的定制 轮询： 加权轮询： ip hash: 动静分离： 动静分离，通过中间将动静分离和静态请求进行分离； 通过中间件将动态请求和静态请求分离，可以建上不必要的请求消耗，同时能减少请求的延时。 通过中间件将动态请求和静态请求分离，逻辑图如下 : 动静分离只有好处：动静分离后，即使动态服务不可用，但静态资源不会受到影响。 ","date":"2021-04-12","objectID":"/nginx/:3:3","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"nginx安装： 官网地址：http://nginx.org/en/download.html ","date":"2021-04-12","objectID":"/nginx/:4:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"Windows下安装： 1、官网下载稳定版本，下载即运行，不用任何安装 2、命令行输入nginx.exe,双击运行一闪而过看不到效果，浏览查看80端口： ","date":"2021-04-12","objectID":"/nginx/:4:1","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"linux下安装： 1、官网下载稳定版本，上传到服务器： 2、解压安装： #解压 tar -zxvf nginx-1.18.0.tar.gz #执行配置 ./configure #执行make命令： make make install 第三步报错： ./configure: error: the HTTP rewrite module requires the PCRE library. You can either disable the module by using --without-http_rewrite_module option, or install the PCRE library into the system, or build the PCRE library statically from the source with nginx by using --with-pcre=\u003cpath\u003e option. #执行命令 安装pcre-devel yum -y install pcre-devel 依旧报错： ./configure: error: the HTTP gzip module requires the zlib library. You can either disable the module by using --without-http_gzip_module option, or install the zlib library into the system, or build the zlib library statically from the source with nginx by using --with-zlib=\u003cpath\u003e option. #安装zlib wget http://www.zlib.net/zlib-1.2.11.tar.gz tar -xzvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make make install 3、查看是否安装成功： [root@jd nginx-1.18.0]# whereis nginx nginx: /usr/local/nginx [root@jd nginx-1.18.0]# cd /usr/local/nginx/ [root@jd nginx]# ls conf html logs sbin [root@jd nginx]# ./sbin/nginx [root@jd nginx]# curl localhost \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eWelcome to nginx!\u003c/title\u003e \u003cstyle\u003e body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eWelcome to nginx!\u003c/h1\u003e \u003cp\u003eIf you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u003c/p\u003e \u003cp\u003eFor online documentation and support please refer to \u003ca href=\"http://nginx.org/\"\u003enginx.org\u003c/a\u003e.\u003cbr/\u003e Commercial support is available at \u003ca href=\"http://nginx.com/\"\u003enginx.com\u003c/a\u003e.\u003c/p\u003e \u003cp\u003e\u003cem\u003eThank you for using nginx.\u003c/em\u003e\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 4、nginx常用命令： cd /usr/local/nginx/sbin/ ./nginx #启动 ./nginx -s stop #停止 ./nginx -s quit #安全退出 ./nginx -s reload #重新加载配置文件 ps aux|grep nginx #查看nginx进程 ","date":"2021-04-12","objectID":"/nginx/:4:2","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"nginx配置使用： 应用场景：现在有多台配置不一样的服务器，根据服务器性能设置不同的权重轮询： 配置实例：8000代表一台服务器，8001代表一台服务器，加权轮询1：3 upstream eccentric{ server 127.0.0.1:8000 weight=1; server 127.0.0.1:8001 weight=3; } server { listen 7999; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location /hello { root html; index index.html index.htm; proxy_pass http://eccentric; } #访问后台管理系统/admin location /admin { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } 本地模拟两个服务器： java -jar democompose-0.0.1-SNAPSHOT.jar --server.port=8000 java -jar democompose-0.0.1-SNAPSHOT.jar --server.port=8001 本地访问localhost:7999: 两台服务器接受到的请求次数： Windows双击运行nginx.exe带来的问题，没有办法通过命令行关闭，nginx80端口一直被占用： #查看占用80端口的进程 netstat -ano | findstr \":80 \" #查看对应进程的应用 tasklist /fi \"PID eq 752\" #杀死进程 taskkill /pid 752 /f #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream eccentric{ server 127.0.0.1:8000 weight=1; server 127.0.0.1:8001 weight=3; } server { listen 7999; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location /hello { root html; index index.html index.htm; proxy_pass http://eccentric; } #访问后台管理系统/admin location /admin { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #} } ","date":"2021-04-12","objectID":"/nginx/:5:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"实际开发生成环境中需要频繁修改代码或者环境变量的值（例如：服务器ip,数据库密码等），如果频繁去修改代码重新上线需要花费大量的事件，为了解决这一问题，今天用到了docker-compose中的env_file： 应用环境变量设置，不用修改代码，重新打包 代码之间解耦，提高可读性 应用环境： Spring Cloud docker ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:0:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"简介 springboot配置文件如下： spring:cloud:bus:trace:enabled:truerabbitmq:host:${RABBIT_MQ_HOST:localhost}port:${RABBIT_MQ_PORT:5672}username:${RABBIT_MQ_USERNAME:guest}password:${RABBIT_MQ_PASSWORD:guest}redis:host:${REDIS_HOST:localhost}port:${REDIS_PORT:6379}lettuce:pool:max-active:300#password: ${REDIS_PASSWORD:123456}datasource:driver-class-name:com.mysql.jdbc.Driverurl:jdbc:${DATASOURCE_DBTYPE:mysql}://${DATASOURCE_HOST:localhost}:${DATASOURCE_PORT:3306}/sys_users?characterEncoding=UTF-8\u0026useUnicode=true\u0026useSSL=falseusername:${DATASOURCE_USERNAME:root}password:${DATASOURCE_PASSWORD:root123} **${RABBIT_MQ_HOST:localhost}**的含义：如果MQ_HOST设置的有值，就用他；如果没有设置值，就用localhost默认值，这样写的好处是做到全局配置的统一性，避免改配置多处修改； 在开发环节为了调试方便，我们可以在application.yml文件中添加如下配置， DATASOURCE_HOST:191.168.1.105DATASOURCE_PORT:7000DATASOURCE_PASSWORD:root123DATASOURCE_USERNAME:root 但是当部署到生产环境这样写没有任何意义，当需要修改变量值，还是需要重新打包。 为此docker-compose提供了一种解决方案：从文件添加环境变量。可以是单个值或列表的多个值【env_file】： DATASOURCE_DBTYPE=sc-mysql DATASOURCE_HOST=mysql DATASOURCE_PORT=3306 DATASOURCE_USERNAME=root DATASOURCE_PASSWORD=root123 DATASOURCE_DRIVER=com.mysql.jdbc.Driver 只需要在docker-compose文件中的某个service下添加： env_file:.env 或者： env_file:- ./common.env- ./apps/web.env- /opt/secrets.env 通过以上配置就可以把相关的环境变量的值存进你的image ps:同一个变量多次赋值，以最后一次为准，覆盖前面的旧值 ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:1:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"场景应用： 利用docker-compose启动web服务，做到改变IP、密码等配置时不修改代码 ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"1、信件env结尾的文件： ### 数据源mysql实例 DATASOURCE_DBTYPE=mysql DATASOURCE_HOST=sc-mysql DATASOURCE_PORT=3306 DATASOURCE_USERNAME=root DATASOURCE_PASSWORD=root123 DATASOURCE_DRIVER=com.mysql.jdbc.Driver ### 分布式缓存 REDIS_HOST=redis REDIS_PORT=6379 ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:1","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"2、编写docker-compose文件添加env_file: # docker-compose.person.ymlversion:'3'services:#人员信息服务person_info:image:java:8container_name:sc-person_inforestart:alwaysnetworks:- sc-netports:- 9009:9009volumes:- \"/home/hubu/dockerfiles/person_info:/data\"command:[\"java\",\"-jar\",\"/data/person.jar\"]env_file:.env ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:2","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"3、上传服务器相关文件，生成镜像，运行容器： # 还运行了其他docker-compose,-f指定文件 docker-compose -f docker-compose.yml -f docker-compose.person.yml -f docker-compose.auth.yml up -d #关闭： docker-compose -f docker-compose.yml -f docker-compose.person.yml -f docker-compose.auth.yml down ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:3","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"4、查看环境变量是否进入容器： #通过docker logs 查看系统日志，如果没有错误就是正确的 docker exec -it sc-person_info /bin/bash env ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:4","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"5、愉快地开始部署项目了！！！ ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:5","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"6、日常小计 限制内存(1.20版本以上)： version:'3'networks:dockercompose_sc-net:external:trueservices:#人员信息服务comp:image:java:8container_name:sc-comprestart:alwaysnetworks:- \"dockercompose_sc-net\"# networks:# - sc-netports:- 5002:9011volumes:- \"/home/hubu/dockerfiles/comp:/data\"deploy:resources:limits:cpus:'0.50'memory:1Gcommand:[\"java\",\"-jar\",\"/data/comp.jar\"]env_file:.env 运行加参数： docker-compose --compatibility up -d ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:6","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["Java后端"],"content":"抽了点时间，整理了一些 maven 常用命令参数，以便参考； ","date":"2021-04-11","objectID":"/mvn/:0:0","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"mvn 命令参数 mvn -v, –version 显示版本信息; mvn -V, –show-version 显示版本信息后继续执行 Maven 其他目标; mvn -h, –help 显示帮助信息; mvn -e, –errors 控制 Maven 的日志级别, 产生执行错误相关消息; mvn -X, –debug 控制 Maven 的日志级别, 产生执行调试信息; mvn -q, –quiet 控制 Maven 的日志级别, 仅仅显示错误; mvn -Pxxx 激活 id 为 xxx 的 profile (如有多个，用逗号隔开); mvn -Dxxx=yyy 指定 java 全局属性; mvn -o , –offline 运行 offline 模式, 不联网更新依赖; mvn -N, –non-recursive 仅在当前项目模块执行命令, 不构建子模块; mvn -pl, –module_name 在指定模块上执行命令; mvn -ff, –fail-fast 遇到构建失败就直接退出; mvn -fn, –fail-never 无论项目结果如何, 构建从不失败; mvn -fae, –fail-at-end 仅影响构建结果, 允许不受影响的构建继续; mvn -C, –strict-checksums 如果校验码不匹配的话, 构建失败; mvn -c, –lax-checksums 如果校验码不匹配的话, 产生告警; mvn -U 强制更新 snapshot 类型的插件或依赖库 (否则 maven 一天只会更新一次 snapshot 依赖); mvn -npu, –no-plugin-updates 对任何相关的注册插件, 不进行最新检查 (使用该选项使 Maven 表现出稳定行为，该稳定行为基于本地仓库当前可用的所有插件版本); mvn -cpu, –check-plugin-updates 对任何相关的注册插件, 强制进行最新检查 (即使项目 POM 里明确规定了 Maven 插件版本, 还是会强制更新); mvn -up, –update-plugins [mvn -cpu] 的同义词; mvn -B, –batch-mode 在非交互（批处理）模式下运行 (该模式下, 当 Mven 需要输入时, 它不会停下来接受用户的输入, 而是使用合理的默认值); mvn -f, –file 强制使用备用的 POM 文件; mvn -s, –settings 用户配置文件的备用路径; mvn -gs, –global-settings 全局配置文件的备用路径; mvn -emp, –encrypt-master-password 加密主安全密码, 存储到 Maven settings 文件里; mvn -ep, –encrypt-password 加密服务器密码, 存储到 Maven settings 文件里; mvn -npr, –no-plugin-registry 对插件版本不使用~/.m2/plugin-registry.xml(插件注册表) 里的配置; ","date":"2021-04-11","objectID":"/mvn/:0:1","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"mvn 常用命令 创建 Maven 的普通 java 项目： mvn archetype:create -DgroupId=packageName -DartifactId=projectName 创建 Maven 的 Web 项目： mvn archetype:create -DgroupId=packageName -DartifactId=webappName -DarchetypeArtifactId=maven-archetype-webapp 编译源代码：mvn compile 编译测试代码：mvn test-compile 运行测试：mvn test 产生 site：mvn site 打包：mvn package 在本地 Repository 中安装 jar：mvn install 清除产生的项目：mvn clean 生成 eclipse 项目：mvn eclipse:eclipse 生成 idea 项目：mvn idea:idea 组合使用 goal 命令，如只打包不测试：mvn -Dtest package 编译测试的内容：mvn test-compile 只打 jar 包: mvn jar:jar 只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile (-skipping 的灵活运用，当然也可以用于其他组合命令) 清除 eclipse 的一些系统设置: mvn eclipse:clean ps 一般使用情况是这样，首先通过 cvs 或 svn 下载代码到本机，然后执行 mvn eclipse:eclipse 生成 ecllipse 项目文件，然后导入到 eclipse 就行了；修改代码后执行 mvn compile 或 mvn test 检验，也可以下载 eclipse 的 maven 插件。 mvn -version/-v 显示版本信息 mvn archetype:generate 创建 mvn 项目 mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app 创建 mvn 项目 mvn package 生成 target 目录，编译、测试代码，生成测试报告，生成 jar/war 文件 mvn jetty:run 运行项目于 jetty 上, mvn compile 编译 mvn test 编译并测试 mvn clean 清空生成的文件 mvn site 生成项目相关信息的网站 mvn -Dwtpversion=1.0 eclipse:eclipse 生成 Wtp 插件的 Web 项目 mvn -Dwtpversion=1.0 eclipse:clean 清除 Eclipse 项目的配置信息 (Web 项目) mvn eclipse:eclipse 将项目转化为 Eclipse 项目 在应用程序用使用多个存储库 \u003crepositories\u003e \u003crepository\u003e \u003cid\u003eIbiblio\u003c/id\u003e \u003cname\u003eIbiblio\u003c/name\u003e \u003curl\u003ehttp://www.ibiblio.org/maven/\u003c/url\u003e \u003c/repository\u003e \u003crepository\u003e \u003cid\u003ePlanetMirror\u003c/id\u003e \u003cname\u003ePlanet Mirror\u003c/name\u003e \u003curl\u003ehttp://public.planetmirror.com/pub/maven/\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e 命令： mvn deploy:deploy-file -DgroupId=com -DartifactId=client -Dversion=0.1.0-Dpackaging=jar -Dfile=d:\\client-0.1.0.jar-DrepositoryId=maven-repository-inner -Durl=ftp://xxxxxxx/opt/maven/repository/ 发布第三方 Jar 到本地库中： mvn install:install-file -DgroupId=com -DartifactId=client -Dversion=0.1.0-Dpackaging=jar -Dfile=d:\\client-0.1.0.jar -DdownloadSources=true -DdownloadJavadocs=true mvn -e 显示详细错误 信息. mvn validate 验证工程是否正确，所有需要的资源是否可用。 mvn test-compile 编译项目测试代码。 mvn integration-test 在集成测试可以运行的环境中处理和发布包。 mvn verify 运行任何检查，验证包是否有效且达到质量标准。 mvn generate-sources 产生应用需要的任何额外的源代码，如 xdoclet。 ","date":"2021-04-11","objectID":"/mvn/:0:2","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"mvn 常用命令 2 mvn -v 显示版本 mvn help:describe -Dplugin=help 使用 help 插件的 describe 目标来输出 Maven Help 插件的信息。 mvn help:describe -Dplugin=help -Dfull 使用 Help 插件输出完整的带有参数的目标列 mvn help:describe -Dplugin=compiler -Dmojo=compile -Dfull 获取单个目标的信息, 设置 mojo 参数和 plugin 参数。此命令列出了 Compiler 插件的 compile 目标的所有信息 mvn help:describe -Dplugin=exec -Dfull 列出所有 Maven Exec 插件可用的目标 mvn help:effective-pom 看这个 “有效的 (effective)”POM，它暴露了 Maven 的默认设置 mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 -DartifactId=simple -DpackageName=org.sonatype.mavenbook 创建 Maven 的普通 java 项目，在命令行使用 Maven Archetype 插件 mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main Exec 插件让我们能够在不往 classpath 载入适当的依赖的情况下，运行这个程序 mvn dependency:resolve 打印出已解决依赖的列表 mvn dependency:tree 打印整个依赖树 mvn install -X 想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开 Maven 的调试标记运行 mvn install -Dmaven.test.skip=true 给任何目标添加 maven.test.skip 属性就能跳过测试 mvn install assembly:assembly 构建装配 Maven Assembly 插件是一个用来创建你应用程序特有分发包的插件 mvn jetty:run 调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用 mvn compile 编译你的项目 mvn clean install 删除再编译 mvn hibernate3:hbm2ddl 使用 Hibernate3 插件构造数据库 ","date":"2021-04-11","objectID":"/mvn/:0:3","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"阿里云短信服务 1、添加用户组和相关权限 2、创建一个用户、获取相应的Acessce Key 要将这个账户保存下来，只显示一次，如果被泄露马上禁用生成新的，后面需要用到 开通阿里云短信服务 帮助指南 1、开通短信服务，找到短信控制台面板 2、添加短信模板、添加签名（中括号里面的名称） 编写代码测试 在pom文件中添加如下依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-core\u003c/artifactId\u003e \u003cversion\u003e4.5.16\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.62\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e 2、编写服务与服务实现： package com.example.democompose.Service.Impl; import com.alibaba.fastjson.JSONObject; import com.aliyuncs.CommonRequest; import com.aliyuncs.CommonResponse; import com.aliyuncs.DefaultAcsClient; import com.aliyuncs.IAcsClient; import com.aliyuncs.exceptions.ClientException; import com.aliyuncs.exceptions.ServerException; import com.aliyuncs.http.MethodType; import com.aliyuncs.profile.DefaultProfile; import com.example.democompose.Service.SendSms; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.Map; @Service public class SendSmsImpl implements SendSms { @Override public boolean send(String phoneNum, String templateCode, Map\u003cString, Object\u003e map) { DefaultProfile profile = DefaultProfile.getProfile(\"cn-qingdao\", \"accessKeyIdxxxxxx\", \"accessKeySecretxxxxxxx\"); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); request.setSysMethod(MethodType.POST); request.setSysDomain(\"dysmsapi.aliyuncs.com\"); request.setSysVersion(\"2017-05-25\"); request.setSysAction(\"SendSms\"); request.putQueryParameter(\"PhoneNumbers\", phoneNum); request.putQueryParameter(\"SignName\", \"东猿叔\"); request.putQueryParameter(\"TemplateCode\", templateCode); request.putQueryParameter(\"TemplateParam\", JSONObject.toJSONString(map)); try { CommonResponse response = client.getCommonResponse(request); System.out.println(response.getData()); return response.getHttpResponse().isSuccess(); } catch (ServerException e) { e.printStackTrace(); } catch (ClientException e) { e.printStackTrace(); } return false; } } 3、controller调用： package com.example.democompose.Controller; import com.aliyuncs.utils.StringUtils; import com.example.democompose.Service.SendSms; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import java.util.HashMap; import java.util.UUID; import java.util.concurrent.TimeUnit; @RestController @CrossOrigin public class SendSmsController { @Autowired private SendSms sendSms; @Autowired private RedisTemplate redisTemplate; @GetMapping(\"/send/{phone}\") public String code(@PathVariable(\"phone\")String phone){ String code=(String) redisTemplate.opsForValue().get(phone); if(!StringUtils.isEmpty(code)){ return phone+\":\"+code+\"已经存在，还没有过期\"; } code = UUID.randomUUID().toString().substring(0, 4); HashMap\u003cString,Object\u003e param=new HashMap\u003c\u003e(); param.put(\"code\",code); boolean isSend = sendSms.send(phone, \"SMS_215116099\", param); if(isSend){ redisTemplate.opsForValue().set(phone,code,5, TimeUnit.MINUTES); return phone+\":\"+code+\"发送成功\"; }else{ return phone+\":\"+code+\"发送失败\"; } } } ","date":"2021-04-10","objectID":"/message/:0:0","tags":["短信验证码"],"title":"短信验证码实现","uri":"/message/"},{"categories":["运维"],"content":"Docker Compose Using Compose is basically a three-step process: Define your app’s environment with a Dockerfile so it can be reproduced anywhere. Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment. Run docker compose up and the Docker compose command starts and runs your entire app. You can alternatively run docker-compose up using the docker-compose binary. Compose是官方的开源项目，需要安装， ​ Dockerfile可以让程序在任何地方运行，但是现在有一个web服务，但是它又需要redis、MySQL、nginx等多个容器，一个一个启动就会十分麻烦。 Compose例子： version:\"3.9\"# optional since v1.27.0services:web:build:.ports:- \"5000:5000\"volumes:- .:/code- logvolume01:/var/loglinks:- redisredis:image:redisvolumes:logvolume01:{} ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:0:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"安装Compose 1、下载： sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo curl -L \"https://get.daocloud.io/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 2、授权 sudo chmod +x /usr/local/bin/docker-compose 3、全局使用 [root@node4 /]# docker-compose version docker-compose version 1.29.0, build 07737305 docker-py version: 5.0.0 CPython version: 3.7.10 OpenSSL version: OpenSSL 1.1.0l 10 Sep 2019 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:1:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"快速体验 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 1: 创建应用 Define the application dependencies. Create a directory for the project(创建目录): $ mkdir composetest $ cd composetest Create a file called app.py in your project directory and paste this in（创建python文件）: import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) 在这个例子中, redis 是应用网络中redis的容器名称. 使用端口, 6379. 注意get_hit_coun函数的编写方式。这个基本的重试循环允许我们在redis服务不可用时多次尝试请求。当应用程序上线时，这在启动时很有用，但如果在应用程序的生命周期内需要随时重新启动Redis服务，也会使我们的应用程序更有弹性。在集群中，这也有助于处理节点之间的瞬时连接中断。 创建 requirements.txt 文件: flask redis ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 2: 编写Dockerfile 这一步将编写dockerfile并build image ,这个镜像包含了python所需要的环境 Dockerfile 文件: FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP=app.py ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers COPY requirements.txt requirements.txt RUN pip install -r requirements.txt EXPOSE 5000 COPY . . CMD [\"flask\", \"run\"] This tells Docker to: Build an image starting with the Python 3.7 image. Set the working directory to /code. Set environment variables used by the flask command. Install gcc and other dependencies Copy requirements.txt and install the Python dependencies. Add metadata to the image to describe that the container is listening on port 5000 Copy the current directory . in the project to the workdir . in the image. Set the default command for the container to flask run. For more information on how to write Dockerfiles, see the Docker user guide and the Dockerfile reference. ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 3: 在Compose文件中定义Service 创建 docker-compose.yml 文件: version: \"3.9\" services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 这个Compose声明了两个service: web and redis. [root@node4 composetest]# ll 总用量 16 -rw-r--r--. 1 root root 514 4月 9 16:48 app.py -rw-r--r--. 1 root root 111 4月 9 17:00 docker-compose.yml -rw-r--r--. 1 root root 252 4月 9 16:50 Dockerfile -rw-r--r--. 1 root root 12 4月 9 16:49 requirements.txt ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 4: 用Compose启动多个容器 docker-compose up [root@node4 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9a28f238ee73 composetest_web \"flask run\" 34 seconds ago Up 32 seconds 0.0.0.0:5000-\u003e5000/tcp composetest_web_1 e4cb9836d38d redis:alpine \"docker-entrypoint.s…\" 34 seconds ago Up 32 seconds 6379/tcp composetest_redis_1 [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 1 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 2 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 3 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 4 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 5 times. [root@node4 ~]# docker network inspect composetest_default [ { \"Name\": \"composetest_default\", \"Id\": \"25ec9a55f82b6ff2c9b190c911cf6a89ce998759b912c3f2dbf5c2849a6c89d5\", \"Created\": \"2021-04-09T17:01:45.524551071+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": null, \"Config\": [ { \"Subnet\": \"172.18.0.0/16\", \"Gateway\": \"172.18.0.1\" } ] }, \"Internal\": false, \"Attachable\": true, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"9a28f238ee7334688d70f20a2838cbcea964bb3f1282b99b4c787b61370bd202\": { \"Name\": \"composetest_web_1\", \"EndpointID\": \"920c033116c19419b0e2807f75284d768436cb272735642b7e8257f9564d9e45\", \"MacAddress\": \"02:42:ac:12:00:03\", \"IPv4Address\": \"172.18.0.3/16\", \"IPv6Address\": \"\" }, \"e4cb9836d38deb2d2dbd4211106dd2364ace9f97ab5e8827736fc7d39b5ba166\": { \"Name\": \"composetest_redis_1\", \"EndpointID\": \"7f359906cf87650c9ef25939d25c7cfe070ac1135855ff888f1b7a881682aa31\", \"MacAddress\": \"02:42:ac:12:00:02\", \"IPv4Address\": \"172.18.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": { \"com.docker.compose.network\": \"default\", \"com.docker.compose.project\": \"composetest\", \"com.docker.compose.version\": \"1.29.0\" } } ] 流程： 创建网络 执行docker-compose.yml 启动服务 默认规则： 默认服务名（容器名）：文件夹名_服务名__num num为副本数量，因为服务不可能只有一个，弹性扩容，高可用 docker images 会自动pull所需images docker network ls 自动生成网络（同一个网络通过service名称连通） composetest_自定义网络名称 停止compose： docker-compose down ctrl+c #一键停止所有容器 ^CGracefully stopping... (press Ctrl+C again to force) Stopping composetest_web_1 ... Stopping composetest_web_1 ... done ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"yml文件编写规则 compose文件编写参考：https://docs.docker.com/compose/compose-file/compose-file-v3/ #第一层version:''#向下兼容#第二层service:#服务服务1:#服务配置images:build:network:...服务2:...#第三层volumes:network:config:... 多看官方文档，开源项目的compose ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"部署Woedpress项目 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"1、创建目录： mkdir my_wordpress cd my_wordpress/ ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"2、创建compose文件： nano docker-compose.ymlversion:\"3.9\"services:db:image:mysql:5.7volumes:- db_data:/var/lib/mysqlrestart:alwaysenvironment:MYSQL_ROOT_PASSWORD:somewordpressMYSQL_DATABASE:wordpressMYSQL_USER:wordpressMYSQL_PASSWORD:wordpresswordpress:depends_on:- dbimage:wordpress:latestports:- \"8000:80\"restart:alwaysenvironment:WORDPRESS_DB_HOST:db:3306WORDPRESS_DB_USER:wordpressWORDPRESS_DB_PASSWORD:wordpressWORDPRESS_DB_NAME:wordpressvolumes:db_data:{} ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"3、启动： docker-compose up -d #后台启动 [root@node4 my_wordpress]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a56f5f6a9eb6 wordpress:latest \"docker-entrypoint.s…\" About a minute ago Up About a minute 0.0.0.0:8000-\u003e80/tcp my_wordpress_wordpress_1 63f261196b58 mysql:5.7 \"docker-entrypoint.s…\" About a minute ago Up About a minute 3306/tcp, 33060/tcp my_wordpress_db_1 All are easy!!!! ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"实战：自己编写服务上线 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"1、编写自己的服务： package com.example.democompose.Controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @Autowired StringRedisTemplate redisTemplate; @GetMapping(\"/hello\") public String hello(){ Long views=redisTemplate.opsForValue().increment(\"views\"); return \"hello,这是第\"+views+\"次访问\"; } } server.port=8080 spring.redis.host=redis ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"2、编写Dockerfile文件： FROM java:8 COPY *.jar /app.jar CMD [\"--server.port=8080\"] EXPOSE 8888 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"3、编写docker-compose.yml文件 version:'3.8'services:myapp:build:.image:mytextappcomposedepends_on:- redisports:- \"8080:8080\"redis:image:\"library/redis:alpine\" ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"4、打jar包上传服务器 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"5、运行服务： docker-compose up -d docker-compose up --build #重新构建 Docker Swarm ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:5","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"搭建集群 集群—–4台服务器（一主三从） 4台机器安装Docker(Xshell窗口右键：发送键输入到所有会话): sudo yum install -y yum-utils # 3、设置镜像仓 sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 默认是国外的 可换国内 yum makecache fast # 4、安装相关的额 sudo yum install docker-ce docker-ce-cli containerd.io # 5、启动 sudo systemctl start docker docker version noe2 192.168.80.133 noe3 192.168.80.134 node4 192.168.80.135 test 192.168.80.136 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化管理节点node2: # 初始化一个manager节点 docker swarm init --advertise-addr 192.168.80.133 [root@node2 network-scripts]# docker swarm init --advertise-addr 192.168.80.133 Swarm initialized: current node (a5gz7qpsgbjolzgzg1tlaj8lh) is now a manager. To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions. docker swarm join加入一个节点： #获取令牌 docker swarm join-token manager #管理节点 docker swarm join-token worker #工作节点 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化工作节点node3: [root@node3 ~]# docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 This node joined a swarm as a worker. 查看现有集群状态： [root@node2 /]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Leader 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Ready Active 20.10.5 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化工作节点node4: [root@node2 /]# docker swarm join-token worker To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 [root@node2 /]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Leader 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Ready Active 20.10.5 6ne9u5knznm8ei0c5uz7znka9 node4 Ready Active 20.10.5 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化管理节点test: docker swarm join-token manager docker node ls [root@localhost ~]# docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-66whvjsogw3qsqozb79oprffr 192.168.80.133:2377 Error response from daemon: manager stopped: can't initialize raft node: rpc error: code = Unknown desc = could not connect to prospective new cluster member using its advertised address: rpc error: code = Unavailable desc = connection error: desc = \"transport: Error while dialing dial tcp 192.168.80.136:2377: connect: no route to host\" 试了好多次发现总是加入管理节点错误，一开始怀疑自己网络通信问题，后来网上无脑抄袭一致认为代理问题： 最终发现是自己新建的虚拟机test防火墙没有关: #查看防火墙状态 systemctl status firewalld.service #停止防火墙 systemctl stop firewalld.service #永久停止 systemctl disable firewalld.service ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Raft协议 现在：双主双从，假设一个节点挂了，其他节点是否可用？？ Raft协议：保证大多数节点存活集群才可用，至少大于1台，集群至少大于3台！！ 实验： 1、将node2管理节点停止，宕机，另外一个管理节点也不能用了 systemctl stop docker 在test管理节点查看集群，发现不可用： 2、重新启动node2: systemctl start docker 发现leader节点变了： 3、工作节点node3离开： docker swarm --help docker swarm leave 4、三主一工作： docker swarm join-token manager jb30cv8ej8xjokjc1cu5l8kjo localhost.localdomain Ready Active Leader 20.10.5 a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Reachable 20.10.5 nmhr2t2b5cgy4l64bcwl0mxjt node3 Ready Active Reachable 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Down Active 20.10.5 6ne9u5knznm8ei0c5uz7znka9 node4 Ready Active 20.10.5 现在就是3台作为管理节点： 5、停掉Leader(test)： 现在Leader是test节点，停掉： 在node2查看集群状态,发现node3变成了leader，集群任然可用 6、大多数存活可用 现在只有两个管理节点（node2/node3），一个工作节点(node4)，如果再停止一个管理节点，那就无法使用了： [root@node3 ~]# docker node ls Error response from daemon: rpc error: code = Unknown desc = The swarm does not have a leader. It's possible that too few managers are online. Make sure more than half of the managers are online. 大多数管理节点存活才可用 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:7:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"集群部署应用、弹性、扩缩容 以后告别docker run 集群：高可用，web-\u003eredis(分布在三台不同主机上，服务副本，挂了一个没事，其他可用) 容器=》服务=》副本 docker run # 容器启动，不具备扩缩容功能 docker service #服务，具备扩缩容、滚动跟新、灰度发布 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"服务部署 #前提是swarm搭建好 #在node2中创建服务 docker service create -p 8888:80 --name mynginx nginx docker service ls docker service ps mynginx docker service inspect mynginx [root@node2 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS ndtmy83nj0v3 mynginx.1 nginx:latest node3 Running Running 34 seconds ago [root@node2 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 1/1 nginx:latest *:8888-\u003e80/tcp # 服务副本只有一个，并且服务运行在node3主机上 [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 4 minutes ago Up 4 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v 现在服务只随机创建了一个服务，在node3主机上，假如现在访问量加大，需要扩容： # 创建3个副本 docker service update --replicas 3 mynginx [root@node3 ~]# docker service update --replicas 3 mynginx mynginx overall progress: 3 out of 3 tasks 1/3: running [==================================================\u003e] 2/3: running [==================================================\u003e] 3/3: running [==================================================\u003e] verify: Service converged [root@node3 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 3/3 nginx:latest *:8888-\u003e80/tcp [root@node3 ~]# docker service inspect mynginx 此时三个服务副本在node3、node4、test主机上 在集群中的任意一个节点都可访问，服务可以有多个副本来实现高可用： 但是现在通过node3IP无法访问服务，其他正常 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"大无语事件来了，有彩蛋: #如果把副本数量讲到1个会怎么样？？降！！！ [root@node3 ~]# docker service update --replicas 1 mynginx mynginx overall progress: 1 out of 1 tasks 1/1: running [==================================================\u003e] verify: Service converged #那就是只有这个一个副本？？？（bug） [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 40 minutes ago Up 40 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v #发现还是访问不了，查看日志，发现他的日志启动一半，少了许多日志，那就重启 [root@node3 ~]# docker restart mynginx.1.ndtmy83nj0v3oathgaleiw37v mynginx.1.ndtmy83nj0v3oathgaleiw37v [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 42 minutes ago Up About a minute 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v [root@node3 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 1/1 nginx:latest *:8888-\u003e80/tcp 但是我又发现，怎么会有两个： [root@node2 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2bc639d336dd nginx:latest \"/docker-entrypoint.…\" 13 minutes ago Up 13 minutes 80/tcp mynginx.1.wgk7pwm0mm7zs6fawmb7p6otf [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 55 minutes ago Up 14 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v 我把其中一个关掉还是不能访问，此时通过mynginx信息发现如下错误： [root@node2 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS x8advkit107e mynginx.1 nginx:latest node4 Running Running 6 minutes ago wgk7pwm0mm7z \\_ mynginx.1 nginx:latest node2 Shutdown Complete 6 minutes ago ndtmy83nj0v3 \\_ mynginx.1 nginx:latest node3 Shutdown Failed 25 minutes ago \"task: non-zero exit (137)\" 那就只能重来一遍： docker service rm mynginx docker service create -p 8888:80 --replicas 3 --name mynginxtest nginx [root@node2 ~]# docker service ps mynginxtest ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS fultv05jwsbm mynginxtest.1 nginx:latest localhost.localdomain Running Running 15 seconds ago yikbwlzinhd5 mynginxtest.2 nginx:latest node3 Running Running 17 seconds ago f5cljf1f6d73 mynginxtest.3 nginx:latest node2 Running Running 16 seconds ago [root@node2 ~]# docker service ps mynginxtest ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS fultv05jwsbm mynginxtest.1 nginx:latest localhost.localdomain Running Running 7 minutes ago yikbwlzinhd5 mynginxtest.2 nginx:latest node3 Running Running 7 minutes ago f5cljf1f6d73 mynginxtest.3 nginx:latest node2 Running Running 7 minutes ago [root@node2 ~]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION jb30cv8ej8xjokjc1cu5l8kjo localhost.localdomain Ready Active Reachable 20.10.5 a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Reachable 20.10.5 nmhr2t2b5cgy4l64bcwl0mxjt node3 Ready Active Leader 20.10.5 6ne9u5knznm8ei0c5uz7znka9 node4 Ready Active 20.10.5 问题依旧存在(只有node3不能访问)，不搞了，等后续，欢迎留言？？？ 问题最终还是解决了？？？ #以为node3的防火墙没有关，或者是leader节点不能访问？ systemctl stop docker #让他重新选举leader，发现还是可以访问leader， systemctl status firewalld.service #防火墙状态关闭 systemctl start docker #重新启动又好了,玄学 副本服务与全局服务 docker service create --mode replicated --name mytom tomcat:7 #默认worker节点创建服务 docker service create --mode global --name mytom tomcat:7 #全局 减少副本： docker service update --replicas 1 mynginx 扩缩容： docker service scale mynginxtest=5 docker service update --replicas 5 mynginxtest ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS fultv05jwsbm mynginxtest.1 nginx:latest localhost.localdomain Running Running 12 minutes ago yikbwlzinhd5 mynginxtest.2 nginx:latest node3 Running Running 12 minutes ago f5cljf1f6d73 mynginxtest.3 nginx:latest node2 Running Running 12 minutes ago l4blkh6mq996 mynginxtest.4 nginx:latest node4 Running Running about a minute kvn9nhtwymds mynginxtest.5 nginx:latest node4 Running Running about a minute ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"总结 swarm: ​ 集群的管理和编排，docker可以初始化一个swarm集群，其他节点可以加入（manager OR worker） node： ​ 就是一个docker节点，多个节点就组成了一个网络集群 service ​ 就是一个任务，可以在管理节点或者工作节点运行，核心 ​ swarm网络：overlay,ingress Docker Stack docker-compose:适合单机部署项目！ docker stack：集群部署项目(已经快被k8s替代了) #单机部署 docker-compose up -d wordpress.yml #集群部署 docker stack deploy wordpress.yml Docker Secret 安全，密码、证书配置： Docker Config 配置： ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:9:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["算法"],"content":"冒泡排序 ​ 冒泡排序是通过比较两个相邻元素的大小实现排序，如果前一个元素大于后一个元素，就交换这两个元素。这样就会让每一趟冒泡都能找到最大一个元素并放到最后。 以 [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，对它进行冒泡排序： ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] maopaoSort(int[] array){ boolean isChanged=false; for(int i=0;i\u003carray.length-1;i++){ for(int j=0;j\u003carray.length-1-i;j++){ if(array[j]\u003earray[j+1]){ int temp=array[j+1]; array[j+1]=array[j]; array[j]=temp; isChanged=true; } } } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它是指对同样的数据进行排序，会不会改变它的相对位置。比如 [ 1, 3, 2, 4, 2 ] 经过排序后，两个相同的元素 2 位置会不会被交换。冒泡排序是比较相邻两个元素的大小，显然不会破坏稳定性。 空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1); 时间复杂度：由于嵌套了 2 层循环，故为 O(n*n); ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"选择排序 ​ 选择排序的思想是，依次从「无序列表」中找到一个最小的元素放到「有序列表」的最后面。以 arr = [ 8, 1, 4, 6, 2, 3, 5, 4 ] 为例，排序开始时把 arr 分为有序列表 A = [ ], 无序列表 B = [ 8, 1, 4, 6, 2, 3, 5, 4 ]，依次从 B 中找出最小的元素放到 A 的最后面。这种排序也是逻辑上的分组，实际上不会创建 A 和 B，只是用下标来标记 A 和 B。 ​ 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 4 ] 为例，第一次找到最小元素 1 与 8 进行交换，这时有列表 A = [1], 无序列表 B = [8, 4, 6, 2, 3, 5, 4]；第二次从 B 中找到最小元素 2，与 B 中的第一个元素进行交换，交换后 A = [1，2]，B = [4, 6, 8, 3, 5, 4]；就这样不断缩短 B，扩大 A，最终达到有序。 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 方法一： public static int[] selectSort(int[] array){ for(int i=0;i\u003carray.length-1;i++){ int index=i; //找出n次无序列表中的最小值和他的下标 for(int j=i;j\u003carray.length;j++){ if(array[j]\u003carray[index]) { index = j; } } int temp=array[index]; array[index]=array[i]; array[i]=temp; } return array; } 方法二： public static int[] selectSort(int[] array){ for(int i=0;i\u003carray.length-1;i++){ int index=i; int temp=999; //找出n次无序列表中的最小值和他的下标 for(int j=i;j\u003carray.length;j++){ if(array[j]\u003carray[index]){ index=j; } temp=array[index]; } //把[i,index]后移一位，给有序增加空位，插入最小值 for(int m=index;m\u003ei;m--){ array[m]=array[m-1]; } array[i]=temp; } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：排序过程中元素是按顺序进行遍历，相同元素相对位置不会发生变化，故稳定。 空间复杂度：在原序列进行操作，故为 O( 1 ); 时间复杂度：需要 2 次循环遍历，故为 O( n * n ); ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"插入排序 ​ 在整个排序过程如图所示，以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7] 为例，它会把 arr 分成两组 A = [ 8 ] 和 B = [ 1, 4, 6, 2, 3, 5, 7] ，逐步遍历 B 中元素插入到 A 中，最终构成一个有序序列： ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] insertSort(int[] array){ for(int i=1;i\u003carray.length;i++){ int preindex=i-1; // 必须记录这个元素，不然会被覆盖掉 int current=array[i]; // 当前元素小于排序好的元素，就移动到下一个位置,从后向前找位置插入 while(preindex\u003e=0\u0026\u0026current\u003carray[preindex]){ array[preindex+1]=array[preindex]; preindex--; } array[preindex+1]=current; } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它是从后往前遍历已排序好的序列，相同元素不会改变位置，故为稳定排序； 空间复杂度：它是在原序列进行排序，故为 O ( 1 ); 时间复杂度：排序的过程中，首先要遍历所有的元素，然后在已排序序列中找到合适的位置并插入。共需要 2 层循环，故为 O ( n * n ); ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"希尔排序 ​ 希尔排序，它是由 D.L.Shell 于1959 年提出而得名。根据它的名字很难想象算法的核心思想。[ 所以只能死记硬背了，面试官问：希尔排序的思想是什么？]。它的核心思想是把一个序列分组，对分组后的内容进行插入排序，这里的分组只是逻辑上的分组，不会重新开辟存储空间。它其实是插入排序的优化版，插入排序对基本有序的序列性能好，希尔排序利用这一特性把原序列分组，对每个分组进行排序，逐步完成排序。 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，通过 floor(8/2) 来分为 4 组，8 表示数组中元素的个数。分完组后，对组内元素进行插入排序。 「 利用第 1 次分组结果进行第 2 次分组 」 「 利用第 2 次分组结果进行最后一次分组 」 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] lshellSort(int[] array){ //len=9 int len=array.length; //floor向下取整，4，2，1 for(int gap=(int)Math.floor(len/2);gap\u003e0;gap=gap/2){ //i=4; for (int i = gap; i \u003c len; i++) { // j=0,1,2,3,4 // [0]-[4] [1]-[5] [2]-[6] [3]-[7] [4]-[8] for (int j = i - gap; j \u003e= 0 \u0026\u0026 array[j] \u003e array[j+gap]; j-=gap) { // 交换位置 int temp = array[j]; array[j] = array[gap+j]; array[gap+j] = temp; } } } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它可能会把相同元素分到不同的组中，那么两个相同的元素就有可能调换相对位置，故不稳定。 空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1); 时间复杂度：希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(log n的3/2)，希尔排序时间复杂度的下界是n*log2n ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"快速排序 快速排序的核心思想是对待排序序列通过一个「支点」（支点就是序列中的一个元素，别把它想的太高大上）进行拆分，使得左边的数据小于支点，右边的数据大于支点。然后把左边和右边再做一次递归，直到递归结束。支点的选择也是一门大学问，我们以 （左边index + 右边index）/ 2 来选择支点。 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，选择一个支点, index= (L+R)/2 = (0+7)/2=3, 支点的值 pivot = arr[index] = arr[3] = 6，接下来需要把 arr 中小于 6 的移到左边，大于 6 的移到右边。 快速排序使用一个高效的方法做数据拆分。 用一个指向左边的游标 i，和指向右边的游标 j，逐渐移动这两个游标，直到找到 arr[i] \u003e 6 和 arr[j] \u003c 6, 停止移动游标，交换 arr[i] 和 arr[j]，交换完后 i++，j–（对下一个元素进行比较），直到 i\u003e=j，停止移动。 图中的 L，R 是指快速排序开始时序列的起始和结束索引，在一趟快速排序中，它们的值不会发生改变，直到下一趟排序时才会改变。 一趟快速排序完成后，分别对小于6和大于等于6的部分进行快速排序，递归就好了。对 [ 5, 1, 4, 3, 2 ] 进行一趟快速排序。 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["运维"],"content":"docker概述 从开发到上线，两套环境，版本不同导致软件不可用，开发与运维有差距！部署配置环境费时费力 原：jar——-redis,mysql,jdk,项目能不能带上环境安装打包？跨平台，隔离， docker容器技术也是一种虚拟化技术 官网：https://www.docker.com/ 文档：https://docs.docker.com/ 仓库地址： https://hub.docker.com/ 镜像（image）:模板，通过这个模板来创建容器服务，可创建多个容器（最终服务或者项目运行在容器中） 容器（container）：一个或一组应用，可以启动，停止，删除，基本命令 仓库（repository）：存放镜像（公有私有），docker hub(默认) 阿里云（国内镜像加速） 安装 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:0:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"start 卸载旧版本 # 1、卸载旧版本 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2、 需要的安装包 sudo yum install -y yum-utils # 3、设置镜像仓库 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 默认是国外的 可换国内 yum makecache fast # 4、安装相关的额 sudo yum install docker-ce docker-ce-cli containerd.io # 5、启动 sudo systemctl start docker docker version # 6、测试 sudo docker run hello-World 查看镜像 docker images 阿里云镜像加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://ax7mfl6a.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"hello-world流程 sudo docker run hello-World–\u003e本机寻找镜像–No–\u003e仓库地址下载—\u003e是否找到—\u003e下载镜像到本地—\u003e使用镜像创建容器运行 docker常用命令 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:2:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"帮助命令 docker version # 显示版本信息 docker info #系统信息，镜像、容器 docker 命令 --help ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:3:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"镜像命令 docker images docker search mysql docker pull mysql docker pull mysql:5.7 #docker分层下载，节省空间 删除镜像docker rmi -f docker rmi -f 容器id docker rmi -f $(docker images -aq) #删除所有镜像 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:4:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"容器命令 拉取镜像 docker pull centos 创建容器并启动 docker run [可选参数] image # 参数设置 --name=\"name\" 容器名称，tomcat01，tomcat02 -it 交互方式运行， -d 后台运行 -p 指定荣放弃的端口 -p 8080:8080 -p ip:主机端口：容器端口 -p 主机端口：容器端口 -p 容器端口 容器端口 -P 随机指定端口 C:\\Users\\26505\u003edocker pull centos Using default tag: latest latest: Pulling from library/centos 7a0437f04f83: Pulling fs layer latest: Pulling from library/centos 7a0437f04f83: Pull complete Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1 Status: Downloaded newer image for centos:latest docker.io/library/centos:latest C:\\Users\\26505\u003edocker run -it centos /bin/bash [root@177a03668b45 /]# exit exit C:\\Users\\26505\u003edocker ps #正在运行的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bc1f05966db8 mysql \"docker-entrypoint.s…\" 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-\u003e3306/tcp mysql 741b6a4bccc2 docker/getting-started \"/docker-entrypoint.…\" 7 hours ago Up 7 hours 0.0.0.0:8080-\u003e80/tcp docker-test C:\\Users\\26505\u003edocker ps -a #历史容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 177a03668b45 centos \"/bin/bash\" 4 minutes ago Exited (0) 3 minutes ago stoic_rosalind bc1f05966db8 mysql \"docker-entrypoint.s…\" 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-\u003e3306/tcp mysql 741b6a4bccc2 docker/getting-started \"/docker-entrypoint.…\" 7 hours ago Up 7 hours 0.0.0.0:8080-\u003e80/tcp docker-test 70b02a4a1833 hello-world \"/hello\" 7 hours ago Exited (0) 7 hours ago stupefied_neumann ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:5:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"退出容器 exit #退出并停止容器 ctrl+P+Q #退出终端不停止容器 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:6:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"删除容器 rm -f docker rm 容器id #不能删除正在运行的容器 docker rm -f $(docker pa -aq) #删除全部容器 docker ps -a -q|xargs docker rm #删除全部容器(管道) ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:7:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"启动停止容器 docker start id #启动 docker restart id #重启 docker stop id #停止 docker kill id #强制停止 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:8:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"常用的其他命令 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"后台启动 docker run -d centos #问题 :docker ps 发现centos停止了 # 常见的坑，后台运行后，就必须有一个前台进程，docker发现没有应用，就自动停止了 #nginx 容器启动后，没有提供服务，就会立刻停止 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:1","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"日志命令 docker logs --help docker logs -tf --tail 10 id #查看后10条日志 docker logs -tf id #查看所有日志 docker run -d centos /bin/sh -C \"while true ;do echo tanjindong;sleep 1;done\" ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:2","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"查看容器中的进程信息 # top命令 docker top --help docker top id ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:3","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"查看镜像源数据 # inspect docker inspect id C:\\Users\\26505\u003edocker inspect 741b6a4bccc2 [ { \"Id\": \"741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3\", \"Created\": \"2021-03-21T07:20:22.6575041Z\", \"Path\": \"/docker-entrypoint.sh\", \"Args\": [ \"nginx\", \"-g\", \"daemon off;\" ], \"State\": { \"Status\": \"running\", \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 2067, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2021-03-21T07:20:26.022246Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, \"Image\": \"sha256:3ba8f2ff0727d36bccad59f6344f7f3a101bcd9c70b984aa2dd006914c496cb8\", \"ResolvConfPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/hostname\", \"HostsPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/hosts\", \"LogPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3-json.log\", \"Name\": \"/docker-test\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"MountLabel\": \"\", \"ProcessLabel\": \"\", \"AppArmorProfile\": \"\", \"ExecIDs\": [ \"4ac8b9a918d39e7560ebf5e35fad12ef83ed66cabc27035095870d4fe13ac56c\" ], \"HostConfig\": { \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": { \"Type\": \"json-file\", \"Config\": {} }, \"NetworkMode\": \"default\", \"PortBindings\": { \"80/tcp\": [ { \"HostIp\": \"\", \"HostPort\": \"8080\" } ] }, \"RestartPolicy\": { \"Name\": \"no\", \"MaximumRetryCount\": 0 }, \"AutoRemove\": false, \"VolumeDriver\": \"\", \"VolumesFrom\": null, \"CapAdd\": null, \"CapDrop\": null, \"CgroupnsMode\": \"host\", \"Dns\": [], \"DnsOptions\": [], \"DnsSearch\": [], \"ExtraHosts\": null, \"GroupAdd\": null, \"IpcMode\": \"private\", \"Cgroup\": \"\", \"Links\": null, \"OomScoreAdj\": 0, \"PidMode\": \"\", \"Privileged\": false, \"PublishAllPorts\": false, \"ReadonlyRootfs\": false, \"SecurityOpt\": null, \"UTSMode\": \"\", \"UsernsMode\": \"\", \"ShmSize\": 67108864, \"Runtime\": \"runc\", \"ConsoleSize\": [ 31, 120 ], \"Isolation\": \"\", \"CpuShares\": 0, \"Memory\": 0, \"NanoCpus\": 0, \"CgroupParent\": \"\", \"BlkioWeight\": 0, \"BlkioWeightDevice\": [], \"BlkioDeviceReadBps\": null, \"BlkioDeviceWriteBps\": null, \"BlkioDeviceReadIOps\": null, \"BlkioDeviceWriteIOps\": null, \"CpuPeriod\": 0, \"CpuQuota\": 0, \"CpuRealtimePeriod\": 0, \"CpuRealtimeRuntime\": 0, \"CpusetCpus\": \"\", \"CpusetMems\": \"\", \"Devices\": [], \"DeviceCgroupRules\": null, \"DeviceRequests\": null, \"KernelMemory\": 0, \"KernelMemoryTCP\": 0, \"MemoryReservation\": 0, \"MemorySwap\": 0, \"MemorySwappiness\": null, \"OomKillDisable\": false, \"PidsLimit\": null, \"Ulimits\": null, \"CpuCount\": 0, \"CpuPercent\": 0, \"IOMaximumIOps\": 0, \"IOMaximumBandwidth\": 0, \"MaskedPaths\": [ \"/proc/asound\", \"/proc/acpi\", \"/proc/kcore\", \"/proc/keys\", \"/proc/latency_stats\", \"/proc/timer_list\", \"/proc/timer_stats\", \"/proc/sched_debug\", \"/proc/scsi\", \"/sys/firmware\" ], \"ReadonlyPaths\": [ \"/proc/bus\", \"/proc/fs\", \"/proc/irq\", \"/proc/sys\", \"/proc/sysrq-trigger\" ] }, \"GraphDriver\": { \"Data\": { \"LowerDir\": \"/var/lib/docker/overlay2/6d343bc9ad04de2e498e78ef2f579175c692ed808c08b393d1eb997f1dd5d84b-init/diff:/var/lib/docker/overlay2/214cc931af263a16f14aeb6d585e2dbee7150a57e19e84650bfdc32734a5846f/diff:/var/lib/docker/overlay2/47fae1cab0a2404c969f4cea1cfcb6b054b1bbdea8d8c6149c21848a77c816dc/diff:/var/lib/docker/overlay2/17096a2500c8f19f644b2554a0bd01af1b469f6f3b1b0d47718f826fe6c1e01e/diff:/var/lib/docker/overlay2/bbe4a1e6f6189b486a01f819c7fc91f2c558eb60e3eda0a16629e9b40cef3937/diff:/var/lib/docker/overlay2/98581fdc9425566ddfa8a8b96d8fe61544f2140e026d1df3cbdc507d38f582cd/diff:/var/lib/docker/overlay2/66a3d69a78eff1300e49d125d6a2ad49e2e9b48f826c802ae6e654b83db3016d/diff:/var/lib/docker/overlay2/8dafe228d5bec8620615e6252f815baeb01884e592865f8edac2f7fec8317da8/diff:/var/lib/docker/overlay2/d0ca3a53296feb329ea10d4f75f54b57bed2bdf53b67a24de0a1b6d726877d85/diff\", \"MergedDir\": \"/var/l","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:4","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"进入当前正在运行的容器 docker exec -it 容器id bashshell docker ps # 方式一 进入容器之后开启一个新的终端(常用) docker exec -it id /bin/bash #方式二 进入执行的终端 docker attach 容器id 正在执行的代码。。。。。 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:5","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"从容器拷贝文件到主机 cp docker cp id:/home/test.java /home docker cp 容器id:容器目录 本机目录 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:6","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业一：部署nginx docker pull nginx #下载镜像 docker images docker run -d --name nginx-01 -p 3344:80 nginx #运行容器 curl localhost:3344 #测试 pi@raspberrypi:~ $ docker exec -it nginx-01 /bin/bash #进入容器 root@9ddb6ad99473:/# whereis nginx nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx root@9ddb6ad99473:/# cd etc/nginx/ root@9ddb6ad99473:/etc/nginx# ls conf.d fastcgi_params koi-utf koi-win mime.types modules nginx.conf scgi_params uwsgi_params win-utf pi@raspberrypi:~ $ docker stop nginx-01 #停止容器 nginx-01 pi@raspberrypi:~ $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES #每次修改nginx配置，都需要进入容器，十分麻烦，映射路径，达到修改容器配置的目的，数据卷技术！！！！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:10:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业二：部署tomcat #官方使用 docker run -it --rm tomcat:9.0 #之前都是后台，停止了之后，容器还可以查到，docker run -it --rm用完即删，一般用来测试 #下载启动 docker pull tomcat docker images docker run -d --name tomcat-01 -p 3355:8080 tomcat #运行 外部3355 but 原因：官方镜像最简化，所以找不到资源文件： docker exec -it tomcat-01 /bin/bash #进入容器 cp -r webapps.dist/* webapps ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:11:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业三：部署es+kibana # elasticsearch暴露端口十分多 # ES 十分耗内存 # 数据一般挂载在安全目录 # --net somenetwork ？网络配置 docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.11.2 docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.11.2 C:\\Users\\26505\u003ecurl localhost:9200 { \"name\" : \"2ab0292e5b49\", \"cluster_name\" : \"docker-cluster\", \"cluster_uuid\" : \"661wGGJlSRqiLH_ht2P48A\", \"version\" : { \"number\" : \"7.11.2\", \"build_flavor\" : \"default\", \"build_type\" : \"docker\", \"build_hash\" : \"3e5a16cfec50876d20ea77b075070932c6464c7d\", \"build_date\" : \"2021-03-06T05:54:38.141101Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.7.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } # 启动之后非常卡 how to 解决 docker stats 查看cpu状态 docker stats # 解决一：增加内存限制，修改配置文件， -e 环境的配置修改 docker run -d --name elasticsearch -p 9201:9200 -p 9301:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" elasticsearch:7.11.2 使用kibana连接ES： ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:12:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"可视化工具 portainer(不是最佳选择，先用) # -v /var/run/docker.sock 挂载，里面数据挂载到本机 # --privileged=true 授权，本机可访问 docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 测试访问：8088 Rancher（CI/CD） docker镜像原理 UFS 联合文件系统，分层轻量，分层下载，分层加载，多镜像共用 公共内核(bootfs) 对于一个OS，rootfs可以很小，只需要包含基本的命令、工具和程序库就可以了，因为底层直接用host的kernel，自己只需要提供rootfs就可以了，由此可见，不同版本的Linux发行版，bootfs是相同的，只是rootfs不同罢了。 bootfs引导启动非常慢，rootfs库启动非常快，所以虚拟机启动分钟级别，docker启动秒级。 分层理解： ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:13:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"如何打包一个自己的镜像：commit docker commit #提交容器 docker commit -m=\"提交描述信息\" -a=\"作者\" 容器id 目标镜像名:[tag] docker commit -a=\"jd\" -m=\"add webapps\" 7sssdvhfgs tomcat02:1.0 容器数据卷 如果数据都在容器中，容器删除之后，数据就会丢失，需求：数据可持久化， MySQL，容器删除了，MySQL数据就没了，MySQL可以保存在本地吗？ 数据共享技术，docker容器中产生的数据同步到本地， 卷技术，？目录挂载，将容器内的目录挂载在宿主机上，持久化与同步操作，容器间数据可以共享 # 方式一：使用-v挂载 docker run -d -v 主机目录:容器目录 docker run -it -v /home/ceshi:/home --name ubuntu01 ubuntu /bin/bash docker inspect 容器id docker stop 1bfb0a3ad95e #停止docker 容器 sudo nano test.txt #修改Host文件 docker start 1bfb0a3ad95e #重新启动 # 进入容器查看文件变化 pi@raspberrypi:~ $ docker exec -it 1bfb0a3ad95e /bin/bash root@1bfb0a3ad95e:/# cd /home root@1bfb0a3ad95e:/home# ls test test.b test.java test.txt root@1bfb0a3ad95e:/home# cat test/txt cat: test/txt: No such file or directory root@1bfb0a3ad95e:/home# cat test.txt yasethbitgejk nadeuioaguhno arezln # 容器内的数据依旧是同步的！！！！！！ # 通过-v挂载配置文件和资源文件，就不用进入容器修改，只用修改本地，容器自动同步 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:14:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"部署MySQL mysql数据持久化问题 docker pull mysql:5.7 #需要配置密码 -e MYSQL_ROOT_PASSWORD=my-secret-pw # docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag docker run -d -p 3310:3306 --name mysql-test -v H:\\myNotsBooks\\docker\\conf:/etc/mysql/conf.d -v H:\\myNotsBooks\\docker\\data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 链接成功： 数据挂载成功：（conf） 即使删除容器，本地的数据卷依旧没有丢失，这就达到了数据持久化 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:15:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"具名和匿名挂载 #匿名挂载 # -v 容器内路径！ docker run -d -P --name nginx-test -v /etc/nginx nginx # 查看所有卷volume的挂载情况 pi@raspberrypi:/home/ceshi $ docker run -d -P --name nginx-test -v /etc/nginx nginx 9f4ba2383cab2eedc09916c2191858b88673cc43ef85194b42eb67cb8c2bca54 pi@raspberrypi:/home/ceshi $ docker volume --help Usage: docker volume COMMAND Manage volumes Commands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumes Run 'docker volume COMMAND --help' for more information on a command. pi@raspberrypi:/home/ceshi $ docker volume ls DRIVER VOLUME NAME local 27f1cec7789cd92096fc7177238808528b7201f2b7f2628c57fc4f350bff7c09 #匿名挂载 local 28ce6884130cf729f12f33decf67c96f0bab95032c193302553cd9050f8ff7e8 # -v 的时候只写了容器内部的路径 #具名挂载 pi@raspberrypi:~ $ docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx nginx 70500d6c7b7f937a953990007fc0af3db4628df5687eead2081abdfaeb582b4f pi@raspberrypi:~ $ docker volume ls DRIVER VOLUME NAME local 27f1cec7789cd92096fc7177238808528b7201f2b7f2628c57fc4f350bff7c09 local 28ce6884130cf729f12f33decf67c96f0bab95032c193302553cd9050f8ff7e8 local jumingfs pi@raspberrypi:~ $ docker volume inspect nginx-juming [] Error: No such volume: nginx-juming pi@raspberrypi:~ $ docker volume inspect jumingfs [ { \"CreatedAt\": \"2021-03-25T11:06:02+08:00\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/jumingfs/_data\", \"Name\": \"jumingfs\", \"Options\": null, \"Scope\": \"local\" } ] 所有docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/jumingfs/_data 我们通过具名挂载可以方便找到我们的一个大卷，大多数情况下使用的是具名挂载 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:16:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"如何区分是具名挂载还是匿名挂载还是指定路径挂载 -v 容器内路径 #匿名挂载 -v 卷名:容器内路径 #具名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:17:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"扩展 #设置容器权限，对挂载数据卷有限制 docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx:ro nginx docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx:rw nginx # ro 只能通过宿主机来操作，不能通过容器内部操作 # 默认rw: 可读可写 Dockerfile:构建docker的文件 一段命令脚本 pi@raspberrypi:/home/docker-test-file-volume $ docker build -f ./dockerfile1 -t jd/centos:1.0 . #构建镜像 Sending build context to Docker daemon 2.048kB Step 1/4 : FROM ubuntu ---\u003e 3324772e8bdf Step 2/4 : VOLUME [\"volume01\",\"volume02\"] ---\u003e Running in e07670d15bd9 Removing intermediate container e07670d15bd9 ---\u003e 067080c3c46e Step 3/4 : CMD echo \"........end........\" ---\u003e Running in 0ac9ebb25a05 Removing intermediate container 0ac9ebb25a05 ---\u003e 5fa9a5e368ba Step 4/4 : CMD /bin/bash ---\u003e Running in 492dcb1825df Removing intermediate container 492dcb1825df ---\u003e e5bd1def5d82 Successfully built e5bd1def5d82 Successfully tagged jd/centos:1.0 pi@raspberrypi:/home/docker-test-file-volume $ docker images #查看镜像 REPOSITORY TAG IMAGE ID CREATED SIZE jd/centos 1.0 e5bd1def5d82 7 seconds ago 49.8MB portainer/portainer latest 9b438d60114e 6 days ago 62.4MB nginx latest 4f718772a0b3 13 days ago 103MB ubuntu latest 3324772e8bdf 5 months ago 49.8MB hello-world latest 851163c78e4a 14 months ago 4.85kB java 8 d23bdf5b1b1b 4 years ago 643MB pi@raspberrypi:/home/docker-test-file-volume $ cat dockerfile1 FROM ubuntu VOLUME [\"volume01\",\"volume02\"] #匿名挂载 CMD echo \"........end........\" CMD /bin/bash docker inspect id #查看卷挂载路径 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:18:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"多个docker同步数据 # 多个MySQL数据同步 # 启动三个容器 docker run -it --name docker01 jd/centos:1.0 docker run -it --name docker02 --volumes-from docker01 jd/centos:1.0 docker run -it --name docker03 --volumes-from docker01 jd/centos:1.0 # 进入docker01创建文件 root@450d606a17a0:/# pi@raspberrypi:/ $ docker attach 0721edbafafb root@0721edbafafb:/# ls bin dev home media opt root sbin sys usr volume01 boot etc lib mnt proc run srv tmp var volume02 root@0721edbafafb:/# cd vo bash: cd: vo: No such file or directory root@0721edbafafb:/# cd volume01 root@0721edbafafb:/volume01# ls root@0721edbafafb:/volume01# touch docker01.txt touch: setting times of 'docker01.txt': Operation not permitted root@0721edbafafb:/volume01# ls docker01.txt #进入docker02查看 pi@raspberrypi:/ $ docker attach 450d606a17a0 root@450d606a17a0:/# ls bin dev home media opt root sbin sys usr volume01 boot etc lib mnt proc run srv tmp var volume02 root@450d606a17a0:/# cd volume01 root@450d606a17a0:/volume01# ls docker01.txt docker02 volumesfrom docker01 docker03 volumesfrom docker01 如果把1删除了，2，3还在吗？？？ 发现还在，只要有一个容器使用，就依旧存在，共享备份机制，双向拷贝的概念 # 多个mysql实现数据共享 docker run -d -p 3301:3306 --name mysql01 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 docker run -d -p 3302:3306 --name mysql02 --volumes-from mysql01 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 #这个时候可以实现两个容器数据同步 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止， 但是一旦持久化挂载-v到本地，本地不会被删除！！！！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:19:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerfile 命令参数脚本 1、编写一个dockerfile文件 2、docker build 一个镜像 3、docker run 运行容器 4、docker push 发布镜像（dockerhub,阿里云镜像） 查看一下官方这么做的： FROM scratch ADD centos-8-x86_64.tar.xz / LABEL org.label-schema.schema-version=\"1.0\" org.label-schema.name=\"CentOS Base Image\" org.label-schema.vendor=\"CentOS\" org.label-schema.license=\"GPLv2\" org.label-schema.build-date=\"20201204\" CMD [\"/bin/bash\"] ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:20:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"构建过程 从上到下顺序执行，指令大写，每个指令就会创建一个新的镜像层 企业交付的标准！！！！！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:21:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerfile指令 dockerHub 80% 来自FROM scratch FROM #基础镜像，一切从这里开始构建 MAINTAINER #镜像是谁写的，姓名+邮箱 RUN #构建镜像时需要运行的命令 ADD #步骤，tomcat压缩包，添加内容 WORKDIR #镜像的工作目录 VOLUME #挂载卷 EXPOSE #指定暴露端口原来-p CMD #指定这个容器启动的时候运行的命令，只有最后一个会失效，可被替代 ENTRYPOINT #指定这个容器启动的时候运行的命令，可追加 ONBUILD #当构建一个被继承dockerfile,触发指令 COPY #类似ADD，拷贝文件到镜像 ENV #构建的时候设置环境变量 -e 自己写一个dockerfile：：：：：：：：： ＃　entos-vim-ip FROM centos MAINTAINER 金东\u003c2650523664@qq.com ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"------end-----\" CMD /bin/bash docker build -f centos-vim-ip -t mycentos:1.0 . docker images docker run -it --name mycentostest mycentos:1.0 # 现在vim 与 ifconfig命令都可以用了,官方不可用 docker history mycentos:1.0 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:22:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"CMD与ENTRYPOINT区别 FROM centos CMD [\"ls\",\"-a\"]　# 指定容器启动时运行的命令，只有最后一个生效，可被替代 H:\\myNotsBooks\\docker\\dockerfile\u003edocker run -it cmdtest -l docker: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: \"-l\": executable file not found in $PATH: unknown. # cmd的清理下，-l代替了CMD [\"ls\",\"-a\"],但是-l不是命令，所以报错 H:\\myNotsBooks\\docker\\dockerfile\u003edocker run -it cmdtest ls -al #这就对了 total 56 drwxr-xr-x 1 root root 4096 Mar 25 14:21 . drwxr-xr-x 1 root root 4096 Mar 25 14:21 .. -rwxr-xr-x 1 root root 0 Mar 25 14:21 .dockerenv lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -\u003e usr/bin drwxr-xr-x 5 root root 360 Mar 25 14:21 dev drwxr-xr-x 1 root root 4096 Mar 25 14:21 etc drwxr-xr-x 2 root root 4096 Nov 3 15:22 home lrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -\u003e usr/lib lrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -\u003e usr/lib64 drwx------ 2 root root 4096 Dec 4 17:37 lost+found drwxr-xr-x 2 root root 4096 Nov 3 15:22 media drwxr-xr-x 2 root root 4096 Nov 3 15:22 mnt drwxr-xr-x 2 root root 4096 Nov 3 15:22 opt dr-xr-xr-x 196 root root 0 Mar 25 14:21 proc dr-xr-x--- 2 root root 4096 Dec 4 17:37 root drwxr-xr-x 11 root root 4096 Dec 4 17:37 run lrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -\u003e usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 15:22 srv dr-xr-xr-x 11 root root 0 Mar 25 14:21 sys drwxrwxrwt 7 root root 4096 Dec 4 17:37 tmp drwxr-xr-x 12 root root 4096 Dec 4 17:37 usr drwxr-xr-x 20 root root 4096 Dec 4 17:37 var #ENTRYPOINT 命令可追加 FROM centos ENTRYPOINT [\"ls\",\"-a\"] docker build -f docker-entrypoint-test -t entrypointtest . docker run -it entrypointtest H:\\myNotsBooks\\docker\\dockerfile\\cmd ENTRYPOINT\u003edocker run -it entrypointtest . .dockerenv dev home lib64 media opt root sbin sys usr .. bin etc lib lost+found mnt proc run srv tmp var H:\\myNotsBooks\\docker\\dockerfile\\cmd ENTRYPOINT\u003edocker run -it entrypointtest -l #加-l不报错,加到a前面了 total 56 drwxr-xr-x 1 root root 4096 Mar 25 14:29 . drwxr-xr-x 1 root root 4096 Mar 25 14:29 .. -rwxr-xr-x 1 root root 0 Mar 25 14:29 .dockerenv lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -\u003e usr/bin drwxr-xr-x 5 root root 360 Mar 25 14:29 dev drwxr-xr-x 1 root root 4096 Mar 25 14:29 etc drwxr-xr-x 2 root root 4096 Nov 3 15:22 home lrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -\u003e usr/lib lrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -\u003e usr/lib64 drwx------ 2 root root 4096 Dec 4 17:37 lost+found drwxr-xr-x 2 root root 4096 Nov 3 15:22 media drwxr-xr-x 2 root root 4096 Nov 3 15:22 mnt drwxr-xr-x 2 root root 4096 Nov 3 15:22 opt dr-xr-xr-x 195 root root 0 Mar 25 14:29 proc dr-xr-x--- 2 root root 4096 Dec 4 17:37 root drwxr-xr-x 11 root root 4096 Dec 4 17:37 run lrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -\u003e usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 15:22 srv dr-xr-xr-x 11 root root 0 Mar 25 14:29 sys drwxrwxrwt 7 root root 4096 Dec 4 17:37 tmp drwxr-xr-x 12 root root 4096 Dec 4 17:37 usr drwxr-xr-x 20 root root 4096 Dec 4 17:37 var ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:22:1","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"实战：tomcat镜像 1、准备镜像文件：tomcat jdk 2、编写dockerfile文件 FROM centos MAINTAINER jd\u003c2650523664@qq.com\u003e COPY readme.txt /usr/local/readme.txt ADD apache-tomcat-9.0.44.tar.gz /usr/local/ ADD jdk-8u201-linux-x64.tar.gz /usr/local/ RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_201 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.44 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.44 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.44/bin/startup.sh \u0026\u0026 tail -F /usr/local/apache-tomcat-9.0.44/bin/logs/catalina.out 3、构建镜像 docker build -t mytomcat . # 构建镜像 4、启动镜像 docker run -d -p 9090:8080 --name testmytomcat -v /root/environment/tomcat-test-3-26/test:/usr/local/apache-tomcat-9.0.44/webapps/test -v /root/environment/tomcat-test-3-26/tomlogs:/usr/local/apache-tomcat-9.0.44/logs mytomcat 5、访问测试 6、发布项目（由于实现了卷挂载，所以我们就直接在本地写项目发布就可以了） jps页面 \u003chtml\u003e \u003chead\u003e\u003ctitle\u003eHello World\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e Hello World!\u003cbr/\u003e \u003c% System.out.println(\"-----------start my tomcat-----\"); %\u003e \u003c/body\u003e \u003c/html\u003e web.xml文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\" metadata-complete=\"true\"\u003e \u003c/web-app\u003e ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:23:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"发布镜像 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:24:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerHub镜像 1、注册账户：https://registry.hub.docker.com/ 2、客户端提交镜像 [root@jd tomcat-test-3-26]# docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username [root@jd tomcat-test-3-26]# docker login -u hubu8023 Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 3、发布镜像 [root@jd ~]# docker tag 5599ee6a7e53 hubu8023/mytest:1.0 [root@jd ~]# docker push hubu8023/mytest:1.0 [root@jd ~]# docker tag hello-world:latest hubu8023/myhello:2.0 #增加标签 [root@jd ~]# docker push hubu8023/myhello:2.0 # The push refers to repository [docker.io/hubu8023/myhello] f22b99068db9: Mounted from library/hello-world 2.0: digest: sha256:1b26826f602946860c279fce658f31050cff2c596583af237d971f4629b57792 size: 525 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:24:1","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"阿里云镜像 1、登录阿里云https://cr.console.aliyun.com/cn-hangzhou/instance/repositories 2、找到容器镜像服务 3、创建命名空间 4、创建容器镜像 5、浏览页面信息 登录阿里云Docker Registry $ sudo docker login --username=18871955259东 registry.cn-hangzhou.aliyuncs.com 用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在访问凭证页面修改凭证密码。 从Registry中拉取镜像 $ sudo docker pull registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] 将镜像推送到Registry $ sudo docker login --username=18871955259东 registry.cn-hangzhou.aliyuncs.com $ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] $ sudo docker push registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] 请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 小结： Docker网络 docker网络核心docker0: 两个容器之间如何访问？？？？？ docker run -d -P --name tomcat01 tomcat [root@jd ~]# docker exec -it tomcat01 ip addr 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 18: eth0@if19: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 查看容器内网IP地址，发现容器启动的时候得到一个eth0@if19 IP地址，这是docker分配的！！！ 现在能不能ping通容器？？？linux可以ping通容器内部 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:24:2","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"原理： 1、我们每启动一个docker容器，docker就会给容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0(桥接模式–evth-pair) 2、再启动一个docker容器，发现又多了一对网卡： # 容器的网卡都是成对出现的， # evth-pair就是一对虚拟设备接口，他们都是成对出现的，一端连接协议，一端彼此相连 # 正因为有这个特性，evth-pair充当一个桥梁，连接各种虚拟网络设备， 3、测试两个tomcat能不能互通： 网络模型 结论：tomcat01和tomcat02 共用一个路由器docker0, 所有的容器不指定网络，都是docker0路由的，docker会给容器分配一个默认可用IP 255.255.0.1/16 : 能用IP;255*255-0.0-255.255=255*255-1-1 255.255.0.1/24 : 能用IP;255*255-0.0-255.255=255-1-1 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:25:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"–link(基本不用) 场景：微服务或者springboot中database.url配置怎么写？？IP一直变 项目不重启，数据库IP变了，我们希望可以通过名字来访问容器 [root@jd ~]# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known # 实现tomcat03 ping tomcat02 [root@jd ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat 7dd6fe9dbe2e5732dfa53d3d2b2e6f14eb7abaccbf2771c44ae03db2dcc4faaf [root@jd ~]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.109 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.079 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.100 ms # 反向tomcat02 不能ping tomcat03 [root@jd ~]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 探究inspect: [root@jd ~]# docker network ls NETWORK ID NAME DRIVER SCOPE c592ad97632c bridge bridge local c9c57d03a4a4 host host local 85a3888c406a none null local [root@jd ~]# docker network inspect c592ad97632c #docker0网卡信息 docker inspect tomcat03 # 原理发现！！！！！！！！！！！！！！！！！！！！ # 查看tomcat03 hosts文件 docker exec -it tomcat03 cat /etc/hosts [root@jd ~]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.3 tomcat02 9dce1424d4fe #9dce1424d4fe tomcat02容器id 172.17.0.4 7dd6fe9dbe2e #7dd6fe9dbe2e tomcat03本机容器id 容器02： [root@jd ~]# docker exec -it tomcat02 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.3 9dce1424d4fe 只要在这里增加容器03的网络配置就可以实现互通， 但是现在docker已经不建议使用–link技术了，自定义网络，不用docker0, docker0问题：他不支持容器名链接访问！ ！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:26:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"自定义网络 # 查看所有网络 [root@jd ~]# docker network ls NETWORK ID NAME DRIVER SCOPE c592ad97632c bridge bridge local c9c57d03a4a4 host host local 85a3888c406a none null local 网络模式： bridge : 桥接模式（默认），自己创建也是使用bridge模式 none: 不配置网络， host: 和Linux主机共享网络 container: 容器网络连通（用的少，局限性很大） 测试 # 原来启动容器，默认--net bridge 二这个就是我们的docker0 docker run -d -P --name tomcat01 --net bridge tomcat docker run -d -P --name tomcat01 tomcat # docker0特点： 默认。域名不能访问，--link可以打通 # 因此我们需要自定义一个网络 [root@jd ~]# docker network --help Usage: docker network COMMAND Manage networks Commands: connect Connect a container to a network create Create a network disconnect Disconnect a container from a network inspect Display detailed information on one or more networks ls List networks prune Remove all unused networks rm Remove one or more networks docker network create --help # --subnet子网地址 192.168.0.2--------192.168.255.255 # --gateway 网关，路由器地址 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mytestnet docker network ls [root@jd ~]# docker network inspect mytestnet [ { \"Name\": \"mytestnet\", \"Id\": \"779b38cb0d482db5eb7156e0ba327da1740a86d71106438f27f22f6ceee2e82e\", \"Created\": \"2021-03-27T14:17:45.675341638+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": {}, \"Options\": {}, \"Labels\": {} } ] 用自己创建的网络模式创建容器 [root@jd ~]# docker run -d -P --name tomcat-net-01 --net mytestnet tomcat 56554c258e04f1ed4c300e26d337ca39c35087aa4d92f782e0a2b87138484b99 [root@jd ~]# docker run -d -P --name tomcat-net-02 --net mytestnet tomcat 1ccb18d09020622d029b4373c6d09f40259b5944ee27269ee0195ad8bd94269 [root@jd ~]# docker network inspect mytestnet [ { \"Name\": \"mytestnet\", \"Id\": \"779b38cb0d482db5eb7156e0ba327da1740a86d71106438f27f22f6ceee2e82e\", \"Created\": \"2021-03-27T14:17:45.675341638+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"1ccb18d09020622d029b4373c6d09f40259b5944ee27269ee0195ad8bd942694\": { \"Name\": \"tomcat-net-02\", \"EndpointID\": \"fa949ca6e5a71662a6656b83ed483d812972e815e5f1fc8d1c4c1f33e714cadb\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" }, \"56554c258e04f1ed4c300e26d337ca39c35087aa4d92f782e0a2b87138484b99\": { \"Name\": \"tomcat-net-01\", \"EndpointID\": \"5e2022a9c3c27a9d225d7b2d54f2ab16196fff5cfa9aa3f9a28be4e4d2a8f649\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": {} } ] #此时tomcat-net-01与02就处于我们自己创建的网络模式中 好处： [root@jd ~]# docker exec -it tomcat-net-01 ping tomcat-net-02 PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data. 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=1 ttl=64 time=0.125 ms 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=2 ttl=64 time=0.085 ms 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=3 ttl=64 time=0.107 ms [root@jd ~]# docker exec -it tomcat-net-02 ping tomcat-net-01 PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data. 64 bytes from tomcat-net-01.mytestnet (192.168.0.2): icmp_seq=1 ttl=64 time=0.108 ms 64 bytes from tomcat-net-01.mytestnet (192.168.0.2): icmp_seq=2 ttl=64 time=0.098 ms # 可以直接通过容器名称互通，不用使用--link 自定义网络已经维护好了对应关系，推荐使用自定义网络 redis集群，mysql集群使用不同的网络，保证集群的隔离性与数据安全 ，网络互相隔离 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:27:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"网络互通 测试 [root@jd ~]# docker run -d -P --name tomcat01 tomcat 999d0f449539783be990b3bb36f5036a4dc4419a8cfba1ffe9907e0bc08352d6 [root@jd ~]# docker run -d -P --name tomcat02 tomcat 5b6d4843a2fe7aede6cc377f4825dfb014bf035333ecf16d739576dc1a9b3237 [root@jd ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 5b6d4843a2fe tomcat \"catalina.sh run\" 6 seconds ago Up 5 seconds 0.0.0.0:49160-\u003e8080/tcp tomcat02 999d0f449539 tomcat \"catalina.sh run\" 16 seconds ago Up 16 seconds 0.0.0.0:49159-\u003e8080/tcp tomcat01 1ccb18d09020 tomcat \"catalina.sh run\" 15 minutes ago Up 15 minutes 0.0.0.0:49158-\u003e8080/tcp tomcat-net-02 56554c258e04 tomcat \"catalina.sh run\" 15 minutes ago Up 15 minutes 0.0.0.0:49157-\u003e8080/tcp tomcat-net-01 [root@jd ~]# docker network connect mytestnet tomcat01 [root@jd ~]# docker network inspect mytestnet 连通之后就是将tomcat01放在了mytestnet网络下 其实就是一个容器两个IP [root@jd ~]# docker exec -it tomcat-net-01 ping tomcat01 PING tomcat01 (192.168.0.4) 56(84) bytes of data. 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=1 ttl=64 time=0.126 ms 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=2 ttl=64 time=0.083 ms 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=3 ttl=64 time=0.084 ms tomcat02依旧不同 加入需要跨网络操作容器，就需要使用dockers network connect mytestnet tomcat-sjvbk ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:28:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"部署redis集群 分片+高可用+负载均衡 # 创建网络 docker network create redis-net --subnet 172.38.0.0/16 docker network ls docker network inspect redis-net # 通过脚本创建6个redis for port in $(seq 1 6); \\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003e/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done for port in $(seq 1 6); \\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003e/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done # 创建6个redis节点 docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\ -v /mydata/redis/node-1/data:/data \\ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis-net --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6373:6379 -p 16373:16379 --name redis-3 \\ -v /mydata/redis/node-3/data:/data \\ -v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis-net --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf # 通过脚本一次启动6个redis容器 docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \\ -v /mydata/redis/node-${port}/data:/data \\ -v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf done docker ps # 交互模式进节点 docker exec -it redis-1 /bin/sh # 创建redis集群 redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 \\ 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 \\ 172.38.0.16:6379 --cluster-replicas 1 # 输入yes 测试 redis-cli -c cluster info cluster nodes /data # redis-cli -c 127.0.0.1:6379\u003e cluster info cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:7 cluster_my_epoch:1 cluster_stats_messages_ping_sent:866 cluster_stats_messages_pong_sent:847 cluster_stats_messages_fail_sent:5 cluster_stats_messages_auth-ack_sent:1 cluster_stats_messages_update_sent:1 cluster_stats_messages_sent:1720 cluster_stats_messages_ping_received:842 cluster_stats_messages_pong_received:833 cluster_stats_messages_meet_received:5 cluster_stats_messages_fail_received:1 cluster_stats_messages_auth-req_received:1 cluster_stats_messages_received:1682 127.0.0.1:6379\u003e cluster nodes 9d043104052b4904cb3c6587ae09a72691953b02 172.38.0.13:6379@16379 slave #从d6411ab58802fd1408e66c304760d1f31688321b 0 1616830729000 7 connected 62ae6caadcf0a38c0d5c3a26c1364026a926b7e9 172.38.0.15:6379@16379 slave #从69169db2f42fb6d9015a23b7fe7cb13a8e6d62b1 0 1616830730548 5 connected 53634e5afa3791069ca0b97183be5bd1d4496bb4 172.38.0.16:6379@16379 slave #从344c681321b27f5b53f59674fb21876889a92020 0 1616830730548 6 connected 344c681321b27f5b53f59674fb21876889a92020 172.38.0.12:6379@16379 master - 0 1616830730648 2 connected 5461-10922 #主 d6411ab58802fd1408e66c304760d1f31688321b 172.38.0.14:6379@16379 master - 0 1616830729000 7 connected 10923-16383 #主 69169db2f42fb6d9015a23b7fe7cb13a8e6d62b1 172.38.0.11:6379@16379 myself,master - 0 1616830730000 1 connected 0-5460 #主 127.0.0.1:6379\u003e get a -\u003e Redirected to slot [15495] located at 172.38.0.14:6379 \"b\" springboot项目部署 1、构建项目 2、打包应用 3、编写dockerfile FROM java:8 COPY *.jar /app/ CMD [\"----server.port=8080------\"] EXPOSE 9980 ENTRYPOINT [\"java\",\"-jar\",\"/app/posttimer.jar\"] 4、构建镜像 docker build -t posttimer . [root@jd posttimer]# docker build -t posttimer . Sending build context to Docker daemon 56.69MB Step 1/5 : FROM java:8 8: Pulling from library/java 5040bd298390: Pull comple","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:29:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"一、Nosql概述 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"为什么使用Nosql 1、单机Mysql时代 90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题 数据量增加到一定程度，单机数据库就放不下了 数据的索引（B+ Tree）,一个机器内存也存放不下 访问量变大后（读写混合），一台服务器承受不住。 2、Memcached(缓存) + Mysql + 垂直拆分（读写分离） 网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！ 优化过程经历了以下几个过程： 优化数据库的数据结构和索引(难度大) 文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了 MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。 3、分库分表 + 水平拆分 + Mysql集群 4、如今最近的年代 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。 目前一个基本的互联网项目 为什么要用NoSQL ？ 用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！ 这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"什么是Nosql NoSQL = Not Only SQL（不仅仅是SQL） Not Only Structured Query Language 关系型数据库：列+行，同一个表下数据的结构是一样的。 非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。 NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Nosql特点 方便扩展（数据之间没有关系，很好扩展！） 大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！） 数据类型是多样型的！（不需要事先设计数据库，随取随用） 传统的 RDBMS 和 NoSQL 传统的 RDBMS(关系型数据库) - 结构化组织 - SQL - 数据和关系都存在单独的表中 row col - 操作，数据定义语言 - 严格的一致性 - 基础的事务 - ... Nosql - 不仅仅是数据 - 没有固定的查询语言 - 键值对存储，列存储，文档存储，图形数据库（社交关系） - 最终一致性 - CAP定理和BASE - 高性能，高可用，高扩展 - ... 了解：3V + 3高 大数据时代的3V ：主要是描述问题的 海量Velume 多样Variety 实时Velocity 大数据时代的3高 ： 主要是对程序的要求 高并发 高可扩 高性能 真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"阿里巴巴演进分析 推荐阅读：阿里云的这群疯子https://yq.aliyun.com/articles/653511 # 商品信息 - 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。 # 商品描述、评论(文字居多) - 文档型数据库：MongoDB # 图片 - 分布式文件系统 FastDFS - 淘宝：TFS - Google: GFS - Hadoop: HDFS - 阿里云: oss # 商品关键字 用于搜索 - 搜索引擎：solr,elasticsearch - 阿里：Isearch 多隆 # 商品热门的波段信息 - 内存数据库：Redis，Memcache # 商品交易，外部支付接口 - 第三方应用 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Nosql的四大分类 KV键值对 新浪：Redis 美团：Redis + Tair 阿里、百度：Redis + Memcache 文档型数据库（bson数据格式）： MongoDB(掌握) 基于分布式文件存储的数据库。C++编写，用于处理大量文档。 MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。 ConthDB 列存储数据库 HBase(大数据必学) 分布式文件系统 图关系数据库 用于广告推荐，社交网络 Neo4j、InfoGrid 分类 Examples举例 典型应用场景 数据模型 优点 缺点 键值对（key-value） Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB 内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。 Key 指向 Value 的键值对，通常用hash table来实现 查找速度快 数据无结构化，通常只被当作字符串或者二进制数据 列存储数据库 Cassandra, HBase, Riak 分布式的文件系统 以列簇式存储，将同一列数据存在一起 查找速度快，可扩展性强，更容易进行分布式扩展 功能相对局限 文档型数据库 CouchDB, MongoDb Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容） Key-Value对应的键值对，Value为结构化数据 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 查询性能不高，而且缺乏统一的查询语法。 图形(Graph)数据库 Neo4J, InfoGrid, Infinite Graph 社交网络，推荐系统等。专注于构建关系图谱 图结构 利用图结构相关算法。比如最短路径寻址，N度关系查找等 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"二、Redis入门 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"概述 Redis是什么？ Redis（Remote Dictionary Server )，即远程字典服务。 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis能该干什么？ 内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF） 高效率、用于高速缓冲 发布订阅系统 地图信息分析 计时器、计数器(eg：浏览量) 。。。 特性 多样的数据类型 持久化 集群 事务 … ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"环境搭建 官网：https://redis.io/ 推荐使用Linux服务器学习。 windows版本的Redis已经停更很久了… ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Windows安装 https://github.com/dmajkic/redis 解压安装包 开启redis-server.exe 启动redis-cli.exe测试 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Linux安装 下载安装包！redis-5.0.8.tar.gz 解压Redis的安装包！程序一般放在 /opt 目录下 基本环境安装 yum install gcc-c++ # 然后进入redis目录下执行 make # 然后执行 make install redis默认安装路径 /usr/local/bin 将redis的配置文件复制到 程序安装目录 /usr/local/bin/kconfig下 redis默认不是后台启动的，需要修改配置文件！ 通过制定的配置文件启动redis服务 使用redis-cli连接指定的端口号测试，Redis的默认端口6379 查看redis进程是否开启 关闭Redis服务 shutdown 再次查看进程是否存在 后面我们会使用单机多Redis启动集群测试 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"测试性能 **redis-benchmark：**Redis官方提供的性能测试工具，参数选项如下： 简单测试： # 测试：100个并发连接 100000请求 redis-benchmark -h localhost -p 6379 -c 100 -n 100000 12 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"基础知识 redis默认有16个数据库 默认使用的第0个; 16个数据库为：DB 0~DB 15 默认使用DB 0 ，可以使用select n切换到DB n，dbsize可以查看当前数据库的大小，与key数量相关。 127.0.0.1:6379\u003e config get databases # 命令行查看数据库数量databases 1) \"databases\" 2) \"16\" 127.0.0.1:6379\u003e select 8 # 切换数据库 DB 8 OK 127.0.0.1:6379[8]\u003e dbsize # 查看数据库大小 (integer) 0 # 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。 127.0.0.1:6379\u003e set name sakura OK 127.0.0.1:6379\u003e SELECT 8 OK 127.0.0.1:6379[8]\u003e get name # db8中并不能获取db0中的键值对。 (nil) 127.0.0.1:6379[8]\u003e DBSIZE (integer) 0 127.0.0.1:6379[8]\u003e SELECT 0 OK 127.0.0.1:6379\u003e keys * 1) \"counter:__rand_int__\" 2) \"mylist\" 3) \"name\" 4) \"key:__rand_int__\" 5) \"myset:__rand_int__\" 127.0.0.1:6379\u003e DBSIZE # size和key个数相关 (integer) 5 keys * ：查看当前数据库中所有的key。 flushdb：清空当前数据库中的键值对。 flushall：清空所有数据库的键值对。 Redis是单线程的，Redis是基于内存操作的。 所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。 那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+ Redis为什么单线程还这么快？ 误区1：高性能的服务器一定是多线程的？ 误区2：多线程（CPU上下文会切换！）一定比单线程效率高！ 核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:6","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"三、五大数据类型 Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Redis-key 在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。 下面学习的命令： exists key：判断键是否存在 del key：删除键值对 move key db：将键值对移动到指定数据库 expire key second：设置键值对的过期时间 type key：查看value的数据类型 127.0.0.1:6379\u003e keys * # 查看当前数据库所有key (empty list or set) 127.0.0.1:6379\u003e set name qinjiang # set key OK 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e keys * 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e move age 1 # 将键值对移动到指定数据库 (integer) 1 127.0.0.1:6379\u003e EXISTS age # 判断键是否存在 (integer) 0 # 不存在 127.0.0.1:6379\u003e EXISTS name (integer) 1 # 存在 127.0.0.1:6379\u003e SELECT 1 OK 127.0.0.1:6379[1]\u003e keys * 1) \"age\" 127.0.0.1:6379[1]\u003e del age # 删除键值对 (integer) 1 # 删除个数 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e EXPIRE age 15 # 设置键值对的过期时间 (integer) 1 # 设置成功 开始计数 127.0.0.1:6379\u003e ttl age # 查看key的过期剩余时间 (integer) 13 127.0.0.1:6379\u003e ttl age (integer) 11 127.0.0.1:6379\u003e ttl age (integer) 9 127.0.0.1:6379\u003e ttl age (integer) -2 # -2 表示key过期，-1表示key未设置过期时间 127.0.0.1:6379\u003e get age # 过期的key 会被自动delete (nil) 127.0.0.1:6379\u003e keys * 1) \"name\" 127.0.0.1:6379\u003e type name # 查看value的数据类型 string 关于TTL命令 Redis的key，通过TTL命令返回key的过期时间，一般来说有3种： 当前key没有设置过期时间，所以会返回-1. 当前key有设置过期时间，而且key已经过期，所以会返回-2. 当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间. 关于重命名RENAME和RENAMENX RENAME key newkey修改 key 的名称 RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。 更多命令学习：https://www.redis.net.cn/order/ [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wBVZtGVm-1597890996517)(狂神说 Redis.assets/image-20200813114228439.png)] ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"String(字符串) 普通的set、get直接略过。 命令 描述 示例 APPEND key value 向指定的key的value后追加字符串 127.0.0.1:6379\u003e set msg hello OK 127.0.0.1:6379\u003e append msg \" world\" (integer) 11 127.0.0.1:6379\u003e get msg “hello world” DECR/INCR key 将指定key的value数值进行+1/-1(仅对于数字) 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e incr age (integer) 21 127.0.0.1:6379\u003e decr age (integer) 20 INCRBY/DECRBY key n 按指定的步长对数值进行加减 127.0.0.1:6379\u003e INCRBY age 5 (integer) 25 127.0.0.1:6379\u003e DECRBY age 10 (integer) 15 INCRBYFLOAT key n 为数值加上浮点型数值 127.0.0.1:6379\u003e INCRBYFLOAT age 5.2 “20.2” STRLEN key 获取key保存值的字符串长度 127.0.0.1:6379\u003e get msg “hello world” 127.0.0.1:6379\u003e STRLEN msg (integer) 11 GETRANGE key start end 按起止位置获取字符串（闭区间，起止位置都取） 127.0.0.1:6379\u003e get msg “hello world” 127.0.0.1:6379\u003e GETRANGE msg 3 9 “lo worl” SETRANGE key offset value 用指定的value 替换key中 offset开始的值 127.0.0.1:6379\u003e SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379\u003e get msg “tehello” GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 127.0.0.1:6379\u003e GETSET msg test “hello world” SETNX key value 仅当key不存在时进行set 127.0.0.1:6379\u003e SETNX msg test (integer) 0 127.0.0.1:6379\u003e SETNX name sakura (integer) 1 SETEX key seconds value set 键值对并设置过期时间 127.0.0.1:6379\u003e setex name 10 root OK 127.0.0.1:6379\u003e get name (nil) MSET key1 value1 [key2 value2..] 批量set键值对 127.0.0.1:6379\u003e MSET k1 v1 k2 v2 k3 v3 OK MSETNX key1 value1 [key2 value2..] 批量设置键值对，仅当参数中所有的key都不存在时执行 127.0.0.1:6379\u003e MSETNX k1 v1 k4 v4 (integer) 0 MGET key1 [key2..] 批量获取多个key保存的值 127.0.0.1:6379\u003e MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3” PSETEX key milliseconds value 和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间， getset key value 如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值 String类似的使用场景：value除了是字符串还可以是数字，用途举例： 计数器 统计多单位的数量：uid:123666：follow 0 粉丝数 对象存储缓存 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"List(列表) Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等 正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN 命令 描述 LPUSH/RPUSH key value1[value2..] 从左边/右边向列表中PUSH值(一个或者多个)。 LRANGE key start end 获取list 起止元素==（索引从左往右 递增）== LPUSHX/RPUSHX key value 向已存在的列名中push值（一个或者多个） `LINSERT key BEFORE AFTER pivot value` LLEN key 查看列表长度 LINDEX key index 通过索引获取列表元素 LSET key index value 通过索引为元素设值 LPOP/RPOP key 从最左边/最右边移除值 并返回 RPOPLPUSH source destination 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部 LTRIM key start end 通过下标截取指定范围内的列表 LREM key count value List中是允许value重复的 count \u003e 0：从头部开始搜索 然后删除指定的value 至多删除count个 count \u003c 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。 BLPOP/BRPOP key1[key2] timout 移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOPLPUSH source destination timeout 和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 ---------------------------LPUSH---RPUSH---LRANGE-------------------------------- 127.0.0.1:6379\u003e LPUSH mylist k1 # LPUSH mylist=\u003e{1} (integer) 1 127.0.0.1:6379\u003e LPUSH mylist k2 # LPUSH mylist=\u003e{2,1} (integer) 2 127.0.0.1:6379\u003e RPUSH mylist k3 # RPUSH mylist=\u003e{2,1,3} (integer) 3 127.0.0.1:6379\u003e get mylist # 普通的get是无法获取list值的 (error) WRONGTYPE Operation against a key holding the wrong kind of value 127.0.0.1:6379\u003e LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素 1) \"k2\" 2) \"k1\" 3) \"k3\" 127.0.0.1:6379\u003e LRANGE mylist 0 2 1) \"k2\" 2) \"k1\" 3) \"k3\" 127.0.0.1:6379\u003e LRANGE mylist 0 1 1) \"k2\" 2) \"k1\" 127.0.0.1:6379\u003e LRANGE mylist 0 -1 # 获取全部元素 1) \"k2\" 2) \"k1\" 3) \"k3\" ---------------------------LPUSHX---RPUSHX----------------------------------- 127.0.0.1:6379\u003e LPUSHX list v1 # list不存在 LPUSHX失败 (integer) 0 127.0.0.1:6379\u003e LPUSHX list v1 v2 (integer) 0 127.0.0.1:6379\u003e LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5 (integer) 5 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"k1\" 5) \"k3\" ---------------------------LINSERT--LLEN--LINDEX--LSET---------------------------- 127.0.0.1:6379\u003e LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1 (integer) 6 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"ins_key1\" 5) \"k1\" 6) \"k3\" 127.0.0.1:6379\u003e LLEN mylist # 查看mylist的长度 (integer) 6 127.0.0.1:6379\u003e LINDEX mylist 3 # 获取下标为3的元素 \"ins_key1\" 127.0.0.1:6379\u003e LINDEX mylist 0 \"k5\" 127.0.0.1:6379\u003e LSET mylist 3 k6 # 将下标3的元素 set值为k6 OK 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"k6\" 5) \"k1\" 6) \"k3\" ---------------------------LPOP--RPOP-------------------------- 127.0.0.1:6379\u003e LPOP mylist # 左侧(头部)弹出 \"k5\" 127.0.0.1:6379\u003e RPOP mylist # 右侧(尾部)弹出 \"k3\" ---------------------------RPOPLPUSH-------------------------- 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" 3) \"k6\" 4) \"k1\" 127.0.0.1:6379\u003e RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部 \"k1\" 127.0.0.1:6379\u003e LRANGE newlist 0 -1 1) \"k1\" 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" 3) \"k6\" ---------------------------LTRIM-------------------------- 127.0.0.1:6379\u003e LTRIM mylist 0 1 # 截取mylist中的 0~1部分 OK 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" # 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2 ---------------------------LREM-------------------------- 127.0.0.1:6379\u003e LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2 (integer) 3 # 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2 127.0.0.1:6379\u003e LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2 (integer) 2 # 删除后：mylist: k2,k2,k2,k4,k2,k2 ---------------------------BLPOP--BRPOP-------------------------- mylist: k2,k2,k2,k4,k2,k2 newlist: k1 127.0.0.1:6379\u003e BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选 1) \"newlist\" # 弹出 2) \"k1\" 127.0.0.1:6379\u003e BLPOP newlist mylist 30 1) \"mylist\" # 由于newlist空了 从mylist中弹出 2) \"k2\" 127.0.0.1:6379\u003e BLPOP newlist 30 (30.10s) # 超时了 127.0.0.1:6379\u003e BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。 1) \"newlist\" 2) \"test\" (12.54s) 小结 list实际上是一个链表，before Node after , left, right 都可以插入值 如果key不存在，则创建新的链表 如果key存在，新增内容 如果移除了所有值，空链表，也代表不存在 在两边插入或者改动值，效率最高！修改中间元素，效率相对较低 应用： 消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop） ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Set(集合) Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 命令 描述 SADD key member1[member2..] 向集合中无序增加一个/多个成员 SCARD key 获取集合的成员数 SMEMBERS key 返回集合中所有的成员 SISMEMBER key member 查询member元素是否是集合的成员,结果是无序的 SRANDMEMBER key [count] 随机返回集合中count个成员，count缺省值为1 SPOP key [count] 随机移除并返回集合中count个成员，count缺省值为1 SMOVE source destination member 将source集合的成员member移动到destination集合 SREM key member1[member2..] 移除集合中一个/多个成员 SDIFF key1[key2..] 返回所有集合的差集 key1- key2 - … SDIFFSTORE destination key1[key2..] 在SDIFF的基础上，将结果保存到集合中==(覆盖)==。不能保存到其他类型key噢！ SINTER key1 [key2..] 返回所有集合的交集 SINTERSTORE destination key1[key2..] 在SINTER的基础上，存储结果到集合中。覆盖 SUNION key1 [key2..] 返回所有集合的并集 SUNIONSTORE destination key1 [key2..] 在SUNION的基础上，存储结果到及和张。覆盖 SSCAN KEY [MATCH pattern] [COUNT count] 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分 ---------------SADD--SCARD--SMEMBERS--SISMEMBER-------------------- 127.0.0.1:6379\u003e SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4 (integer) 4 127.0.0.1:6379\u003e SCARD myset # 获取集合的成员数目 (integer) 4 127.0.0.1:6379\u003e smembers myset # 获取集合中所有成员 1) \"m4\" 2) \"m3\" 3) \"m2\" 4) \"m1\" 127.0.0.1:6379\u003e SISMEMBER myset m5 # 查询m5是否是myset的成员 (integer) 0 # 不是，返回0 127.0.0.1:6379\u003e SISMEMBER myset m2 (integer) 1 # 是，返回1 127.0.0.1:6379\u003e SISMEMBER myset m3 (integer) 1 ---------------------SRANDMEMBER--SPOP---------------------------------- 127.0.0.1:6379\u003e SRANDMEMBER myset 3 # 随机返回3个成员 1) \"m2\" 2) \"m3\" 3) \"m4\" 127.0.0.1:6379\u003e SRANDMEMBER myset # 随机返回1个成员 \"m3\" 127.0.0.1:6379\u003e SPOP myset 2 # 随机移除并返回2个成员 1) \"m1\" 2) \"m4\" # 将set还原到{m1,m2,m3,m4} ---------------------SMOVE--SREM---------------------------------------- 127.0.0.1:6379\u003e SMOVE myset newset m3 # 将myset中m3成员移动到newset集合 (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset 1) \"m4\" 2) \"m2\" 3) \"m1\" 127.0.0.1:6379\u003e SMEMBERS newset 1) \"m3\" 127.0.0.1:6379\u003e SREM newset m3 # 从newset中移除m3元素 (integer) 1 127.0.0.1:6379\u003e SMEMBERS newset (empty list or set) # 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算 # setx=\u003e{m1,m2,m4,m6}, sety=\u003e{m2,m5,m6}, setz=\u003e{m1,m3,m6} -----------------------------SDIFF------------------------------------ 127.0.0.1:6379\u003e SDIFF setx sety setz # 等价于setx-sety-setz 1) \"m4\" 127.0.0.1:6379\u003e SDIFF setx sety # setx - sety 1) \"m4\" 2) \"m1\" 127.0.0.1:6379\u003e SDIFF sety setx # sety - setx 1) \"m5\" -------------------------SINTER--------------------------------------- # 共同关注（交集） 127.0.0.1:6379\u003e SINTER setx sety setz # 求 setx、sety、setx的交集 1) \"m6\" 127.0.0.1:6379\u003e SINTER setx sety # 求setx sety的交集 1) \"m2\" 2) \"m6\" -------------------------SUNION--------------------------------------- 127.0.0.1:6379\u003e SUNION setx sety setz # setx sety setz的并集 1) \"m4\" 2) \"m6\" 3) \"m3\" 4) \"m2\" 5) \"m1\" 6) \"m5\" 127.0.0.1:6379\u003e SUNION setx sety # setx sety 并集 1) \"m4\" 2) \"m6\" 3) \"m2\" 4) \"m1\" 5) \"m5\" ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Hash（哈希） Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。 Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。 命令 描述 HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0 HMSET key field1 value1 [field2 value2..] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 HGET key field value 获取存储在哈希表中指定字段的值 HMGET key field1 [field2..] 获取所有给定字段的值 HGETALL key 获取在哈希表key 的所有字段和值 HKEYS key 获取哈希表key中所有的字段 HLEN key 获取哈希表中字段的数量 HVALS key 获取哈希表中所有值 HDEL key field1 [field2..] 删除哈希表key中一个/多个field字段 HINCRBY key field n 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段 HINCRBYFLOAT key field n 为哈希表 key 中的指定字段的浮点数值加上增量 n。 HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。 ------------------------HSET--HMSET--HSETNX---------------- 127.0.0.1:6379\u003e HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura (integer) 1 127.0.0.1:6379\u003e HSET studentx name gyc # 重复设置field进行覆盖，并返回0 (integer) 0 127.0.0.1:6379\u003e HSET studentx age 20 # 设置studentx的age为20 (integer) 1 127.0.0.1:6379\u003e HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886 OK 127.0.0.1:6379\u003e HSETNX studentx name gyc # HSETNX 设置已存在的field (integer) 0 # 失败 127.0.0.1:6379\u003e HSETNX studentx email 12345@qq.com (integer) 1 # 成功 ----------------------HEXISTS-------------------------------- 127.0.0.1:6379\u003e HEXISTS studentx name # name字段在studentx中是否存在 (integer) 1 # 存在 127.0.0.1:6379\u003e HEXISTS studentx addr (integer) 0 # 不存在 -------------------HGET--HMGET--HGETALL----------- 127.0.0.1:6379\u003e HGET studentx name # 获取studentx中name字段的value \"gyc\" 127.0.0.1:6379\u003e HMGET studentx name age tel # 获取studentx中name、age、tel字段的value 1) \"gyc\" 2) \"20\" 3) \"15623667886\" 127.0.0.1:6379\u003e HGETALL studentx # 获取studentx中所有的field及其value 1) \"name\" 2) \"gyc\" 3) \"age\" 4) \"20\" 5) \"sex\" 6) \"1\" 7) \"tel\" 8) \"15623667886\" 9) \"email\" 10) \"12345@qq.com\" --------------------HKEYS--HLEN--HVALS-------------- 127.0.0.1:6379\u003e HKEYS studentx # 查看studentx中所有的field 1) \"name\" 2) \"age\" 3) \"sex\" 4) \"tel\" 5) \"email\" 127.0.0.1:6379\u003e HLEN studentx # 查看studentx中的字段数量 (integer) 5 127.0.0.1:6379\u003e HVALS studentx # 查看studentx中所有的value 1) \"gyc\" 2) \"20\" 3) \"1\" 4) \"15623667886\" 5) \"12345@qq.com\" -------------------------HDEL-------------------------- 127.0.0.1:6379\u003e HDEL studentx sex tel # 删除studentx 中的sex、tel字段 (integer) 2 127.0.0.1:6379\u003e HKEYS studentx 1) \"name\" 2) \"age\" 3) \"email\" -------------HINCRBY--HINCRBYFLOAT------------------------ 127.0.0.1:6379\u003e HINCRBY studentx age 1 # studentx的age字段数值+1 (integer) 21 127.0.0.1:6379\u003e HINCRBY studentx name 1 # 非整数字型字段不可用 (error) ERR hash value is not an integer 127.0.0.1:6379\u003e HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6 \"90.8\" Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Zset（有序集合） 不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。 score相同：按字典顺序排序 有序集合的成员是唯一的,但分数(score)却可以重复。 命令 描述 ZADD key score member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数 ZCARD key 获取有序集合的成员数 ZCOUNT key min max 计算在有序集合中指定区间score的成员数 ZINCRBY key n member 有序集合中对指定成员的分数加上增量 n ZSCORE key member 返回有序集中，成员的分数值 ZRANK key member 返回有序集合中指定成员的索引 ZRANGE key start end 通过索引区间返回有序集合成指定区间内的成员 ZRANGEBYLEX key min max 通过字典区间返回有序集合的成员 ZRANGEBYSCORE key min max 通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()== ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量 ZREM key member1 [member2..] 移除有序集合中一个/多个成员 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员 ZREVRANGE key start end 返回有序集中指定区间内的成员，通过索引，分数从高到底 ZREVRANGEBYSCORRE key max min 返回有序集中指定分数区间内的成员，分数从高到低排序 ZREVRANGEBYLEX key max min 返回有序集中指定字典区间内的成员，按字典顺序倒序 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 ZINTERSTORE destination numkeys key1 [key2 ..] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score ZUNIONSTORE destination numkeys key1 [key2..] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 ZSCAN key cursor [MATCH pattern\\] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值） -------------------ZADD--ZCARD--ZCOUNT-------------- 127.0.0.1:6379\u003e ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2.. (integer) 2 127.0.0.1:6379\u003e ZCARD myzset # 获取有序集合的成员数 (integer) 2 127.0.0.1:6379\u003e ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量 (integer) 1 127.0.0.1:6379\u003e ZCOUNT myzset 0 2 (integer) 2 ----------------ZINCRBY--ZSCORE-------------------------- 127.0.0.1:6379\u003e ZINCRBY myzset 5 m2 # 将成员m2的score +5 \"7\" 127.0.0.1:6379\u003e ZSCORE myzset m1 # 获取成员m1的score \"1\" 127.0.0.1:6379\u003e ZSCORE myzset m2 \"7\" --------------ZRANK--ZRANGE----------------------------------- 127.0.0.1:6379\u003e ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加 (integer) 0 127.0.0.1:6379\u003e ZRANK myzset m2 (integer) 2 127.0.0.1:6379\u003e ZRANGE myzset 0 1 # 获取索引在 0~1的成员 1) \"m1\" 2) \"m3\" 127.0.0.1:6379\u003e ZRANGE myzset 0 -1 # 获取全部成员 1) \"m1\" 2) \"m3\" 3) \"m2\" #testset=\u003e{abc,add,amaze,apple,back,java,redis} score均为0 ------------------ZRANGEBYLEX--------------------------------- 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + # 返回所有成员 1) \"abc\" 2) \"add\" 3) \"amaze\" 4) \"apple\" 5) \"back\" 6) \"java\" 7) \"redis\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录 1) \"abc\" 2) \"add\" 3) \"amaze\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录 1) \"apple\" 2) \"back\" 3) \"java\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员 1) \"abc\" 2) \"add\" 3) \"amaze\" 4) \"apple\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员 1) \"apple\" 2) \"back\" 3) \"java\" -----------------------ZRANGEBYSCORE--------------------- 127.0.0.1:6379\u003e ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员 1) \"m1\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e ZRANGEBYSCORE myzset 1 5 1) \"m1\" 2) \"m3\" --------------------ZLEXCOUNT----------------------------- 127.0.0.1:6379\u003e ZLEXCOUNT testset - + (integer) 7 127.0.0.1:6379\u003e ZLEXCOUNT testset [apple [java (integer) 3 ------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE-------------------------------- 127.0.0.1:6379\u003e ZREM testset abc # 移除成员abc (integer) 1 127.0.0.1:6379\u003e ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员 (integer) 3 127.0.0.1:6379\u003e ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员 (integer) 2 127.0.0.1:6379\u003e ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员 (integer) 2 # testset=\u003e {abc,add,apple,amaze,back,java,redis} score均为0 # myzset=\u003e {(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)} ----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX----------- 127.0.0.1:6379\u003e ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3 1) \"m9\" 2) \"m7\" 3) \"m4\" 4) \"m3\" 127.0.0.1:6379\u003e ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4 1) \"m4\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员 1) \"m4\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:6","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"四、三种特殊数据类型 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Geospatial(地理位置) 使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用 命令 描述 geoadd key longitud(经度) latitude(纬度) member [..] 将具体经纬度的坐标存入一个有序集合 geopos key member [member..] 获取集合中的一个/多个成员坐标 geodist key member1 member2 [unit] 返回两个给定位置之间的距离。默认以米作为单位。 `georadius key longitude latitude radius m km GEORADIUSBYMEMBER key member radius... 功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。 geohash key member1 [member2..] 返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。 有效经纬度 有效的经度从-180度到180度。 有效的纬度从-85.05112878度到85.05112878度。 指定单位的参数 unit 必须是以下单位的其中一个： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 关于GEORADIUS的参数 通过georadius就可以完成 附近的人功能 withcoord:带上坐标 withdist:带上距离，单位与半径单位相同 COUNT n : 只显示前n个(按距离递增排序) ----------------georadius--------------------- 127.0.0.1:6379\u003e GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员 1) 1) \"hangzhou\" 2) \"29.4151\" 3) 1) \"120.20000249147415\" 2) \"30.199999888333501\" 2) 1) \"shanghai\" 2) \"205.3611\" 3) 1) \"121.40000134706497\" 2) \"31.400000253193539\" ------------geohash--------------------------- 127.0.0.1:6379\u003e geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示 1) \"wmrjwbr5250\" 2) \"wtw6ds0y300\" ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Hyperloglog(基数统计) Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。 因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 其底层使用string数据类型 什么是基数？ 数据集中不重复的元素的个数。 应用场景： 网页的访问量（UV）：一个用户多次访问，也只能算作一个人。 传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。 命令 描述 PFADD key element1 [elememt2..] 添加指定元素到 HyperLogLog 中 PFCOUNT key [key] 返回给定 HyperLogLog 的基数估算值。 PFMERGE destkey sourcekey [sourcekey..] 将多个 HyperLogLog 合并为一个 HyperLogLog ----------PFADD--PFCOUNT--------------------- 127.0.0.1:6379\u003e PFADD myelemx a b c d e f g h i j k # 添加元素 (integer) 1 127.0.0.1:6379\u003e type myelemx # hyperloglog底层使用String string 127.0.0.1:6379\u003e PFCOUNT myelemx # 估算myelemx的基数 (integer) 11 127.0.0.1:6379\u003e PFADD myelemy i j k z m c b v p q s (integer) 1 127.0.0.1:6379\u003e PFCOUNT myelemy (integer) 11 ----------------PFMERGE----------------------- 127.0.0.1:6379\u003e PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemz OK 127.0.0.1:6379\u003e PFCOUNT myelemz # 估算基数 (integer) 17 如果允许容错，那么一定可以使用Hyperloglog ! 如果不允许容错，就使用set或者自己的数据类型即可 ！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"BitMaps(位图) 使用位存储，信息状态只有 0 和 1 Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。 应用场景 签到统计、状态统计 命令 描述 setbit key offset value 为指定key的offset位设置值 getbit key offset 获取offset位的值 bitcount key [start end] 统计字符串被设置为1的bit数，也可以指定统计范围按字节 bitop operration destkey key[key..] 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 BITPOS key bit [start] [end] 返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位 ------------setbit--getbit-------------- 127.0.0.1:6379\u003e setbit sign 0 1 # 设置sign的第0位为 1 (integer) 0 127.0.0.1:6379\u003e setbit sign 2 1 # 设置sign的第2位为 1 不设置默认 是0 (integer) 0 127.0.0.1:6379\u003e setbit sign 3 1 (integer) 0 127.0.0.1:6379\u003e setbit sign 5 1 (integer) 0 127.0.0.1:6379\u003e type sign string 127.0.0.1:6379\u003e getbit sign 2 # 获取第2位的数值 (integer) 1 127.0.0.1:6379\u003e getbit sign 3 (integer) 1 127.0.0.1:6379\u003e getbit sign 4 # 未设置默认是0 (integer) 0 -----------bitcount---------------------------- 127.0.0.1:6379\u003e BITCOUNT sign # 统计sign中为1的位数 (integer) 4 bitmaps的底层 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PlszjhS-1597890996519)(D:\\我\\MyBlog\\狂神说 Redis.assets\\image-20200803234336175.png)] 这样设置以后你能get到的值是：\\xA2\\x80，所以bitmaps是一串从左到右的二进制串 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"五、事务 Redis的单条命令是保证原子性的，但是redis事务不能保证原子性 Redis事务本质：一组命令的集合。 —————– 队列 set set set 执行 ——————- 事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。 一次性 顺序性 排他性 Redis事务没有隔离级别的概念 Redis单条命令是保证原子性的，但是事务不保证原子性！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Redis事务操作过程 开启事务（multi） 命令入队 执行事务（exec） 所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。 127.0.0.1:6379\u003e multi # 开启事务 OK 127.0.0.1:6379\u003e set k1 v1 # 命令入队 QUEUED 127.0.0.1:6379\u003e set k2 v2 # .. QUEUED 127.0.0.1:6379\u003e get k1 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e keys * QUEUED 127.0.0.1:6379\u003e exec # 事务执行 1) OK 2) OK 3) \"v1\" 4) OK 5) 1) \"k3\" 2) \"k2\" 3) \"k1\" 取消事务(discurd) 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e DISCARD # 放弃事务 OK 127.0.0.1:6379\u003e EXEC (error) ERR EXEC without MULTI # 当前未开启事务 127.0.0.1:6379\u003e get k1 # 被放弃事务中命令并未执行 (nil) ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"事务错误 代码语法错误（编译时异常）所有的命令都不执行 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e error k1 # 这是一条语法错误命令 (error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e EXEC (error) EXECABORT Transaction discarded because of previous errors. # 执行报错 127.0.0.1:6379\u003e get k1 (nil) # 其他命令并没有被执行 代码逻辑错误 (运行时异常) **其他命令可以正常执行 ** »\u003e 所以不保证事务原子性 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e INCR k1 # 这条命令逻辑错误（对字符串进行增量） QUEUED 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e exec 1) OK 2) OK 3) (error) ERR value is not an integer or out of range # 运行时报错 4) \"v2\" # 其他命令正常执行 # 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。 # 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"监控 悲观锁： 很悲观，认为什么时候都会出现问题，无论做什么都会加锁 乐观锁： 很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据 获取version 更新的时候比较version 使用watch key监控指定数据，相当于乐观锁加锁。 正常执行 127.0.0.1:6379\u003e set money 100 # 设置余额:100 OK 127.0.0.1:6379\u003e set use 0 # 支出使用:0 OK 127.0.0.1:6379\u003e watch money # 监视money (上锁) OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY use 20 QUEUED 127.0.0.1:6379\u003e exec # 监视值没有被中途修改，事务正常执行 1) (integer) 80 2) (integer) 20 测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion） 我们启动另外一个客户端模拟插队线程。 线程1： 127.0.0.1:6379\u003e watch money # money上锁 OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY use 20 QUEUED 127.0.0.1:6379\u003e # 此时事务并没有执行 模拟线程插队，线程2： 127.0.0.1:6379\u003e INCRBY money 500 # 修改了线程一中监视的money (integer) 600 12 回到线程1，执行事务： 127.0.0.1:6379\u003e EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败 (nil) # 没有结果，说明事务执行失败 127.0.0.1:6379\u003e get money # 线程2 修改生效 \"600\" 127.0.0.1:6379\u003e get use # 线程1事务执行失败，数值没有被修改 \"0\" 解锁获取最新值，然后再加锁进行事务。 unwatch进行解锁。 注意：每次提交执行exec后都会自动释放锁，不管是否成功 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"六、Jedis 使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。 导入依赖 \u003c!--导入jredis的包--\u003e \u003cdependency\u003e \u003cgroupId\u003eredis.clients\u003c/groupId\u003e \u003cartifactId\u003ejedis\u003c/artifactId\u003e \u003cversion\u003e3.2.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--fastjson--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.70\u003c/version\u003e \u003c/dependency\u003e 编码测试 连接数据库 修改redis的配置文件 vim /usr/local/bin/myconfig/redis.conf 1 将只绑定本地注释 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4IRUFJ95-1597890996520)(狂神说 Redis.assets/image-20200813161921480.png)] 保护模式改为 no [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oKjIVapw-1597890996521)(狂神说 Redis.assets/image-20200813161939847.png)] 允许后台运行 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c2IMvpZL-1597890996522)(狂神说 Redis.assets/image-20200813161954567.png)] 开放端口6379 firewall-cmd --zone=public --add-port=6379/tcp --permanet 1 重启防火墙服务 systemctl restart firewalld.service 1 阿里云服务器控制台配置安全组 重启redis-server [root@AlibabaECS bin]# redis-server myconfig/redis.conf 1 操作命令 TestPing.java public class TestPing { public static void main(String[] args) { Jedis jedis = new Jedis(\"192.168.xx.xxx\", 6379); String response = jedis.ping(); System.out.println(response); // PONG } } 断开连接 事务 public class TestTX { public static void main(String[] args) { Jedis jedis = new Jedis(\"39.99.xxx.xx\", 6379); JSONObject jsonObject = new JSONObject(); jsonObject.put(\"hello\", \"world\"); jsonObject.put(\"name\", \"kuangshen\"); // 开启事务 Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); // jedis.watch(result) try { multi.set(\"user1\", result); multi.set(\"user2\", result); // 执行事务 multi.exec(); }catch (Exception e){ // 放弃事务 multi.discard(); } finally { // 关闭连接 System.out.println(jedis.get(\"user1\")); System.out.println(jedis.get(\"user2\")); jedis.close(); } } } ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:6:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"七、SpringBoot整合 导入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。 jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式 lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式 我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。 那么就一定还存在一个RedisProperties类 之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。 先看Jedis: @ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的 然后再看Lettuce： 完美生效。 现在我们回到RedisAutoConfiguratio 只有两个简单的Bean RedisTemplate StringRedisTemplate 当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。 在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的 说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties 这是一些基本的配置属性。 还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。 编写配置文件 # 配置redis spring.redis.host=39.99.xxx.xx spring.redis.port=6379 使用RedisTemplate @SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { // redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // opsForValue 操作字符串 类似String // opsForList 操作List 类似List // opsForHah // 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD // 获取连接对象 //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); //connection.flushDb(); //connection.flushAll(); redisTemplate.opsForValue().set(\"mykey\",\"kuangshen\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\")); } } 测试结果 此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出： 这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。 我们转到看那个默认的RedisTemplate内部什么样子： 在最开始就能看到几个关于序列化的参数。 默认的序列化器是采用JDK序列化器 而默认的RedisTemplate中的所有序列化器都是使用这个序列化器： 后续我们定制RedisTemplate就可以对其进行修改。 RedisSerializer提供了多种序列化方案： 直接调用RedisSerializer的静态方法来返回序列化器，然后set 自己new 相应的实现类，然后set 定制RedisTemplate的模板： 我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。 @Configuration public class RedisConfig { @Bean public RedisTemplate\u003cString, Object\u003e redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { // 将template 泛型设置为 \u003cString, Object\u003e RedisTemplate\u003cString, Object\u003e template = new RedisTemplate(); // 连接工厂，不必修改 template.setConnectionFactory(redisConnectionFactory); /* * 序列化设置 */ // key、hash的key 采用 String序列化方式 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // value、hash的value 采用 Jackson 序列化方式 template.setValueSerializer(RedisSerializer.json()); template.setHashValueSerializer(RedisSerializer.json()); template.afterPropertiesSet(); return template; } } 这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oc8kJP08-1597890996523)(狂神说 Redis.assets/image-20200817175638086.png)] ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:7:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"八、自定义Redis工具类 使用RedisTemplate需要频繁调用.opForxxx然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。 工具类参考博客： https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html https://www.cnblogs.com/zhzhlong/p/11434284.html ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:8:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"九、Redis.conf 容量单位不区分大小写，G和GB有区别 可以使用 include 组合多个配置问题 网络配置 日志输出级别 日志输出文件 持久化规则 由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中 持久化方式： RDB AOF RDB文件相关 主从复制 Security模块中进行密码设置 客户端连接相关 maxclients 10000 最大客户端数量 maxmemory \u003cbytes\u003e 最大内存限制 maxmemory-policy noeviction # 内存达到限制值的处理策略 redis 中的默认的过期策略是 volatile-lru 。 设置方式 config set maxmemory-policy volatile-lru 1 maxmemory-policy 六种方式 **1、volatile-lru：**只对设置了过期时间的key进行LRU（默认值） 2、allkeys-lru ： 删除lru算法的key **3、volatile-random：**随机删除即将过期key **4、allkeys-random：**随机删除 5、volatile-ttl ： 删除即将过期的 6、noeviction ： 永不过期，返回错误 AOF相关部分 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:9:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十、持久化—RDB RDB：Redis Databases [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-C0mm1D4A-1597890996524)(狂神说 Redis.assets/image-20200818122236614.png)] ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"什么是RDB 在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ； 默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"工作原理 在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作； Redis 调用forks。同时拥有父进程和子进程。 子进程将数据集写入到一个临时 RDB 文件中。 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。 这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。) ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"触发机制 save的规则满足的情况下，会自动触发rdb原则 执行flushall命令，也会触发我们的rdb原则 退出redis，也会自动产生rdb文件 save 使用 save 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了； 由于 save 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求。 flushall命令 flushall 命令也会触发持久化 ； 触发持久化规则 满足配置条件中的触发条件 ； 可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。 bgsave bgsave 是异步进行，进行持久化的时候，redis 还可以将继续响应客户端请求 ； bgsave和save对比 命令 save bgsave IO类型 同步 异步 阻塞？ 是 是（阻塞发生在fock()，通常非常快） 复杂度 O(n) O(n) 优点 不会消耗额外的内存 不阻塞客户端命令 缺点 阻塞客户端命令 需要fock子进程，消耗内存 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"优缺点 优点： 适合大规模的数据恢复 对数据的完整性要求不高 缺点： 需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。 fork进程的时候，会占用一定的内容空间。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十一、持久化AOF Append Only File 将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z8wr9lBW-1597890996525)(狂神说 Redis.assets/image-20200818123711375.png)] 以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:11:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"什么是AOF 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。 如果要使用AOF，需要修改配置文件： appendonly no yes则表示启用AOF 默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！ 如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件 redis给我们提供了一个工具redis-check-aof --fix 优点和缺点 appendonly yes # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用 appendfilename \"appendonly.aof\" # appendfsync always # 每次修改都会sync 消耗性能 appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据 # appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快 优点 每一次修改都会同步，文件的完整性会更加好 没秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点 相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！ Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:11:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十二、RDB和AOP选择 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:12:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"RDB 和 AOF 对比 RDB AOF 启动优先级 低 高 体积 小 大 恢复速度 快 慢 数据安全性 丢数据 根据策略决定 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:12:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"如何选择使用哪种持久化方式？ 一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。 有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:12:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十三、Redis发布与订阅 Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IBT2pjCa-1597890996526)(狂神说 Redis.assets/image-20200818162849693.png)] 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"命令 命令 描述 PSUBSCRIBE pattern [pattern..] 订阅一个或多个符合给定模式的频道。 PUNSUBSCRIBE pattern [pattern..] 退订一个或多个符合给定模式的频道。 PUBSUB subcommand [argument[argument]] 查看订阅与发布系统状态。 PUBLISH channel message 向指定频道发布消息 SUBSCRIBE channel [channel..] 订阅给定的一个或多个频道。 SUBSCRIBE channel [channel..] 退订一个或多个频道 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"示例 ------------订阅端---------------------- 127.0.0.1:6379\u003e SUBSCRIBE sakura # 订阅sakura频道 Reading messages... (press Ctrl-C to quit) # 等待接收消息 1) \"subscribe\" # 订阅成功的消息 2) \"sakura\" 3) (integer) 1 1) \"message\" # 接收到来自sakura频道的消息 \"hello world\" 2) \"sakura\" 3) \"hello world\" 1) \"message\" # 接收到来自sakura频道的消息 \"hello i am sakura\" 2) \"sakura\" 3) \"hello i am sakura\" --------------消息发布端------------------- 127.0.0.1:6379\u003e PUBLISH sakura \"hello world\" # 发布消息到sakura频道 (integer) 1 127.0.0.1:6379\u003e PUBLISH sakura \"hello i am sakura\" # 发布消息 (integer) 1 -----------------查看活跃的频道------------ 127.0.0.1:6379\u003e PUBSUB channels 1) \"sakura\" ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"原理 每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。 客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缺点 如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。 这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"应用 消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现） 多人在线聊天室。 稍微复杂的场景，我们就会使用消息中间件MQ处理。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十四、Redis主从复制 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。 默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。 故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式 负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。 高可用基石：主从复制还是哨兵和集群能够实施的基础。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"为什么使用集群 单台服务器难以负载大量的请求 单台服务器故障率高，系统崩坏概率大 单台服务器内存容量有限。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"环境配置 我们在讲解配置文件的时候，注意到有一个replication模块 (见Redis.conf中第8条) 查看当前库的信息：info replication 127.0.0.1:6379\u003e info replication # Replication role:master # 角色 connected_slaves:0 # 从机数量 master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息： 端口号 pid文件名 日志文件名 rdb文件名 启动单机多服务集群： ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"一主二从配置 ==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！ 认老大！一主（79）二从（80，81） 使用SLAVEOF host port就可以为从机配置主机了。 然后主机上也能看到从机的状态： 我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"使用规则 从机只能读，不能写，主机可读可写但是多用于写。 127.0.0.1:6381\u003e set name sakura # 从机6381写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6380\u003e set name sakura # 从机6380写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6379\u003e set name sakura OK 127.0.0.1:6379\u003e get name \"sakura\" 当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。 当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。 第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机： 从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机 使用哨兵模式（自动选举） 如果没有老大了，这个时候能不能选择出来一个老大呢？手动！ 如果主机断开了连接，我们可以使用SLAVEOF no one让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:6","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十五、哨兵模式 更多信息参考博客：https://www.jianshu.com/p/06ab9daf921d 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。 单机单个哨兵 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2ENYVAPp-1597890996527)(狂神说 Redis.assets/image-20200818233231154.png)] 哨兵的作用： 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。 多哨兵模式 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ga1RyfVc-1597890996528)(狂神说 Redis.assets/image-20200818233316478.png)] 哨兵的核心配置 sentinel monitor mymaster 127.0.0.1 6379 1 数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。 测试 redis-sentinel xxx/sentinel.conf 成功启动哨兵模式 此时哨兵监视着我们的主机6379，当我们断开主机后： 哨兵模式优缺点 优点： 哨兵集群，基于主从复制模式，所有主从复制的优点，它都有 主从可以切换，故障可以转移，系统的可用性更好 哨兵模式是主从模式的升级，手动到自动，更加健壮 缺点： Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦 实现哨兵模式的配置其实是很麻烦的，里面有很多配置项 哨兵模式的全部配置 完整的哨兵模式配置文件 sentinel.conf # Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379 port 26379 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\".-_\"组成。 # quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了 # sentinel monitor \u003cmaster-name\u003e \u003cip\u003e \u003credis-port\u003e \u003cquorum\u003e sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码 # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass \u003cmaster-name\u003e \u003cpassword\u003e sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 # sentinel down-after-milliseconds \u003cmaster-name\u003e \u003cmilliseconds\u003e sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs \u003cmaster-name\u003e \u003cnumslaves\u003e sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout \u003cmaster-name\u003e \u003cmilliseconds\u003e sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。 #对于脚本的运行结果有以下规则： #若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 #一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本， #这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数， #一个是事件的类型， #一个是事件的描述。 #如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。 #通知脚本 # sentinel notification-script \u003cmaster-name\u003e \u003cscript-path\u003e sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # \u003cmaster-name\u003e \u003crole\u003e \u003cstate\u003e \u003cfrom-ip\u003e \u003cfrom-port\u003e \u003cto-ip\u003e \u003cto-port\u003e # 目前\u003cstate\u003e总是“failover”, # \u003crole\u003e是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的 # 这个脚本应该是通用的，能被多次调用，不是针对性的。 # sentinel client-reconfig-script \u003cmaster-name\u003e \u003cscript-path\u003e sentinel client-reconfig-script mymaster /var/redis/reconfig.sh ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:15:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十六、缓存穿透与雪崩 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缓存穿透（查不到） 概念 在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。 解决方案 布隆过滤器 对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。 缓存空对象 一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缓存击穿（量太大，缓存过期） 概念 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。 解决方案 设置热点数据永不过期 这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。 加互斥锁(分布式锁) 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缓存雪崩 概念 大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。 解决方案 redis高可用 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群 限流降级 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 数据预热 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"Spring5 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:0:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.、Spring ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.1、简介 Spring ——\u003e 春天，为开源软件带来了春天 2002，首次推出了Spring框架的雏形：interface21框架！ Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版 Spring的理念：使用现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！ SSH：Struct2 + Spring + Hibernate（全自动持久化框架）！ SSM：SpringMVC + Spring + MyBatis（半自动持久化框架，可自定义性质更强）！ spring官网： https://spring.io/projects/spring-framework#overview 官方下载： https://repo.spring.io/release/org/springframework/spring/ GitHub： https://github.com/spring-projects/spring-framework Spring Web MVC： spring-webmvc最新版 Spring Web MVC和Spring-JDBC的pom配置文件： \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.2 优点 Spring是一个开源的免费的框架（容器）！ Spring是一个轻量级的、非入侵式的框架！ 控制反转（IoC），面向切面编程（AOP） 支持事务的处理，对框架整合的支持！（几乎市面上所有热门框架都能整合进去）！ === 总结一句话：Spring就是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的框架！ === ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.3 组成 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.4、扩展 现代化的java开发 -\u003e 基于Spring的开发！ Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速开发单个微服务 约定大于配置！ Spring Cloud SpringCloud是基于SpringBoot实现的！ 因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！ ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:4","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"2、IoC（控制反转）理论推导 传统的调用 UserDao package dao; public interface UserDao { void getUser(); } UserDaoImp package dao; public class UserDaoImpl implements UserDao{ public void getUser() { System.out.println(\"默认获取用户数据\"); } } UserSevice package Service; public interface UserService { void getUser(); } UserServiceImp package Service; import dao.UserDao; import dao.UserDaoImpl; public class UserServiceImpl implements UserService{ UserDao userDao = new UserDaoImpl(); public void getUser(){ userDao.getUser(); } } 测试 package holle0; import Service.UserService; import Service.UserServiceImpl; public class MyTest0 { public static void main(String[] args) { // 用户实际调用的是业务层，dao层他们不需要接触 UserService userService = new UserServiceImpl(); userService.getUser(); } } 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！ **改良：**我们使用一个Set接口实现。已经发生了革命性的变化！ //在Service层的实现类(UserServiceImpl)增加一个Set()方法 //利用set动态实现值的注入！ //DAO层并不写死固定调用哪一个UserDao的实现类 //而是通过Service层调用方法设置实现类！ private UserDao userDao; public void setUserDao(UserDao userDao){ this.userDao = userDao; } set() 方法实际上是动态改变了 UserDao userDao 的 初始化部分（new UserDaoImpl()） 测试中加上 ((UserServiceImpl)userService).setUserDao(new UserDaoImpl()); 之前，程序是主动创建对象！控制权在程序猿手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！（主动权在客户手上） 本质上解决了问题，程序员不用再去管理对象的创建 系统的耦合性大大降低，可以更专注在业务的实现上 这是IoC（控制反转）的原型，反转(理解)：主动权交给了用户 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:2:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"IoC本质 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:2:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"3、HolleSpring 在父模块中导入jar包 \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e pojo的Hello.java package pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \"Holle [str=\" + str + \"]\"; } } 在resource里面的xml配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--在Spring中创建对象，在Spring这些都称为bean 类型 变量名 = new 类型(); Holle holle = new Holle(); bean = 对象(holle) id = 变量名(holle) class = new的对象(new Holle();) property 相当于给对象中的属性设值,让str=\"Spring\" --\u003e \u003cbean id=\"hello\" class=\"pojo.Hello\"\u003e \u003cproperty name=\"str\" value=\"Spring\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 测试类MyTest package holle1; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Hello; public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //我们的对象下能在都在spring·中管理了，我们要使用，直接取出来就可以了 Hello holle = (Hello) context.getBean(\"hello\"); System.out.println(holle.toString()); } } 核心用set注入，所以必须要有下面的se()方法 //Hello类 public void setStr(String str) { this.str = str; } 思考： IoC：对象由Spring 来创建，管理，装配！ 弹幕评论里面的理解： 原来这套程序是：你写好菜单买好菜，客人来了自己把菜炒好招待，就相当于你请人吃饭 现在这套程序是：你告诉楼下餐厅，你要哪些菜，客人来的时候，餐厅把做好的你需要的菜送上来 IoC：炒菜这件事，不再由你自己来做，而是委托给了第三方__餐厅来做 此时的区别就是，如果我还需要做其他的菜，我不需要自己搞菜谱买材料再做好，而是告诉餐厅，我要什么菜，什么时候要，你做好送来 . 在前面第一个module试试引入Spring \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"userDaomSql\" class=\"dao.UserDaoMysqlImpl\"\u003e\u003c/bean\u003e \u003cbean id=\"userServiceImpl\" class=\"service.UserServiceImp\"\u003e \u003c!--ref引用spring中已经创建很好的对象--\u003e \u003c!--value是一个具体的值,基本数据类型--\u003e \u003cproperty name=\"userDao\" ref=\"userDaomSql\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 第一个module改良后测试 package holle0; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import service.UserServiceImpl; public class MyTest0 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(\"userServiceImpl\"); userServiceImpl.getUser(); } } 总结： 所有的类都要装配的beans.xml 里面； 所有的bean 都要通过容器去取； 容器里面取得的bean，拿出来就是一个对象，用对象调用方法即可； ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:3:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"4、IoC创建对象的方式 使用无参构造创建对象，默认。 使用有参构造（如下） 下标赋值 index指的是有参构造中参数的下标，下标从0开始; \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"chen\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 类型赋值（不建议使用） \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg type=\"java.lang.String\" value=\"kuang\"/\u003e \u003c/bean\u003e 直接通过参数名（掌握） \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"kuang\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003c!-- 比如参数名是name，则有name=\"具体值\" --\u003e 注册bean之后就对象的初始化了（类似 new 类名()） 弹幕评论： name方式还需要无参构造和set方法,index和type只需要有参构造 就算是new 两个对象，也是只有一个实例（单例模式：全局唯一） User user = (User) context.getBean(\"user\"); User user2 = (User) context.getBean(\"user\"); system.out.println(user == user2)//结果为true 总结：在配置文件加载的时候，容器(\u003c bean\u003e)中管理的对象就已经初始化了 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:4:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5、Spring配置 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5.1、别名 \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"chen\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003calias name=\"user\" alias=\"userLove\"/\u003e \u003c!-- 使用时 User user2 = (User) context.getBean(\"userLove\"); --\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5.2、Bean的配置 \u003c!--id：bean的唯一标识符，也就是相当于我们学的对象名 class：bean对象所对应的会限定名：包名+类型 name：也是别名，而且name可以同时取多个别名 --\u003e \u003cbean id=\"user\" class=\"pojo.User\" name=\"u1 u2,u3;u4\"\u003e \u003cproperty name=\"name\" value=\"chen\"/\u003e \u003c/bean\u003e \u003c!-- 使用时 User user2 = (User) context.getBean(\"u1\"); --\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5.3、import import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个 假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利 用import将所有人的beans.xml合并为一个总的！ 张三(beans.xm1) 李四(beans2.xm1) 王五(beans3.xm1) applicationContext.xml \u003cimport resource=\"beans.xm1\"/\u003e \u003cimport resource=\"beans2.xml\"/\u003e \u003cimport resource=\"beans3.xm1\"/\u003e 使用的时候，直接使用总的配置就可以了 弹幕评论： 按照在总的xml中的导入顺序来进行创建，后导入的会重写先导入的，最终实例化的对象会是后导入xml中的那个 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6、依赖注入（DI） ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.1、构造器注入 第4点有提到 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.2、set方式注入【重点】 依赖注入：set注入！ 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 【环境搭建】 复杂类型 Address类 真实测试对象 Student类 beans.xml 测试 MyTest3 Student类 package pojo; import java.util.*; @Get @Set public class Student { //别忘了写get和set方法（用lombok注解也行） private String name; private Address address; private String[] books; private List\u003cString\u003e hobbies; private Map\u003cString, String\u003e card; private Set\u003cString\u003e game; private Properties infor; private String wife; @Override public String toString() { return \"Student{\" +\"\\n\"+ \"name='\" + name + '\\'' +\"\\n\"+ \", address=\" + address.toString() +\"\\n\"+ \", books=\" + Arrays.toString(books) +\"\\n\"+ \", hobbies=\" + hobbies +\"\\n\"+ \", card=\" + card +\"\\n\"+ \", game=\" + game +\"\\n\"+ \", infor=\" + infor +\"\\n\"+ \", wife='\" + wife + '\\'' +\"\\n\"+ '}'; } } Address类 package pojo; public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"Address{\" + \"address='\" + address + '\\'' + '}'; } } beans.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"address\" class=\"pojo.Address\"\u003e \u003cproperty name=\"address\" value=\"address你好\" /\u003e \u003c/bean\u003e \u003cbean id=\"student\" class=\"pojo.Student\"\u003e \u003c!--第一种，普通值注入 --\u003e \u003cproperty name=\"name\" value=\"name你好\" /\u003e \u003c!--第二种，ref注入 --\u003e \u003cproperty name=\"address\" ref=\"address\" /\u003e \u003c!--数组注入 --\u003e \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e三国\u003c/value\u003e \u003cvalue\u003e西游\u003c/value\u003e \u003cvalue\u003e水浒\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c!--list列表注入 --\u003e \u003cproperty name=\"hobbies\"\u003e \u003clist\u003e \u003cvalue\u003e唱\u003c/value\u003e \u003cvalue\u003e跳\u003c/value\u003e \u003cvalue\u003erap\u003c/value\u003e \u003cvalue\u003e篮球\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!--map键值对注入 --\u003e \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"username\" value=\"root\" /\u003e \u003centry key=\"password\" value=\"root\" /\u003e \u003c/map\u003e \u003c/property\u003e \u003c!--set(可去重)注入 --\u003e \u003cproperty name=\"game\"\u003e \u003cset\u003e \u003cvalue\u003ewangzhe\u003c/value\u003e \u003cvalue\u003elol\u003c/value\u003e \u003cvalue\u003egalname\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003c!--空指针null注入 --\u003e \u003cproperty name=\"wife\"\u003e \u003cnull\u003e\u003c/null\u003e \u003c/property\u003e \u003c!--properties常量注入 --\u003e \u003cproperty name=\"infor\"\u003e \u003cprops\u003e \u003cprop key=\"id\"\u003e20200802\u003c/prop\u003e \u003cprop key=\"name\"\u003ecbh\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e MyTest3 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Student; public class MyTest3 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student stu = (Student) context.getBean(\"student\"); System.out.println(stu.toString()); } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.3、拓展注入 官方文档位置 pojo增加User类 package pojo; public class User { private String name; private int id; public User() { } public User(String name, int id) { super(); this.name = name; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return \"User [name=\" + name + \", id=\" + id + \"]\"; } } 注意： beans 里面加上这下面两行 使用p和c命名空间需要导入xml约束 xmlns:p=“http://www.springframework.org/schema/p” xmlns:c=“http://www.springframework.org/schema/c” ?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--p命名空间注入/set注入，可以直接注入属性的值-》property--\u003e \u003cbean id=\"user\" class=\"pojo.User\" p:name=\"cxk\" p:id=\"20\" \u003e \u003c/bean\u003e \u003c!--c命名空间，通过构造器注入，需要写入有参和无参构造方法-》construct-args--\u003e \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cbh\" c:id=\"22\"\u003e\u003c/bean\u003e \u003c/beans\u003e 测试 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = context.getBean(\"user\",User.class);//确定class对象，就不用再强转了 System.out.println(user.toString()); ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.4、Bean作用域 单例模式（默认） \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"singleton\"\u003e\u003c/bean\u003e 1 弹幕评论：单例模式是把对象放在pool中，需要再取出来，使用的都是同一个对象实例 原型模式: 每次从容器中get的时候，都产生一个新对象！ \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"prototype\"\u003e\u003c/bean\u003e 1 其余的request、session、application这些只能在web开放中使用！ ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:4","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"7、Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文自动寻找，并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显示配置 在java中显示配置 隐式的自动装配bean 【重要】 环境搭建：一个人有两个宠物 byType自动装配：byType会自动查找，和自己对象set方法参数的类型相同的bean 保证所有的class唯一(类为全局唯一) byName自动装配：byName会自动查找，和自己对象set对应的值对应的id 保证所有id唯一，并且和set注入的值一致 \u003c!-- 找不到id和多个相同class --\u003e \u003cbean id=\"cat1\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"cat2\" class=\"pojo.Cat\"/\u003e \u003c!-- 找不到 id=cat，且有两个Cat --\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:7:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"7.1测试：自动装配 pojo的Cat类 public class Cat { public void shut(){ System.out.println(\"miao\"); } } pojo的Dog类 public class Dog { public void shut(){ System.out.println(\"wow\"); } } pojo的People类 package pojo; public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"People{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } } xml配置 -\u003e byType 自动装配 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"cat\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"pojo.Dog\"/\u003e \u003c!--byType会在容器自动查找，和自己对象属性相同的bean 例如，Dog dog; 那么就会查找pojo的Dog类，再进行自动装配 --\u003e \u003cbean id=\"people\" class=\"pojo.People\" autowire=\"byType\"\u003e \u003cproperty name=\"name\" value=\"cbh\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e xml配置 -\u003e byName 自动装配 \u003cbean id=\"cat\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"pojo.Dog\"/\u003e \u003c!--byname会在容器自动查找，和自己对象set方法的set后面的值对应的id 例如:setDog()，取set后面的字符作为id，则要id = dog 才可以进行自动装配 --\u003e \u003cbean id=\"people\" class=\"pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"cbh\"\u003e\u003c/property\u003e \u003c/bean\u003e 弹幕评论：byName只能取到小写，大写取不到 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:7:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"7.2、使用注解实现自动装配 jdk1.5支持的注解，spring2.5支持的注解 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.（翻译：基于注释的配置的引入提出了一个问题，即这种方法是否比XML“更好”） 导入context约束 xmlns:context=“http://www.springframework.org/schema/context\" 配置注解的支持：\u003c context:annotation-config/\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e 7.2.1、@Autowired 默认是byType方式，如果匹配不上，就会byName 在属性上个使用，也可以在set上使用 我们可以不用编写set方法了，前提是自动装配的属性在Spring容器里，且要符合ByName 自动装配 public class People { @Autowired private Cat cat; @Autowired private Dog dog; private String name; } @Nullable 字段标记了这个注解，说明该字段可以为空 public name(@Nullable String name){ } //源码 public @interface Autowired { boolean required() default true; } 如果定义了Autowire的require属性为false，说明这个对象可以为null，否则不允许为空（false表示找不到装配，不抛出异常） 7.2.2、@Autowired+@Qualifier @Autowired不能唯一装配时，需要@Autowired+@Qualifier 如果@Autowired自动装配环境比较复杂。自动装配无法通过一个注解完成的时候，可以使用@Qualifier(value = “dog”)去配合使用，指定一个唯一的id对象 public class People { @Autowired private Cat cat; @Autowired @Qualifier(value = \"dog\") private Dog dog; private String name; } 弹幕评论： 如果xml文件中同一个对象被多个bean使用，Autowired无法按类型找到，可以用@Qualifier指定id查找 7.2.3、@Resource 默认是byName方式，如果匹配不上，就会byType public class People { Resource(name=\"cat\") private Cat cat; Resource(name=\"dog\") private Dog dog; private String name; } 弹幕评论： Autowired是byType，@Autowired+@Qualifier = byType || byName Autowired是先byteType,如果唯一則注入，否则byName查找。resource是先byname,不符合再继续byType 区别： @Resource和@Autowired的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】 @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】 执行顺序不同：@Autowired通过byType的方式实现。@Resource默认通过byname的方式实现 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:7:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8、使用注解开发 在spring4之后，使用注解开发，必须要保证aop包的导入 使用注解需要导入contex的约束 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.1、bean 弹幕评论： 有了\u003c context:component-scan\u003e，另一个\u003c context:annotation-config/\u003e标签可以移除掉，因为已经被包含进去了。 \u003c!--指定要扫描的包，这个包下面的注解才会生效 别只扫一个com.kuang.pojo包--\u003e \u003ccontext:component-scan base-package=\"com.kuang\"/\u003e \u003ccontext:annotation-config/\u003e //@Component 组件 //等价于\u003cbean id=\"user\" classs\"pojo.User\"/\u003e @Component public class User { public String name =\"秦疆\"; } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.2、属性如何注入@value @Component public class User { //相当于\u003cproperty name=\"name\" value=\"kuangshen\"/\u003e @value(\"kuangshen\") public String name; //也可以放在set方法上面 //@value(\"kuangshen\") public void setName(String name) { this.name = name; } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.3、衍生的注解 @Component有几个衍生注解，会按照web开发中，mvc架构中分层。 dao （@Repository） service（@Service） controller（@Controller） 这四个注解的功能是一样的，都是代表将某个类注册到容器中 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.4、自动装配置 @Autowired：默认是byType方式，如果匹配不上，就会byName @Nullable：字段标记了这个注解，说明该字段可以为空 @Resource：默认是byName方式，如果匹配不上，就会byType ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:4","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.5、作用域@scope //原型模式prototype，单例模式singleton //scope(\"prototype\")相当于\u003cbean scope=\"prototype\"\u003e\u003c/bean\u003e @Component @scope(\"prototype\") public class User { //相当于\u003cproperty name=\"name\" value=\"kuangshen\"/\u003e @value(\"kuangshen\") public String name; //也可以放在set方法上面 @value(\"kuangshen\") public void setName(String name) { this.name = name; } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:5","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.6、小结 xml与注解： xml更加万能，维护简单，适用于任何场合 注解，不是自己的类使用不了，维护复杂 最佳实践： xml用来管理bean 注解只用来完成属性的注入 要开启注解支持 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:6","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"9、使用Java的方式配置Spring 不使用Spring的xml配置，完全交给java来做！ Spring的一个子项目，在spring4之后，，，它成为了核心功能 实体类：pojo的User.java //这里这个注解的意思,就是说明这个类被Spring接管了,注册到了容器中 @component public class User { private String name; public String getName() { return name; } //属性注入值 @value(\"QINJIANG') public void setName(String name) { this.name = name; } @Override public String toString() { return \"user{\" + \"name='\" + name + '\\''+ '}'; } } 弹幕评论：要么使用@Bean，要么使用@Component和ComponentScan，两种效果一样 配置文件：config中的kuang.java @Import(KuangConfig2.class)，用@import来包含KuangConfig2.java //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于\u003cbeans\u003e标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -\u003egetUser //这个方法的返同值,就相当于bean 标签中的class 属性 -\u003eUser //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 public class MyTest { public static void main(String[ ] args) { //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); } } 会创建两个相同对象问题的说明： 弹幕总结 - -\u003e @Bean是相当于\u003c bean\u003e标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于\u003cbeans\u003e标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -\u003egetUser //这个方法的返同值,就相当于bean 标签中的class 属性 -\u003eUser //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 public class MyTest { public static void main(String[ ] args) { //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); } } 会创建两个相同对象问题的说明： 弹幕总结 - -\u003e @Bean是相当于\u003c bean\u003e标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:9:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"10、动态代理 代理模式是SpringAOP的底层 分类：动态代理和静态代理 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:10:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"10.1、静态代理 代码步骤： 1、接口 package pojo; public interface Host { public void rent(); } 2、真实角色 package pojo; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要出租房子\"); } } 3、代理角色 package pojo; public class Proxy { public Host host; public Proxy() { } public Proxy(Host host) { super(); this.host = host; } public void rent() { seeHouse(); host.rent(); fee(); sign(); } //看房 public void seeHouse() { System.out.println(\"看房子\"); } //收费 public void fee() { System.out.println(\"收中介费\"); } //合同 public void sign() { System.out.println(\"签合同\"); } } 4、客户端访问代理角色 package holle4_proxy; import pojo.Host; import pojo.HostMaster; import pojo.Proxy; public class My { public static void main(String[] args) { //房东要出租房子 Host host = new HostMaster(); //中介帮房东出租房子，但也收取一定费用（增加一些房东不做的操作） Proxy proxy = new Proxy(host); //看不到房东，但通过代理，还是租到了房子 proxy.rent(); } } 代码翻倍：几十个真实角色就得写几十个代理 AOP横向开发 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:10:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"10.2、动态代理 动态代理和静态角色一样，动态代理底层是反射机制 动态代理类是动态生成的，不是我们直接写好的！ 动态代理(两大类)：基于接口，基于类 基于接口：JDK的动态代理【使用ing】 基于类：cglib java字节码实现：javasisit 了解两个类 1、Proxy：代理 2、InvocationHandler：调用处理程序 实例： 接口 Host.java //接口 package pojo2; public interface Host { public void rent(); } 接口Host实现类 HostMaster.java //接口实现类 package pojo2; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要租房子\"); } } 代理角色的处理程序类 ProxyInvocationHandler.java package pojo2; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; ///用这个类，自动生成代理 public class ProxyInvocationHandler implements InvocationHandler { // Foo f =(Foo) Proxy.NewProxyInstance(Foo. Class.GetClassLoader(), // new Class\u003c?\u003e[] { Foo.Class }, // handler); // 被代理的接口 public HostMaster hostMaster ; public void setHostMaster(HostMaster hostMaster) { this.hostMaster = hostMaster; } // 得到生成的代理类 public Object getProxy() { // newProxyInstance() -\u003e 生成代理对象，就不用再写具体的代理类了 // this.getClass().getClassLoader() -\u003e 找到加载类的位置 // hostMaster.getClass().getInterfaces() -\u003e 代理的具体接口 // this -\u003e 代表了接口InvocationHandler的实现类ProxyInvocationHandler return Proxy.newProxyInstance(this.getClass().getClassLoader(), hostMaster.getClass().getInterfaces(), this); // 处理代理实例并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(hostMaster, args); fee(); return result; } public void seeHouse() { System.out.println(\"看房子\"); } public void fee() { System.out.println(\"收中介费\"); } } 用户类 My2.java package holle4_proxy; import pojo2.Host; import pojo2.Host2; import pojo2.HostMaster; import pojo2.ProxyInvocationHandler; public class My2 { public static void main(String[] args) { //真实角色 HostMaster hostMaster = new HostMaster(); //代理角色，现在没有；用代理角色的处理程序来实现Host接口的调用 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //pih -\u003e HostMaster接口类 -\u003e Host接口 pih.setHostMaster(hostMaster); //获取newProxyInstance动态生成代理类 Host proxy = (Host) pih.getProxy(); proxy.rent(); } } 弹幕评论： 什么时候调用invoke方法的? 代理实例调用方法时invoke方法就会被调用，可以debug试试 改为万能代理类 ///用这个类，自动生代理 public class ProxyInvocationHandler implements InvocationHandler { // 被代理的接口 public Object target; public void setTarget(Object target) { this.target = target; } // 得到生成的代理类 -\u003e 固定的代码 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // 处理代理实例并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(target, args); return result; } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:10:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11、AOP ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11.1、什么是AOP ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11.2、AOP在Spring中的使用 提供声明式事务，允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等… 切面(Aspect)：横切关注点 被模块化的特殊对象。即，它是一个类。（Log类） 通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法。（Log类中的方法） 目标(Target)：被通知对象。（生成的代理类) 代理(Proxy)：向目标对象应用通知之后创建的对象。（生成的代理类） 切入点(PointCut)：切面通知执行的”地点”的定义。（最后两点：在哪个地方执行，比如：method.invoke()） 连接点(JointPoint)：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即AOP在不改变原有代码的情况下，去增加新的功能。（代理） ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11.3、使用Spring实现AOP 导入jar包 \u003c!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e 11.3.1、方法一：使用原生spring接口 springAPI接口实现 applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--注册bean--\u003e \u003cbean id=\"userservice\" class=\"service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"log.AfterLog\"/\u003e \u003c!--方式一，使用原生Spring API接口--\u003e \u003c!--配置aop,还需要导入aop约束--\u003e \u003caop:config\u003e \u003c!--切入点：expression:表达式，execution（要执行的位置）--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* service.UserServiceImpl.*(..))\"/\u003e \u003c!--UserServiceImpl.*(..) -》 UserServiceImpl类下的所以方法(参数)--\u003e \u003c!--执行环绕增加--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/\u003e \u003c!-- 环绕,在id=\"pointcut\"的前后切入 --\u003e \u003c/aop:config\u003e \u003c/beans\u003e execution(返回类型，类名，方法名(参数)) -\u003e execution(* com.service.*,*(…)) UserService.java package service; public interface UserService { public void add() ; public void delete() ; public void query() ; public void update(); } UserService 的实现类 UserServiceImp.java package service; public class UserServiceImpl implements UserService { public void add() { System.out.println(\"add增\"); } public void delete() { System.out.println(\"delete删\"); } public void update() { System.out.println(\"update改\"); } public void query() { System.out.println(\"query查\"); } } 前置Log.java package log; import org.springframework.aop.MethodBeforeAdvice; import java.lang.reflect.Method; public class Log implements MethodBeforeAdvice { //method：要执行的目标对象的方法 //args：参数 //target：目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); } } 后置AfterLog.java package log; import java.lang.reflect.Method; import org.springframework.aop.AfterReturningAdvice; public class AfterLog implements AfterReturningAdvice { //returnVaule: 返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"方法，返回值是\"+returnValue); } } 测试类MyTest5 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import service.UserService; public class MyTest5 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //注意:动态代理代理的是接口 UserService userService = (UserService) context.getBean(\"userservice\"); userService.add(); } } 11.3.2、方法二：自定义类实现AOP \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--注册bean--\u003e \u003cbean id=\"userservice\" class=\"service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"log.AfterLog\"/\u003e \u003c!-- 方式二，自定义 --\u003e \u003cbean id=\"diy\" class=\"diy.DiyPointcut\"/\u003e \u003caop:config\u003e \u003c!--自定义切面--\u003e \u003caop:aspect ref=\"diy\"\u003e \u003c!--切入点--\u003e \u003caop:pointcut id=\"point\" expression=\"execution(* service.UserServiceImpl.*(..))\"/\u003e \u003caop:before method=\"before\" pointcut-ref=\"point\"/\u003e \u003caop:after method=\"after\" pointcut-ref=\"point\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e \u003c/beans\u003e package diy; public class DiyPointcut { public","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"12、整合mybatis mybatis-spring官网：https://mybatis.org/spring/zh/ mybatis的配置流程： 编写实体类 编写核心配置文件 编写接口 编写Mapper.xmi 测试 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:12:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"12.1、mybatis-spring-方式一 编写数据源配置 sqISessionFactory sqISessionTemplate（相当于sqISession） 需要给接口加实现类【new】 将自己写的实现类，注入到Spring中 测试！ 先导入jar包 \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--在build中配置resources，来防止资源导出失败的问题--\u003e \u003c!-- Maven解决静态资源过滤问题 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 编写顺序： User -\u003e UserMapper -\u003e UserMapper.xml -\u003e spring-dao.xml -\u003e UserServiceImpl -\u003e applicationContext.xml -\u003e MyTest6 代码步骤： pojo实体类 User package pojo; import lombok.Data; @Data public class User { private int id; private String name; private String pwd; } mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper package mapper; import java.util.List; import pojo.User; public interface UserMapper { public List\u003cUser\u003e getUser(); } UserMapperImpl package mapper; import java.util.List; import org.mybatis.spring.SqlSessionTemplate; import pojo.User; public class UserMapperImpl implements UserMapper{ //我们的所有操作，在原来都使用sqlSession来执行，现在都使用SqlSessionTemplate； private SqlSessionTemplate sqlSessionTemplate; public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) { this.sqlSessionTemplate = sqlSessionTemplate; } public List\u003cUser\u003e getUser() { UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class); return mapper.getUser(); } } UserMapper.xml （狂神给面子才留下来的） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- 绑定接口 --\u003e \u003cmapper namespace=\"mapper.UserMapper\"\u003e \u003cselect id=\"getUser\" resultType=\"pojo.User\"\u003e select * from mybatis.mybatis \u003c/select\u003e \u003c/mapper\u003e resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!--开启日志--\u003e \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\" /\u003e \u003c/settings\u003e \u003c!--可以给实体类起别名 --\u003e \u003ctypeAliases\u003e \u003cpackage name=\"pojo\" /\u003e \u003c/typeAliases\u003e \u003c/configuration\u003e spring-dao.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --\u003e \u003c!--data source --\u003e \u003cbean id=\"datasource\" class=\"org.spr","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:12:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"12.2、mybatis-spring-方式二 UserServiceImpl2 package mapper; import pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; //继承SqlSessionDaoSupport 类 public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper { public List\u003cUser\u003e getUser() { SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者一句话：return getSqlSession().getMapper(UserMapper.class).getUser(); } } spring-dao.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--DataSource:使用Spring的数帮源替换Mybatis的配置 c3p0 dbcp druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --\u003e \u003c!--data source --\u003e \u003cbean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=Asia/Shanghai\"/\u003e \u003cproperty name=\"username\" value=\"root\" /\u003e \u003cproperty name=\"password\" value=\"root\" /\u003e \u003c/bean\u003e \u003c!--sqlSessionFactory--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\" /\u003e \u003c!--绑定 mybatis 配置文件--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/\u003e \u003c/bean\u003e \u003c!-- 方法二：SqlSessionTemplate 可以不写了--\u003e \u003c/beans\u003e applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003cimport resource=\"spring-dao.xml\" /\u003e \u003c!-- 方法二 --\u003e \u003cbean id=\"userMapper2\" class=\"mapper.UserMapperImpl2\"\u003e \u003cproperty name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e 测试 public class MyTest6 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = (UserMapper) context.getBean(\"userMapper2\"); for (User user : userMapper.getUser()) { System.out.println(user); } } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:12:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"13. 声明式事务 把一组业务当成一个业务来做；要么都成功，要么都失败！ 事务在项目开发中，十分的重要，涉及到数据的一致性问题 确保完整性和一致性 事务的ACID原则： 1、原子性 2、隔离性 3、一致性 4、持久性 ACID参考文章：https://www.cnblogs.com/malaikuangren/archive/2012/04/06/2434760.html Spring中的事务管理 声明式事务：AOP 编程式事务：需要再代码中，进行事务管理 声明式事务 先导入jar包 \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--在build中配置resources，来防止资源导出失败的问题--\u003e \u003c!-- Maven解决静态资源过滤问题 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 代码步骤： pojo实体类 User package pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; private String pwd; } mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper package mapper; import java.util.List; import org.apache.ibatis.annotations.Param; import pojo.User; public interface UserMapper { public List\u003cUser\u003e getUser(); public int insertUser(User user); public int delUser(@Param(\"id\") int id); } UserMapperImpl package mapper; import pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper { public List\u003cUser\u003e getUser() { User user = new User(5,\"你好\",\"ok\"); insertUser(user); delUser(5); SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者return getSqlSession().getMapper(UserMapper.class).getUser(); } //插入 public int insertUser(User user) { return getSqlSession().getMapper(UserMapper.class).insertUser(user); } //删除 public int delUser(int id) { return getSqlSession().getMapper(UserMapper.class).delUser(id); } } UserMapper.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- 绑定接口 --\u003e \u003cmapper namespace=\"mapper.UserMapper\"\u003e \u003cselect id=\"getUser\" resultType=\"pojo.User\"\u003e select * from mybatis.mybatis \u003c/select\u003e \u003cinsert id=\"insertUser\" parameterType=\"pojo.User\" \u003e insert into mybatis.mybatis (id,name,pwd) values (#{id},#{name},#{pwd}) \u003c/insert\u003e \u003cdelete id=\"delUser\" parameterType=\"_int\"\u003e deleteAAAAA from mybatis.mybatis where id = #{id} \u003c!-- deleteAAAAA是故意写错的 --\u003e \u003c/delete\u003e \u003c/mapper\u003e resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003c!-- configuration --\u003e \u003cconfiguration\u003e \u003c!--开启日志--\u003e \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGIN","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:13:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["实训笔记"],"content":"《小米商城后台管理系统》 ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:1:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["实训笔记"],"content":"一、需求分析 电商系统项目结构 管理员登录 管理员要使用正确的账号和密码进行登录之后才能使用这个管理系统 商品类别管理 通过管理系统，能够动态完成添加商品类别、商品类别列表、修改类别及删除类别等操作 商品管理 通过管理系统，可以动态完成商品发布、商品列表（分页）、修改商品信息、删除商品信息（下架） 用户管理 订单管理 售后服务 ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:2:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["实训笔记"],"content":"二、项目设计 2.1 数据库设计 2.1.1 分析数据实体 管理员 类别 商品 2.1.2 提取实体数据项 根据甲方的业务需求及项目的功能需求分析每个数据实体的属性 管理员（管理员编号/工号，管理员账号，管理员密码，管理员姓名，管理员头像，管理员电话） 类别（类别ID，类别名称，类别描述） 商品（商品编号，商品名称，商品图片，商品价格，商品库存，商品说明，图文详情）、 2.1.3 规范实体数据项 使用数据库设计范式检查数据项是否合理——数据库设计三范式 第一范式：数据表中的字段不可再分 第二范式：不存在非关键字段对关键字段的部分函数依赖 第三范式：不存在非关键字段之间的传递依赖 2.1.4 绘制实体关系图（E-R） 通过E-R图例，分析实体和实体之间的关系（一对一、一对多、多对一、多对多） 在企业开发中通常是通过PD进行数据库建模 实体关系图 2.1.5 数据表设计（三线图） 2.1.6 建库建表（SQL） 大家根据三线图自行完成 2.2 业务流程设计 项目中业务实现的过程 2.2.1 管理登录业务流程 管理员登录 2.2.2 类别管理业务流程 添加类别 类别列表 修改类别 删除类别 2.2.3 商品管理业务流程 发布商品 商品列表 修改商品 删除商品 商品详情 2.3 UI界面设计 2.3.1 管理员登录 登录页面 login.html 主页面 index.html 2.3.2 类别管理 类别添加页面 type-add.html 类别列表页面 type-list.html 类别修改页面 type-modify.html 提示页面 tips.html 2.3.3 商品管理 暂略 ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:3:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["实训笔记"],"content":"三、编码—数据库编程、UI 3.1 创建项目—web项目 3.1.1 web项目创建 3.1.2 IDEA启动tomcat 启动 如果在启动Tomcat时出现以下错误，请手动打开Tomcat/bin/tomcat8w.exe关闭之前运行的Tomcat 3.1.3 修改项目的访问路径 在IDEA中启动Tomcat，会自动将web项目部署到Tomcat，但是web项目的访问路径默认与web名称时不一致的；我们可以设置项目访问路径 3.1.4 设置项目的默认访问页面 当我们启动Tomcat之后，通过路径http://ip:port/pro_name后面没有指定访问的页面名称，会默认访问index.html,如果没有index.html就寻找index.jsp web/WEB-INF/web.xml 3.2 完成项目业务所需的JDBC操作 完成项目业务流程中所需的数据库操作 3.2.1 向web项目中添加mysql数据库驱动文件 在web/WEB-INF目录下创建lib文件夹，将驱动文件拷贝粘贴到此文件夹，然后Add as Library 目录结构 3.2.2 创建数据库连接工具类DBUtil 创建cn.edu.hubu.xmsc.utils包 在cn.edu.hubu.xmsc.utils包装创建DBUtil类 DBUtil 3.2.3 完成管理登录所需的数据库操作 DTO类 Manager DAO类 ManagerDAO 3.2.4 完成类别管理的数据库操作 DTO类 Type DAO类 TypeDAO 3.3 设计界面并把界面整合到项目中 3.3.1 添加页面到项目的web目录 将在HBuilder中设计完成的HTML文件及其关联的静态资源(css\\js\\img\\fonts)拷贝到Javaweb项目的 web目录 3.3.2 将HTML页面转换成JSP页面 JSP（Java Server Page） 是一种基于web服务器运行的动态网页技术 支持Java代码 必须依赖于web服务器运行，不能使用浏览器直接打开 兼容HTML，在JSP中可以向在HTML文件中一样写HTML/CSS和JS ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:4:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["实训笔记"],"content":"四、编码— 业务(流程)实现 按照设计阶段完成业务流程，完成项目功能的实现 4.1 管理员登录功能 4.1.1 创建LoginServlet Servlet类——指的是继承了javax.servlet.HttpServlet类、实现了HTTP协议、能够接收HTTP请求的类 Servlet类的创建步骤 4.1.2 login.jsp提交数据到LoginServlet类 login.jsp 4.1.3 在LoginServlet类接收并处理请求 LoginServlet 4.1.4 在login.jsp显示提示信息 login.jsp 4.1.5 使用session解决登录认证问题 登录认证问题：如果管理员没有，我们不允许浏览器访问处理login.jsp以外的任何页面 index.jsp LoginServlet 4.1.6 在index.jsp显示当前登录管理员的姓名和头像 当管理员登录成功之后，我们将管理员的信息已经存放到了session中 index.jsp 4.2 类别管理—添加类别 4.2.1 点击添加类别跳转到type-add.jsp index.jsp 4.2.2 创建TypeAddServlet TypeAddServlet 4.2.3 type-add.jsp提交类别信息到TypeAddServlet type-add.jsp 4.2.4 在TypeAddServlet中接收并保存类信息，并跳转到提示页面 TypeAddServlet 4.2.5 在tips页面显示提示信息 因为操作成功和操作失败显示不同的信息，因此在jsp页面中需要实现流程控制—分支语句。 我们可以在JSP页面中使用JSTL实现流程控制（分支、循环） 在JSP页面中使用JSTL标签的准备工作： 下载jstl.jar 和 standard.jar并添加到项目 在需要使用JSTL标签库的JSP页面中引入标签 \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e tips.jsp 4.2.6 类别数据校验 type-add.jsp 4.3 类别管理—类别列表 4.3.1 创建TypeListServlet类 TypeListServlet 4.3.2 在index.jsp点击类别列表跳转到TypeListServlet index.jsp 4.3.3 在TypeListServlet中查询所有类别并传递到type-list.jsp TypeListServlet 4.3.4 在type-list.jsp中显示类别列表信息 因为TypeListServlet传递的是一个Type的集合，因此在type-list.jsp中需要通过JSTL的循环来遍历所有的类别 type-list.jsp 4.4 类别管理—修改类别 4.4.1 创建TypeQueryServlet 因为点击类别列表中的“修改”之后，需要跳转到TypeQueryServlet，因此要先完成TypeQueryServlet的创建 TypeQueryServlet 4.4.2 点击type-list.jsp页面的修改将类别ID传递到TypeQueryServlet type-list.jsp 4.4.3 在TypeQueryServlet接收类别ID、查询并传递到type-modify.jsp TypeQueryServlet 4.4.4 在type-modify.jsp显示类别的原始信息 type-modify.jsp 4.4.5 创建TypeUpdateServlet 4.4.6 在type-modify.jsp完成修改之后提交到TypeUpdateServlet type-modify.jsp 4.4.7 在TypeUpdateServlet接收类别信息并执行修改 TypeUpdateServlet 4.5 类别管理—删除类别 4.5.1 创建TypeDeleteServlet类 4.5.2 在type-list.jsp页面点击删除跳转到TypeDeleteServlet type-list.jsp 4.5.3 在TypeDeleteServlet中接收类别ID并执行删除 TypeDeleteServlet 4.5.4 当点击“删除”之后弹出弹窗确认 type-list.jsp 4.6 商品管理—发布商品 4.6.1 设计goods-add.jsp 步骤略 4.6.2 完成数据库操作 创建DTO类 Goods 创建DAO类 GoodsDAO 4.6.3 创建GoodsListTypeServlet类 4.6.4 在index.jsp页面点击发布商品跳转到 index.jsp 4.6.5. 在GoodsListTypeServlet类中查询类别列表传递到goods-add.jsp GoodsListTypeServlet 4.6.6 在goods-add.jsp中通过JSTL显示类别信息到下拉菜单选项 goods-add.jsp 4.6.7 创建GoodsAddServlet类 4.6.8 在goods-add.jsp点击“立即提交”提交到GoodsAddServlet类 在goods-add.jsp表单中包含了文件，如果提交的form表单中包含文件，需要注意以下几点： form的提交方式必须为 post form表单中的数据默认会压缩传输，如果包了文件就必须设置 enctype=\"multipart/form-data\"声明表达中的数据非压缩传输 goods-add.jsp 4.6.9 在GoodsAddServlet类中接收商品信息 因为表单提交数据采用enctype=\"multipart/form-data\"提交，所以在Servlet中按照原来的方式接收数据就接收不到了，必须在GoodsAddServlet类前添加@MultipartConfig解析非压缩方式提交的数据 上传的文件需要保存在特定的目录——在项目的web目录下创建名为files的文件夹用于保存图片（如果files文件夹是空的，项目部署时不会自动创建此目录，因此建议在files目录下默认放一个文件） GoodsAddServlet 4.7 商品管理—商品列表 4.7.1 设计goods-list.jsp 4.7.2 完成此功能的数据库操作 GoodsDAO 4.7.3 创建GoodsListServlet类 4.7.4 在index.jsp中点击商品列表跳转到GoodsListServlet类 默认显示第一页商品信息，传递默认页码为1 index.jsp 4.7.5 在GoodsListServlet类中接收页码、查询数据 GoodsListServlet 4.7.6 在goods-list.jsp中通过JSTL显示商品信息、分页信息 goods-list.jsp 显示商品数据 goods-list.jsp 显示分页数据 4.8 商品管理—搜索—按类别搜索 4.8.1 完成按类别查询商品的数据库操作 GoodsDAO 4.8.2 在GoodsListServlet中查询所有类别，并传递到goods-list.jsp GoodsListServlet 4.8.3 在商品列表页面显示类别列表 goods-list.jsp 4.8.4 创建GoodsListByTypeServlet类 4.8.5 点击商品类别页面的类别跳转到GoodsListByTypeServlet类 goods-list.jsp 4.8.6 在GoodsListByTypeServlet中接收类别ID和页码进行查询 GoodsListByTypeServlet 4.8.9 按类别查询商品分页问题 GoodsListServlet GoodsListByTypeServlet goods-list.jsp ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:5:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["实训笔记"],"content":"五、项目部署（Linux） 项目开发完成之后，将项目部署到生产环境正式的上线运营 5.1 Linux介绍 5.1.1 优点 用于生产环境的服务器主机通常会选择Linux系统 windows的优点是有比较人性化的可视化操作界面，这个可视化界面会占用大量的系统资源；但是生产环境中服务器主机主要用于web容器（tomcat）的执行，为了最大限度的使用硬件资源，所以我们通常会选择系统开销更小的Linux Linux系统是开源 Linux性能比windows更稳定（宕机概率较低） Linux防火墙组件性能高、保证系统安全 5.1.2 版本 RedHat（效率高、可靠性好） Ubuntu CentOS（基于RedHat源码编译而成，完全开源） 6.x 7.x 5.1.3 如何获取Linux 安装虚拟机，在虚拟机中安装CentOS 购买硬件主机、安装（成本高、商用） 购买云主机 5.2 购买云主机 5.2.1 云主机运营商 阿里云（推荐） https://developer.aliyun.com/adc/student/#ecscolleges-collocation-stu https://dashi.aliyun.com/site/cloud/student 腾讯云 5.3 管理云主机 5.3.1 登录到云主机 登录到阿里云的控制台（使用购买云主机时的账号和密码） https://account.aliyun.com/ 进入到ECS服务器管理界面 点击购买的实例进入到实例的配置页面 5.3.2 云主机系统管理 常规配置 5.3.3 修改云主机密码 设置root用户的登录密码 密码重置完成之后，重启服务器 5.3.4 安全组设置 阿里云主机为了保证系统的安全，提供了访问限制（端口配置） 进入到安全组配置页面 放行 3306端口 放行8080端口 5.4 使用远程工具连接云主机 云主机是远程的主机，需要使用工具进行远程连接，然后通过远程工具进行云主机的操作 5.4.1 xftp xftp是一个远程的文件传输工具，可以将本机上的文件上传到云主机 从群文件下载并安装（傻瓜式安装） 创建连接 将Tomcat和JDK的安装包 上传到 Linux 5.4.2 xshell xshell是一个远程终端，可以通过指令操作远程云主机 从群文件下载并安装（傻瓜式） 如果xftp已经与云主机建立连接，xshell其实是可以不用建立连接的，建议在xshell创建连接 5.5 在Linux系统中安装JDK并配置环境变量 5.5.1 将JDK的安装包上传到Linux系统的usr/local目录 使用xftp上传文件 5.5.2 解压JDK的压缩包 xshell连接到云主机 [root@theo ~]# cd /usr/local [root@theo local]# ls aegis apache-tomcat-8.5.46.tar.gz bin etc games include jdk-8u221-linux-x64.tar.gz lib lib64 libexec sbin share src [root@theo local]# tar -zxvf jdk-8u221-linux-x64.tar.gz 查看解压后的目录结构 [root@theo local]# ls aegis apache-tomcat-8.5.46.tar.gz bin etc games include jdk1.8.0_221 jdk-8u221-linux-x64.tar.gz lib lib64 libexec sbin share src [root@theo local]# cd jdk1.8.0_221/ [root@theo jdk1.8.0_221]# ls bin COPYRIGHT include javafx-src.zip jre lib LICENSE man README.html release src.zip THIRDPARTYLICENSEREADME-JAVAFX.txt THIRDPARTYLICENSEREADME.txt [root@theo jdk1.8.0_221]# cd bin [root@theo bin]# ls appletviewer jar javadoc javapackager jconsole jhat jmc jsadebugd jvisualvm pack200 rmiregistry tnameserv xjc ControlPanel jarsigner javafxpackager java-rmi.cgi jcontrol jinfo jmc.ini jstack keytool policytool schemagen unpack200 extcheck java javah javaws jdb jjs jps jstat native2ascii rmic serialver wsgen idlj javac javap jcmd jdeps jmap jrunscript jstatd orbd rmid servertool wsimport 5.5.3 配置JDK环境变量 进入到/etc目录，找到profile文件 [root@theo bin]# cd /etc [root@theo etc]# ls 编辑这个profile文件，在文件中添加JDK环境变量 [root@theo etc]# vim profile 可以打开文件编辑器，必须输入字母i进入到编辑状态,在最后面添加如下四项配置： export JAVA_HOME=/usr/local/jdk1.8.0_221 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib export PATH=$JAVA_HOME/bin:$PATH 编辑完成之后，点击键盘“Esc”按键退出编辑状态，输入:wq保存并退出编辑器 5.5.4 重新加载配置文件 [root@theo etc]# source /etc/profile [root@theo etc]# java -version java version \"1.8.0_221\" Java(TM) SE Runtime Environment (build 1.8.0_221-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode) 5.6 在Linux系统中安装Tomcat 5.6.1 从群文件按下载Tomcat安装包并上传到Linux的/usr/local目录 5.6.2 解压tomcat xshell连接到linux，在xshell中输入以下指令： [root@theo etc]# cd /usr/local [root@theo local]# tar -zxvf apache-tomcat-8.5.46.tar.gz 5.6.3 启动Tomcat [root@theo local]# cd apache-tomcat-8.5.46/ [root@theo apache-tomcat-8.5.46]# cd bin [root@theo bin]# ./startup.sh Using CATALINA_BASE: /usr/local/apache-tomcat-8.5.46 Using CATALINA_HOME: /usr/local/apache-tomcat-8.5.46 Using CATALINA_TMPDIR: /usr/local/apache-tomcat-8.5.46/temp Using JRE_HOME: /usr/local/jdk1.8.0_221/jre Using CLASSPATH: /usr/local/apache-tomcat-8.5.46/bin/bootstrap.jar:/usr/local/apache-tomcat-8.5.46/bin/tomcat-juli.jar Tomcat started. 5.6.4 关闭linux防火墙 # 查看防火墙状态 [root@theo bin]# systemctl status firewalld ● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: inactive (dead) Docs: man:firewalld(1) # 关闭防火墙 [root@theo bin]# systemctl stop firewalld # 启动防火墙 [root@theo bin]# systemctl start firewalld 5.6.5 远程访问linux中的tomcat http://47.96.11.185:8080/ 5.6.6 停止Tomcat # 在Linux系统中安装lsof指令（安装一次之后就不用重复安装了） [root@theo bin]# yum install -y lsof # 通过lsof 指令查看8080的进程号 [root@theo bin]# l","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:6:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["实训笔记"],"content":"六、项目开发任务（必须完成） 1.随堂项目功能需要完成 管理员登录 类别管理 添加类别（JS数据校验） 类别列表 删除类别（JS提示） 修改类别 商品管理 发布商品 商品列表+分页 2.扩展功能（自行完成） 管理员登录的表单校验 类别管理 修改类别（JS数据校验） 商品管理 发布商品（JS数据校验） 删除商品 修改商品 商品详情 ","date":"2021-04-06","objectID":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/:7:0","tags":[],"title":"商城系统笔记","uri":"/%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"},{"categories":["实训笔记"],"content":"一、实训规划 1.1 项目 项目名称：《小米商城后台管理系统》 项目功能要求： 管理员登录 商品类别管理 商品信息管理 文件上传 分页 1.2 课程规划 时间 内容 Day1 Java语法复习（补充必要的知识点）、数据库复习（MySQL安装配置，SQL） Day2 JDBC数据库编程（DAO\\DTO模式、CRUD操作封装）—-完成项目的数据库设计 Day3 前端（HTML\\CSS复习，JavaScript，前端框架Layui）—-完成项目的页面设计 Day4 Servlet复习，JSP（Java Server Page），JSTL Day5 完成管理员登录功能、商品类别添加功能 Day6 完成商品类别列表、删除类别、修改类别功能 Day7 完成商品添加（文件上传）、商品列表、商品详情 （商品修改、删除商品自行完成） Day8 项目部署、项目验收 1.3 软件的基本结构 如果要去完成一个项目，首先就要了解一个项目的结构，从项目的结构中分析所需的技术，然后补充相应的技术，以完成项目的开发。 软件结构 1.4 软件开发流程 明确项目的需求 项目功能设计 完成数据库设计 完成流程设计 完成UI界面 项目功能实现 编码 运行(功能测试) 项目测试（专业测试人员） 项目交付（项目部署） ","date":"2021-04-06","objectID":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/:1:0","tags":[],"title":"实训笔记","uri":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/"},{"categories":["实训笔记"],"content":"二、Java语言的复习 2.1 Java概述 Java是一种面向对象的服务器编程语言 Java出现于1991年，正式发布于1995年 Java语言的摇篮：SUN Java语言之父：James·Gosling 高斯林 Java语言的技术架构（Java语言可以干什么？） 2002开始占据编程语言排行榜第一 J2ME 传统手机上的软件（嵌入式编程） JavaSE AWT/swing PC桌面程序 （百里挑一） JavaEE 企业级应用（B/S）、互联网应用——解决三高问题 Android-SDK 手机应用（Android） （百里有一） 2.2 编译和解释 编程语言都是由字母、数字、符号组成，然而计算机只能识别机器语言（二进制），因此我们写好的程序源文件在计算机OS上执行必须要经过一个转换的过程，转换的方式有2种：编译和解释 编译 源文件先经过产生一个中间文件（可执行文件），计算机OS执行这个可执行文件 解释 源文件不会提前编译产生中间文件，计算机每次执行程序时都会再次进行动态的转换 Java语言是一种编译解释型语言 Java语言如何实现跨平台： Java源文件经过编译之后产生的字节码文件与操作系统无关，而是面向JVM运行的，因此无论是什么样的OS，只要能够安装JVM，就能执行Java程序 Java语言的编译解释执行过程： 2.3 JDK安装及环境变量配置 2.3.1 下载 64位链接：https://pan.baidu.com/s/1oiBEHPa4i0N94G4Br7agdQ 提取码：052g 32位链接：https://pan.baidu.com/s/1zytJsPyGCkmjp5cJbk6Hiw 提取码：atpm 2.3.2 安装 安装及环境变量配置视频链接：https://pan.baidu.com/s/1oDMk6u4ju9nPorB7-FjfxQ 提取码：zdww 傻瓜式安装 （默认安装在：） 安装目录如下 2.3.3 配置环境变量 配置环境变量，就是将JDK的bin目录路径配置到操作系统，以便于在CMD命令行窗口中输入指令时能够找到JDK的工具文件。 最简洁的配置方式： 2.4 IDE集成开发环境 2.4.1 记事本开发流程 编辑源文件： 编译运行 2.4.2 IDE工具 使用记事本做开发：第一开发效率低；第二没有错误异常提示、错误率高；项目中的多个文件不便于管理。 eclipse IDEA 2.4.3 下载安装IDEA IDEA2019.2+破解链接：https://pan.baidu.com/s/1cBrRz8Mns_yQQwna4QHGzg 提取码：v0z6 傻瓜式安装：选择界面风格（Dark,Light） 2.4.4 IDEA基本使用 代码写在方法中，方法创建在类中，类定义在包中，包创建在项目中 创建项目（基本Java项目） 启动IDEA创建Java项目 2.5 编程规范 代码的质量和优雅型处理考察功能完成情况、还会考察代码编写规范 可读性——让别人看起容易懂、看着舒服 语法规则（法律）：必须遵守的，不遵守代码不能运行 编程规范（道德）：需要遵守但是也可以不遵守 2.5.1 包名的命名规范 包名中所有字符小写 采用域后缀名倒置的形式命名 千锋 www.qfedu.com 湖大 www.hubu.edu.cn 包名结构：域后缀名.单位名称.模块名/项目组代号/项目名.包自己的名字 包名能够体现包的作用（有语义性） 2.5.2 类名的命名规范 见名知意：选取能够表达类的作用的英文单词组成 驼峰式命名：类名首字母大写，如果包含多个单词，每个单词首字母都大写 类名可以包含字母、数字、$和_，但是不能以数字开头 类名可以使用中文，但是不提倡使用 2.6 Java基础知识 2.6.1 基础部分 基础语法：变量、标识符、关键字、运算符、流程控制 面向对象：类与对象、方法定义与方法调用、特征(抽象、封装、继承、多态 ) 异常处理：try、catch、自定义异常 数组：数组定义及创建、数组遍历、排序（冒泡、快排、插入、选择）、二分法查找 常用类：String、Math、Date、DateFormat、Calendar、封装类（8个） 集合：ArrayList 集合家族Collection \\ Map家族 2.6.2 高级部分 IO流 网络编程 多线程 AWT/Swing 2.7 类、属性、方法 2.7.1 类 属性和方法要定义在类中 类的定义语法 [public] class \u003cClassName\u003e{ } []包含的内容表示可有可无 \u003c\u003e包含的内容必须有，但是可以改变 2.7.2 方法 方法，就是能够完成特定功能代码块 [\u003cpublic|protected|private\u003e] [static] \u003creturn_type\u003e \u003cmethodName\u003e([\u003cargsList\u003e]){ } 参数和返回值 package cn.edu.hubu.demo.dao; public class ClassA { /** * 无参数无返回值的方法：打印乘法口诀 */ public void printCFKJ(){ for (int i = 1; i \u003c=9 ; i++) { for (int j = 1; j \u003c=i ; j++) { System.out.print(i+\"*\"+j+\"=\"+i*j + \"\\t\"); } System.out.println(); } } /** * 有参数有返回值的方法：获取一个指定范围内的随机数 */ public int getRandomNum(int a,int b){ double d = Math.random(); // 0.45238947178923478 double d2 = d*(b-a)+a; // d2 [0,b-a) --- [a,b) int num = (int)Math.round(d2); //[a,b] return num; } } 2.7.3 对象创建及方法调用 package cn.edu.hubu.demo.dao; public class ClassB { public static void main(String[] args) { //打印乘法口诀 //调用ClassA中的printCFKJ方法 //1.对象的创建：如果我们要调用某个类中的方法，需要先创建这个类的对象 // 通过new关键字调用构造器创建对象 ClassA a = new ClassA(); //2.通过创建的对象调用类中的方法 a.printCFKJ(); int m = a.getRandomNum(10,30); System.out.println(m); } } Java基础参考视频：https://www.bilibili.com/video/BV1tQ4y1N7oh ","date":"2021-04-06","objectID":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/:2:0","tags":[],"title":"实训笔记","uri":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/"},{"categories":["实训笔记"],"content":"三、数据库设计 SQLServer Oracle (收钱) MySQL 3.1 MySQL的安装和配置 3.1.1 MySQL版本 MySQL 5.x v5.6 v5.7 MySQL 8.x 下载：MySQL5.6链接：https://pan.baidu.com/s/1Sk37sP66WJsnYrIiKxkelg 提取码：3t1m 3.1.2 MySQL安装 傻瓜式安装 端口：3306 设置密码（root）：admin123 3.1.3 安装数据库管理工具——Navicat MySQL是以服务的形式运行在OS中，没有提供可视化的窗口界面，只提供了一个DOS命令窗口用于进行指令操作；为了便于开发过程中对数据库的操作，我们需要安装一个数据库管理的视图工具——DBMS 傻瓜式安装 配置Navicat连接到MySQL数据库 Navicat连接到MySQL数据库 3.2 SQL复习 我们可以通过SQL指令完成对数据库的各种操作：建库建表、数据的增删查改等等 SQL 结构化查询语言——就是一种数据库可以“听懂”的语言 3.2.1 SQL分类 根据SQL语句的作用，我们可以将SQL语句分为四类： DDL 数据定义语言 ——建库、建表、索引、视图、存储过程、触发器 DML 数据操纵语言 ——对数据表中的数据进行增删改操作（insert\\delete\\update） DQL 数据查询语言 ——对数据表中的数据进行查询操作（select） DCL 数据控制语言 ——完成事务管理等操作（begin、commit、rollback） 3.2.2 DDL（建库建表） 数据是存储在数据表中的，数据表是创建在数据库中 数据库管理 -- 创建数据库 create database db_ytao; -- 使用数据库 use db_ytao; -- 删除数据库 drop database db_ytao; 数据表管理 -- 创建数据表 -- 学生信息表：学号、姓名、性别、年龄、手机、QQ、个性签名 -- 字符串 char定长 varchar可变 create table tb_students( stu_num char(15) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, stu_tel char(11) not null unique, stu_qq varchar(11) not null unique, stu_desc varchar(200) ); 3.2.3 DML 添加操作 -- 学生信息表中添加一条数据(在表名后的括号中列出字段名) insert into tb_students(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_desc) values('201801010101001','王二狗','男',21,'13030303300','123456','哥只是一个传说'); insert into tb_articles(article_id,article_title,article_content) values(12,'Java学习心得','2021.01.09日开始学习Java...'); 删除操作 -- delete from table 会删除数据表中所有的数据，需要通过where来限定删除条件 delete from tb_articles where article_id=\u003e13; 修改语句 -- 修改学号为201801010101001的学生的名字和年龄 update tb_students set stu_name='王小狗',stu_age=18 where stu_num='201801010101001'; 3.2.4 DQL 查询操作 -- 显示指定列 select stu_num,stu_name,stu_gender from tb_students; select stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_desc from tb_students; select * from tb_students; -- 条件筛选查询 select * from tb_students where stu_gender='女'; -- order by 对查询结果进行排序 select * from tb_students order by stu_age desc -- group by分组查询: select 关键字后的字段只能是被分组字段和聚合函数（count\\sum\\max\\min\\avg） select stu_gender,count(1) from tb_students group by stu_gender; -- having 分组筛选 select stu_age,count(1) from tb_students group by stu_age having stu_age\u003e=20; -- 学生信息表有9个学生，4条记录为1页，可以分为3页 -- 第1页 1-4 select * from tb_students limit 0,4; -- 第2页 5-8 select * from tb_students limit 4,4; -- 第3页 9 select * from tb_students limit 8,4; -- 第n页 select * from tb_students limit (n-1)*4,4; -- 每页显示pageSize条，查询第pageNum页 select * from tb_students limit (pageNum-1)*pageSize,pageSize; 3.3 软件开发流程 3.3.1 软件项目的开发流程 软件工程——软件开发生命周期 问题定义：甲方提出项目需求（业务需求） 可行性分析：从技术、经济、社会因素综合评估这个项目能不能做、要不要做 需求分析：需求采集—需求分析 概要设计：项目业务流程、数据库设计、UI设计 详细设计：设计具体功能的实现流程 编码 测试 交付：交项目（项目部署实施）、付款 3.3.2 《小米商城后台管理系统》项目的功能需求 电商系统项目结构 管理员登录 管理员要使用正确的账号和密码进行登录之后才能使用这个管理系统 商品类别管理 通过管理系统，能够动态完成添加商品类别、商品类别列表、修改类别及删除类别等操作 商品管理 通过管理系统，可以动态完成商品发布、商品列表（分页）、修改商品信息、删除商品信息（下架） 用户管理 订单管理 售后服务 3.4 《小米商城后台管理系统》数据库设计 3.4.1.分析数据实体 根据项目的功能确定要存储的数据对象 管理员 用户 类别 商品 购物车 订单 3.4.2 提取实体数据项 根据甲方的业务需求及项目的功能需求分析每个数据实体的属性 管理员（管理员编号/工号，管理员账号，管理员密码，管理员姓名，管理员头像，管理员电话） 用户（用户ID，账号/手机，密码，性别、年龄….） 类别（类别ID，类别名称，类别描述） 商品（商品编号，商品名称，商品图片，商品价格，商品库存，商品说明，图文详情） 购物车（购物车ID，用户ID，商品ID，数量，日期） 订单(订单ID，用户ID，订单日期，订单状态，….） 商品快照表（….） 购物车和订单数据关系 3.4.3 规范实体数据项 使用数据库设计范式检查数据项是否合理——数据库设计三范式 第一范式：数据表中的字段不可再分 傻子都不可能创建出不满足第一范式的表格，目前现有的数据库都不支持如下结构的创建 第一范式反例： 第二范式：不存在非关键字段对关键字段的部分函数依赖 第二范式案例： 第三范式：不存在非关键字段之间的传递依赖 第三范式案例： 3.4.4 绘制实体关系图（E-R） 通过E-R图例，分析实体和实体之间的关系（一对一、一对多、多对一、多对多） 在企业开发中通常是通过PD进行数据库建模 实体关系图 3.4.5 数据表设计（三线图） 3.4.6 建库建表（SQL） 大家根据三线图自行完成 ","date":"2021-04-06","objectID":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/:3:0","tags":[],"title":"实训笔记","uri":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/"},{"categories":["实训笔记"],"content":"四、数据库编程 使用Java代码完成对数据库、数据表中的数据的访问——JDBC 4.1 JDBC的步骤 JDBC操作数据库7个步骤 4.2 JDBC实现：添加操作 案例：使用Java代码向db_ytao数据库的tb_students表中添加一条学生信息 4.2.1 建立数据库连接 将数据库连接驱动文件添加到项目中 选择Java项目名—右键—New Directory—lib 将mysql-connector-java-5.1.47.jar文件拷贝并粘贴到创建的lib文件夹 选择lib中的mysql-connector-java-5.1.47.jar文件—右键—Add as Library–OK 加载驱动 获取连接 创建连接 4.2.2 JDBC操作代码（2-7步） 2021.01.11晚上练习任务 1.复习今天的笔记，掌握软件的开发流程及数据库设计规范，完成小米商城数据表的创建 2.总结JDBC操作步骤，完成学生信息的添加操作（课堂案例） 3.完成学生信息的删除操作（根据输入的学号删除一条学生信息） 4.完成学生信息的修改操作（根据学号修改学生的姓名、性别、…） 4.3 JDBC实现：删除操作 代码如下： package cn.edu.hubu.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.util.Scanner; public class DeleteStudent { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"请输入要删除的学生学号：\"); String stuNum = scanner.nextLine(); try { //如果这句代码需要进行异常处理，将鼠标放在红色提示后面：ALT+ENTER Class.forName(\"com.mysql.jdbc.Driver\"); //数据库连接字符串 String url = \"jdbc:mysql://localhost:3306/db_ytao?characterEncoding=utf-8\"; String username = \"root\"; String password = \"admin123\"; //在IDEA如果调用的方法有返回值，可以在方法调用完成之后，直接.var回车自动定义接收返回值的变量 Connection connection = DriverManager.getConnection(url, username, password); String sql = \"delete from tb_students where stu_num=?\"; PreparedStatement ps = connection.prepareStatement(sql); ps.setString(1,stuNum); int i = ps.executeUpdate(); System.out.println(i\u003e0?\"删除成功！\":\"删除失败！\"); connection.close(); } catch (Exception e) { e.printStackTrace(); } } } 4.4 JDBC操作：修改操作 代码如下 package cn.edu.hubu.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.util.Scanner; public class UpdateStudent { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"请输入要修改的学生学号：\"); String stuNum = scanner.nextLine(); System.out.println(\"请输入新姓名：\"); String stuName = scanner.nextLine(); System.out.println(\"请输入新性别：\"); String stuGender = scanner.nextLine(); System.out.println(\"请输入新年龄：\"); String stuAge = scanner.nextLine(); System.out.println(\"请输入新电话：\"); String stuTel = scanner.nextLine(); System.out.println(\"请输入新QQ：\"); String stuQQ = scanner.nextLine(); System.out.println(\"请输入新签名：\"); String stuDesc = scanner.nextLine(); try { Class.forName(\"com.mysql.jdbc.Driver\"); String url = \"jdbc:mysql://localhost:3306/db_ytao?characterEncoding=utf-8\"; String username = \"root\"; String password = \"admin123\"; Connection connection = DriverManager.getConnection(url, username, password); String sql = \"update tb_students set stu_name=?,stu_gender=?,stu_age=?,stu_tel=?,stu_qq=?,stu_desc=? where stu_num=?\"; PreparedStatement ps = connection.prepareStatement(sql); ps.setString(1,stuName); ps.setString(2,stuGender); ps.setString(3,stuAge); ps.setString(4,stuTel); ps.setString(5,stuQQ); ps.setString(6,stuDesc); ps.setString(7,stuNum); int i = ps.executeUpdate(); System.out.println(i\u003e0?\"修改成功！\":\"修改失败！\"); connection.close(); } catch (Exception e) { e.printStackTrace(); } } } 4.5 DBUtil工具类封装 每一个JDBC操作都必须先创建数据库的连接，我们可以将创建连接的工作单独定义成一个方法来实现，在具体的JDBC操作中只需调用此方法就可以完成创建连接的工作 DBUtil封装 4.6 DAO封装 为了提供数据库JDBC操作的复用性，我们将能够实现特定数据库操作的代码单独定义成一个方法； 我们将对于一张表的不同的JDBC操作的方法定义在同一个类中，这个类我们称之为DAO类； DAO(Data Access Object)数据访问对象 当我们需要对张数据表进行操作的时候，我们只需调用对应DAO类中的方法 4.7 DTO封装 DTO (Data Transfer Object)数据传输对象 /** * DTO类：用来为JDBC操作传递数据的（一个DTO类的对象可以存放数据表中的一条数据） * DTO类的创建规范： * 1.DTO类中属性的个数和类型要与对应的数据表保持一致（Student --- tb_students ） * 2.提供无参构造器：右键---Generate---Constructor---点击select None按钮 * 3.提供全参构造器：右键---Generate---Constructor--- 选择所有属性 ---点击OK按钮 * 4.提供所有属性的get和set方法：右键---Generate---Getter and Setter---选择所有属性 ---点击OK按钮 */ public class Student { private String stuNum; private String stuName; private String stuGender; private int stuAge; private String stuTel; private String stuQQ; private String stuDesc; //无参构造器 //全参构造器 //所有属性的get和set方法 } 4.8 JDBC操作：查询操作 根据ID查询一条记录 //根据学号查询一个学生信息 public Student queryStudent(String stuNum){ Student student = null; try{ //根据学号查询学生信息，将查询到学生信息的7个值存储到student对象中 Connection connection = ","date":"2021-04-06","objectID":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/:4:0","tags":[],"title":"实训笔记","uri":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/"},{"categories":["实训笔记"],"content":"五、网页设计 5.1 B/S 和 C/S 项目架构方式 B/S (Browser-Server) 基于浏览器和服务器的架构模式 C/S (Client-Server) 基于客户端和服务器的架构模式，专用客户端模式（QQ） 5.2 网页设计介绍 网页就是存储在服务器、可以通过网络传输到用户、并通过浏览器展示出特定视图页面的文件 5.2.1 网页文件特点 后缀名为.html或者.htm 可以通过浏览器显示出界面 网页文件基本结构：标签 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"/\u003e \u003ctitle\u003e登录页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 5.2.2 网页三要素 HTML 超文本标记语言，决定了网页的结构（显示的内容） CSS 层叠样式表，决定了网页中视图的显示效果 JavaScript 脚本语言，决定了网页中动态效果及功能 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"/\u003e \u003ctitle\u003e登录页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" style=\"width:100px;height:25px\" value=\"点我呀\" onclick=\"test()\"/\u003e \u003cscript type=\"text/javascript\"\u003e function test(){ alert(\"从前有座山\"); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 5.3 HTML常用标签 5.3.1 显示标签 将文本、图片、声音、视频等在网页中进行显示和播放 \u003c!--文本--\u003e \u003clabel style=\"color:red; font-size:15px; font-family:黑体\"\u003e文本内容\u003c/label\u003e \u003c!--图片--\u003e \u003cimg src=\"img/001.jpg\" width=\"200\" height=\"100\"/\u003e \u003c!--声音--\u003e \u003caudio controls src=\"song/001.mp3\" autoplay loop=\"-1\"\u003e\u003c/audio\u003e \u003c!--视频--\u003e \u003cvideo controls src=\"mv/001.mp4\" autoplay loop=\"-1\"\u003e\u003c/video\u003e 5.3.2 输入标签 在网页中提供输入视图（文本输入框、密码输入框等）以便用户可以在页面中输入数据 \u003c!--文本输入框--\u003e\u003cinput type=\"text\"/\u003e \u003c!--密码输入框--\u003e\u003cinput type=\"password\"/\u003e \u003c!--文件选择框--\u003e\u003cinput type=\"file\"/\u003e \u003c!--单选按钮: 必须提供value属性，必须提供name属性并且同一组选项name属性必须相同--\u003e \u003cinput type=\"radio\" value=\"M\" name=”gender“/\u003e男 \u003cinput type=\"radio\" value=\"F\" name=”gender“/\u003e女 \u003c!--复选框：同单选按钮--\u003e \u003cinput type=\"checkbox\" value=\"t\" name=\"hobby\"/\u003e旅游 \u003c!--普通按钮：默认按钮上没有文字，需要通过value属性指定按钮上的文字--\u003e \u003cinput type=\"button\" value=\"普通按钮\"/\u003e \u003c!--提交按钮--\u003e\u003cinput type=\"submit\"/\u003e \u003c!--重置按钮--\u003e\u003cinput type=\"reset\"/\u003e \u003c!--图片按钮: 作用其实是一个提交按钮，通过src属性指定按钮图片--\u003e \u003cinput type=\"image\" src=\"img/btn.jpg\"/\u003e \u003c!--颜色选择框--\u003e\u003cinput type=\"color\"/\u003e \u003c!--日期输入框--\u003e\u003cinput type=\"date\"/\u003e \u003c!--数字输入框--\u003e\u003cinput type=\"number\"/\u003e \u003c!--下拉菜单：选项option标签必须提供value属性--\u003e \u003cselect\u003e \u003coption value=\"深圳\"\u003e深圳\u003c/option\u003e \u003coption value=\"WH\"\u003e武汉\u003c/option\u003e \u003c/select\u003e \u003c!--文本域:多行输入框--\u003e \u003ctextarea\u003e\u003c/textarea\u003e 5.3.3 布局标签 布局标签，就是对网页中的元素进行排版 \u003c!-- 换行 --\u003e\u003cbr/\u003e \u003c!-- 水平分割线 --\u003e \u003chr/\u003e \u003c!-- 段落 --\u003e\u003cp\u003e\u003c/p\u003e \u003c!-- 字段域 --\u003e \u003cfieldset\u003e \u003clegend\u003e字段域标题\u003c/legend\u003e \u003c/fieldset\u003e \u003c!-- 列表 --\u003e \u003cul\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003c/ul\u003e \u003col\u003e \u003cli\u003e\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003c/ol\u003e \u003c!-- 表格 --\u003e \u003ctable\u003e \u003ccaption\u003e表格标题\u003c/caption\u003e \u003ctr\u003e \u003ctd\u003e\u003c/td\u003e \u003ctd\u003e\u003c/td\u003e \u003ctd\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003c/td\u003e \u003ctd\u003e\u003c/td\u003e \u003ctd\u003e\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c!-- div+css: 绝对布局、相对布局、浮动布局 --\u003e \u003cdiv style=\"postition:absolute|relative|float; left:10px ; top:10px\"\u003e \u003c/div\u003e 5.3.4 页面框架 页面框架，实现同一个网页中动态展示多个网页 \u003c!--frameset--\u003e \u003c!--iframe---\u003e 页面框架案例： 2021年1月11日 练习任务 JDBC练习 创建一个图书信息表： tb_books 新建一个Java项目：jdbc-bims 在项目中添加 mysql驱动文件 在项目中创建\"cn.edu.hubu.bims.utils\"包，完成DBUtil类 在项目中创建\"cn.edu.hubu.bims.dto\"包，创建Boot类 在项目中创建\"cn.edu.hubu.bims.dao\"包，创建BookDAO类，完成如下操作： 添加图书信息 根据图书编号删除图书信息 根据图书编号修改图书信息 根据图书编号查询一个图书信息 分页查询图书信息 查询图书信息总记录数 5.4 CSS样式总结 5.4.1 CSS基本语法 几乎所有的HTML标签都可以添加style属性来设置元素的显示样式 \u003cimg src=\"img/01.jpg\" style=\"width:200px;height:100px;\"/\u003e 如果在同一个网页中，有多个HTML标签具有相同的样式，我们可以直接将样式定义在style标签中；在style标签定义样式常用的有三种选择器： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e /*如果我们将样式定义在style标签中，常用的有三种选择器：*/ /*1.标签选择器:使用标签的名字作为样式名称 img{ width:200px; height:100px; } */ /*2.类选择器：对网页中\"class=样式名\"的标签有效*/ .style1{ width:200px; height:100px; } /*3.id选择器：对网页中\"id=样式名\"的标签有效*/ #img2{ border-radius: 10px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cimg src=\"img/01.jpg\" id=\"img2\"/\u003e \u003cimg src=\"img/02.jpg\" /\u003e \u003cimg src=\"img/03.jpg\" /\u003e \u003cimg src=\"img/04.jpg\" class=\"style1\"/\u003e \u003ctextarea class=\"style1\"\u003e\u003c/textarea\u003e \u003c/body\u003e \u003c/html\u003e 在一个HTML标签中的class属性可以引用style中定义的多种样式 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e .style1{ width:200px; height:100px; } .style2{ border-radius: 50px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cimg src=\"img/04.jpg\" class=\"style1 style2\"/\u003e \u003c/body\u003e \u003c/html\u003e 如果一个标签引用多个样式时，在多个样式中出现了样式属性值的冲突——就近一致 如果多个网页中需要使用相同的样式，我们可以把公用的样式单独定义在一个css文件中，然后在需要使用样式的HTML文档中引用这个css文件即可 样式文件 5.4.2 CSS常用样式 盒子模型：尺寸、背景、边框、外边距、内边距、字体、文本 高级样式：2D/3D 过渡 动画 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e /*尺寸样式*/ .sizeStyle{ width:400px; height: 200px; } /*边框样式*/ .bor","date":"2021-04-06","objectID":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/:5:0","tags":[],"title":"实训笔记","uri":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/"},{"categories":["实训笔记"],"content":"六、web服务器 当我们完成了网页的设计之后，如何能够让我们的网页能够被互联网用户访问呢？ 我们需要借助于web服务器软件来提供web项目的网络访问； 6.1 web服务器介绍 web服务器软件：用来管理web项目、能够接收HTTP协议请求的软件 Tomcat访问过程 6.2 安装Tomcat 6.2.1 下载安装JDK Tomcat需要依赖JDK 6.2.2 下载安装Tomcat 下载：http://tomcat.apache.org (群文件下载) 安装：注意如果没有默认加载jre路径，需要手动选择 tomcat安装选择JRE 安装之后，默认在C:\\Program Files\\Apache Software Foundation\\Tomcat 8.5 Tomcat目录结构 6.3 web项目部署 web项目部署：就是将web项目拷贝粘贴到Tomcat的webapps目录 web项目部署 6.4 启动Tomcat 启动服务器 6.5 在浏览器中访问Tomcat中的项目 6.6 云主机 由于我们使用的网络都是非商用IP，因此如果我们把项目部署在本地（自己的计算机），只能同一个局域网内可访问，如何实现互联网访问呢？ 购买商用IP 使用内网穿透（需要本地计算机服务器同时启动） 使用云主机 项目上云 ","date":"2021-04-06","objectID":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/:6:0","tags":[],"title":"实训笔记","uri":"/%E5%AE%9E%E8%AE%AD%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"PDF文章列表 pdf名称 备注 1、JavaSE：Java入门.pdf 2、JavaSE：基础语法.pdf 3、JavaSE：流程控制.pdf 4、JavaSE：方法.pdf 5、JavaSE：数组.pdf 6、JavaSE：面向对象.pdf 7、JavaSE：异常机制.pdf 8、JavaSE：常用类.pdf 9、JavaSE：集合框架.pdf 10、JavaSE：IO流.pdf 11、JavaSE：多线程.pdf 12、JavaSE：网络编程.pdf 13、JavaSE：Gui编程.pdf 14、JavaSE：注解和反射.pdf 15、MySQL和JDBC.pdf 16、前端：Html5.pdf 18、前端：JavaScript、jQuery.pdf 19、JavaWeb.pdf 20、MyBatis.pdf 21、Spring.pdf 22、SpringMVC.pdf 23、大前端串讲.pdf 24、Vue精讲.pdf 25、SpringBoot入门及原理.pdf 26、SpringBoot操作数据库.pdf 27、SpringBoot开发单体应用.pdf 28、SpringBootWeb开发提升.pdf 29、SpringSecurity权限控制.pdf 31、Shiro.pdf 32、SpringCloudNetflix-H版.pdf 33、JVM探究.pdf 34、JUC精讲.pdf 35、Git.pdf 36、Linux使用.pdf 37、Redis精讲.pdf 38、ElasticSearch.pdf 40、Docker.pdf docker 基础 41、Docker下.pdf compose、swarm Exin DevOps Master WhitePaper_V1.5_CN.pdf DevOps Master 白皮书企业DevOps的成功之路 Devops之基于Jenkins的CI与CD(1).pdf Devops之基于Jenkins的CI与CD Jenkins与Gitlab.pdf 2021阿里巴巴Java面试手册 剑指OFFER名企面试官精讲典型编程题_第2版 剑指OFFER 机器学习 机器学习 ","date":"2019-08-02","objectID":"/pdflist/:0:0","tags":null,"title":"pdf列表","uri":"/pdflist/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于本站","uri":"/about/"},{"categories":null,"content":"许可协议 更多信息请查看 LICENSE 文件。 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于本站","uri":"/about/"}]