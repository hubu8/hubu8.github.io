[{"categories":["Windows"],"content":"1 config.toml 配置 首先我们配置好 config.toml 的 algolia 的配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"hugo\" appID = \"CTZ67PPVA3\" searchKey = \"e41367b9d69db67ea65d45a33d7ae089\" ","date":"2021-04-13","objectID":"/git_algolia_sh/:1:0","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2 Algolia 配置 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:0","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.1 登录 Algolia 官网 ，注册账号，创建 Application 名为 “test01”作为举例，默认选择 “FREE” 即可，这里自定义名称 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:1","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.2 我这里选择香港作为存储地区 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:2","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.3 创建index，要与config.toml 的配置 index 一样 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:3","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"2.4 将 API Keys 里面补充到 config.toml 里面 ","date":"2021-04-13","objectID":"/git_algolia_sh/:2:4","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3 使用 atomic-algolia 来完成自动更新索引 ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:0","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.1 首先安装 npm，这里不介绍 ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:1","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.2 安装 atomic-algolia npm -g install atomic-algolia --save ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:2","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.3 创建 .env 文件存放 algolia 配置 ALGOLIA_APP_ID=\"CTZ67PPVA3\" ALGOLIA_ADMIN_KEY=\"b8709236a9a4453ddd4ac2a219eb7493\" ALGOLIA_INDEX_NAME=\"hugo\" ALGOLIA_INDEX_FILE=\"public/index.json\" ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:3","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.4 修改根目录下的 package.json 文件（没有就新建），在 scripts 下添加 \"algolia\": \"atomic-algolia\" { \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" } } ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:4","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"3.5 上传索引的命令 你可以本地执行 npm run algolia 查看运行效果 ","date":"2021-04-13","objectID":"/git_algolia_sh/:3:5","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"4 定制化脚本 #!/bin/sh # If a command fails then the deploy stops set -e start_local_hugo_server(){ hugo server --disableFastRender } update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia ！！！\\033[0m\\n\" sleep 10 } pushMyBlogHugo(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/hubu8/hubu8\"\\033[0m\\n\" git pull # Add changes to git. git add . # Commit changes. msg=\"change MyBlogHugo site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/hubu8/hubu8.github.io\"\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public pwd git pull # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push sleep 10 } case $1 in 1) start_local_hugo_server ;; 2) pushMyBlogHugo $* ;; 3) push_public $* ;; 4) update_algolia ;; 5) hugo serve -e production ;; 6) hugo server --source=themes/LoveIt/exampleSite ;; esac 脚本解析： sh deploy.sh 1：启动 hugo 作为本地调试使用，实时将文章的内容更新到站点，不需要重启也能边修改边观看效果。 sh deploy.sh 2：将 MyHugoBlog 上传到 Github 存储库。 sh deploy.sh 3：将 public 静态文件站点上传到Github Pages 存储库。 sh deploy.sh 4：更新 algolia 的索引. sh deploy.sh 5：主要是用来调试 cdn，评论系统等，所以要用 production 变量来启动。 sh deploy.sh 6：查看官方例子，方便调试。 仓库代码检验： algolia 的索引: ","date":"2021-04-13","objectID":"/git_algolia_sh/:4:0","tags":["shell"],"title":"Git_algolia_sh","uri":"/git_algolia_sh/"},{"categories":["Windows"],"content":"应用场景： 搭建hugo静态博客时，只需要上传public目录下的静态资源，但是为了源文件不丢失，也想把根目录上传到另一个仓库备份。但是这样就有了两个仓库，每次推送代码需要push两次，比较麻烦 蠢人有蠢人的办法，写一个批处理脚本，在脚本中在两个目录push: echo \"Start submitting code to the local repository\" echo \"The current directory is:%cd%\" git add . echo; echo \"Commit the changes to the local repository\" set now=%date% %time% echo %now% git commit -m \"%now%\" echo; echo \"Commit the changes to the remote git server\" git push echo; echo \"Batch execution complete!\" echo; hugo cd public echo \"Start submitting code to the local repository\" echo \"The current directory is:%cd%\" git add . echo; echo \"Commit the changes to the local repository\" set now=%date% %time% echo %now% git commit -m \"%now%\" echo; echo \"Commit the changes to the remote git server\" git push echo; echo \"Batch execution complete!\" echo; echo. \u0026 pause 最后按任意键退出。 ","date":"2021-04-13","objectID":"/git_bat/:0:0","tags":["bat"],"title":"Git_bat","uri":"/git_bat/"},{"categories":["nginx"],"content":"nginx 项目最初上线的时候并发量小、用户使用少，所以在低并发的情况下，一个Jar包、一个tomcat服务器就够了 但是用户多了，并发量就增大了，这时候一台服务器就不能满足需求，于是可以横向扩展服务器，这时候几个项目启动在不同的服务器上，由于session不共享，就需要一个代理服务器，通过代理服务器请求转发： 我们希望这个代理服务器可以帮助我们接受用户请求，然后按照规则转发在不同服务器上，这个过程用户是无感知的，用户并不知道哪台服务器在返回结果，还希望它可以按照服务器性能提供不同的权重选择 ","date":"2021-04-12","objectID":"/nginx/:1:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"什么是nginx Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 在高连接并发的情况下，Nginx是Apache服务器不错的替代品。 nginx相对于apache的优点： 轻量级，同样起web 服务，比apache 占用更少的内存及资源 ，抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能，高度模块化的设计，编写模块相对简单 ，社区活跃，各种高性能模块出品迅速。 官方数据统计表明能够支持50000个并发量。 ","date":"2021-04-12","objectID":"/nginx/:2:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"nginx作用 http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。 ","date":"2021-04-12","objectID":"/nginx/:3:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"正向代理： 例如我们用的VPN，相当于一个中介跳转；正向代理代理的是客户端，反向代理代理的是服务器。 ","date":"2021-04-12","objectID":"/nginx/:3:1","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"反向代理： ","date":"2021-04-12","objectID":"/nginx/:3:2","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"负载均衡： nginx提供两种负载均衡策略：内置策略和扩展策略；内置策略为轮询、加权轮询，ip hash;扩展策略就是天马行空，任意的定制 轮询： 加权轮询： ip hash: 动静分离： 动静分离，通过中间将动静分离和静态请求进行分离； 通过中间件将动态请求和静态请求分离，可以建上不必要的请求消耗，同时能减少请求的延时。 通过中间件将动态请求和静态请求分离，逻辑图如下 : 动静分离只有好处：动静分离后，即使动态服务不可用，但静态资源不会受到影响。 ","date":"2021-04-12","objectID":"/nginx/:3:3","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"nginx安装： 官网地址：http://nginx.org/en/download.html ","date":"2021-04-12","objectID":"/nginx/:4:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"Windows下安装： 1、官网下载稳定版本，下载即运行，不用任何安装 2、命令行输入nginx.exe,双击运行一闪而过看不到效果，浏览查看80端口： ","date":"2021-04-12","objectID":"/nginx/:4:1","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"linux下安装： 1、官网下载稳定版本，上传到服务器： 2、解压安装： #解压 tar -zxvf nginx-1.18.0.tar.gz #执行配置 ./configure #执行make命令： make make install 第三步报错： ./configure: error: the HTTP rewrite module requires the PCRE library. You can either disable the module by using --without-http_rewrite_module option, or install the PCRE library into the system, or build the PCRE library statically from the source with nginx by using --with-pcre=\u003cpath\u003e option. #执行命令 安装pcre-devel yum -y install pcre-devel 依旧报错： ./configure: error: the HTTP gzip module requires the zlib library. You can either disable the module by using --without-http_gzip_module option, or install the zlib library into the system, or build the zlib library statically from the source with nginx by using --with-zlib=\u003cpath\u003e option. #安装zlib wget http://www.zlib.net/zlib-1.2.11.tar.gz tar -xzvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make make install 3、查看是否安装成功： [root@jd nginx-1.18.0]# whereis nginx nginx: /usr/local/nginx [root@jd nginx-1.18.0]# cd /usr/local/nginx/ [root@jd nginx]# ls conf html logs sbin [root@jd nginx]# ./sbin/nginx [root@jd nginx]# curl localhost \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eWelcome to nginx!\u003c/title\u003e \u003cstyle\u003e body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eWelcome to nginx!\u003c/h1\u003e \u003cp\u003eIf you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u003c/p\u003e \u003cp\u003eFor online documentation and support please refer to \u003ca href=\"http://nginx.org/\"\u003enginx.org\u003c/a\u003e.\u003cbr/\u003e Commercial support is available at \u003ca href=\"http://nginx.com/\"\u003enginx.com\u003c/a\u003e.\u003c/p\u003e \u003cp\u003e\u003cem\u003eThank you for using nginx.\u003c/em\u003e\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 4、nginx常用命令： cd /usr/local/nginx/sbin/ ./nginx #启动 ./nginx -s stop #停止 ./nginx -s quit #安全退出 ./nginx -s reload #重新加载配置文件 ps aux|grep nginx #查看nginx进程 ","date":"2021-04-12","objectID":"/nginx/:4:2","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["nginx"],"content":"nginx配置使用： 应用场景：现在有多台配置不一样的服务器，根据服务器性能设置不同的权重轮询： 配置实例：8000代表一台服务器，8001代表一台服务器，加权轮询1：3 upstream eccentric{ server 127.0.0.1:8000 weight=1; server 127.0.0.1:8001 weight=3; } server { listen 7999; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location /hello { root html; index index.html index.htm; proxy_pass http://eccentric; } #访问后台管理系统/admin location /admin { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } 本地模拟两个服务器： java -jar democompose-0.0.1-SNAPSHOT.jar --server.port=8000 java -jar democompose-0.0.1-SNAPSHOT.jar --server.port=8001 本地访问localhost:7999: 两台服务器接受到的请求次数： Windows双击运行nginx.exe带来的问题，没有办法通过命令行关闭，nginx80端口一直被占用： #查看占用80端口的进程 netstat -ano | findstr \":80 \" #查看对应进程的应用 tasklist /fi \"PID eq 752\" #杀死进程 taskkill /pid 752 /f ","date":"2021-04-12","objectID":"/nginx/:5:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/nginx/"},{"categories":["运维"],"content":"实际开发生成环境中需要频繁修改代码或者环境变量的值（例如：服务器ip,数据库密码等），如果频繁去修改代码重新上线需要花费大量的事件，为了解决这一问题，今天用到了docker-compose中的env_file： 应用环境变量设置，不用修改代码，重新打包 代码之间解耦，提高可读性 应用环境： Spring Cloud docker ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:0:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"简介 springboot配置文件如下： spring:cloud:bus:trace:enabled:truerabbitmq:host:${RABBIT_MQ_HOST:localhost}port:${RABBIT_MQ_PORT:5672}username:${RABBIT_MQ_USERNAME:guest}password:${RABBIT_MQ_PASSWORD:guest}redis:host:${REDIS_HOST:localhost}port:${REDIS_PORT:6379}lettuce:pool:max-active:300#password: ${REDIS_PASSWORD:123456}datasource:driver-class-name:com.mysql.jdbc.Driverurl:jdbc:${DATASOURCE_DBTYPE:mysql}://${DATASOURCE_HOST:localhost}:${DATASOURCE_PORT:3306}/sys_users?characterEncoding=UTF-8\u0026useUnicode=true\u0026useSSL=falseusername:${DATASOURCE_USERNAME:root}password:${DATASOURCE_PASSWORD:root123} **${RABBIT_MQ_HOST:localhost}**的含义：如果MQ_HOST设置的有值，就用他；如果没有设置值，就用localhost默认值，这样写的好处是做到全局配置的统一性，避免改配置多处修改； 在开发环节为了调试方便，我们可以在application.yml文件中添加如下配置， DATASOURCE_HOST:191.168.1.105DATASOURCE_PORT:7000DATASOURCE_PASSWORD:root123DATASOURCE_USERNAME:root 但是当部署到生产环境这样写没有任何意义，当需要修改变量值，还是需要重新打包。 为此docker-compose提供了一种解决方案：从文件添加环境变量。可以是单个值或列表的多个值【env_file】： DATASOURCE_DBTYPE=sc-mysql DATASOURCE_HOST=mysql DATASOURCE_PORT=3306 DATASOURCE_USERNAME=root DATASOURCE_PASSWORD=root123 DATASOURCE_DRIVER=com.mysql.jdbc.Driver 只需要在docker-compose文件中的某个service下添加： env_file:.env 或者： env_file:- ./common.env- ./apps/web.env- /opt/secrets.env 通过以上配置就可以把相关的环境变量的值存进你的image ps:同一个变量多次赋值，以最后一次为准，覆盖前面的旧值 ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:1:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"场景应用： 利用docker-compose启动web服务，做到改变IP、密码等配置时不修改代码 ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"1、信件env结尾的文件： ### 数据源mysql实例 DATASOURCE_DBTYPE=mysql DATASOURCE_HOST=sc-mysql DATASOURCE_PORT=3306 DATASOURCE_USERNAME=root DATASOURCE_PASSWORD=root123 DATASOURCE_DRIVER=com.mysql.jdbc.Driver ### 分布式缓存 REDIS_HOST=redis REDIS_PORT=6379 ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:1","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"2、编写docker-compose文件添加env_file: # docker-compose.person.ymlversion:'3'services:#人员信息服务person_info:image:java:8container_name:sc-person_inforestart:alwaysnetworks:- sc-netports:- 9009:9009volumes:- \"/home/hubu/dockerfiles/person_info:/data\"command:[\"java\",\"-jar\",\"/data/person.jar\"]env_file:.env ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:2","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"3、上传服务器相关文件，生成镜像，运行容器： # 还运行了其他docker-compose,-f指定文件 docker-compose -f docker-compose.yml -f docker-compose.person.yml -f docker-compose.auth.yml up -d #关闭： docker-compose -f docker-compose.yml -f docker-compose.person.yml -f docker-compose.auth.yml down ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:3","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"4、查看环境变量是否进入容器： #通过docker logs 查看系统日志，如果没有错误就是正确的 docker exec -it sc-person_info /bin/bash env ","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:4","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["运维"],"content":"5、愉快地开始部署项目了！！！","date":"2021-04-11","objectID":"/docker-compose%E4%B9%8Benv_file/:2:5","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/docker-compose%E4%B9%8Benv_file/"},{"categories":["Java后端"],"content":"抽了点时间，整理了一些 maven 常用命令参数，以便参考； ","date":"2021-04-11","objectID":"/mvn/:0:0","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"mvn 命令参数 mvn -v, –version 显示版本信息; mvn -V, –show-version 显示版本信息后继续执行 Maven 其他目标; mvn -h, –help 显示帮助信息; mvn -e, –errors 控制 Maven 的日志级别, 产生执行错误相关消息; mvn -X, –debug 控制 Maven 的日志级别, 产生执行调试信息; mvn -q, –quiet 控制 Maven 的日志级别, 仅仅显示错误; mvn -Pxxx 激活 id 为 xxx 的 profile (如有多个，用逗号隔开); mvn -Dxxx=yyy 指定 java 全局属性; mvn -o , –offline 运行 offline 模式, 不联网更新依赖; mvn -N, –non-recursive 仅在当前项目模块执行命令, 不构建子模块; mvn -pl, –module_name 在指定模块上执行命令; mvn -ff, –fail-fast 遇到构建失败就直接退出; mvn -fn, –fail-never 无论项目结果如何, 构建从不失败; mvn -fae, –fail-at-end 仅影响构建结果, 允许不受影响的构建继续; mvn -C, –strict-checksums 如果校验码不匹配的话, 构建失败; mvn -c, –lax-checksums 如果校验码不匹配的话, 产生告警; mvn -U 强制更新 snapshot 类型的插件或依赖库 (否则 maven 一天只会更新一次 snapshot 依赖); mvn -npu, –no-plugin-updates 对任何相关的注册插件, 不进行最新检查 (使用该选项使 Maven 表现出稳定行为，该稳定行为基于本地仓库当前可用的所有插件版本); mvn -cpu, –check-plugin-updates 对任何相关的注册插件, 强制进行最新检查 (即使项目 POM 里明确规定了 Maven 插件版本, 还是会强制更新); mvn -up, –update-plugins [mvn -cpu] 的同义词; mvn -B, –batch-mode 在非交互（批处理）模式下运行 (该模式下, 当 Mven 需要输入时, 它不会停下来接受用户的输入, 而是使用合理的默认值); mvn -f, –file 强制使用备用的 POM 文件; mvn -s, –settings 用户配置文件的备用路径; mvn -gs, –global-settings 全局配置文件的备用路径; mvn -emp, –encrypt-master-password 加密主安全密码, 存储到 Maven settings 文件里; mvn -ep, –encrypt-password 加密服务器密码, 存储到 Maven settings 文件里; mvn -npr, –no-plugin-registry 对插件版本不使用~/.m2/plugin-registry.xml(插件注册表) 里的配置; ","date":"2021-04-11","objectID":"/mvn/:0:1","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"mvn 常用命令 创建 Maven 的普通 java 项目： mvn archetype:create -DgroupId=packageName -DartifactId=projectName 创建 Maven 的 Web 项目： mvn archetype:create -DgroupId=packageName -DartifactId=webappName -DarchetypeArtifactId=maven-archetype-webapp 编译源代码：mvn compile 编译测试代码：mvn test-compile 运行测试：mvn test 产生 site：mvn site 打包：mvn package 在本地 Repository 中安装 jar：mvn install 清除产生的项目：mvn clean 生成 eclipse 项目：mvn eclipse:eclipse 生成 idea 项目：mvn idea:idea 组合使用 goal 命令，如只打包不测试：mvn -Dtest package 编译测试的内容：mvn test-compile 只打 jar 包: mvn jar:jar 只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile (-skipping 的灵活运用，当然也可以用于其他组合命令) 清除 eclipse 的一些系统设置: mvn eclipse:clean ps 一般使用情况是这样，首先通过 cvs 或 svn 下载代码到本机，然后执行 mvn eclipse:eclipse 生成 ecllipse 项目文件，然后导入到 eclipse 就行了；修改代码后执行 mvn compile 或 mvn test 检验，也可以下载 eclipse 的 maven 插件。 mvn -version/-v 显示版本信息 mvn archetype:generate 创建 mvn 项目 mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app 创建 mvn 项目 mvn package 生成 target 目录，编译、测试代码，生成测试报告，生成 jar/war 文件 mvn jetty:run 运行项目于 jetty 上, mvn compile 编译 mvn test 编译并测试 mvn clean 清空生成的文件 mvn site 生成项目相关信息的网站 mvn -Dwtpversion=1.0 eclipse:eclipse 生成 Wtp 插件的 Web 项目 mvn -Dwtpversion=1.0 eclipse:clean 清除 Eclipse 项目的配置信息 (Web 项目) mvn eclipse:eclipse 将项目转化为 Eclipse 项目 在应用程序用使用多个存储库 \u003crepositories\u003e \u003crepository\u003e \u003cid\u003eIbiblio\u003c/id\u003e \u003cname\u003eIbiblio\u003c/name\u003e \u003curl\u003ehttp://www.ibiblio.org/maven/\u003c/url\u003e \u003c/repository\u003e \u003crepository\u003e \u003cid\u003ePlanetMirror\u003c/id\u003e \u003cname\u003ePlanet Mirror\u003c/name\u003e \u003curl\u003ehttp://public.planetmirror.com/pub/maven/\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e 命令： mvn deploy:deploy-file -DgroupId=com -DartifactId=client -Dversion=0.1.0-Dpackaging=jar -Dfile=d:\\client-0.1.0.jar-DrepositoryId=maven-repository-inner -Durl=ftp://xxxxxxx/opt/maven/repository/ 发布第三方 Jar 到本地库中： mvn install:install-file -DgroupId=com -DartifactId=client -Dversion=0.1.0-Dpackaging=jar -Dfile=d:\\client-0.1.0.jar -DdownloadSources=true -DdownloadJavadocs=true mvn -e 显示详细错误 信息. mvn validate 验证工程是否正确，所有需要的资源是否可用。 mvn test-compile 编译项目测试代码。 mvn integration-test 在集成测试可以运行的环境中处理和发布包。 mvn verify 运行任何检查，验证包是否有效且达到质量标准。 mvn generate-sources 产生应用需要的任何额外的源代码，如 xdoclet。 ","date":"2021-04-11","objectID":"/mvn/:0:2","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"mvn 常用命令 2 mvn -v 显示版本 mvn help:describe -Dplugin=help 使用 help 插件的 describe 目标来输出 Maven Help 插件的信息。 mvn help:describe -Dplugin=help -Dfull 使用 Help 插件输出完整的带有参数的目标列 mvn help:describe -Dplugin=compiler -Dmojo=compile -Dfull 获取单个目标的信息, 设置 mojo 参数和 plugin 参数。此命令列出了 Compiler 插件的 compile 目标的所有信息 mvn help:describe -Dplugin=exec -Dfull 列出所有 Maven Exec 插件可用的目标 mvn help:effective-pom 看这个 “有效的 (effective)”POM，它暴露了 Maven 的默认设置 mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 -DartifactId=simple -DpackageName=org.sonatype.mavenbook 创建 Maven 的普通 java 项目，在命令行使用 Maven Archetype 插件 mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main Exec 插件让我们能够在不往 classpath 载入适当的依赖的情况下，运行这个程序 mvn dependency:resolve 打印出已解决依赖的列表 mvn dependency:tree 打印整个依赖树 mvn install -X 想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开 Maven 的调试标记运行 mvn install -Dmaven.test.skip=true 给任何目标添加 maven.test.skip 属性就能跳过测试 mvn install assembly:assembly 构建装配 Maven Assembly 插件是一个用来创建你应用程序特有分发包的插件 mvn jetty:run 调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用 mvn compile 编译你的项目 mvn clean install 删除再编译 mvn hibernate3:hbm2ddl 使用 Hibernate3 插件构造数据库 ","date":"2021-04-11","objectID":"/mvn/:0:3","tags":["maven"],"title":"maven常用命令","uri":"/mvn/"},{"categories":["Java后端"],"content":"阿里云短信服务 1、添加用户组和相关权限 2、创建一个用户、获取相应的Acessce Key 要将这个账户保存下来，只显示一次，如果被泄露马上禁用生成新的，后面需要用到 开通阿里云短信服务 帮助指南 1、开通短信服务，找到短信控制台面板 2、添加短信模板、添加签名（中括号里面的名称） 编写代码测试 在pom文件中添加如下依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-core\u003c/artifactId\u003e \u003cversion\u003e4.5.16\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.62\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e 2、编写服务与服务实现： package com.example.democompose.Service.Impl; import com.alibaba.fastjson.JSONObject; import com.aliyuncs.CommonRequest; import com.aliyuncs.CommonResponse; import com.aliyuncs.DefaultAcsClient; import com.aliyuncs.IAcsClient; import com.aliyuncs.exceptions.ClientException; import com.aliyuncs.exceptions.ServerException; import com.aliyuncs.http.MethodType; import com.aliyuncs.profile.DefaultProfile; import com.example.democompose.Service.SendSms; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.Map; @Service public class SendSmsImpl implements SendSms { @Override public boolean send(String phoneNum, String templateCode, Map\u003cString, Object\u003e map) { DefaultProfile profile = DefaultProfile.getProfile(\"cn-qingdao\", \"accessKeyIdxxxxxx\", \"accessKeySecretxxxxxxx\"); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); request.setSysMethod(MethodType.POST); request.setSysDomain(\"dysmsapi.aliyuncs.com\"); request.setSysVersion(\"2017-05-25\"); request.setSysAction(\"SendSms\"); request.putQueryParameter(\"PhoneNumbers\", phoneNum); request.putQueryParameter(\"SignName\", \"东猿叔\"); request.putQueryParameter(\"TemplateCode\", templateCode); request.putQueryParameter(\"TemplateParam\", JSONObject.toJSONString(map)); try { CommonResponse response = client.getCommonResponse(request); System.out.println(response.getData()); return response.getHttpResponse().isSuccess(); } catch (ServerException e) { e.printStackTrace(); } catch (ClientException e) { e.printStackTrace(); } return false; } } 3、controller调用： package com.example.democompose.Controller; import com.aliyuncs.utils.StringUtils; import com.example.democompose.Service.SendSms; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import java.util.HashMap; import java.util.UUID; import java.util.concurrent.TimeUnit; @RestController @CrossOrigin public class SendSmsController { @Autowired private SendSms sendSms; @Autowired private RedisTemplate redisTemplate; @GetMapping(\"/send/{phone}\") public String code(@PathVariable(\"phone\")String phone){ String code=(String) redisTemplate.opsForValue().get(phone); if(!StringUtils.isEmpty(code)){ return phone+\":\"+code+\"已经存在，还没有过期\"; } code = UUID.randomUUID().toString().substring(0, 4); HashMap\u003cString,Object\u003e param=new HashMap\u003c\u003e(); param.put(\"code\",code); boolean isSend = sendSms.send(phone, \"SMS_215116099\", param); if(isSend){ redisTemplate.opsForValue().set(phone,code,5, TimeUnit.MINUTES); return phone+\":\"+code+\"发送成功\"; }else{ return phone+\":\"+code+\"发送失败\"; } } } ","date":"2021-04-10","objectID":"/message/:0:0","tags":["短信验证码"],"title":"短信验证码实现","uri":"/message/"},{"categories":["运维"],"content":"Docker Compose Using Compose is basically a three-step process: Define your app’s environment with a Dockerfile so it can be reproduced anywhere. Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment. Run docker compose up and the Docker compose command starts and runs your entire app. You can alternatively run docker-compose up using the docker-compose binary. Compose是官方的开源项目，需要安装， ​ Dockerfile可以让程序在任何地方运行，但是现在有一个web服务，但是它又需要redis、MySQL、nginx等多个容器，一个一个启动就会十分麻烦。 Compose例子： version:\"3.9\"# optional since v1.27.0services:web:build:.ports:- \"5000:5000\"volumes:- .:/code- logvolume01:/var/loglinks:- redisredis:image:redisvolumes:logvolume01:{} ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:0:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"安装Compose 1、下载： sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo curl -L \"https://get.daocloud.io/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 2、授权 sudo chmod +x /usr/local/bin/docker-compose 3、全局使用 [root@node4 /]# docker-compose version docker-compose version 1.29.0, build 07737305 docker-py version: 5.0.0 CPython version: 3.7.10 OpenSSL version: OpenSSL 1.1.0l 10 Sep 2019 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:1:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"快速体验 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 1: 创建应用 Define the application dependencies. Create a directory for the project(创建目录): $ mkdir composetest $ cd composetest Create a file called app.py in your project directory and paste this in（创建python文件）: import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) 在这个例子中, redis 是应用网络中redis的容器名称. 使用端口, 6379. 注意get_hit_coun函数的编写方式。这个基本的重试循环允许我们在redis服务不可用时多次尝试请求。当应用程序上线时，这在启动时很有用，但如果在应用程序的生命周期内需要随时重新启动Redis服务，也会使我们的应用程序更有弹性。在集群中，这也有助于处理节点之间的瞬时连接中断。 创建 requirements.txt 文件: flask redis ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 2: 编写Dockerfile 这一步将编写dockerfile并build image ,这个镜像包含了python所需要的环境 Dockerfile 文件: FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP=app.py ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers COPY requirements.txt requirements.txt RUN pip install -r requirements.txt EXPOSE 5000 COPY . . CMD [\"flask\", \"run\"] This tells Docker to: Build an image starting with the Python 3.7 image. Set the working directory to /code. Set environment variables used by the flask command. Install gcc and other dependencies Copy requirements.txt and install the Python dependencies. Add metadata to the image to describe that the container is listening on port 5000 Copy the current directory . in the project to the workdir . in the image. Set the default command for the container to flask run. For more information on how to write Dockerfiles, see the Docker user guide and the Dockerfile reference. ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 3: 在Compose文件中定义Service 创建 docker-compose.yml 文件: version: \"3.9\" services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 这个Compose声明了两个service: web and redis. [root@node4 composetest]# ll 总用量 16 -rw-r--r--. 1 root root 514 4月 9 16:48 app.py -rw-r--r--. 1 root root 111 4月 9 17:00 docker-compose.yml -rw-r--r--. 1 root root 252 4月 9 16:50 Dockerfile -rw-r--r--. 1 root root 12 4月 9 16:49 requirements.txt ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 4: 用Compose启动多个容器 docker-compose up [root@node4 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9a28f238ee73 composetest_web \"flask run\" 34 seconds ago Up 32 seconds 0.0.0.0:5000-\u003e5000/tcp composetest_web_1 e4cb9836d38d redis:alpine \"docker-entrypoint.s…\" 34 seconds ago Up 32 seconds 6379/tcp composetest_redis_1 [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 1 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 2 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 3 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 4 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 5 times. [root@node4 ~]# docker network inspect composetest_default [ { \"Name\": \"composetest_default\", \"Id\": \"25ec9a55f82b6ff2c9b190c911cf6a89ce998759b912c3f2dbf5c2849a6c89d5\", \"Created\": \"2021-04-09T17:01:45.524551071+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": null, \"Config\": [ { \"Subnet\": \"172.18.0.0/16\", \"Gateway\": \"172.18.0.1\" } ] }, \"Internal\": false, \"Attachable\": true, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"9a28f238ee7334688d70f20a2838cbcea964bb3f1282b99b4c787b61370bd202\": { \"Name\": \"composetest_web_1\", \"EndpointID\": \"920c033116c19419b0e2807f75284d768436cb272735642b7e8257f9564d9e45\", \"MacAddress\": \"02:42:ac:12:00:03\", \"IPv4Address\": \"172.18.0.3/16\", \"IPv6Address\": \"\" }, \"e4cb9836d38deb2d2dbd4211106dd2364ace9f97ab5e8827736fc7d39b5ba166\": { \"Name\": \"composetest_redis_1\", \"EndpointID\": \"7f359906cf87650c9ef25939d25c7cfe070ac1135855ff888f1b7a881682aa31\", \"MacAddress\": \"02:42:ac:12:00:02\", \"IPv4Address\": \"172.18.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": { \"com.docker.compose.network\": \"default\", \"com.docker.compose.project\": \"composetest\", \"com.docker.compose.version\": \"1.29.0\" } } ] 流程： 创建网络 执行docker-compose.yml 启动服务 默认规则： 默认服务名（容器名）：文件夹名_服务名__num num为副本数量，因为服务不可能只有一个，弹性扩容，高可用 docker images 会自动pull所需images docker network ls 自动生成网络（同一个网络通过service名称连通） composetest_自定义网络名称 停止compose： docker-compose down ctrl+c #一键停止所有容器 ^CGracefully stopping... (press Ctrl+C again to force) Stopping composetest_web_1 ... Stopping composetest_web_1 ... done ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:2:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"yml文件编写规则 compose文件编写参考：https://docs.docker.com/compose/compose-file/compose-file-v3/ #第一层version:''#向下兼容#第二层service:#服务服务1:#服务配置images:build:network:...服务2:...#第三层volumes:network:config:... 多看官方文档，开源项目的compose ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:3:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"部署Woedpress项目 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"1、创建目录： mkdir my_wordpress cd my_wordpress/ ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"2、创建compose文件： nano docker-compose.ymlversion:\"3.9\"services:db:image:mysql:5.7volumes:- db_data:/var/lib/mysqlrestart:alwaysenvironment:MYSQL_ROOT_PASSWORD:somewordpressMYSQL_DATABASE:wordpressMYSQL_USER:wordpressMYSQL_PASSWORD:wordpresswordpress:depends_on:- dbimage:wordpress:latestports:- \"8000:80\"restart:alwaysenvironment:WORDPRESS_DB_HOST:db:3306WORDPRESS_DB_USER:wordpressWORDPRESS_DB_PASSWORD:wordpressWORDPRESS_DB_NAME:wordpressvolumes:db_data:{} ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"3、启动： docker-compose up -d #后台启动 [root@node4 my_wordpress]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a56f5f6a9eb6 wordpress:latest \"docker-entrypoint.s…\" About a minute ago Up About a minute 0.0.0.0:8000-\u003e80/tcp my_wordpress_wordpress_1 63f261196b58 mysql:5.7 \"docker-entrypoint.s…\" About a minute ago Up About a minute 3306/tcp, 33060/tcp my_wordpress_db_1 All are easy!!!! ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:4:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"实战：自己编写服务上线 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"1、编写自己的服务： package com.example.democompose.Controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @Autowired StringRedisTemplate redisTemplate; @GetMapping(\"/hello\") public String hello(){ Long views=redisTemplate.opsForValue().increment(\"views\"); return \"hello,这是第\"+views+\"次访问\"; } } server.port=8080 spring.redis.host=redis ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"2、编写Dockerfile文件： FROM java:8 COPY *.jar /app.jar CMD [\"--server.port=8080\"] EXPOSE 8888 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"3、编写docker-compose.yml文件 version:'3.8'services:myapp:build:.image:mytextappcomposedepends_on:- redisports:- \"8080:8080\"redis:image:\"library/redis:alpine\" ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"4、打jar包上传服务器 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"5、运行服务： docker-compose up -d docker-compose up --build #重新构建 Docker Swarm ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:5:5","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"搭建集群 集群—–4台服务器（一主三从） 4台机器安装Docker(Xshell窗口右键：发送键输入到所有会话): sudo yum install -y yum-utils # 3、设置镜像仓 sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 默认是国外的 可换国内 yum makecache fast # 4、安装相关的额 sudo yum install docker-ce docker-ce-cli containerd.io # 5、启动 sudo systemctl start docker docker version noe2 192.168.80.133 noe3 192.168.80.134 node4 192.168.80.135 test 192.168.80.136 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化管理节点node2: # 初始化一个manager节点 docker swarm init --advertise-addr 192.168.80.133 [root@node2 network-scripts]# docker swarm init --advertise-addr 192.168.80.133 Swarm initialized: current node (a5gz7qpsgbjolzgzg1tlaj8lh) is now a manager. To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions. docker swarm join加入一个节点： #获取令牌 docker swarm join-token manager #管理节点 docker swarm join-token worker #工作节点 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化工作节点node3: [root@node3 ~]# docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 This node joined a swarm as a worker. 查看现有集群状态： [root@node2 /]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Leader 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Ready Active 20.10.5 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化工作节点node4: [root@node2 /]# docker swarm join-token worker To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 [root@node2 /]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Leader 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Ready Active 20.10.5 6ne9u5knznm8ei0c5uz7znka9 node4 Ready Active 20.10.5 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化管理节点test: docker swarm join-token manager docker node ls [root@localhost ~]# docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-66whvjsogw3qsqozb79oprffr 192.168.80.133:2377 Error response from daemon: manager stopped: can't initialize raft node: rpc error: code = Unknown desc = could not connect to prospective new cluster member using its advertised address: rpc error: code = Unavailable desc = connection error: desc = \"transport: Error while dialing dial tcp 192.168.80.136:2377: connect: no route to host\" 试了好多次发现总是加入管理节点错误，一开始怀疑自己网络通信问题，后来网上无脑抄袭一致认为代理问题： 最终发现是自己新建的虚拟机test防火墙没有关: #查看防火墙状态 systemctl status firewalld.service #停止防火墙 systemctl stop firewalld.service #永久停止 systemctl disable firewalld.service ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:6:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Raft协议 现在：双主双从，假设一个节点挂了，其他节点是否可用？？ Raft协议：保证大多数节点存活集群才可用，至少大于1台，集群至少大于3台！！ 实验： 1、将node2管理节点停止，宕机，另外一个管理节点也不能用了 systemctl stop docker 在test管理节点查看集群，发现不可用： 2、重新启动node2: systemctl start docker 发现leader节点变了： 3、工作节点node3离开： docker swarm --help docker swarm leave 4、三主一工作： docker swarm join-token manager jb30cv8ej8xjokjc1cu5l8kjo localhost.localdomain Ready Active Leader 20.10.5 a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Reachable 20.10.5 nmhr2t2b5cgy4l64bcwl0mxjt node3 Ready Active Reachable 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Down Active 20.10.5 6ne9u5knznm8ei0c5uz7znka9 node4 Ready Active 20.10.5 现在就是3台作为管理节点： 5、停掉Leader(test)： 现在Leader是test节点，停掉： 在node2查看集群状态,发现node3变成了leader，集群任然可用 6、大多数存活可用 现在只有两个管理节点（node2/node3），一个工作节点(node4)，如果再停止一个管理节点，那就无法使用了： [root@node3 ~]# docker node ls Error response from daemon: rpc error: code = Unknown desc = The swarm does not have a leader. It's possible that too few managers are online. Make sure more than half of the managers are online. 大多数管理节点存活才可用 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:7:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"集群部署应用、弹性、扩缩容 以后告别docker run 集群：高可用，web-\u003eredis(分布在三台不同主机上，服务副本，挂了一个没事，其他可用) 容器=》服务=》副本 docker run # 容器启动，不具备扩缩容功能 docker service #服务，具备扩缩容、滚动跟新、灰度发布 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"服务部署 #前提是swarm搭建好 #在node2中创建服务 docker service create -p 8888:80 --name mynginx nginx docker service ls docker service ps mynginx docker service inspect mynginx [root@node2 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS ndtmy83nj0v3 mynginx.1 nginx:latest node3 Running Running 34 seconds ago [root@node2 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 1/1 nginx:latest *:8888-\u003e80/tcp # 服务副本只有一个，并且服务运行在node3主机上 [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 4 minutes ago Up 4 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v 现在服务只随机创建了一个服务，在node3主机上，假如现在访问量加大，需要扩容： # 创建3个副本 docker service update --replicas 3 mynginx [root@node3 ~]# docker service update --replicas 3 mynginx mynginx overall progress: 3 out of 3 tasks 1/3: running [==================================================\u003e] 2/3: running [==================================================\u003e] 3/3: running [==================================================\u003e] verify: Service converged [root@node3 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 3/3 nginx:latest *:8888-\u003e80/tcp [root@node3 ~]# docker service inspect mynginx 此时三个服务副本在node3、node4、test主机上 在集群中的任意一个节点都可访问，服务可以有多个副本来实现高可用： 但是现在通过node3IP无法访问服务，其他正常 ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"大无语事件来了，有彩蛋: #如果把副本数量讲到1个会怎么样？？降！！！ [root@node3 ~]# docker service update --replicas 1 mynginx mynginx overall progress: 1 out of 1 tasks 1/1: running [==================================================\u003e] verify: Service converged #那就是只有这个一个副本？？？（bug） [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 40 minutes ago Up 40 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v #发现还是访问不了，查看日志，发现他的日志启动一半，少了许多日志，那就重启 [root@node3 ~]# docker restart mynginx.1.ndtmy83nj0v3oathgaleiw37v mynginx.1.ndtmy83nj0v3oathgaleiw37v [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 42 minutes ago Up About a minute 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v [root@node3 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 1/1 nginx:latest *:8888-\u003e80/tcp 但是我又发现，怎么会有两个： [root@node2 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2bc639d336dd nginx:latest \"/docker-entrypoint.…\" 13 minutes ago Up 13 minutes 80/tcp mynginx.1.wgk7pwm0mm7zs6fawmb7p6otf [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 55 minutes ago Up 14 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v 我把其中一个关掉还是不能访问，此时通过mynginx信息发现如下错误： [root@node2 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS x8advkit107e mynginx.1 nginx:latest node4 Running Running 6 minutes ago wgk7pwm0mm7z \\_ mynginx.1 nginx:latest node2 Shutdown Complete 6 minutes ago ndtmy83nj0v3 \\_ mynginx.1 nginx:latest node3 Shutdown Failed 25 minutes ago \"task: non-zero exit (137)\" 那就只能重来一遍： docker service rm mynginx docker service create -p 8888:80 --replicas 3 --name mynginxtest nginx [root@node2 ~]# docker service ps mynginxtest ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS fultv05jwsbm mynginxtest.1 nginx:latest localhost.localdomain Running Running 15 seconds ago yikbwlzinhd5 mynginxtest.2 nginx:latest node3 Running Running 17 seconds ago f5cljf1f6d73 mynginxtest.3 nginx:latest node2 Running Running 16 seconds ago [root@node2 ~]# docker service ps mynginxtest ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS fultv05jwsbm mynginxtest.1 nginx:latest localhost.localdomain Running Running 7 minutes ago yikbwlzinhd5 mynginxtest.2 nginx:latest node3 Running Running 7 minutes ago f5cljf1f6d73 mynginxtest.3 nginx:latest node2 Running Running 7 minutes ago [root@node2 ~]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION jb30cv8ej8xjokjc1cu5l8kjo localhost.localdomain Ready Active Reachable 20.10.5 a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Reachable 20.10.5 nmhr2t2b5cgy4l64bcwl0mxjt node3 Ready Active Leader 20.10.5 6ne9u5knznm8ei0c5uz7znka9 node4 Ready Active 20.10.5 问题依旧存在(只有node3不能访问)，不搞了，等后续，欢迎留言？？？ 问题最终还是解决了？？？ #以为node3的防火墙没有关，或者是leader节点不能访问？ systemctl stop docker #让他重新选举leader，发现还是可以访问leader， systemctl status firewalld.service #防火墙状态关闭 systemctl start docker #重新启动又好了,玄学 副本服务与全局服务 docker service create --mode replicated --name mytom tomcat:7 #默认worker节点创建服务 docker service create --mode global --name mytom tomcat:7 #全局 减少副本： docker service update --replicas 1 mynginx 扩缩容： docker service scale mynginxtest=5 docker service update --replicas 5 mynginxtest ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS fultv05jwsbm mynginxtest.1 nginx:latest localhost.localdomain Running Running 12 minutes ago yikbwlzinhd5 mynginxtest.2 nginx:latest node3 Running Running 12 minutes ago f5cljf1f6d73 mynginxtest.3 nginx:latest node2 Running Running 12 minutes ago l4blkh6mq996 mynginxtest.4 nginx:latest node4 Running Running about a minute kvn9nhtwymds mynginxtest.5 nginx:latest node4 Running Running about a minute ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:8:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"总结 swarm: ​ 集群的管理和编排，docker可以初始化一个swarm集群，其他节点可以加入（manager OR worker） node： ​ 就是一个docker节点，多个节点就组成了一个网络集群 service ​ 就是一个任务，可以在管理节点或者工作节点运行，核心 ​ swarm网络：overlay,ingress Docker Stack docker-compose:适合单机部署项目！ docker stack：集群部署项目(已经快被k8s替代了) #单机部署 docker-compose up -d wordpress.yml #集群部署 docker stack deploy wordpress.yml Docker Secret 安全，密码、证书配置： Docker Config 配置： ","date":"2021-04-09","objectID":"/docker%E8%BF%9B%E9%98%B6/:9:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/docker%E8%BF%9B%E9%98%B6/"},{"categories":["算法"],"content":"冒泡排序 ​ 冒泡排序是通过比较两个相邻元素的大小实现排序，如果前一个元素大于后一个元素，就交换这两个元素。这样就会让每一趟冒泡都能找到最大一个元素并放到最后。 以 [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，对它进行冒泡排序： ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] maopaoSort(int[] array){ boolean isChanged=false; for(int i=0;i\u003carray.length-1;i++){ for(int j=0;j\u003carray.length-1-i;j++){ if(array[j]\u003earray[j+1]){ int temp=array[j+1]; array[j+1]=array[j]; array[j]=temp; isChanged=true; } } } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它是指对同样的数据进行排序，会不会改变它的相对位置。比如 [ 1, 3, 2, 4, 2 ] 经过排序后，两个相同的元素 2 位置会不会被交换。冒泡排序是比较相邻两个元素的大小，显然不会破坏稳定性。 空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1); 时间复杂度：由于嵌套了 2 层循环，故为 O(n*n); ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"选择排序 ​ 选择排序的思想是，依次从「无序列表」中找到一个最小的元素放到「有序列表」的最后面。以 arr = [ 8, 1, 4, 6, 2, 3, 5, 4 ] 为例，排序开始时把 arr 分为有序列表 A = [ ], 无序列表 B = [ 8, 1, 4, 6, 2, 3, 5, 4 ]，依次从 B 中找出最小的元素放到 A 的最后面。这种排序也是逻辑上的分组，实际上不会创建 A 和 B，只是用下标来标记 A 和 B。 ​ 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 4 ] 为例，第一次找到最小元素 1 与 8 进行交换，这时有列表 A = [1], 无序列表 B = [8, 4, 6, 2, 3, 5, 4]；第二次从 B 中找到最小元素 2，与 B 中的第一个元素进行交换，交换后 A = [1，2]，B = [4, 6, 8, 3, 5, 4]；就这样不断缩短 B，扩大 A，最终达到有序。 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 方法一： public static int[] selectSort(int[] array){ for(int i=0;i\u003carray.length-1;i++){ int index=i; //找出n次无序列表中的最小值和他的下标 for(int j=i;j\u003carray.length;j++){ if(array[j]\u003carray[index]) { index = j; } } int temp=array[index]; array[index]=array[i]; array[i]=temp; } return array; } 方法二： public static int[] selectSort(int[] array){ for(int i=0;i\u003carray.length-1;i++){ int index=i; int temp=999; //找出n次无序列表中的最小值和他的下标 for(int j=i;j\u003carray.length;j++){ if(array[j]\u003carray[index]){ index=j; } temp=array[index]; } //把[i,index]后移一位，给有序增加空位，插入最小值 for(int m=index;m\u003ei;m--){ array[m]=array[m-1]; } array[i]=temp; } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：排序过程中元素是按顺序进行遍历，相同元素相对位置不会发生变化，故稳定。 空间复杂度：在原序列进行操作，故为 O( 1 ); 时间复杂度：需要 2 次循环遍历，故为 O( n * n ); ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"插入排序 ​ 在整个排序过程如图所示，以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7] 为例，它会把 arr 分成两组 A = [ 8 ] 和 B = [ 1, 4, 6, 2, 3, 5, 7] ，逐步遍历 B 中元素插入到 A 中，最终构成一个有序序列： ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] insertSort(int[] array){ for(int i=1;i\u003carray.length;i++){ int preindex=i-1; // 必须记录这个元素，不然会被覆盖掉 int current=array[i]; // 当前元素小于排序好的元素，就移动到下一个位置,从后向前找位置插入 while(preindex\u003e=0\u0026\u0026current\u003carray[preindex]){ array[preindex+1]=array[preindex]; preindex--; } array[preindex+1]=current; } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它是从后往前遍历已排序好的序列，相同元素不会改变位置，故为稳定排序； 空间复杂度：它是在原序列进行排序，故为 O ( 1 ); 时间复杂度：排序的过程中，首先要遍历所有的元素，然后在已排序序列中找到合适的位置并插入。共需要 2 层循环，故为 O ( n * n ); ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"希尔排序 ​ 希尔排序，它是由 D.L.Shell 于1959 年提出而得名。根据它的名字很难想象算法的核心思想。[ 所以只能死记硬背了，面试官问：希尔排序的思想是什么？]。它的核心思想是把一个序列分组，对分组后的内容进行插入排序，这里的分组只是逻辑上的分组，不会重新开辟存储空间。它其实是插入排序的优化版，插入排序对基本有序的序列性能好，希尔排序利用这一特性把原序列分组，对每个分组进行排序，逐步完成排序。 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，通过 floor(8/2) 来分为 4 组，8 表示数组中元素的个数。分完组后，对组内元素进行插入排序。 「 利用第 1 次分组结果进行第 2 次分组 」 「 利用第 2 次分组结果进行最后一次分组 」 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] lshellSort(int[] array){ //len=9 int len=array.length; //floor向下取整，4，2，1 for(int gap=(int)Math.floor(len/2);gap\u003e0;gap=gap/2){ //i=4; for (int i = gap; i \u003c len; i++) { // j=0,1,2,3,4 // [0]-[4] [1]-[5] [2]-[6] [3]-[7] [4]-[8] for (int j = i - gap; j \u003e= 0 \u0026\u0026 array[j] \u003e array[j+gap]; j-=gap) { // 交换位置 int temp = array[j]; array[j] = array[gap+j]; array[gap+j] = temp; } } } return array; } ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它可能会把相同元素分到不同的组中，那么两个相同的元素就有可能调换相对位置，故不稳定。 空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1); 时间复杂度：希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(log n的3/2)，希尔排序时间复杂度的下界是n*log2n ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"快速排序 快速排序的核心思想是对待排序序列通过一个「支点」（支点就是序列中的一个元素，别把它想的太高大上）进行拆分，使得左边的数据小于支点，右边的数据大于支点。然后把左边和右边再做一次递归，直到递归结束。支点的选择也是一门大学问，我们以 （左边index + 右边index）/ 2 来选择支点。 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，选择一个支点, index= (L+R)/2 = (0+7)/2=3, 支点的值 pivot = arr[index] = arr[3] = 6，接下来需要把 arr 中小于 6 的移到左边，大于 6 的移到右边。 快速排序使用一个高效的方法做数据拆分。 用一个指向左边的游标 i，和指向右边的游标 j，逐渐移动这两个游标，直到找到 arr[i] \u003e 6 和 arr[j] \u003c 6, 停止移动游标，交换 arr[i] 和 arr[j]，交换完后 i++，j–（对下一个元素进行比较），直到 i\u003e=j，停止移动。 图中的 L，R 是指快速排序开始时序列的起始和结束索引，在一趟快速排序中，它们的值不会发生改变，直到下一趟排序时才会改变。 一趟快速排序完成后，分别对小于6和大于等于6的部分进行快速排序，递归就好了。对 [ 5, 1, 4, 3, 2 ] 进行一趟快速排序。 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:0","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:1","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点","date":"2021-04-07","objectID":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:2","tags":["排序算法"],"title":"排序算法","uri":"/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["运维"],"content":"docker概述 从开发到上线，两套环境，版本不同导致软件不可用，开发与运维有差距！部署配置环境费时费力 原：jar——-redis,mysql,jdk,项目能不能带上环境安装打包？跨平台，隔离， docker容器技术也是一种虚拟化技术 官网：https://www.docker.com/ 文档：https://docs.docker.com/ 仓库地址： https://hub.docker.com/ 镜像（image）:模板，通过这个模板来创建容器服务，可创建多个容器（最终服务或者项目运行在容器中） 容器（container）：一个或一组应用，可以启动，停止，删除，基本命令 仓库（repository）：存放镜像（公有私有），docker hub(默认) 阿里云（国内镜像加速） 安装 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:0:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"start 卸载旧版本 # 1、卸载旧版本 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2、 需要的安装包 sudo yum install -y yum-utils # 3、设置镜像仓库 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 默认是国外的 可换国内 yum makecache fast # 4、安装相关的额 sudo yum install docker-ce docker-ce-cli containerd.io # 5、启动 sudo systemctl start docker docker version # 6、测试 sudo docker run hello-World 查看镜像 docker images 阿里云镜像加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://ax7mfl6a.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"hello-world流程 sudo docker run hello-World–\u003e本机寻找镜像–No–\u003e仓库地址下载—\u003e是否找到—\u003e下载镜像到本地—\u003e使用镜像创建容器运行 docker常用命令 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:2:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"帮助命令 docker version # 显示版本信息 docker info #系统信息，镜像、容器 docker 命令 --help ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:3:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"镜像命令 docker images docker search mysql docker pull mysql docker pull mysql:5.7 #docker分层下载，节省空间 删除镜像docker rmi -f docker rmi -f 容器id docker rmi -f $(docker images -aq) #删除所有镜像 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:4:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"容器命令 拉取镜像 docker pull centos 创建容器并启动 docker run [可选参数] image # 参数设置 --name=\"name\" 容器名称，tomcat01，tomcat02 -it 交互方式运行， -d 后台运行 -p 指定荣放弃的端口 -p 8080:8080 -p ip:主机端口：容器端口 -p 主机端口：容器端口 -p 容器端口 容器端口 -P 随机指定端口 C:\\Users\\26505\u003edocker pull centos Using default tag: latest latest: Pulling from library/centos 7a0437f04f83: Pulling fs layer latest: Pulling from library/centos 7a0437f04f83: Pull complete Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1 Status: Downloaded newer image for centos:latest docker.io/library/centos:latest C:\\Users\\26505\u003edocker run -it centos /bin/bash [root@177a03668b45 /]# exit exit C:\\Users\\26505\u003edocker ps #正在运行的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bc1f05966db8 mysql \"docker-entrypoint.s…\" 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-\u003e3306/tcp mysql 741b6a4bccc2 docker/getting-started \"/docker-entrypoint.…\" 7 hours ago Up 7 hours 0.0.0.0:8080-\u003e80/tcp docker-test C:\\Users\\26505\u003edocker ps -a #历史容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 177a03668b45 centos \"/bin/bash\" 4 minutes ago Exited (0) 3 minutes ago stoic_rosalind bc1f05966db8 mysql \"docker-entrypoint.s…\" 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-\u003e3306/tcp mysql 741b6a4bccc2 docker/getting-started \"/docker-entrypoint.…\" 7 hours ago Up 7 hours 0.0.0.0:8080-\u003e80/tcp docker-test 70b02a4a1833 hello-world \"/hello\" 7 hours ago Exited (0) 7 hours ago stupefied_neumann ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:5:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"退出容器 exit #退出并停止容器 ctrl+P+Q #退出终端不停止容器 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:6:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"删除容器 rm -f docker rm 容器id #不能删除正在运行的容器 docker rm -f $(docker pa -aq) #删除全部容器 docker ps -a -q|xargs docker rm #删除全部容器(管道) ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:7:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"启动停止容器 docker start id #启动 docker restart id #重启 docker stop id #停止 docker kill id #强制停止 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:8:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"常用的其他命令 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"后台启动 docker run -d centos #问题 :docker ps 发现centos停止了 # 常见的坑，后台运行后，就必须有一个前台进程，docker发现没有应用，就自动停止了 #nginx 容器启动后，没有提供服务，就会立刻停止 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:1","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"日志命令 docker logs --help docker logs -tf --tail 10 id #查看后10条日志 docker logs -tf id #查看所有日志 docker run -d centos /bin/sh -C \"while true ;do echo tanjindong;sleep 1;done\" ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:2","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"查看容器中的进程信息 # top命令 docker top --help docker top id ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:3","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"查看镜像源数据 # inspect docker inspect id C:\\Users\\26505\u003edocker inspect 741b6a4bccc2 [ { \"Id\": \"741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3\", \"Created\": \"2021-03-21T07:20:22.6575041Z\", \"Path\": \"/docker-entrypoint.sh\", \"Args\": [ \"nginx\", \"-g\", \"daemon off;\" ], \"State\": { \"Status\": \"running\", \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 2067, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2021-03-21T07:20:26.022246Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, \"Image\": \"sha256:3ba8f2ff0727d36bccad59f6344f7f3a101bcd9c70b984aa2dd006914c496cb8\", \"ResolvConfPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/hostname\", \"HostsPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/hosts\", \"LogPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3-json.log\", \"Name\": \"/docker-test\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"MountLabel\": \"\", \"ProcessLabel\": \"\", \"AppArmorProfile\": \"\", \"ExecIDs\": [ \"4ac8b9a918d39e7560ebf5e35fad12ef83ed66cabc27035095870d4fe13ac56c\" ], \"HostConfig\": { \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": { \"Type\": \"json-file\", \"Config\": {} }, \"NetworkMode\": \"default\", \"PortBindings\": { \"80/tcp\": [ { \"HostIp\": \"\", \"HostPort\": \"8080\" } ] }, \"RestartPolicy\": { \"Name\": \"no\", \"MaximumRetryCount\": 0 }, \"AutoRemove\": false, \"VolumeDriver\": \"\", \"VolumesFrom\": null, \"CapAdd\": null, \"CapDrop\": null, \"CgroupnsMode\": \"host\", \"Dns\": [], \"DnsOptions\": [], \"DnsSearch\": [], \"ExtraHosts\": null, \"GroupAdd\": null, \"IpcMode\": \"private\", \"Cgroup\": \"\", \"Links\": null, \"OomScoreAdj\": 0, \"PidMode\": \"\", \"Privileged\": false, \"PublishAllPorts\": false, \"ReadonlyRootfs\": false, \"SecurityOpt\": null, \"UTSMode\": \"\", \"UsernsMode\": \"\", \"ShmSize\": 67108864, \"Runtime\": \"runc\", \"ConsoleSize\": [ 31, 120 ], \"Isolation\": \"\", \"CpuShares\": 0, \"Memory\": 0, \"NanoCpus\": 0, \"CgroupParent\": \"\", \"BlkioWeight\": 0, \"BlkioWeightDevice\": [], \"BlkioDeviceReadBps\": null, \"BlkioDeviceWriteBps\": null, \"BlkioDeviceReadIOps\": null, \"BlkioDeviceWriteIOps\": null, \"CpuPeriod\": 0, \"CpuQuota\": 0, \"CpuRealtimePeriod\": 0, \"CpuRealtimeRuntime\": 0, \"CpusetCpus\": \"\", \"CpusetMems\": \"\", \"Devices\": [], \"DeviceCgroupRules\": null, \"DeviceRequests\": null, \"KernelMemory\": 0, \"KernelMemoryTCP\": 0, \"MemoryReservation\": 0, \"MemorySwap\": 0, \"MemorySwappiness\": null, \"OomKillDisable\": false, \"PidsLimit\": null, \"Ulimits\": null, \"CpuCount\": 0, \"CpuPercent\": 0, \"IOMaximumIOps\": 0, \"IOMaximumBandwidth\": 0, \"MaskedPaths\": [ \"/proc/asound\", \"/proc/acpi\", \"/proc/kcore\", \"/proc/keys\", \"/proc/latency_stats\", \"/proc/timer_list\", \"/proc/timer_stats\", \"/proc/sched_debug\", \"/proc/scsi\", \"/sys/firmware\" ], \"ReadonlyPaths\": [ \"/proc/bus\", \"/proc/fs\", \"/proc/irq\", \"/proc/sys\", \"/proc/sysrq-trigger\" ] }, \"GraphDriver\": { \"Data\": { \"LowerDir\": \"/var/lib/docker/overlay2/6d343bc9ad04de2e498e78ef2f579175c692ed808c08b393d1eb997f1dd5d84b-init/diff:/var/lib/docker/overlay2/214cc931af263a16f14aeb6d585e2dbee7150a57e19e84650bfdc32734a5846f/diff:/var/lib/docker/overlay2/47fae1cab0a2404c969f4cea1cfcb6b054b1bbdea8d8c6149c21848a77c816dc/diff:/var/lib/docker/overlay2/17096a2500c8f19f644b2554a0bd01af1b469f6f3b1b0d47718f826fe6c1e01e/diff:/var/lib/docker/overlay2/bbe4a1e6f6189b486a01f819c7fc91f2c558eb60e3eda0a16629e9b40cef3937/diff:/var/lib/docker/overlay2/98581fdc9425566ddfa8a8b96d8fe61544f2140e026d1df3cbdc507d38f582cd/diff:/var/lib/docker/overlay2/66a3d69a78eff1300e49d125d6a2ad49e2e9b48f826c802ae6e654b83db3016d/diff:/var/lib/docker/overlay2/8dafe228d5bec8620615e6252f815baeb01884e592865f8edac2f7fec8317da8/diff:/var/lib/docker/overlay2/d0ca3a53296feb329ea10d4f75f54b57bed2bdf53b67a24de0a1b6d726877d85/diff\", \"MergedDir\": \"/var/l","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:4","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"进入当前正在运行的容器 docker exec -it 容器id bashshell docker ps # 方式一 进入容器之后开启一个新的终端(常用) docker exec -it id /bin/bash #方式二 进入执行的终端 docker attach 容器id 正在执行的代码。。。。。 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:5","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"从容器拷贝文件到主机 cp docker cp id:/home/test.java /home docker cp 容器id:容器目录 本机目录 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:9:6","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业一：部署nginx docker pull nginx #下载镜像 docker images docker run -d --name nginx-01 -p 3344:80 nginx #运行容器 curl localhost:3344 #测试 pi@raspberrypi:~ $ docker exec -it nginx-01 /bin/bash #进入容器 root@9ddb6ad99473:/# whereis nginx nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx root@9ddb6ad99473:/# cd etc/nginx/ root@9ddb6ad99473:/etc/nginx# ls conf.d fastcgi_params koi-utf koi-win mime.types modules nginx.conf scgi_params uwsgi_params win-utf pi@raspberrypi:~ $ docker stop nginx-01 #停止容器 nginx-01 pi@raspberrypi:~ $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES #每次修改nginx配置，都需要进入容器，十分麻烦，映射路径，达到修改容器配置的目的，数据卷技术！！！！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:10:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业二：部署tomcat #官方使用 docker run -it --rm tomcat:9.0 #之前都是后台，停止了之后，容器还可以查到，docker run -it --rm用完即删，一般用来测试 #下载启动 docker pull tomcat docker images docker run -d --name tomcat-01 -p 3355:8080 tomcat #运行 外部3355 but 原因：官方镜像最简化，所以找不到资源文件： docker exec -it tomcat-01 /bin/bash #进入容器 cp -r webapps.dist/* webapps ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:11:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业三：部署es+kibana # elasticsearch暴露端口十分多 # ES 十分耗内存 # 数据一般挂载在安全目录 # --net somenetwork ？网络配置 docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.11.2 docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.11.2 C:\\Users\\26505\u003ecurl localhost:9200 { \"name\" : \"2ab0292e5b49\", \"cluster_name\" : \"docker-cluster\", \"cluster_uuid\" : \"661wGGJlSRqiLH_ht2P48A\", \"version\" : { \"number\" : \"7.11.2\", \"build_flavor\" : \"default\", \"build_type\" : \"docker\", \"build_hash\" : \"3e5a16cfec50876d20ea77b075070932c6464c7d\", \"build_date\" : \"2021-03-06T05:54:38.141101Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.7.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } # 启动之后非常卡 how to 解决 docker stats 查看cpu状态 docker stats # 解决一：增加内存限制，修改配置文件， -e 环境的配置修改 docker run -d --name elasticsearch -p 9201:9200 -p 9301:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" elasticsearch:7.11.2 使用kibana连接ES： ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:12:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"可视化工具 portainer(不是最佳选择，先用) # -v /var/run/docker.sock 挂载，里面数据挂载到本机 # --privileged=true 授权，本机可访问 docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 测试访问：8088 Rancher（CI/CD） docker镜像原理 UFS 联合文件系统，分层轻量，分层下载，分层加载，多镜像共用 公共内核(bootfs) 对于一个OS，rootfs可以很小，只需要包含基本的命令、工具和程序库就可以了，因为底层直接用host的kernel，自己只需要提供rootfs就可以了，由此可见，不同版本的Linux发行版，bootfs是相同的，只是rootfs不同罢了。 bootfs引导启动非常慢，rootfs库启动非常快，所以虚拟机启动分钟级别，docker启动秒级。 分层理解： ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:13:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"如何打包一个自己的镜像：commit docker commit #提交容器 docker commit -m=\"提交描述信息\" -a=\"作者\" 容器id 目标镜像名:[tag] docker commit -a=\"jd\" -m=\"add webapps\" 7sssdvhfgs tomcat02:1.0 容器数据卷 如果数据都在容器中，容器删除之后，数据就会丢失，需求：数据可持久化， MySQL，容器删除了，MySQL数据就没了，MySQL可以保存在本地吗？ 数据共享技术，docker容器中产生的数据同步到本地， 卷技术，？目录挂载，将容器内的目录挂载在宿主机上，持久化与同步操作，容器间数据可以共享 # 方式一：使用-v挂载 docker run -d -v 主机目录:容器目录 docker run -it -v /home/ceshi:/home --name ubuntu01 ubuntu /bin/bash docker inspect 容器id docker stop 1bfb0a3ad95e #停止docker 容器 sudo nano test.txt #修改Host文件 docker start 1bfb0a3ad95e #重新启动 # 进入容器查看文件变化 pi@raspberrypi:~ $ docker exec -it 1bfb0a3ad95e /bin/bash root@1bfb0a3ad95e:/# cd /home root@1bfb0a3ad95e:/home# ls test test.b test.java test.txt root@1bfb0a3ad95e:/home# cat test/txt cat: test/txt: No such file or directory root@1bfb0a3ad95e:/home# cat test.txt yasethbitgejk nadeuioaguhno arezln # 容器内的数据依旧是同步的！！！！！！ # 通过-v挂载配置文件和资源文件，就不用进入容器修改，只用修改本地，容器自动同步 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:14:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"部署MySQL mysql数据持久化问题 docker pull mysql:5.7 #需要配置密码 -e MYSQL_ROOT_PASSWORD=my-secret-pw # docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag docker run -d -p 3310:3306 --name mysql-test -v H:\\myNotsBooks\\docker\\conf:/etc/mysql/conf.d -v H:\\myNotsBooks\\docker\\data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 链接成功： 数据挂载成功：（conf） 即使删除容器，本地的数据卷依旧没有丢失，这就达到了数据持久化 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:15:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"具名和匿名挂载 #匿名挂载 # -v 容器内路径！ docker run -d -P --name nginx-test -v /etc/nginx nginx # 查看所有卷volume的挂载情况 pi@raspberrypi:/home/ceshi $ docker run -d -P --name nginx-test -v /etc/nginx nginx 9f4ba2383cab2eedc09916c2191858b88673cc43ef85194b42eb67cb8c2bca54 pi@raspberrypi:/home/ceshi $ docker volume --help Usage: docker volume COMMAND Manage volumes Commands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumes Run 'docker volume COMMAND --help' for more information on a command. pi@raspberrypi:/home/ceshi $ docker volume ls DRIVER VOLUME NAME local 27f1cec7789cd92096fc7177238808528b7201f2b7f2628c57fc4f350bff7c09 #匿名挂载 local 28ce6884130cf729f12f33decf67c96f0bab95032c193302553cd9050f8ff7e8 # -v 的时候只写了容器内部的路径 #具名挂载 pi@raspberrypi:~ $ docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx nginx 70500d6c7b7f937a953990007fc0af3db4628df5687eead2081abdfaeb582b4f pi@raspberrypi:~ $ docker volume ls DRIVER VOLUME NAME local 27f1cec7789cd92096fc7177238808528b7201f2b7f2628c57fc4f350bff7c09 local 28ce6884130cf729f12f33decf67c96f0bab95032c193302553cd9050f8ff7e8 local jumingfs pi@raspberrypi:~ $ docker volume inspect nginx-juming [] Error: No such volume: nginx-juming pi@raspberrypi:~ $ docker volume inspect jumingfs [ { \"CreatedAt\": \"2021-03-25T11:06:02+08:00\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/jumingfs/_data\", \"Name\": \"jumingfs\", \"Options\": null, \"Scope\": \"local\" } ] 所有docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/jumingfs/_data 我们通过具名挂载可以方便找到我们的一个大卷，大多数情况下使用的是具名挂载 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:16:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"如何区分是具名挂载还是匿名挂载还是指定路径挂载 -v 容器内路径 #匿名挂载 -v 卷名:容器内路径 #具名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:17:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"扩展 #设置容器权限，对挂载数据卷有限制 docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx:ro nginx docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx:rw nginx # ro 只能通过宿主机来操作，不能通过容器内部操作 # 默认rw: 可读可写 Dockerfile:构建docker的文件 一段命令脚本 pi@raspberrypi:/home/docker-test-file-volume $ docker build -f ./dockerfile1 -t jd/centos:1.0 . #构建镜像 Sending build context to Docker daemon 2.048kB Step 1/4 : FROM ubuntu ---\u003e 3324772e8bdf Step 2/4 : VOLUME [\"volume01\",\"volume02\"] ---\u003e Running in e07670d15bd9 Removing intermediate container e07670d15bd9 ---\u003e 067080c3c46e Step 3/4 : CMD echo \"........end........\" ---\u003e Running in 0ac9ebb25a05 Removing intermediate container 0ac9ebb25a05 ---\u003e 5fa9a5e368ba Step 4/4 : CMD /bin/bash ---\u003e Running in 492dcb1825df Removing intermediate container 492dcb1825df ---\u003e e5bd1def5d82 Successfully built e5bd1def5d82 Successfully tagged jd/centos:1.0 pi@raspberrypi:/home/docker-test-file-volume $ docker images #查看镜像 REPOSITORY TAG IMAGE ID CREATED SIZE jd/centos 1.0 e5bd1def5d82 7 seconds ago 49.8MB portainer/portainer latest 9b438d60114e 6 days ago 62.4MB nginx latest 4f718772a0b3 13 days ago 103MB ubuntu latest 3324772e8bdf 5 months ago 49.8MB hello-world latest 851163c78e4a 14 months ago 4.85kB java 8 d23bdf5b1b1b 4 years ago 643MB pi@raspberrypi:/home/docker-test-file-volume $ cat dockerfile1 FROM ubuntu VOLUME [\"volume01\",\"volume02\"] #匿名挂载 CMD echo \"........end........\" CMD /bin/bash docker inspect id #查看卷挂载路径 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:18:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"多个docker同步数据 # 多个MySQL数据同步 # 启动三个容器 docker run -it --name docker01 jd/centos:1.0 docker run -it --name docker02 --volumes-from docker01 jd/centos:1.0 docker run -it --name docker03 --volumes-from docker01 jd/centos:1.0 # 进入docker01创建文件 root@450d606a17a0:/# pi@raspberrypi:/ $ docker attach 0721edbafafb root@0721edbafafb:/# ls bin dev home media opt root sbin sys usr volume01 boot etc lib mnt proc run srv tmp var volume02 root@0721edbafafb:/# cd vo bash: cd: vo: No such file or directory root@0721edbafafb:/# cd volume01 root@0721edbafafb:/volume01# ls root@0721edbafafb:/volume01# touch docker01.txt touch: setting times of 'docker01.txt': Operation not permitted root@0721edbafafb:/volume01# ls docker01.txt #进入docker02查看 pi@raspberrypi:/ $ docker attach 450d606a17a0 root@450d606a17a0:/# ls bin dev home media opt root sbin sys usr volume01 boot etc lib mnt proc run srv tmp var volume02 root@450d606a17a0:/# cd volume01 root@450d606a17a0:/volume01# ls docker01.txt docker02 volumesfrom docker01 docker03 volumesfrom docker01 如果把1删除了，2，3还在吗？？？ 发现还在，只要有一个容器使用，就依旧存在，共享备份机制，双向拷贝的概念 # 多个mysql实现数据共享 docker run -d -p 3301:3306 --name mysql01 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 docker run -d -p 3302:3306 --name mysql02 --volumes-from mysql01 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 #这个时候可以实现两个容器数据同步 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止， 但是一旦持久化挂载-v到本地，本地不会被删除！！！！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:19:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerfile 命令参数脚本 1、编写一个dockerfile文件 2、docker build 一个镜像 3、docker run 运行容器 4、docker push 发布镜像（dockerhub,阿里云镜像） 查看一下官方这么做的： FROM scratch ADD centos-8-x86_64.tar.xz / LABEL org.label-schema.schema-version=\"1.0\" org.label-schema.name=\"CentOS Base Image\" org.label-schema.vendor=\"CentOS\" org.label-schema.license=\"GPLv2\" org.label-schema.build-date=\"20201204\" CMD [\"/bin/bash\"] ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:20:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"构建过程 从上到下顺序执行，指令大写，每个指令就会创建一个新的镜像层 企业交付的标准！！！！！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:21:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerfile指令 dockerHub 80% 来自FROM scratch FROM #基础镜像，一切从这里开始构建 MAINTAINER #镜像是谁写的，姓名+邮箱 RUN #构建镜像时需要运行的命令 ADD #步骤，tomcat压缩包，添加内容 WORKDIR #镜像的工作目录 VOLUME #挂载卷 EXPOSE #指定暴露端口原来-p CMD #指定这个容器启动的时候运行的命令，只有最后一个会失效，可被替代 ENTRYPOINT #指定这个容器启动的时候运行的命令，可追加 ONBUILD #当构建一个被继承dockerfile,触发指令 COPY #类似ADD，拷贝文件到镜像 ENV #构建的时候设置环境变量 -e 自己写一个dockerfile：：：：：：：：： ＃　entos-vim-ip FROM centos MAINTAINER 金东\u003c2650523664@qq.com ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"------end-----\" CMD /bin/bash docker build -f centos-vim-ip -t mycentos:1.0 . docker images docker run -it --name mycentostest mycentos:1.0 # 现在vim 与 ifconfig命令都可以用了,官方不可用 docker history mycentos:1.0 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:22:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"CMD与ENTRYPOINT区别 FROM centos CMD [\"ls\",\"-a\"]　# 指定容器启动时运行的命令，只有最后一个生效，可被替代 H:\\myNotsBooks\\docker\\dockerfile\u003edocker run -it cmdtest -l docker: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: \"-l\": executable file not found in $PATH: unknown. # cmd的清理下，-l代替了CMD [\"ls\",\"-a\"],但是-l不是命令，所以报错 H:\\myNotsBooks\\docker\\dockerfile\u003edocker run -it cmdtest ls -al #这就对了 total 56 drwxr-xr-x 1 root root 4096 Mar 25 14:21 . drwxr-xr-x 1 root root 4096 Mar 25 14:21 .. -rwxr-xr-x 1 root root 0 Mar 25 14:21 .dockerenv lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -\u003e usr/bin drwxr-xr-x 5 root root 360 Mar 25 14:21 dev drwxr-xr-x 1 root root 4096 Mar 25 14:21 etc drwxr-xr-x 2 root root 4096 Nov 3 15:22 home lrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -\u003e usr/lib lrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -\u003e usr/lib64 drwx------ 2 root root 4096 Dec 4 17:37 lost+found drwxr-xr-x 2 root root 4096 Nov 3 15:22 media drwxr-xr-x 2 root root 4096 Nov 3 15:22 mnt drwxr-xr-x 2 root root 4096 Nov 3 15:22 opt dr-xr-xr-x 196 root root 0 Mar 25 14:21 proc dr-xr-x--- 2 root root 4096 Dec 4 17:37 root drwxr-xr-x 11 root root 4096 Dec 4 17:37 run lrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -\u003e usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 15:22 srv dr-xr-xr-x 11 root root 0 Mar 25 14:21 sys drwxrwxrwt 7 root root 4096 Dec 4 17:37 tmp drwxr-xr-x 12 root root 4096 Dec 4 17:37 usr drwxr-xr-x 20 root root 4096 Dec 4 17:37 var #ENTRYPOINT 命令可追加 FROM centos ENTRYPOINT [\"ls\",\"-a\"] docker build -f docker-entrypoint-test -t entrypointtest . docker run -it entrypointtest H:\\myNotsBooks\\docker\\dockerfile\\cmd ENTRYPOINT\u003edocker run -it entrypointtest . .dockerenv dev home lib64 media opt root sbin sys usr .. bin etc lib lost+found mnt proc run srv tmp var H:\\myNotsBooks\\docker\\dockerfile\\cmd ENTRYPOINT\u003edocker run -it entrypointtest -l #加-l不报错,加到a前面了 total 56 drwxr-xr-x 1 root root 4096 Mar 25 14:29 . drwxr-xr-x 1 root root 4096 Mar 25 14:29 .. -rwxr-xr-x 1 root root 0 Mar 25 14:29 .dockerenv lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -\u003e usr/bin drwxr-xr-x 5 root root 360 Mar 25 14:29 dev drwxr-xr-x 1 root root 4096 Mar 25 14:29 etc drwxr-xr-x 2 root root 4096 Nov 3 15:22 home lrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -\u003e usr/lib lrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -\u003e usr/lib64 drwx------ 2 root root 4096 Dec 4 17:37 lost+found drwxr-xr-x 2 root root 4096 Nov 3 15:22 media drwxr-xr-x 2 root root 4096 Nov 3 15:22 mnt drwxr-xr-x 2 root root 4096 Nov 3 15:22 opt dr-xr-xr-x 195 root root 0 Mar 25 14:29 proc dr-xr-x--- 2 root root 4096 Dec 4 17:37 root drwxr-xr-x 11 root root 4096 Dec 4 17:37 run lrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -\u003e usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 15:22 srv dr-xr-xr-x 11 root root 0 Mar 25 14:29 sys drwxrwxrwt 7 root root 4096 Dec 4 17:37 tmp drwxr-xr-x 12 root root 4096 Dec 4 17:37 usr drwxr-xr-x 20 root root 4096 Dec 4 17:37 var ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:22:1","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"实战：tomcat镜像 1、准备镜像文件：tomcat jdk 2、编写dockerfile文件 FROM centos MAINTAINER jd\u003c2650523664@qq.com\u003e COPY readme.txt /usr/local/readme.txt ADD apache-tomcat-9.0.44.tar.gz /usr/local/ ADD jdk-8u201-linux-x64.tar.gz /usr/local/ RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_201 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.44 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.44 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.44/bin/startup.sh \u0026\u0026 tail -F /usr/local/apache-tomcat-9.0.44/bin/logs/catalina.out 3、构建镜像 docker build -t mytomcat . # 构建镜像 4、启动镜像 docker run -d -p 9090:8080 --name testmytomcat -v /root/environment/tomcat-test-3-26/test:/usr/local/apache-tomcat-9.0.44/webapps/test -v /root/environment/tomcat-test-3-26/tomlogs:/usr/local/apache-tomcat-9.0.44/logs mytomcat 5、访问测试 6、发布项目（由于实现了卷挂载，所以我们就直接在本地写项目发布就可以了） jps页面 \u003chtml\u003e \u003chead\u003e\u003ctitle\u003eHello World\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e Hello World!\u003cbr/\u003e \u003c% System.out.println(\"-----------start my tomcat-----\"); %\u003e \u003c/body\u003e \u003c/html\u003e web.xml文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\" metadata-complete=\"true\"\u003e \u003c/web-app\u003e ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:23:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"发布镜像 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:24:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerHub镜像 1、注册账户：https://registry.hub.docker.com/ 2、客户端提交镜像 [root@jd tomcat-test-3-26]# docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username [root@jd tomcat-test-3-26]# docker login -u hubu8023 Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 3、发布镜像 [root@jd ~]# docker tag 5599ee6a7e53 hubu8023/mytest:1.0 [root@jd ~]# docker push hubu8023/mytest:1.0 [root@jd ~]# docker tag hello-world:latest hubu8023/myhello:2.0 #增加标签 [root@jd ~]# docker push hubu8023/myhello:2.0 # The push refers to repository [docker.io/hubu8023/myhello] f22b99068db9: Mounted from library/hello-world 2.0: digest: sha256:1b26826f602946860c279fce658f31050cff2c596583af237d971f4629b57792 size: 525 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:24:1","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"阿里云镜像 1、登录阿里云https://cr.console.aliyun.com/cn-hangzhou/instance/repositories 2、找到容器镜像服务 3、创建命名空间 4、创建容器镜像 5、浏览页面信息 登录阿里云Docker Registry $ sudo docker login --username=18871955259东 registry.cn-hangzhou.aliyuncs.com 用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在访问凭证页面修改凭证密码。 从Registry中拉取镜像 $ sudo docker pull registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] 将镜像推送到Registry $ sudo docker login --username=18871955259东 registry.cn-hangzhou.aliyuncs.com $ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] $ sudo docker push registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] 请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 小结： Docker网络 docker网络核心docker0: 两个容器之间如何访问？？？？？ docker run -d -P --name tomcat01 tomcat [root@jd ~]# docker exec -it tomcat01 ip addr 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 18: eth0@if19: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 查看容器内网IP地址，发现容器启动的时候得到一个eth0@if19 IP地址，这是docker分配的！！！ 现在能不能ping通容器？？？linux可以ping通容器内部 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:24:2","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"原理： 1、我们每启动一个docker容器，docker就会给容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0(桥接模式–evth-pair) 2、再启动一个docker容器，发现又多了一对网卡： # 容器的网卡都是成对出现的， # evth-pair就是一对虚拟设备接口，他们都是成对出现的，一端连接协议，一端彼此相连 # 正因为有这个特性，evth-pair充当一个桥梁，连接各种虚拟网络设备， 3、测试两个tomcat能不能互通： 网络模型 结论：tomcat01和tomcat02 共用一个路由器docker0, 所有的容器不指定网络，都是docker0路由的，docker会给容器分配一个默认可用IP 255.255.0.1/16 : 能用IP;255*255-0.0-255.255=255*255-1-1 255.255.0.1/24 : 能用IP;255*255-0.0-255.255=255-1-1 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:25:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"–link(基本不用) 场景：微服务或者springboot中database.url配置怎么写？？IP一直变 项目不重启，数据库IP变了，我们希望可以通过名字来访问容器 [root@jd ~]# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known # 实现tomcat03 ping tomcat02 [root@jd ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat 7dd6fe9dbe2e5732dfa53d3d2b2e6f14eb7abaccbf2771c44ae03db2dcc4faaf [root@jd ~]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.109 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.079 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.100 ms # 反向tomcat02 不能ping tomcat03 [root@jd ~]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 探究inspect: [root@jd ~]# docker network ls NETWORK ID NAME DRIVER SCOPE c592ad97632c bridge bridge local c9c57d03a4a4 host host local 85a3888c406a none null local [root@jd ~]# docker network inspect c592ad97632c #docker0网卡信息 docker inspect tomcat03 # 原理发现！！！！！！！！！！！！！！！！！！！！ # 查看tomcat03 hosts文件 docker exec -it tomcat03 cat /etc/hosts [root@jd ~]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.3 tomcat02 9dce1424d4fe #9dce1424d4fe tomcat02容器id 172.17.0.4 7dd6fe9dbe2e #7dd6fe9dbe2e tomcat03本机容器id 容器02： [root@jd ~]# docker exec -it tomcat02 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.3 9dce1424d4fe 只要在这里增加容器03的网络配置就可以实现互通， 但是现在docker已经不建议使用–link技术了，自定义网络，不用docker0, docker0问题：他不支持容器名链接访问！ ！ ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:26:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"自定义网络 # 查看所有网络 [root@jd ~]# docker network ls NETWORK ID NAME DRIVER SCOPE c592ad97632c bridge bridge local c9c57d03a4a4 host host local 85a3888c406a none null local 网络模式： bridge : 桥接模式（默认），自己创建也是使用bridge模式 none: 不配置网络， host: 和Linux主机共享网络 container: 容器网络连通（用的少，局限性很大） 测试 # 原来启动容器，默认--net bridge 二这个就是我们的docker0 docker run -d -P --name tomcat01 --net bridge tomcat docker run -d -P --name tomcat01 tomcat # docker0特点： 默认。域名不能访问，--link可以打通 # 因此我们需要自定义一个网络 [root@jd ~]# docker network --help Usage: docker network COMMAND Manage networks Commands: connect Connect a container to a network create Create a network disconnect Disconnect a container from a network inspect Display detailed information on one or more networks ls List networks prune Remove all unused networks rm Remove one or more networks docker network create --help # --subnet子网地址 192.168.0.2--------192.168.255.255 # --gateway 网关，路由器地址 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mytestnet docker network ls [root@jd ~]# docker network inspect mytestnet [ { \"Name\": \"mytestnet\", \"Id\": \"779b38cb0d482db5eb7156e0ba327da1740a86d71106438f27f22f6ceee2e82e\", \"Created\": \"2021-03-27T14:17:45.675341638+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": {}, \"Options\": {}, \"Labels\": {} } ] 用自己创建的网络模式创建容器 [root@jd ~]# docker run -d -P --name tomcat-net-01 --net mytestnet tomcat 56554c258e04f1ed4c300e26d337ca39c35087aa4d92f782e0a2b87138484b99 [root@jd ~]# docker run -d -P --name tomcat-net-02 --net mytestnet tomcat 1ccb18d09020622d029b4373c6d09f40259b5944ee27269ee0195ad8bd94269 [root@jd ~]# docker network inspect mytestnet [ { \"Name\": \"mytestnet\", \"Id\": \"779b38cb0d482db5eb7156e0ba327da1740a86d71106438f27f22f6ceee2e82e\", \"Created\": \"2021-03-27T14:17:45.675341638+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"1ccb18d09020622d029b4373c6d09f40259b5944ee27269ee0195ad8bd942694\": { \"Name\": \"tomcat-net-02\", \"EndpointID\": \"fa949ca6e5a71662a6656b83ed483d812972e815e5f1fc8d1c4c1f33e714cadb\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" }, \"56554c258e04f1ed4c300e26d337ca39c35087aa4d92f782e0a2b87138484b99\": { \"Name\": \"tomcat-net-01\", \"EndpointID\": \"5e2022a9c3c27a9d225d7b2d54f2ab16196fff5cfa9aa3f9a28be4e4d2a8f649\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": {} } ] #此时tomcat-net-01与02就处于我们自己创建的网络模式中 好处： [root@jd ~]# docker exec -it tomcat-net-01 ping tomcat-net-02 PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data. 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=1 ttl=64 time=0.125 ms 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=2 ttl=64 time=0.085 ms 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=3 ttl=64 time=0.107 ms [root@jd ~]# docker exec -it tomcat-net-02 ping tomcat-net-01 PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data. 64 bytes from tomcat-net-01.mytestnet (192.168.0.2): icmp_seq=1 ttl=64 time=0.108 ms 64 bytes from tomcat-net-01.mytestnet (192.168.0.2): icmp_seq=2 ttl=64 time=0.098 ms # 可以直接通过容器名称互通，不用使用--link 自定义网络已经维护好了对应关系，推荐使用自定义网络 redis集群，mysql集群使用不同的网络，保证集群的隔离性与数据安全 ，网络互相隔离 ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:27:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"网络互通 测试 [root@jd ~]# docker run -d -P --name tomcat01 tomcat 999d0f449539783be990b3bb36f5036a4dc4419a8cfba1ffe9907e0bc08352d6 [root@jd ~]# docker run -d -P --name tomcat02 tomcat 5b6d4843a2fe7aede6cc377f4825dfb014bf035333ecf16d739576dc1a9b3237 [root@jd ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 5b6d4843a2fe tomcat \"catalina.sh run\" 6 seconds ago Up 5 seconds 0.0.0.0:49160-\u003e8080/tcp tomcat02 999d0f449539 tomcat \"catalina.sh run\" 16 seconds ago Up 16 seconds 0.0.0.0:49159-\u003e8080/tcp tomcat01 1ccb18d09020 tomcat \"catalina.sh run\" 15 minutes ago Up 15 minutes 0.0.0.0:49158-\u003e8080/tcp tomcat-net-02 56554c258e04 tomcat \"catalina.sh run\" 15 minutes ago Up 15 minutes 0.0.0.0:49157-\u003e8080/tcp tomcat-net-01 [root@jd ~]# docker network connect mytestnet tomcat01 [root@jd ~]# docker network inspect mytestnet 连通之后就是将tomcat01放在了mytestnet网络下 其实就是一个容器两个IP [root@jd ~]# docker exec -it tomcat-net-01 ping tomcat01 PING tomcat01 (192.168.0.4) 56(84) bytes of data. 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=1 ttl=64 time=0.126 ms 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=2 ttl=64 time=0.083 ms 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=3 ttl=64 time=0.084 ms tomcat02依旧不同 加入需要跨网络操作容器，就需要使用dockers network connect mytestnet tomcat-sjvbk ","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:28:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"部署redis集群 分片+高可用+负载均衡 # 创建网络 docker network create redis-net --subnet 172.38.0.0/16 docker network ls docker network inspect redis-net # 通过脚本创建6个redis for port in $(seq 1 6); \\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003e/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done for port in $(seq 1 6); \\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003e/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done # 创建6个redis节点 docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\ -v /mydata/redis/node-1/data:/data \\ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis-net --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6373:6379 -p 16373:16379 --name redis-3 \\ -v /mydata/redis/node-3/data:/data \\ -v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis-net --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf # 通过脚本一次启动6个redis容器 docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \\ -v /mydata/redis/node-${port}/data:/data \\ -v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf done docker ps # 交互模式进节点 docker exec -it redis-1 /bin/sh # 创建redis集群 redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 \\ 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 \\ 172.38.0.16:6379 --cluster-replicas 1 # 输入yes 测试 redis-cli -c cluster info cluster nodes /data # redis-cli -c 127.0.0.1:6379\u003e cluster info cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:7 cluster_my_epoch:1 cluster_stats_messages_ping_sent:866 cluster_stats_messages_pong_sent:847 cluster_stats_messages_fail_sent:5 cluster_stats_messages_auth-ack_sent:1 cluster_stats_messages_update_sent:1 cluster_stats_messages_sent:1720 cluster_stats_messages_ping_received:842 cluster_stats_messages_pong_received:833 cluster_stats_messages_meet_received:5 cluster_stats_messages_fail_received:1 cluster_stats_messages_auth-req_received:1 cluster_stats_messages_received:1682 127.0.0.1:6379\u003e cluster nodes 9d043104052b4904cb3c6587ae09a72691953b02 172.38.0.13:6379@16379 slave #从d6411ab58802fd1408e66c304760d1f31688321b 0 1616830729000 7 connected 62ae6caadcf0a38c0d5c3a26c1364026a926b7e9 172.38.0.15:6379@16379 slave #从69169db2f42fb6d9015a23b7fe7cb13a8e6d62b1 0 1616830730548 5 connected 53634e5afa3791069ca0b97183be5bd1d4496bb4 172.38.0.16:6379@16379 slave #从344c681321b27f5b53f59674fb21876889a92020 0 1616830730548 6 connected 344c681321b27f5b53f59674fb21876889a92020 172.38.0.12:6379@16379 master - 0 1616830730648 2 connected 5461-10922 #主 d6411ab58802fd1408e66c304760d1f31688321b 172.38.0.14:6379@16379 master - 0 1616830729000 7 connected 10923-16383 #主 69169db2f42fb6d9015a23b7fe7cb13a8e6d62b1 172.38.0.11:6379@16379 myself,master - 0 1616830730000 1 connected 0-5460 #主 127.0.0.1:6379\u003e get a -\u003e Redirected to slot [15495] located at 172.38.0.14:6379 \"b\" springboot项目部署 1、构建项目 2、打包应用 3、编写dockerfile FROM java:8 COPY *.jar /app/ CMD [\"----server.port=8080------\"] EXPOSE 9980 ENTRYPOINT [\"java\",\"-jar\",\"/app/posttimer.jar\"] 4、构建镜像 docker build -t posttimer . [root@jd posttimer]# docker build -t posttimer . Sending build context to Docker daemon 56.69MB Step 1/5 : FROM java:8 8: Pulling from library/java 5040bd298390: Pull comple","date":"2021-04-06","objectID":"/docker%E5%9F%BA%E7%A1%80/:29:0","tags":["docker基础"],"title":"Docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["数据库"],"content":"一、Nosql概述 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"为什么使用Nosql 1、单机Mysql时代 90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题 数据量增加到一定程度，单机数据库就放不下了 数据的索引（B+ Tree）,一个机器内存也存放不下 访问量变大后（读写混合），一台服务器承受不住。 2、Memcached(缓存) + Mysql + 垂直拆分（读写分离） 网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！ 优化过程经历了以下几个过程： 优化数据库的数据结构和索引(难度大) 文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了 MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。 3、分库分表 + 水平拆分 + Mysql集群 4、如今最近的年代 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。 目前一个基本的互联网项目 为什么要用NoSQL ？ 用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！ 这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"什么是Nosql NoSQL = Not Only SQL（不仅仅是SQL） Not Only Structured Query Language 关系型数据库：列+行，同一个表下数据的结构是一样的。 非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。 NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Nosql特点 方便扩展（数据之间没有关系，很好扩展！） 大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！） 数据类型是多样型的！（不需要事先设计数据库，随取随用） 传统的 RDBMS 和 NoSQL 传统的 RDBMS(关系型数据库) - 结构化组织 - SQL - 数据和关系都存在单独的表中 row col - 操作，数据定义语言 - 严格的一致性 - 基础的事务 - ... Nosql - 不仅仅是数据 - 没有固定的查询语言 - 键值对存储，列存储，文档存储，图形数据库（社交关系） - 最终一致性 - CAP定理和BASE - 高性能，高可用，高扩展 - ... 了解：3V + 3高 大数据时代的3V ：主要是描述问题的 海量Velume 多样Variety 实时Velocity 大数据时代的3高 ： 主要是对程序的要求 高并发 高可扩 高性能 真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"阿里巴巴演进分析 推荐阅读：阿里云的这群疯子https://yq.aliyun.com/articles/653511 # 商品信息 - 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。 # 商品描述、评论(文字居多) - 文档型数据库：MongoDB # 图片 - 分布式文件系统 FastDFS - 淘宝：TFS - Google: GFS - Hadoop: HDFS - 阿里云: oss # 商品关键字 用于搜索 - 搜索引擎：solr,elasticsearch - 阿里：Isearch 多隆 # 商品热门的波段信息 - 内存数据库：Redis，Memcache # 商品交易，外部支付接口 - 第三方应用 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Nosql的四大分类 KV键值对 新浪：Redis 美团：Redis + Tair 阿里、百度：Redis + Memcache 文档型数据库（bson数据格式）： MongoDB(掌握) 基于分布式文件存储的数据库。C++编写，用于处理大量文档。 MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。 ConthDB 列存储数据库 HBase(大数据必学) 分布式文件系统 图关系数据库 用于广告推荐，社交网络 Neo4j、InfoGrid 分类 Examples举例 典型应用场景 数据模型 优点 缺点 键值对（key-value） Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB 内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。 Key 指向 Value 的键值对，通常用hash table来实现 查找速度快 数据无结构化，通常只被当作字符串或者二进制数据 列存储数据库 Cassandra, HBase, Riak 分布式的文件系统 以列簇式存储，将同一列数据存在一起 查找速度快，可扩展性强，更容易进行分布式扩展 功能相对局限 文档型数据库 CouchDB, MongoDb Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容） Key-Value对应的键值对，Value为结构化数据 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 查询性能不高，而且缺乏统一的查询语法。 图形(Graph)数据库 Neo4J, InfoGrid, Infinite Graph 社交网络，推荐系统等。专注于构建关系图谱 图结构 利用图结构相关算法。比如最短路径寻址，N度关系查找等 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:1:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"二、Redis入门 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"概述 Redis是什么？ Redis（Remote Dictionary Server )，即远程字典服务。 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis能该干什么？ 内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF） 高效率、用于高速缓冲 发布订阅系统 地图信息分析 计时器、计数器(eg：浏览量) 。。。 特性 多样的数据类型 持久化 集群 事务 … ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"环境搭建 官网：https://redis.io/ 推荐使用Linux服务器学习。 windows版本的Redis已经停更很久了… ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Windows安装 https://github.com/dmajkic/redis 解压安装包 开启redis-server.exe 启动redis-cli.exe测试 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Linux安装 下载安装包！redis-5.0.8.tar.gz 解压Redis的安装包！程序一般放在 /opt 目录下 基本环境安装 yum install gcc-c++ # 然后进入redis目录下执行 make # 然后执行 make install redis默认安装路径 /usr/local/bin 将redis的配置文件复制到 程序安装目录 /usr/local/bin/kconfig下 redis默认不是后台启动的，需要修改配置文件！ 通过制定的配置文件启动redis服务 使用redis-cli连接指定的端口号测试，Redis的默认端口6379 查看redis进程是否开启 关闭Redis服务 shutdown 再次查看进程是否存在 后面我们会使用单机多Redis启动集群测试 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"测试性能 **redis-benchmark：**Redis官方提供的性能测试工具，参数选项如下： 简单测试： # 测试：100个并发连接 100000请求 redis-benchmark -h localhost -p 6379 -c 100 -n 100000 12 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"基础知识 redis默认有16个数据库 默认使用的第0个; 16个数据库为：DB 0~DB 15 默认使用DB 0 ，可以使用select n切换到DB n，dbsize可以查看当前数据库的大小，与key数量相关。 127.0.0.1:6379\u003e config get databases # 命令行查看数据库数量databases 1) \"databases\" 2) \"16\" 127.0.0.1:6379\u003e select 8 # 切换数据库 DB 8 OK 127.0.0.1:6379[8]\u003e dbsize # 查看数据库大小 (integer) 0 # 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。 127.0.0.1:6379\u003e set name sakura OK 127.0.0.1:6379\u003e SELECT 8 OK 127.0.0.1:6379[8]\u003e get name # db8中并不能获取db0中的键值对。 (nil) 127.0.0.1:6379[8]\u003e DBSIZE (integer) 0 127.0.0.1:6379[8]\u003e SELECT 0 OK 127.0.0.1:6379\u003e keys * 1) \"counter:__rand_int__\" 2) \"mylist\" 3) \"name\" 4) \"key:__rand_int__\" 5) \"myset:__rand_int__\" 127.0.0.1:6379\u003e DBSIZE # size和key个数相关 (integer) 5 keys * ：查看当前数据库中所有的key。 flushdb：清空当前数据库中的键值对。 flushall：清空所有数据库的键值对。 Redis是单线程的，Redis是基于内存操作的。 所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。 那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+ Redis为什么单线程还这么快？ 误区1：高性能的服务器一定是多线程的？ 误区2：多线程（CPU上下文会切换！）一定比单线程效率高！ 核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:2:6","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"三、五大数据类型 Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Redis-key 在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。 下面学习的命令： exists key：判断键是否存在 del key：删除键值对 move key db：将键值对移动到指定数据库 expire key second：设置键值对的过期时间 type key：查看value的数据类型 127.0.0.1:6379\u003e keys * # 查看当前数据库所有key (empty list or set) 127.0.0.1:6379\u003e set name qinjiang # set key OK 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e keys * 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e move age 1 # 将键值对移动到指定数据库 (integer) 1 127.0.0.1:6379\u003e EXISTS age # 判断键是否存在 (integer) 0 # 不存在 127.0.0.1:6379\u003e EXISTS name (integer) 1 # 存在 127.0.0.1:6379\u003e SELECT 1 OK 127.0.0.1:6379[1]\u003e keys * 1) \"age\" 127.0.0.1:6379[1]\u003e del age # 删除键值对 (integer) 1 # 删除个数 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e EXPIRE age 15 # 设置键值对的过期时间 (integer) 1 # 设置成功 开始计数 127.0.0.1:6379\u003e ttl age # 查看key的过期剩余时间 (integer) 13 127.0.0.1:6379\u003e ttl age (integer) 11 127.0.0.1:6379\u003e ttl age (integer) 9 127.0.0.1:6379\u003e ttl age (integer) -2 # -2 表示key过期，-1表示key未设置过期时间 127.0.0.1:6379\u003e get age # 过期的key 会被自动delete (nil) 127.0.0.1:6379\u003e keys * 1) \"name\" 127.0.0.1:6379\u003e type name # 查看value的数据类型 string 关于TTL命令 Redis的key，通过TTL命令返回key的过期时间，一般来说有3种： 当前key没有设置过期时间，所以会返回-1. 当前key有设置过期时间，而且key已经过期，所以会返回-2. 当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间. 关于重命名RENAME和RENAMENX RENAME key newkey修改 key 的名称 RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。 更多命令学习：https://www.redis.net.cn/order/ [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wBVZtGVm-1597890996517)(狂神说 Redis.assets/image-20200813114228439.png)] ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"String(字符串) 普通的set、get直接略过。 命令 描述 示例 APPEND key value 向指定的key的value后追加字符串 127.0.0.1:6379\u003e set msg hello OK 127.0.0.1:6379\u003e append msg \" world\" (integer) 11 127.0.0.1:6379\u003e get msg “hello world” DECR/INCR key 将指定key的value数值进行+1/-1(仅对于数字) 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e incr age (integer) 21 127.0.0.1:6379\u003e decr age (integer) 20 INCRBY/DECRBY key n 按指定的步长对数值进行加减 127.0.0.1:6379\u003e INCRBY age 5 (integer) 25 127.0.0.1:6379\u003e DECRBY age 10 (integer) 15 INCRBYFLOAT key n 为数值加上浮点型数值 127.0.0.1:6379\u003e INCRBYFLOAT age 5.2 “20.2” STRLEN key 获取key保存值的字符串长度 127.0.0.1:6379\u003e get msg “hello world” 127.0.0.1:6379\u003e STRLEN msg (integer) 11 GETRANGE key start end 按起止位置获取字符串（闭区间，起止位置都取） 127.0.0.1:6379\u003e get msg “hello world” 127.0.0.1:6379\u003e GETRANGE msg 3 9 “lo worl” SETRANGE key offset value 用指定的value 替换key中 offset开始的值 127.0.0.1:6379\u003e SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379\u003e get msg “tehello” GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 127.0.0.1:6379\u003e GETSET msg test “hello world” SETNX key value 仅当key不存在时进行set 127.0.0.1:6379\u003e SETNX msg test (integer) 0 127.0.0.1:6379\u003e SETNX name sakura (integer) 1 SETEX key seconds value set 键值对并设置过期时间 127.0.0.1:6379\u003e setex name 10 root OK 127.0.0.1:6379\u003e get name (nil) MSET key1 value1 [key2 value2..] 批量set键值对 127.0.0.1:6379\u003e MSET k1 v1 k2 v2 k3 v3 OK MSETNX key1 value1 [key2 value2..] 批量设置键值对，仅当参数中所有的key都不存在时执行 127.0.0.1:6379\u003e MSETNX k1 v1 k4 v4 (integer) 0 MGET key1 [key2..] 批量获取多个key保存的值 127.0.0.1:6379\u003e MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3” PSETEX key milliseconds value 和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间， getset key value 如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值 String类似的使用场景：value除了是字符串还可以是数字，用途举例： 计数器 统计多单位的数量：uid:123666：follow 0 粉丝数 对象存储缓存 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"List(列表) Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等 正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN 命令 描述 LPUSH/RPUSH key value1[value2..] 从左边/右边向列表中PUSH值(一个或者多个)。 LRANGE key start end 获取list 起止元素==（索引从左往右 递增）== LPUSHX/RPUSHX key value 向已存在的列名中push值（一个或者多个） `LINSERT key BEFORE AFTER pivot value` LLEN key 查看列表长度 LINDEX key index 通过索引获取列表元素 LSET key index value 通过索引为元素设值 LPOP/RPOP key 从最左边/最右边移除值 并返回 RPOPLPUSH source destination 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部 LTRIM key start end 通过下标截取指定范围内的列表 LREM key count value List中是允许value重复的 count \u003e 0：从头部开始搜索 然后删除指定的value 至多删除count个 count \u003c 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。 BLPOP/BRPOP key1[key2] timout 移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOPLPUSH source destination timeout 和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 ---------------------------LPUSH---RPUSH---LRANGE-------------------------------- 127.0.0.1:6379\u003e LPUSH mylist k1 # LPUSH mylist=\u003e{1} (integer) 1 127.0.0.1:6379\u003e LPUSH mylist k2 # LPUSH mylist=\u003e{2,1} (integer) 2 127.0.0.1:6379\u003e RPUSH mylist k3 # RPUSH mylist=\u003e{2,1,3} (integer) 3 127.0.0.1:6379\u003e get mylist # 普通的get是无法获取list值的 (error) WRONGTYPE Operation against a key holding the wrong kind of value 127.0.0.1:6379\u003e LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素 1) \"k2\" 2) \"k1\" 3) \"k3\" 127.0.0.1:6379\u003e LRANGE mylist 0 2 1) \"k2\" 2) \"k1\" 3) \"k3\" 127.0.0.1:6379\u003e LRANGE mylist 0 1 1) \"k2\" 2) \"k1\" 127.0.0.1:6379\u003e LRANGE mylist 0 -1 # 获取全部元素 1) \"k2\" 2) \"k1\" 3) \"k3\" ---------------------------LPUSHX---RPUSHX----------------------------------- 127.0.0.1:6379\u003e LPUSHX list v1 # list不存在 LPUSHX失败 (integer) 0 127.0.0.1:6379\u003e LPUSHX list v1 v2 (integer) 0 127.0.0.1:6379\u003e LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5 (integer) 5 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"k1\" 5) \"k3\" ---------------------------LINSERT--LLEN--LINDEX--LSET---------------------------- 127.0.0.1:6379\u003e LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1 (integer) 6 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"ins_key1\" 5) \"k1\" 6) \"k3\" 127.0.0.1:6379\u003e LLEN mylist # 查看mylist的长度 (integer) 6 127.0.0.1:6379\u003e LINDEX mylist 3 # 获取下标为3的元素 \"ins_key1\" 127.0.0.1:6379\u003e LINDEX mylist 0 \"k5\" 127.0.0.1:6379\u003e LSET mylist 3 k6 # 将下标3的元素 set值为k6 OK 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"k6\" 5) \"k1\" 6) \"k3\" ---------------------------LPOP--RPOP-------------------------- 127.0.0.1:6379\u003e LPOP mylist # 左侧(头部)弹出 \"k5\" 127.0.0.1:6379\u003e RPOP mylist # 右侧(尾部)弹出 \"k3\" ---------------------------RPOPLPUSH-------------------------- 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" 3) \"k6\" 4) \"k1\" 127.0.0.1:6379\u003e RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部 \"k1\" 127.0.0.1:6379\u003e LRANGE newlist 0 -1 1) \"k1\" 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" 3) \"k6\" ---------------------------LTRIM-------------------------- 127.0.0.1:6379\u003e LTRIM mylist 0 1 # 截取mylist中的 0~1部分 OK 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" # 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2 ---------------------------LREM-------------------------- 127.0.0.1:6379\u003e LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2 (integer) 3 # 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2 127.0.0.1:6379\u003e LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2 (integer) 2 # 删除后：mylist: k2,k2,k2,k4,k2,k2 ---------------------------BLPOP--BRPOP-------------------------- mylist: k2,k2,k2,k4,k2,k2 newlist: k1 127.0.0.1:6379\u003e BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选 1) \"newlist\" # 弹出 2) \"k1\" 127.0.0.1:6379\u003e BLPOP newlist mylist 30 1) \"mylist\" # 由于newlist空了 从mylist中弹出 2) \"k2\" 127.0.0.1:6379\u003e BLPOP newlist 30 (30.10s) # 超时了 127.0.0.1:6379\u003e BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。 1) \"newlist\" 2) \"test\" (12.54s) 小结 list实际上是一个链表，before Node after , left, right 都可以插入值 如果key不存在，则创建新的链表 如果key存在，新增内容 如果移除了所有值，空链表，也代表不存在 在两边插入或者改动值，效率最高！修改中间元素，效率相对较低 应用： 消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop） ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Set(集合) Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 命令 描述 SADD key member1[member2..] 向集合中无序增加一个/多个成员 SCARD key 获取集合的成员数 SMEMBERS key 返回集合中所有的成员 SISMEMBER key member 查询member元素是否是集合的成员,结果是无序的 SRANDMEMBER key [count] 随机返回集合中count个成员，count缺省值为1 SPOP key [count] 随机移除并返回集合中count个成员，count缺省值为1 SMOVE source destination member 将source集合的成员member移动到destination集合 SREM key member1[member2..] 移除集合中一个/多个成员 SDIFF key1[key2..] 返回所有集合的差集 key1- key2 - … SDIFFSTORE destination key1[key2..] 在SDIFF的基础上，将结果保存到集合中==(覆盖)==。不能保存到其他类型key噢！ SINTER key1 [key2..] 返回所有集合的交集 SINTERSTORE destination key1[key2..] 在SINTER的基础上，存储结果到集合中。覆盖 SUNION key1 [key2..] 返回所有集合的并集 SUNIONSTORE destination key1 [key2..] 在SUNION的基础上，存储结果到及和张。覆盖 SSCAN KEY [MATCH pattern] [COUNT count] 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分 ---------------SADD--SCARD--SMEMBERS--SISMEMBER-------------------- 127.0.0.1:6379\u003e SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4 (integer) 4 127.0.0.1:6379\u003e SCARD myset # 获取集合的成员数目 (integer) 4 127.0.0.1:6379\u003e smembers myset # 获取集合中所有成员 1) \"m4\" 2) \"m3\" 3) \"m2\" 4) \"m1\" 127.0.0.1:6379\u003e SISMEMBER myset m5 # 查询m5是否是myset的成员 (integer) 0 # 不是，返回0 127.0.0.1:6379\u003e SISMEMBER myset m2 (integer) 1 # 是，返回1 127.0.0.1:6379\u003e SISMEMBER myset m3 (integer) 1 ---------------------SRANDMEMBER--SPOP---------------------------------- 127.0.0.1:6379\u003e SRANDMEMBER myset 3 # 随机返回3个成员 1) \"m2\" 2) \"m3\" 3) \"m4\" 127.0.0.1:6379\u003e SRANDMEMBER myset # 随机返回1个成员 \"m3\" 127.0.0.1:6379\u003e SPOP myset 2 # 随机移除并返回2个成员 1) \"m1\" 2) \"m4\" # 将set还原到{m1,m2,m3,m4} ---------------------SMOVE--SREM---------------------------------------- 127.0.0.1:6379\u003e SMOVE myset newset m3 # 将myset中m3成员移动到newset集合 (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset 1) \"m4\" 2) \"m2\" 3) \"m1\" 127.0.0.1:6379\u003e SMEMBERS newset 1) \"m3\" 127.0.0.1:6379\u003e SREM newset m3 # 从newset中移除m3元素 (integer) 1 127.0.0.1:6379\u003e SMEMBERS newset (empty list or set) # 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算 # setx=\u003e{m1,m2,m4,m6}, sety=\u003e{m2,m5,m6}, setz=\u003e{m1,m3,m6} -----------------------------SDIFF------------------------------------ 127.0.0.1:6379\u003e SDIFF setx sety setz # 等价于setx-sety-setz 1) \"m4\" 127.0.0.1:6379\u003e SDIFF setx sety # setx - sety 1) \"m4\" 2) \"m1\" 127.0.0.1:6379\u003e SDIFF sety setx # sety - setx 1) \"m5\" -------------------------SINTER--------------------------------------- # 共同关注（交集） 127.0.0.1:6379\u003e SINTER setx sety setz # 求 setx、sety、setx的交集 1) \"m6\" 127.0.0.1:6379\u003e SINTER setx sety # 求setx sety的交集 1) \"m2\" 2) \"m6\" -------------------------SUNION--------------------------------------- 127.0.0.1:6379\u003e SUNION setx sety setz # setx sety setz的并集 1) \"m4\" 2) \"m6\" 3) \"m3\" 4) \"m2\" 5) \"m1\" 6) \"m5\" 127.0.0.1:6379\u003e SUNION setx sety # setx sety 并集 1) \"m4\" 2) \"m6\" 3) \"m2\" 4) \"m1\" 5) \"m5\" ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Hash（哈希） Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。 Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。 命令 描述 HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0 HMSET key field1 value1 [field2 value2..] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 HGET key field value 获取存储在哈希表中指定字段的值 HMGET key field1 [field2..] 获取所有给定字段的值 HGETALL key 获取在哈希表key 的所有字段和值 HKEYS key 获取哈希表key中所有的字段 HLEN key 获取哈希表中字段的数量 HVALS key 获取哈希表中所有值 HDEL key field1 [field2..] 删除哈希表key中一个/多个field字段 HINCRBY key field n 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段 HINCRBYFLOAT key field n 为哈希表 key 中的指定字段的浮点数值加上增量 n。 HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。 ------------------------HSET--HMSET--HSETNX---------------- 127.0.0.1:6379\u003e HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura (integer) 1 127.0.0.1:6379\u003e HSET studentx name gyc # 重复设置field进行覆盖，并返回0 (integer) 0 127.0.0.1:6379\u003e HSET studentx age 20 # 设置studentx的age为20 (integer) 1 127.0.0.1:6379\u003e HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886 OK 127.0.0.1:6379\u003e HSETNX studentx name gyc # HSETNX 设置已存在的field (integer) 0 # 失败 127.0.0.1:6379\u003e HSETNX studentx email 12345@qq.com (integer) 1 # 成功 ----------------------HEXISTS-------------------------------- 127.0.0.1:6379\u003e HEXISTS studentx name # name字段在studentx中是否存在 (integer) 1 # 存在 127.0.0.1:6379\u003e HEXISTS studentx addr (integer) 0 # 不存在 -------------------HGET--HMGET--HGETALL----------- 127.0.0.1:6379\u003e HGET studentx name # 获取studentx中name字段的value \"gyc\" 127.0.0.1:6379\u003e HMGET studentx name age tel # 获取studentx中name、age、tel字段的value 1) \"gyc\" 2) \"20\" 3) \"15623667886\" 127.0.0.1:6379\u003e HGETALL studentx # 获取studentx中所有的field及其value 1) \"name\" 2) \"gyc\" 3) \"age\" 4) \"20\" 5) \"sex\" 6) \"1\" 7) \"tel\" 8) \"15623667886\" 9) \"email\" 10) \"12345@qq.com\" --------------------HKEYS--HLEN--HVALS-------------- 127.0.0.1:6379\u003e HKEYS studentx # 查看studentx中所有的field 1) \"name\" 2) \"age\" 3) \"sex\" 4) \"tel\" 5) \"email\" 127.0.0.1:6379\u003e HLEN studentx # 查看studentx中的字段数量 (integer) 5 127.0.0.1:6379\u003e HVALS studentx # 查看studentx中所有的value 1) \"gyc\" 2) \"20\" 3) \"1\" 4) \"15623667886\" 5) \"12345@qq.com\" -------------------------HDEL-------------------------- 127.0.0.1:6379\u003e HDEL studentx sex tel # 删除studentx 中的sex、tel字段 (integer) 2 127.0.0.1:6379\u003e HKEYS studentx 1) \"name\" 2) \"age\" 3) \"email\" -------------HINCRBY--HINCRBYFLOAT------------------------ 127.0.0.1:6379\u003e HINCRBY studentx age 1 # studentx的age字段数值+1 (integer) 21 127.0.0.1:6379\u003e HINCRBY studentx name 1 # 非整数字型字段不可用 (error) ERR hash value is not an integer 127.0.0.1:6379\u003e HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6 \"90.8\" Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Zset（有序集合） 不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。 score相同：按字典顺序排序 有序集合的成员是唯一的,但分数(score)却可以重复。 命令 描述 ZADD key score member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数 ZCARD key 获取有序集合的成员数 ZCOUNT key min max 计算在有序集合中指定区间score的成员数 ZINCRBY key n member 有序集合中对指定成员的分数加上增量 n ZSCORE key member 返回有序集中，成员的分数值 ZRANK key member 返回有序集合中指定成员的索引 ZRANGE key start end 通过索引区间返回有序集合成指定区间内的成员 ZRANGEBYLEX key min max 通过字典区间返回有序集合的成员 ZRANGEBYSCORE key min max 通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()== ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量 ZREM key member1 [member2..] 移除有序集合中一个/多个成员 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员 ZREVRANGE key start end 返回有序集中指定区间内的成员，通过索引，分数从高到底 ZREVRANGEBYSCORRE key max min 返回有序集中指定分数区间内的成员，分数从高到低排序 ZREVRANGEBYLEX key max min 返回有序集中指定字典区间内的成员，按字典顺序倒序 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 ZINTERSTORE destination numkeys key1 [key2 ..] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score ZUNIONSTORE destination numkeys key1 [key2..] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 ZSCAN key cursor [MATCH pattern\\] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值） -------------------ZADD--ZCARD--ZCOUNT-------------- 127.0.0.1:6379\u003e ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2.. (integer) 2 127.0.0.1:6379\u003e ZCARD myzset # 获取有序集合的成员数 (integer) 2 127.0.0.1:6379\u003e ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量 (integer) 1 127.0.0.1:6379\u003e ZCOUNT myzset 0 2 (integer) 2 ----------------ZINCRBY--ZSCORE-------------------------- 127.0.0.1:6379\u003e ZINCRBY myzset 5 m2 # 将成员m2的score +5 \"7\" 127.0.0.1:6379\u003e ZSCORE myzset m1 # 获取成员m1的score \"1\" 127.0.0.1:6379\u003e ZSCORE myzset m2 \"7\" --------------ZRANK--ZRANGE----------------------------------- 127.0.0.1:6379\u003e ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加 (integer) 0 127.0.0.1:6379\u003e ZRANK myzset m2 (integer) 2 127.0.0.1:6379\u003e ZRANGE myzset 0 1 # 获取索引在 0~1的成员 1) \"m1\" 2) \"m3\" 127.0.0.1:6379\u003e ZRANGE myzset 0 -1 # 获取全部成员 1) \"m1\" 2) \"m3\" 3) \"m2\" #testset=\u003e{abc,add,amaze,apple,back,java,redis} score均为0 ------------------ZRANGEBYLEX--------------------------------- 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + # 返回所有成员 1) \"abc\" 2) \"add\" 3) \"amaze\" 4) \"apple\" 5) \"back\" 6) \"java\" 7) \"redis\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录 1) \"abc\" 2) \"add\" 3) \"amaze\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录 1) \"apple\" 2) \"back\" 3) \"java\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员 1) \"abc\" 2) \"add\" 3) \"amaze\" 4) \"apple\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员 1) \"apple\" 2) \"back\" 3) \"java\" -----------------------ZRANGEBYSCORE--------------------- 127.0.0.1:6379\u003e ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员 1) \"m1\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e ZRANGEBYSCORE myzset 1 5 1) \"m1\" 2) \"m3\" --------------------ZLEXCOUNT----------------------------- 127.0.0.1:6379\u003e ZLEXCOUNT testset - + (integer) 7 127.0.0.1:6379\u003e ZLEXCOUNT testset [apple [java (integer) 3 ------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE-------------------------------- 127.0.0.1:6379\u003e ZREM testset abc # 移除成员abc (integer) 1 127.0.0.1:6379\u003e ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员 (integer) 3 127.0.0.1:6379\u003e ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员 (integer) 2 127.0.0.1:6379\u003e ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员 (integer) 2 # testset=\u003e {abc,add,apple,amaze,back,java,redis} score均为0 # myzset=\u003e {(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)} ----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX----------- 127.0.0.1:6379\u003e ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3 1) \"m9\" 2) \"m7\" 3) \"m4\" 4) \"m3\" 127.0.0.1:6379\u003e ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4 1) \"m4\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员 1) \"m4\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:3:6","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"四、三种特殊数据类型 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Geospatial(地理位置) 使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用 命令 描述 geoadd key longitud(经度) latitude(纬度) member [..] 将具体经纬度的坐标存入一个有序集合 geopos key member [member..] 获取集合中的一个/多个成员坐标 geodist key member1 member2 [unit] 返回两个给定位置之间的距离。默认以米作为单位。 `georadius key longitude latitude radius m km GEORADIUSBYMEMBER key member radius... 功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。 geohash key member1 [member2..] 返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。 有效经纬度 有效的经度从-180度到180度。 有效的纬度从-85.05112878度到85.05112878度。 指定单位的参数 unit 必须是以下单位的其中一个： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 关于GEORADIUS的参数 通过georadius就可以完成 附近的人功能 withcoord:带上坐标 withdist:带上距离，单位与半径单位相同 COUNT n : 只显示前n个(按距离递增排序) ----------------georadius--------------------- 127.0.0.1:6379\u003e GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员 1) 1) \"hangzhou\" 2) \"29.4151\" 3) 1) \"120.20000249147415\" 2) \"30.199999888333501\" 2) 1) \"shanghai\" 2) \"205.3611\" 3) 1) \"121.40000134706497\" 2) \"31.400000253193539\" ------------geohash--------------------------- 127.0.0.1:6379\u003e geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示 1) \"wmrjwbr5250\" 2) \"wtw6ds0y300\" ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Hyperloglog(基数统计) Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。 因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 其底层使用string数据类型 什么是基数？ 数据集中不重复的元素的个数。 应用场景： 网页的访问量（UV）：一个用户多次访问，也只能算作一个人。 传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。 命令 描述 PFADD key element1 [elememt2..] 添加指定元素到 HyperLogLog 中 PFCOUNT key [key] 返回给定 HyperLogLog 的基数估算值。 PFMERGE destkey sourcekey [sourcekey..] 将多个 HyperLogLog 合并为一个 HyperLogLog ----------PFADD--PFCOUNT--------------------- 127.0.0.1:6379\u003e PFADD myelemx a b c d e f g h i j k # 添加元素 (integer) 1 127.0.0.1:6379\u003e type myelemx # hyperloglog底层使用String string 127.0.0.1:6379\u003e PFCOUNT myelemx # 估算myelemx的基数 (integer) 11 127.0.0.1:6379\u003e PFADD myelemy i j k z m c b v p q s (integer) 1 127.0.0.1:6379\u003e PFCOUNT myelemy (integer) 11 ----------------PFMERGE----------------------- 127.0.0.1:6379\u003e PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemz OK 127.0.0.1:6379\u003e PFCOUNT myelemz # 估算基数 (integer) 17 如果允许容错，那么一定可以使用Hyperloglog ! 如果不允许容错，就使用set或者自己的数据类型即可 ！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"BitMaps(位图) 使用位存储，信息状态只有 0 和 1 Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。 应用场景 签到统计、状态统计 命令 描述 setbit key offset value 为指定key的offset位设置值 getbit key offset 获取offset位的值 bitcount key [start end] 统计字符串被设置为1的bit数，也可以指定统计范围按字节 bitop operration destkey key[key..] 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 BITPOS key bit [start] [end] 返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位 ------------setbit--getbit-------------- 127.0.0.1:6379\u003e setbit sign 0 1 # 设置sign的第0位为 1 (integer) 0 127.0.0.1:6379\u003e setbit sign 2 1 # 设置sign的第2位为 1 不设置默认 是0 (integer) 0 127.0.0.1:6379\u003e setbit sign 3 1 (integer) 0 127.0.0.1:6379\u003e setbit sign 5 1 (integer) 0 127.0.0.1:6379\u003e type sign string 127.0.0.1:6379\u003e getbit sign 2 # 获取第2位的数值 (integer) 1 127.0.0.1:6379\u003e getbit sign 3 (integer) 1 127.0.0.1:6379\u003e getbit sign 4 # 未设置默认是0 (integer) 0 -----------bitcount---------------------------- 127.0.0.1:6379\u003e BITCOUNT sign # 统计sign中为1的位数 (integer) 4 bitmaps的底层 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PlszjhS-1597890996519)(D:\\我\\MyBlog\\狂神说 Redis.assets\\image-20200803234336175.png)] 这样设置以后你能get到的值是：\\xA2\\x80，所以bitmaps是一串从左到右的二进制串 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:4:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"五、事务 Redis的单条命令是保证原子性的，但是redis事务不能保证原子性 Redis事务本质：一组命令的集合。 —————– 队列 set set set 执行 ——————- 事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。 一次性 顺序性 排他性 Redis事务没有隔离级别的概念 Redis单条命令是保证原子性的，但是事务不保证原子性！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"Redis事务操作过程 开启事务（multi） 命令入队 执行事务（exec） 所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。 127.0.0.1:6379\u003e multi # 开启事务 OK 127.0.0.1:6379\u003e set k1 v1 # 命令入队 QUEUED 127.0.0.1:6379\u003e set k2 v2 # .. QUEUED 127.0.0.1:6379\u003e get k1 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e keys * QUEUED 127.0.0.1:6379\u003e exec # 事务执行 1) OK 2) OK 3) \"v1\" 4) OK 5) 1) \"k3\" 2) \"k2\" 3) \"k1\" 取消事务(discurd) 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e DISCARD # 放弃事务 OK 127.0.0.1:6379\u003e EXEC (error) ERR EXEC without MULTI # 当前未开启事务 127.0.0.1:6379\u003e get k1 # 被放弃事务中命令并未执行 (nil) ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"事务错误 代码语法错误（编译时异常）所有的命令都不执行 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e error k1 # 这是一条语法错误命令 (error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e EXEC (error) EXECABORT Transaction discarded because of previous errors. # 执行报错 127.0.0.1:6379\u003e get k1 (nil) # 其他命令并没有被执行 代码逻辑错误 (运行时异常) **其他命令可以正常执行 ** »\u003e 所以不保证事务原子性 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e INCR k1 # 这条命令逻辑错误（对字符串进行增量） QUEUED 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e exec 1) OK 2) OK 3) (error) ERR value is not an integer or out of range # 运行时报错 4) \"v2\" # 其他命令正常执行 # 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。 # 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"监控 悲观锁： 很悲观，认为什么时候都会出现问题，无论做什么都会加锁 乐观锁： 很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据 获取version 更新的时候比较version 使用watch key监控指定数据，相当于乐观锁加锁。 正常执行 127.0.0.1:6379\u003e set money 100 # 设置余额:100 OK 127.0.0.1:6379\u003e set use 0 # 支出使用:0 OK 127.0.0.1:6379\u003e watch money # 监视money (上锁) OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY use 20 QUEUED 127.0.0.1:6379\u003e exec # 监视值没有被中途修改，事务正常执行 1) (integer) 80 2) (integer) 20 测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion） 我们启动另外一个客户端模拟插队线程。 线程1： 127.0.0.1:6379\u003e watch money # money上锁 OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY use 20 QUEUED 127.0.0.1:6379\u003e # 此时事务并没有执行 模拟线程插队，线程2： 127.0.0.1:6379\u003e INCRBY money 500 # 修改了线程一中监视的money (integer) 600 12 回到线程1，执行事务： 127.0.0.1:6379\u003e EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败 (nil) # 没有结果，说明事务执行失败 127.0.0.1:6379\u003e get money # 线程2 修改生效 \"600\" 127.0.0.1:6379\u003e get use # 线程1事务执行失败，数值没有被修改 \"0\" 解锁获取最新值，然后再加锁进行事务。 unwatch进行解锁。 注意：每次提交执行exec后都会自动释放锁，不管是否成功 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:5:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"六、Jedis 使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。 导入依赖 \u003c!--导入jredis的包--\u003e \u003cdependency\u003e \u003cgroupId\u003eredis.clients\u003c/groupId\u003e \u003cartifactId\u003ejedis\u003c/artifactId\u003e \u003cversion\u003e3.2.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--fastjson--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.70\u003c/version\u003e \u003c/dependency\u003e 编码测试 连接数据库 修改redis的配置文件 vim /usr/local/bin/myconfig/redis.conf 1 将只绑定本地注释 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4IRUFJ95-1597890996520)(狂神说 Redis.assets/image-20200813161921480.png)] 保护模式改为 no [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oKjIVapw-1597890996521)(狂神说 Redis.assets/image-20200813161939847.png)] 允许后台运行 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c2IMvpZL-1597890996522)(狂神说 Redis.assets/image-20200813161954567.png)] 开放端口6379 firewall-cmd --zone=public --add-port=6379/tcp --permanet 1 重启防火墙服务 systemctl restart firewalld.service 1 阿里云服务器控制台配置安全组 重启redis-server [root@AlibabaECS bin]# redis-server myconfig/redis.conf 1 操作命令 TestPing.java public class TestPing { public static void main(String[] args) { Jedis jedis = new Jedis(\"192.168.xx.xxx\", 6379); String response = jedis.ping(); System.out.println(response); // PONG } } 断开连接 事务 public class TestTX { public static void main(String[] args) { Jedis jedis = new Jedis(\"39.99.xxx.xx\", 6379); JSONObject jsonObject = new JSONObject(); jsonObject.put(\"hello\", \"world\"); jsonObject.put(\"name\", \"kuangshen\"); // 开启事务 Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); // jedis.watch(result) try { multi.set(\"user1\", result); multi.set(\"user2\", result); // 执行事务 multi.exec(); }catch (Exception e){ // 放弃事务 multi.discard(); } finally { // 关闭连接 System.out.println(jedis.get(\"user1\")); System.out.println(jedis.get(\"user2\")); jedis.close(); } } } ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:6:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"七、SpringBoot整合 导入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。 jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式 lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式 我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。 那么就一定还存在一个RedisProperties类 之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。 先看Jedis: @ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的 然后再看Lettuce： 完美生效。 现在我们回到RedisAutoConfiguratio 只有两个简单的Bean RedisTemplate StringRedisTemplate 当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。 在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的 说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties 这是一些基本的配置属性。 还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。 编写配置文件 # 配置redis spring.redis.host=39.99.xxx.xx spring.redis.port=6379 使用RedisTemplate @SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { // redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // opsForValue 操作字符串 类似String // opsForList 操作List 类似List // opsForHah // 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD // 获取连接对象 //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); //connection.flushDb(); //connection.flushAll(); redisTemplate.opsForValue().set(\"mykey\",\"kuangshen\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\")); } } 测试结果 此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出： 这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。 我们转到看那个默认的RedisTemplate内部什么样子： 在最开始就能看到几个关于序列化的参数。 默认的序列化器是采用JDK序列化器 而默认的RedisTemplate中的所有序列化器都是使用这个序列化器： 后续我们定制RedisTemplate就可以对其进行修改。 RedisSerializer提供了多种序列化方案： 直接调用RedisSerializer的静态方法来返回序列化器，然后set 自己new 相应的实现类，然后set 定制RedisTemplate的模板： 我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。 @Configuration public class RedisConfig { @Bean public RedisTemplate\u003cString, Object\u003e redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { // 将template 泛型设置为 \u003cString, Object\u003e RedisTemplate\u003cString, Object\u003e template = new RedisTemplate(); // 连接工厂，不必修改 template.setConnectionFactory(redisConnectionFactory); /* * 序列化设置 */ // key、hash的key 采用 String序列化方式 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // value、hash的value 采用 Jackson 序列化方式 template.setValueSerializer(RedisSerializer.json()); template.setHashValueSerializer(RedisSerializer.json()); template.afterPropertiesSet(); return template; } } 这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oc8kJP08-1597890996523)(狂神说 Redis.assets/image-20200817175638086.png)] ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:7:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"八、自定义Redis工具类 使用RedisTemplate需要频繁调用.opForxxx然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。 工具类参考博客： https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html https://www.cnblogs.com/zhzhlong/p/11434284.html ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:8:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"九、Redis.conf 容量单位不区分大小写，G和GB有区别 可以使用 include 组合多个配置问题 网络配置 日志输出级别 日志输出文件 持久化规则 由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中 持久化方式： RDB AOF RDB文件相关 主从复制 Security模块中进行密码设置 客户端连接相关 maxclients 10000 最大客户端数量 maxmemory \u003cbytes\u003e 最大内存限制 maxmemory-policy noeviction # 内存达到限制值的处理策略 redis 中的默认的过期策略是 volatile-lru 。 设置方式 config set maxmemory-policy volatile-lru 1 maxmemory-policy 六种方式 **1、volatile-lru：**只对设置了过期时间的key进行LRU（默认值） 2、allkeys-lru ： 删除lru算法的key **3、volatile-random：**随机删除即将过期key **4、allkeys-random：**随机删除 5、volatile-ttl ： 删除即将过期的 6、noeviction ： 永不过期，返回错误 AOF相关部分 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:9:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十、持久化—RDB RDB：Redis Databases [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-C0mm1D4A-1597890996524)(狂神说 Redis.assets/image-20200818122236614.png)] ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"什么是RDB 在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ； 默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"工作原理 在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作； Redis 调用forks。同时拥有父进程和子进程。 子进程将数据集写入到一个临时 RDB 文件中。 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。 这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。) ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"触发机制 save的规则满足的情况下，会自动触发rdb原则 执行flushall命令，也会触发我们的rdb原则 退出redis，也会自动产生rdb文件 save 使用 save 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了； 由于 save 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求。 flushall命令 flushall 命令也会触发持久化 ； 触发持久化规则 满足配置条件中的触发条件 ； 可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。 bgsave bgsave 是异步进行，进行持久化的时候，redis 还可以将继续响应客户端请求 ； bgsave和save对比 命令 save bgsave IO类型 同步 异步 阻塞？ 是 是（阻塞发生在fock()，通常非常快） 复杂度 O(n) O(n) 优点 不会消耗额外的内存 不阻塞客户端命令 缺点 阻塞客户端命令 需要fock子进程，消耗内存 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"优缺点 优点： 适合大规模的数据恢复 对数据的完整性要求不高 缺点： 需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。 fork进程的时候，会占用一定的内容空间。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:10:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十一、持久化AOF Append Only File 将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z8wr9lBW-1597890996525)(狂神说 Redis.assets/image-20200818123711375.png)] 以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:11:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"什么是AOF 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。 如果要使用AOF，需要修改配置文件： appendonly no yes则表示启用AOF 默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！ 如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件 redis给我们提供了一个工具redis-check-aof --fix 优点和缺点 appendonly yes # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用 appendfilename \"appendonly.aof\" # appendfsync always # 每次修改都会sync 消耗性能 appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据 # appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快 优点 每一次修改都会同步，文件的完整性会更加好 没秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点 相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！ Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:11:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十二、RDB和AOP选择 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:12:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"RDB 和 AOF 对比 RDB AOF 启动优先级 低 高 体积 小 大 恢复速度 快 慢 数据安全性 丢数据 根据策略决定 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:12:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"如何选择使用哪种持久化方式？ 一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。 有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:12:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十三、Redis发布与订阅 Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IBT2pjCa-1597890996526)(狂神说 Redis.assets/image-20200818162849693.png)] 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"命令 命令 描述 PSUBSCRIBE pattern [pattern..] 订阅一个或多个符合给定模式的频道。 PUNSUBSCRIBE pattern [pattern..] 退订一个或多个符合给定模式的频道。 PUBSUB subcommand [argument[argument]] 查看订阅与发布系统状态。 PUBLISH channel message 向指定频道发布消息 SUBSCRIBE channel [channel..] 订阅给定的一个或多个频道。 SUBSCRIBE channel [channel..] 退订一个或多个频道 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"示例 ------------订阅端---------------------- 127.0.0.1:6379\u003e SUBSCRIBE sakura # 订阅sakura频道 Reading messages... (press Ctrl-C to quit) # 等待接收消息 1) \"subscribe\" # 订阅成功的消息 2) \"sakura\" 3) (integer) 1 1) \"message\" # 接收到来自sakura频道的消息 \"hello world\" 2) \"sakura\" 3) \"hello world\" 1) \"message\" # 接收到来自sakura频道的消息 \"hello i am sakura\" 2) \"sakura\" 3) \"hello i am sakura\" --------------消息发布端------------------- 127.0.0.1:6379\u003e PUBLISH sakura \"hello world\" # 发布消息到sakura频道 (integer) 1 127.0.0.1:6379\u003e PUBLISH sakura \"hello i am sakura\" # 发布消息 (integer) 1 -----------------查看活跃的频道------------ 127.0.0.1:6379\u003e PUBSUB channels 1) \"sakura\" ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"原理 每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。 客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缺点 如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。 这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"应用 消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现） 多人在线聊天室。 稍微复杂的场景，我们就会使用消息中间件MQ处理。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:13:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十四、Redis主从复制 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。 默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。 故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式 负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。 高可用基石：主从复制还是哨兵和集群能够实施的基础。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"为什么使用集群 单台服务器难以负载大量的请求 单台服务器故障率高，系统崩坏概率大 单台服务器内存容量有限。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"环境配置 我们在讲解配置文件的时候，注意到有一个replication模块 (见Redis.conf中第8条) 查看当前库的信息：info replication 127.0.0.1:6379\u003e info replication # Replication role:master # 角色 connected_slaves:0 # 从机数量 master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息： 端口号 pid文件名 日志文件名 rdb文件名 启动单机多服务集群： ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:4","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"一主二从配置 ==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！ 认老大！一主（79）二从（80，81） 使用SLAVEOF host port就可以为从机配置主机了。 然后主机上也能看到从机的状态： 我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:5","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"使用规则 从机只能读，不能写，主机可读可写但是多用于写。 127.0.0.1:6381\u003e set name sakura # 从机6381写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6380\u003e set name sakura # 从机6380写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6379\u003e set name sakura OK 127.0.0.1:6379\u003e get name \"sakura\" 当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。 当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。 第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机： 从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机 使用哨兵模式（自动选举） 如果没有老大了，这个时候能不能选择出来一个老大呢？手动！ 如果主机断开了连接，我们可以使用SLAVEOF no one让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！ ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:14:6","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十五、哨兵模式 更多信息参考博客：https://www.jianshu.com/p/06ab9daf921d 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。 单机单个哨兵 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2ENYVAPp-1597890996527)(狂神说 Redis.assets/image-20200818233231154.png)] 哨兵的作用： 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。 多哨兵模式 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ga1RyfVc-1597890996528)(狂神说 Redis.assets/image-20200818233316478.png)] 哨兵的核心配置 sentinel monitor mymaster 127.0.0.1 6379 1 数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。 测试 redis-sentinel xxx/sentinel.conf 成功启动哨兵模式 此时哨兵监视着我们的主机6379，当我们断开主机后： 哨兵模式优缺点 优点： 哨兵集群，基于主从复制模式，所有主从复制的优点，它都有 主从可以切换，故障可以转移，系统的可用性更好 哨兵模式是主从模式的升级，手动到自动，更加健壮 缺点： Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦 实现哨兵模式的配置其实是很麻烦的，里面有很多配置项 哨兵模式的全部配置 完整的哨兵模式配置文件 sentinel.conf # Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379 port 26379 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\".-_\"组成。 # quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了 # sentinel monitor \u003cmaster-name\u003e \u003cip\u003e \u003credis-port\u003e \u003cquorum\u003e sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码 # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass \u003cmaster-name\u003e \u003cpassword\u003e sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 # sentinel down-after-milliseconds \u003cmaster-name\u003e \u003cmilliseconds\u003e sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs \u003cmaster-name\u003e \u003cnumslaves\u003e sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout \u003cmaster-name\u003e \u003cmilliseconds\u003e sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。 #对于脚本的运行结果有以下规则： #若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 #一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本， #这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数， #一个是事件的类型， #一个是事件的描述。 #如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。 #通知脚本 # sentinel notification-script \u003cmaster-name\u003e \u003cscript-path\u003e sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # \u003cmaster-name\u003e \u003crole\u003e \u003cstate\u003e \u003cfrom-ip\u003e \u003cfrom-port\u003e \u003cto-ip\u003e \u003cto-port\u003e # 目前\u003cstate\u003e总是“failover”, # \u003crole\u003e是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的 # 这个脚本应该是通用的，能被多次调用，不是针对性的。 # sentinel client-reconfig-script \u003cmaster-name\u003e \u003cscript-path\u003e sentinel client-reconfig-script mymaster /var/redis/reconfig.sh ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:15:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"十六、缓存穿透与雪崩 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:0","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缓存穿透（查不到） 概念 在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。 解决方案 布隆过滤器 对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。 缓存空对象 一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:1","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缓存击穿（量太大，缓存过期） 概念 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。 解决方案 设置热点数据永不过期 这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。 加互斥锁(分布式锁) 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:2","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"缓存雪崩 概念 大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。 解决方案 redis高可用 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群 限流降级 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 数据预热 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 ","date":"2021-04-06","objectID":"/redis%E7%AC%94%E8%AE%B0/:16:3","tags":["Redis"],"title":"Redis","uri":"/redis%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"Spring5 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:0:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.、Spring ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.1、简介 Spring ——\u003e 春天，为开源软件带来了春天 2002，首次推出了Spring框架的雏形：interface21框架！ Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版 Spring的理念：使用现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！ SSH：Struct2 + Spring + Hibernate（全自动持久化框架）！ SSM：SpringMVC + Spring + MyBatis（半自动持久化框架，可自定义性质更强）！ spring官网： https://spring.io/projects/spring-framework#overview 官方下载： https://repo.spring.io/release/org/springframework/spring/ GitHub： https://github.com/spring-projects/spring-framework Spring Web MVC： spring-webmvc最新版 Spring Web MVC和Spring-JDBC的pom配置文件： \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.2 优点 Spring是一个开源的免费的框架（容器）！ Spring是一个轻量级的、非入侵式的框架！ 控制反转（IoC），面向切面编程（AOP） 支持事务的处理，对框架整合的支持！（几乎市面上所有热门框架都能整合进去）！ === 总结一句话：Spring就是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的框架！ === ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.3 组成 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"1.4、扩展 现代化的java开发 -\u003e 基于Spring的开发！ Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速开发单个微服务 约定大于配置！ Spring Cloud SpringCloud是基于SpringBoot实现的！ 因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！ ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:4","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"2、IoC（控制反转）理论推导 传统的调用 UserDao package dao; public interface UserDao { void getUser(); } UserDaoImp package dao; public class UserDaoImpl implements UserDao{ public void getUser() { System.out.println(\"默认获取用户数据\"); } } UserSevice package Service; public interface UserService { void getUser(); } UserServiceImp package Service; import dao.UserDao; import dao.UserDaoImpl; public class UserServiceImpl implements UserService{ UserDao userDao = new UserDaoImpl(); public void getUser(){ userDao.getUser(); } } 测试 package holle0; import Service.UserService; import Service.UserServiceImpl; public class MyTest0 { public static void main(String[] args) { // 用户实际调用的是业务层，dao层他们不需要接触 UserService userService = new UserServiceImpl(); userService.getUser(); } } 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！ **改良：**我们使用一个Set接口实现。已经发生了革命性的变化！ //在Service层的实现类(UserServiceImpl)增加一个Set()方法 //利用set动态实现值的注入！ //DAO层并不写死固定调用哪一个UserDao的实现类 //而是通过Service层调用方法设置实现类！ private UserDao userDao; public void setUserDao(UserDao userDao){ this.userDao = userDao; } set() 方法实际上是动态改变了 UserDao userDao 的 初始化部分（new UserDaoImpl()） 测试中加上 ((UserServiceImpl)userService).setUserDao(new UserDaoImpl()); 之前，程序是主动创建对象！控制权在程序猿手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！（主动权在客户手上） 本质上解决了问题，程序员不用再去管理对象的创建 系统的耦合性大大降低，可以更专注在业务的实现上 这是IoC（控制反转）的原型，反转(理解)：主动权交给了用户 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:2:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"IoC本质 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:2:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"3、HolleSpring 在父模块中导入jar包 \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e pojo的Hello.java package pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \"Holle [str=\" + str + \"]\"; } } 在resource里面的xml配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--在Spring中创建对象，在Spring这些都称为bean 类型 变量名 = new 类型(); Holle holle = new Holle(); bean = 对象(holle) id = 变量名(holle) class = new的对象(new Holle();) property 相当于给对象中的属性设值,让str=\"Spring\" --\u003e \u003cbean id=\"hello\" class=\"pojo.Hello\"\u003e \u003cproperty name=\"str\" value=\"Spring\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 测试类MyTest package holle1; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Hello; public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //我们的对象下能在都在spring·中管理了，我们要使用，直接取出来就可以了 Hello holle = (Hello) context.getBean(\"hello\"); System.out.println(holle.toString()); } } 核心用set注入，所以必须要有下面的se()方法 //Hello类 public void setStr(String str) { this.str = str; } 思考： IoC：对象由Spring 来创建，管理，装配！ 弹幕评论里面的理解： 原来这套程序是：你写好菜单买好菜，客人来了自己把菜炒好招待，就相当于你请人吃饭 现在这套程序是：你告诉楼下餐厅，你要哪些菜，客人来的时候，餐厅把做好的你需要的菜送上来 IoC：炒菜这件事，不再由你自己来做，而是委托给了第三方__餐厅来做 此时的区别就是，如果我还需要做其他的菜，我不需要自己搞菜谱买材料再做好，而是告诉餐厅，我要什么菜，什么时候要，你做好送来 . 在前面第一个module试试引入Spring \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"userDaomSql\" class=\"dao.UserDaoMysqlImpl\"\u003e\u003c/bean\u003e \u003cbean id=\"userServiceImpl\" class=\"service.UserServiceImp\"\u003e \u003c!--ref引用spring中已经创建很好的对象--\u003e \u003c!--value是一个具体的值,基本数据类型--\u003e \u003cproperty name=\"userDao\" ref=\"userDaomSql\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 第一个module改良后测试 package holle0; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import service.UserServiceImpl; public class MyTest0 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean(\"userServiceImpl\"); userServiceImpl.getUser(); } } 总结： 所有的类都要装配的beans.xml 里面； 所有的bean 都要通过容器去取； 容器里面取得的bean，拿出来就是一个对象，用对象调用方法即可； ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:3:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"4、IoC创建对象的方式 使用无参构造创建对象，默认。 使用有参构造（如下） 下标赋值 index指的是有参构造中参数的下标，下标从0开始; \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"chen\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 类型赋值（不建议使用） \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg type=\"java.lang.String\" value=\"kuang\"/\u003e \u003c/bean\u003e 直接通过参数名（掌握） \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"kuang\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003c!-- 比如参数名是name，则有name=\"具体值\" --\u003e 注册bean之后就对象的初始化了（类似 new 类名()） 弹幕评论： name方式还需要无参构造和set方法,index和type只需要有参构造 就算是new 两个对象，也是只有一个实例（单例模式：全局唯一） User user = (User) context.getBean(\"user\"); User user2 = (User) context.getBean(\"user\"); system.out.println(user == user2)//结果为true 总结：在配置文件加载的时候，容器(\u003c bean\u003e)中管理的对象就已经初始化了 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:4:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5、Spring配置 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5.1、别名 \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"chen\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003calias name=\"user\" alias=\"userLove\"/\u003e \u003c!-- 使用时 User user2 = (User) context.getBean(\"userLove\"); --\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5.2、Bean的配置 \u003c!--id：bean的唯一标识符，也就是相当于我们学的对象名 class：bean对象所对应的会限定名：包名+类型 name：也是别名，而且name可以同时取多个别名 --\u003e \u003cbean id=\"user\" class=\"pojo.User\" name=\"u1 u2,u3;u4\"\u003e \u003cproperty name=\"name\" value=\"chen\"/\u003e \u003c/bean\u003e \u003c!-- 使用时 User user2 = (User) context.getBean(\"u1\"); --\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"5.3、import import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个 假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利 用import将所有人的beans.xml合并为一个总的！ 张三(beans.xm1) 李四(beans2.xm1) 王五(beans3.xm1) applicationContext.xml \u003cimport resource=\"beans.xm1\"/\u003e \u003cimport resource=\"beans2.xml\"/\u003e \u003cimport resource=\"beans3.xm1\"/\u003e 使用的时候，直接使用总的配置就可以了 弹幕评论： 按照在总的xml中的导入顺序来进行创建，后导入的会重写先导入的，最终实例化的对象会是后导入xml中的那个 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:5:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6、依赖注入（DI） ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.1、构造器注入 第4点有提到 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.2、set方式注入【重点】 依赖注入：set注入！ 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 【环境搭建】 复杂类型 Address类 真实测试对象 Student类 beans.xml 测试 MyTest3 Student类 package pojo; import java.util.*; @Get @Set public class Student { //别忘了写get和set方法（用lombok注解也行） private String name; private Address address; private String[] books; private List\u003cString\u003e hobbies; private Map\u003cString, String\u003e card; private Set\u003cString\u003e game; private Properties infor; private String wife; @Override public String toString() { return \"Student{\" +\"\\n\"+ \"name='\" + name + '\\'' +\"\\n\"+ \", address=\" + address.toString() +\"\\n\"+ \", books=\" + Arrays.toString(books) +\"\\n\"+ \", hobbies=\" + hobbies +\"\\n\"+ \", card=\" + card +\"\\n\"+ \", game=\" + game +\"\\n\"+ \", infor=\" + infor +\"\\n\"+ \", wife='\" + wife + '\\'' +\"\\n\"+ '}'; } } Address类 package pojo; public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"Address{\" + \"address='\" + address + '\\'' + '}'; } } beans.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"address\" class=\"pojo.Address\"\u003e \u003cproperty name=\"address\" value=\"address你好\" /\u003e \u003c/bean\u003e \u003cbean id=\"student\" class=\"pojo.Student\"\u003e \u003c!--第一种，普通值注入 --\u003e \u003cproperty name=\"name\" value=\"name你好\" /\u003e \u003c!--第二种，ref注入 --\u003e \u003cproperty name=\"address\" ref=\"address\" /\u003e \u003c!--数组注入 --\u003e \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e三国\u003c/value\u003e \u003cvalue\u003e西游\u003c/value\u003e \u003cvalue\u003e水浒\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c!--list列表注入 --\u003e \u003cproperty name=\"hobbies\"\u003e \u003clist\u003e \u003cvalue\u003e唱\u003c/value\u003e \u003cvalue\u003e跳\u003c/value\u003e \u003cvalue\u003erap\u003c/value\u003e \u003cvalue\u003e篮球\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!--map键值对注入 --\u003e \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"username\" value=\"root\" /\u003e \u003centry key=\"password\" value=\"root\" /\u003e \u003c/map\u003e \u003c/property\u003e \u003c!--set(可去重)注入 --\u003e \u003cproperty name=\"game\"\u003e \u003cset\u003e \u003cvalue\u003ewangzhe\u003c/value\u003e \u003cvalue\u003elol\u003c/value\u003e \u003cvalue\u003egalname\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003c!--空指针null注入 --\u003e \u003cproperty name=\"wife\"\u003e \u003cnull\u003e\u003c/null\u003e \u003c/property\u003e \u003c!--properties常量注入 --\u003e \u003cproperty name=\"infor\"\u003e \u003cprops\u003e \u003cprop key=\"id\"\u003e20200802\u003c/prop\u003e \u003cprop key=\"name\"\u003ecbh\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e MyTest3 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Student; public class MyTest3 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student stu = (Student) context.getBean(\"student\"); System.out.println(stu.toString()); } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.3、拓展注入 官方文档位置 pojo增加User类 package pojo; public class User { private String name; private int id; public User() { } public User(String name, int id) { super(); this.name = name; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return \"User [name=\" + name + \", id=\" + id + \"]\"; } } 注意： beans 里面加上这下面两行 使用p和c命名空间需要导入xml约束 xmlns:p=“http://www.springframework.org/schema/p” xmlns:c=“http://www.springframework.org/schema/c” ?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--p命名空间注入/set注入，可以直接注入属性的值-》property--\u003e \u003cbean id=\"user\" class=\"pojo.User\" p:name=\"cxk\" p:id=\"20\" \u003e \u003c/bean\u003e \u003c!--c命名空间，通过构造器注入，需要写入有参和无参构造方法-》construct-args--\u003e \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cbh\" c:id=\"22\"\u003e\u003c/bean\u003e \u003c/beans\u003e 测试 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = context.getBean(\"user\",User.class);//确定class对象，就不用再强转了 System.out.println(user.toString()); ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"6.4、Bean作用域 单例模式（默认） \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"singleton\"\u003e\u003c/bean\u003e 1 弹幕评论：单例模式是把对象放在pool中，需要再取出来，使用的都是同一个对象实例 原型模式: 每次从容器中get的时候，都产生一个新对象！ \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"prototype\"\u003e\u003c/bean\u003e 1 其余的request、session、application这些只能在web开放中使用！ ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:6:4","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"7、Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文自动寻找，并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显示配置 在java中显示配置 隐式的自动装配bean 【重要】 环境搭建：一个人有两个宠物 byType自动装配：byType会自动查找，和自己对象set方法参数的类型相同的bean 保证所有的class唯一(类为全局唯一) byName自动装配：byName会自动查找，和自己对象set对应的值对应的id 保证所有id唯一，并且和set注入的值一致 \u003c!-- 找不到id和多个相同class --\u003e \u003cbean id=\"cat1\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"cat2\" class=\"pojo.Cat\"/\u003e \u003c!-- 找不到 id=cat，且有两个Cat --\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:7:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"7.1测试：自动装配 pojo的Cat类 public class Cat { public void shut(){ System.out.println(\"miao\"); } } pojo的Dog类 public class Dog { public void shut(){ System.out.println(\"wow\"); } } pojo的People类 package pojo; public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"People{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } } xml配置 -\u003e byType 自动装配 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"cat\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"pojo.Dog\"/\u003e \u003c!--byType会在容器自动查找，和自己对象属性相同的bean 例如，Dog dog; 那么就会查找pojo的Dog类，再进行自动装配 --\u003e \u003cbean id=\"people\" class=\"pojo.People\" autowire=\"byType\"\u003e \u003cproperty name=\"name\" value=\"cbh\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e xml配置 -\u003e byName 自动装配 \u003cbean id=\"cat\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"pojo.Dog\"/\u003e \u003c!--byname会在容器自动查找，和自己对象set方法的set后面的值对应的id 例如:setDog()，取set后面的字符作为id，则要id = dog 才可以进行自动装配 --\u003e \u003cbean id=\"people\" class=\"pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"cbh\"\u003e\u003c/property\u003e \u003c/bean\u003e 弹幕评论：byName只能取到小写，大写取不到 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:7:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"7.2、使用注解实现自动装配 jdk1.5支持的注解，spring2.5支持的注解 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.（翻译：基于注释的配置的引入提出了一个问题，即这种方法是否比XML“更好”） 导入context约束 xmlns:context=“http://www.springframework.org/schema/context\" 配置注解的支持：\u003c context:annotation-config/\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e 7.2.1、@Autowired 默认是byType方式，如果匹配不上，就会byName 在属性上个使用，也可以在set上使用 我们可以不用编写set方法了，前提是自动装配的属性在Spring容器里，且要符合ByName 自动装配 public class People { @Autowired private Cat cat; @Autowired private Dog dog; private String name; } @Nullable 字段标记了这个注解，说明该字段可以为空 public name(@Nullable String name){ } //源码 public @interface Autowired { boolean required() default true; } 如果定义了Autowire的require属性为false，说明这个对象可以为null，否则不允许为空（false表示找不到装配，不抛出异常） 7.2.2、@Autowired+@Qualifier @Autowired不能唯一装配时，需要@Autowired+@Qualifier 如果@Autowired自动装配环境比较复杂。自动装配无法通过一个注解完成的时候，可以使用@Qualifier(value = “dog”)去配合使用，指定一个唯一的id对象 public class People { @Autowired private Cat cat; @Autowired @Qualifier(value = \"dog\") private Dog dog; private String name; } 弹幕评论： 如果xml文件中同一个对象被多个bean使用，Autowired无法按类型找到，可以用@Qualifier指定id查找 7.2.3、@Resource 默认是byName方式，如果匹配不上，就会byType public class People { Resource(name=\"cat\") private Cat cat; Resource(name=\"dog\") private Dog dog; private String name; } 弹幕评论： Autowired是byType，@Autowired+@Qualifier = byType || byName Autowired是先byteType,如果唯一則注入，否则byName查找。resource是先byname,不符合再继续byType 区别： @Resource和@Autowired的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】 @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】 执行顺序不同：@Autowired通过byType的方式实现。@Resource默认通过byname的方式实现 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:7:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8、使用注解开发 在spring4之后，使用注解开发，必须要保证aop包的导入 使用注解需要导入contex的约束 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.1、bean 弹幕评论： 有了\u003c context:component-scan\u003e，另一个\u003c context:annotation-config/\u003e标签可以移除掉，因为已经被包含进去了。 \u003c!--指定要扫描的包，这个包下面的注解才会生效 别只扫一个com.kuang.pojo包--\u003e \u003ccontext:component-scan base-package=\"com.kuang\"/\u003e \u003ccontext:annotation-config/\u003e //@Component 组件 //等价于\u003cbean id=\"user\" classs\"pojo.User\"/\u003e @Component public class User { public String name =\"秦疆\"; } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.2、属性如何注入@value @Component public class User { //相当于\u003cproperty name=\"name\" value=\"kuangshen\"/\u003e @value(\"kuangshen\") public String name; //也可以放在set方法上面 //@value(\"kuangshen\") public void setName(String name) { this.name = name; } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.3、衍生的注解 @Component有几个衍生注解，会按照web开发中，mvc架构中分层。 dao （@Repository） service（@Service） controller（@Controller） 这四个注解的功能是一样的，都是代表将某个类注册到容器中 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.4、自动装配置 @Autowired：默认是byType方式，如果匹配不上，就会byName @Nullable：字段标记了这个注解，说明该字段可以为空 @Resource：默认是byName方式，如果匹配不上，就会byType ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:4","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.5、作用域@scope //原型模式prototype，单例模式singleton //scope(\"prototype\")相当于\u003cbean scope=\"prototype\"\u003e\u003c/bean\u003e @Component @scope(\"prototype\") public class User { //相当于\u003cproperty name=\"name\" value=\"kuangshen\"/\u003e @value(\"kuangshen\") public String name; //也可以放在set方法上面 @value(\"kuangshen\") public void setName(String name) { this.name = name; } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:5","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"8.6、小结 xml与注解： xml更加万能，维护简单，适用于任何场合 注解，不是自己的类使用不了，维护复杂 最佳实践： xml用来管理bean 注解只用来完成属性的注入 要开启注解支持 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:8:6","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"9、使用Java的方式配置Spring 不使用Spring的xml配置，完全交给java来做！ Spring的一个子项目，在spring4之后，，，它成为了核心功能 实体类：pojo的User.java //这里这个注解的意思,就是说明这个类被Spring接管了,注册到了容器中 @component public class User { private String name; public String getName() { return name; } //属性注入值 @value(\"QINJIANG') public void setName(String name) { this.name = name; } @Override public String toString() { return \"user{\" + \"name='\" + name + '\\''+ '}'; } } 弹幕评论：要么使用@Bean，要么使用@Component和ComponentScan，两种效果一样 配置文件：config中的kuang.java @Import(KuangConfig2.class)，用@import来包含KuangConfig2.java //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于\u003cbeans\u003e标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -\u003egetUser //这个方法的返同值,就相当于bean 标签中的class 属性 -\u003eUser //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 public class MyTest { public static void main(String[ ] args) { //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); } } 会创建两个相同对象问题的说明： 弹幕总结 - -\u003e @Bean是相当于\u003c bean\u003e标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于\u003cbeans\u003e标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -\u003egetUser //这个方法的返同值,就相当于bean 标签中的class 属性 -\u003eUser //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 public class MyTest { public static void main(String[ ] args) { //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); } } 会创建两个相同对象问题的说明： 弹幕总结 - -\u003e @Bean是相当于\u003c bean\u003e标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:9:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"10、动态代理 代理模式是SpringAOP的底层 分类：动态代理和静态代理 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:10:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"10.1、静态代理 代码步骤： 1、接口 package pojo; public interface Host { public void rent(); } 2、真实角色 package pojo; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要出租房子\"); } } 3、代理角色 package pojo; public class Proxy { public Host host; public Proxy() { } public Proxy(Host host) { super(); this.host = host; } public void rent() { seeHouse(); host.rent(); fee(); sign(); } //看房 public void seeHouse() { System.out.println(\"看房子\"); } //收费 public void fee() { System.out.println(\"收中介费\"); } //合同 public void sign() { System.out.println(\"签合同\"); } } 4、客户端访问代理角色 package holle4_proxy; import pojo.Host; import pojo.HostMaster; import pojo.Proxy; public class My { public static void main(String[] args) { //房东要出租房子 Host host = new HostMaster(); //中介帮房东出租房子，但也收取一定费用（增加一些房东不做的操作） Proxy proxy = new Proxy(host); //看不到房东，但通过代理，还是租到了房子 proxy.rent(); } } 代码翻倍：几十个真实角色就得写几十个代理 AOP横向开发 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:10:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"10.2、动态代理 动态代理和静态角色一样，动态代理底层是反射机制 动态代理类是动态生成的，不是我们直接写好的！ 动态代理(两大类)：基于接口，基于类 基于接口：JDK的动态代理【使用ing】 基于类：cglib java字节码实现：javasisit 了解两个类 1、Proxy：代理 2、InvocationHandler：调用处理程序 实例： 接口 Host.java //接口 package pojo2; public interface Host { public void rent(); } 接口Host实现类 HostMaster.java //接口实现类 package pojo2; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要租房子\"); } } 代理角色的处理程序类 ProxyInvocationHandler.java package pojo2; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; ///用这个类，自动生成代理 public class ProxyInvocationHandler implements InvocationHandler { // Foo f =(Foo) Proxy.NewProxyInstance(Foo. Class.GetClassLoader(), // new Class\u003c?\u003e[] { Foo.Class }, // handler); // 被代理的接口 public HostMaster hostMaster ; public void setHostMaster(HostMaster hostMaster) { this.hostMaster = hostMaster; } // 得到生成的代理类 public Object getProxy() { // newProxyInstance() -\u003e 生成代理对象，就不用再写具体的代理类了 // this.getClass().getClassLoader() -\u003e 找到加载类的位置 // hostMaster.getClass().getInterfaces() -\u003e 代理的具体接口 // this -\u003e 代表了接口InvocationHandler的实现类ProxyInvocationHandler return Proxy.newProxyInstance(this.getClass().getClassLoader(), hostMaster.getClass().getInterfaces(), this); // 处理代理实例并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(hostMaster, args); fee(); return result; } public void seeHouse() { System.out.println(\"看房子\"); } public void fee() { System.out.println(\"收中介费\"); } } 用户类 My2.java package holle4_proxy; import pojo2.Host; import pojo2.Host2; import pojo2.HostMaster; import pojo2.ProxyInvocationHandler; public class My2 { public static void main(String[] args) { //真实角色 HostMaster hostMaster = new HostMaster(); //代理角色，现在没有；用代理角色的处理程序来实现Host接口的调用 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //pih -\u003e HostMaster接口类 -\u003e Host接口 pih.setHostMaster(hostMaster); //获取newProxyInstance动态生成代理类 Host proxy = (Host) pih.getProxy(); proxy.rent(); } } 弹幕评论： 什么时候调用invoke方法的? 代理实例调用方法时invoke方法就会被调用，可以debug试试 改为万能代理类 ///用这个类，自动生代理 public class ProxyInvocationHandler implements InvocationHandler { // 被代理的接口 public Object target; public void setTarget(Object target) { this.target = target; } // 得到生成的代理类 -\u003e 固定的代码 public Object getProxy() { return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } // 处理代理实例并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(target, args); return result; } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:10:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11、AOP ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11.1、什么是AOP ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11.2、AOP在Spring中的使用 提供声明式事务，允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等… 切面(Aspect)：横切关注点 被模块化的特殊对象。即，它是一个类。（Log类） 通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法。（Log类中的方法） 目标(Target)：被通知对象。（生成的代理类) 代理(Proxy)：向目标对象应用通知之后创建的对象。（生成的代理类） 切入点(PointCut)：切面通知执行的”地点”的定义。（最后两点：在哪个地方执行，比如：method.invoke()） 连接点(JointPoint)：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即AOP在不改变原有代码的情况下，去增加新的功能。（代理） ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"11.3、使用Spring实现AOP 导入jar包 \u003c!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e 11.3.1、方法一：使用原生spring接口 springAPI接口实现 applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--注册bean--\u003e \u003cbean id=\"userservice\" class=\"service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"log.AfterLog\"/\u003e \u003c!--方式一，使用原生Spring API接口--\u003e \u003c!--配置aop,还需要导入aop约束--\u003e \u003caop:config\u003e \u003c!--切入点：expression:表达式，execution（要执行的位置）--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* service.UserServiceImpl.*(..))\"/\u003e \u003c!--UserServiceImpl.*(..) -》 UserServiceImpl类下的所以方法(参数)--\u003e \u003c!--执行环绕增加--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/\u003e \u003c!-- 环绕,在id=\"pointcut\"的前后切入 --\u003e \u003c/aop:config\u003e \u003c/beans\u003e execution(返回类型，类名，方法名(参数)) -\u003e execution(* com.service.*,*(…)) UserService.java package service; public interface UserService { public void add() ; public void delete() ; public void query() ; public void update(); } UserService 的实现类 UserServiceImp.java package service; public class UserServiceImpl implements UserService { public void add() { System.out.println(\"add增\"); } public void delete() { System.out.println(\"delete删\"); } public void update() { System.out.println(\"update改\"); } public void query() { System.out.println(\"query查\"); } } 前置Log.java package log; import org.springframework.aop.MethodBeforeAdvice; import java.lang.reflect.Method; public class Log implements MethodBeforeAdvice { //method：要执行的目标对象的方法 //args：参数 //target：目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); } } 后置AfterLog.java package log; import java.lang.reflect.Method; import org.springframework.aop.AfterReturningAdvice; public class AfterLog implements AfterReturningAdvice { //returnVaule: 返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"方法，返回值是\"+returnValue); } } 测试类MyTest5 import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import service.UserService; public class MyTest5 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //注意:动态代理代理的是接口 UserService userService = (UserService) context.getBean(\"userservice\"); userService.add(); } } 11.3.2、方法二：自定义类实现AOP \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--注册bean--\u003e \u003cbean id=\"userservice\" class=\"service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"log.AfterLog\"/\u003e \u003c!-- 方式二，自定义 --\u003e \u003cbean id=\"diy\" class=\"diy.DiyPointcut\"/\u003e \u003caop:config\u003e \u003c!--自定义切面--\u003e \u003caop:aspect ref=\"diy\"\u003e \u003c!--切入点--\u003e \u003caop:pointcut id=\"point\" expression=\"execution(* service.UserServiceImpl.*(..))\"/\u003e \u003caop:before method=\"before\" pointcut-ref=\"point\"/\u003e \u003caop:after method=\"after\" pointcut-ref=\"point\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e \u003c/beans\u003e package diy; public class DiyPointcut { public","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:11:3","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"12、整合mybatis mybatis-spring官网：https://mybatis.org/spring/zh/ mybatis的配置流程： 编写实体类 编写核心配置文件 编写接口 编写Mapper.xmi 测试 ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:12:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"12.1、mybatis-spring-方式一 编写数据源配置 sqISessionFactory sqISessionTemplate（相当于sqISession） 需要给接口加实现类【new】 将自己写的实现类，注入到Spring中 测试！ 先导入jar包 \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--在build中配置resources，来防止资源导出失败的问题--\u003e \u003c!-- Maven解决静态资源过滤问题 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 编写顺序： User -\u003e UserMapper -\u003e UserMapper.xml -\u003e spring-dao.xml -\u003e UserServiceImpl -\u003e applicationContext.xml -\u003e MyTest6 代码步骤： pojo实体类 User package pojo; import lombok.Data; @Data public class User { private int id; private String name; private String pwd; } mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper package mapper; import java.util.List; import pojo.User; public interface UserMapper { public List\u003cUser\u003e getUser(); } UserMapperImpl package mapper; import java.util.List; import org.mybatis.spring.SqlSessionTemplate; import pojo.User; public class UserMapperImpl implements UserMapper{ //我们的所有操作，在原来都使用sqlSession来执行，现在都使用SqlSessionTemplate； private SqlSessionTemplate sqlSessionTemplate; public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) { this.sqlSessionTemplate = sqlSessionTemplate; } public List\u003cUser\u003e getUser() { UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class); return mapper.getUser(); } } UserMapper.xml （狂神给面子才留下来的） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- 绑定接口 --\u003e \u003cmapper namespace=\"mapper.UserMapper\"\u003e \u003cselect id=\"getUser\" resultType=\"pojo.User\"\u003e select * from mybatis.mybatis \u003c/select\u003e \u003c/mapper\u003e resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003c!--开启日志--\u003e \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\" /\u003e \u003c/settings\u003e \u003c!--可以给实体类起别名 --\u003e \u003ctypeAliases\u003e \u003cpackage name=\"pojo\" /\u003e \u003c/typeAliases\u003e \u003c/configuration\u003e spring-dao.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --\u003e \u003c!--data source --\u003e \u003cbean id=\"datasource\" class=\"org.spr","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:12:1","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"12.2、mybatis-spring-方式二 UserServiceImpl2 package mapper; import pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; //继承SqlSessionDaoSupport 类 public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper { public List\u003cUser\u003e getUser() { SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者一句话：return getSqlSession().getMapper(UserMapper.class).getUser(); } } spring-dao.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--DataSource:使用Spring的数帮源替换Mybatis的配置 c3p0 dbcp druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --\u003e \u003c!--data source --\u003e \u003cbean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=Asia/Shanghai\"/\u003e \u003cproperty name=\"username\" value=\"root\" /\u003e \u003cproperty name=\"password\" value=\"root\" /\u003e \u003c/bean\u003e \u003c!--sqlSessionFactory--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\" /\u003e \u003c!--绑定 mybatis 配置文件--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/\u003e \u003c/bean\u003e \u003c!-- 方法二：SqlSessionTemplate 可以不写了--\u003e \u003c/beans\u003e applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003cimport resource=\"spring-dao.xml\" /\u003e \u003c!-- 方法二 --\u003e \u003cbean id=\"userMapper2\" class=\"mapper.UserMapperImpl2\"\u003e \u003cproperty name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e 测试 public class MyTest6 { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = (UserMapper) context.getBean(\"userMapper2\"); for (User user : userMapper.getUser()) { System.out.println(user); } } } ","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:12:2","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["Java后端"],"content":"13. 声明式事务 把一组业务当成一个业务来做；要么都成功，要么都失败！ 事务在项目开发中，十分的重要，涉及到数据的一致性问题 确保完整性和一致性 事务的ACID原则： 1、原子性 2、隔离性 3、一致性 4、持久性 ACID参考文章：https://www.cnblogs.com/malaikuangren/archive/2012/04/06/2434760.html Spring中的事务管理 声明式事务：AOP 编程式事务：需要再代码中，进行事务管理 声明式事务 先导入jar包 \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--在build中配置resources，来防止资源导出失败的问题--\u003e \u003c!-- Maven解决静态资源过滤问题 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 代码步骤： pojo实体类 User package pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; private String pwd; } mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper package mapper; import java.util.List; import org.apache.ibatis.annotations.Param; import pojo.User; public interface UserMapper { public List\u003cUser\u003e getUser(); public int insertUser(User user); public int delUser(@Param(\"id\") int id); } UserMapperImpl package mapper; import pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper { public List\u003cUser\u003e getUser() { User user = new User(5,\"你好\",\"ok\"); insertUser(user); delUser(5); SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者return getSqlSession().getMapper(UserMapper.class).getUser(); } //插入 public int insertUser(User user) { return getSqlSession().getMapper(UserMapper.class).insertUser(user); } //删除 public int delUser(int id) { return getSqlSession().getMapper(UserMapper.class).delUser(id); } } UserMapper.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!-- 绑定接口 --\u003e \u003cmapper namespace=\"mapper.UserMapper\"\u003e \u003cselect id=\"getUser\" resultType=\"pojo.User\"\u003e select * from mybatis.mybatis \u003c/select\u003e \u003cinsert id=\"insertUser\" parameterType=\"pojo.User\" \u003e insert into mybatis.mybatis (id,name,pwd) values (#{id},#{name},#{pwd}) \u003c/insert\u003e \u003cdelete id=\"delUser\" parameterType=\"_int\"\u003e deleteAAAAA from mybatis.mybatis where id = #{id} \u003c!-- deleteAAAAA是故意写错的 --\u003e \u003c/delete\u003e \u003c/mapper\u003e resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003c!-- configuration --\u003e \u003cconfiguration\u003e \u003c!--开启日志--\u003e \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGIN","date":"2021-04-06","objectID":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:13:0","tags":["Spring"],"title":"Spring","uri":"/spring5%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于本站","uri":"/about/"},{"categories":null,"content":"许可协议 更多信息请查看 LICENSE 文件。 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于本站","uri":"/about/"}]