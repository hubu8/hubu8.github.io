[{"categories":["15"],"content":"docker概述 从开发到上线，两套环境，版本不同导致软件不可用，开发与运维有差距！部署配置环境费时费力 原：jar——-redis,mysql,jdk,项目能不能带上环境安装打包？跨平台，隔离， docker容器技术也是一种虚拟化技术 官网：https://www.docker.com/ 文档：https://docs.docker.com/ 仓库地址： https://hub.docker.com/ 镜像（image）:模板，通过这个模板来创建容器服务，可创建多个容器（最终服务或者项目运行在容器中） 容器（container）：一个或一组应用，可以启动，停止，删除，基本命令 仓库（repository）：存放镜像（公有私有），docker hub(默认) 阿里云（国内镜像加速） 安装 ","date":"2021-04-06","objectID":"/docker/:0:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"start 卸载旧版本 # 1、卸载旧版本 sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine # 2、 需要的安装包 sudo yum install -y yum-utils # 3、设置镜像仓库 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 可换国内 yum makecache fast # 4、安装相关的额 sudo yum install docker-ce docker-ce-cli containerd.io # 5、启动 sudo systemctl start docker docker version # 6、测试 sudo docker run hello-World 查看镜像 docker images 阿里云镜像加速 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://ax7mfl6a.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2021-04-06","objectID":"/docker/:1:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"hello-world流程 sudo docker run hello-World–\u003e本机寻找镜像–No–\u003e仓库地址下载—\u003e是否找到—\u003e下载镜像到本地—\u003e使用镜像创建容器运行 docker常用命令 ","date":"2021-04-06","objectID":"/docker/:2:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"帮助命令 docker version # 显示版本信息 docker info #系统信息，镜像、容器 docker 命令 --help ","date":"2021-04-06","objectID":"/docker/:3:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"镜像命令 docker images docker search mysql docker pull mysql docker pull mysql:5.7 #docker分层下载，节省空间 删除镜像docker rmi -f docker rmi -f 容器id docker rmi -f $(docker images -aq) #删除所有镜像 ","date":"2021-04-06","objectID":"/docker/:4:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"容器命令 拉取镜像 docker pull centos 创建容器并启动 docker run [可选参数] image # 参数设置 --name=\"name\" 容器名称，tomcat01，tomcat02 -it 交互方式运行， -d 后台运行 -p 指定荣放弃的端口 -p 8080:8080 -p ip:主机端口：容器端口 -p 主机端口：容器端口 -p 容器端口 容器端口 -P 随机指定端口 C:\\Users\\26505\u003edocker pull centos Using default tag: latest latest: Pulling from library/centos 7a0437f04f83: Pulling fs layer latest: Pulling from library/centos 7a0437f04f83: Pull complete Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1 Status: Downloaded newer image for centos:latest docker.io/library/centos:latest C:\\Users\\26505\u003edocker run -it centos /bin/bash [root@177a03668b45 /]# exit exit C:\\Users\\26505\u003edocker ps #正在运行的容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bc1f05966db8 mysql \"docker-entrypoint.s…\" 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-\u003e3306/tcp mysql 741b6a4bccc2 docker/getting-started \"/docker-entrypoint.…\" 7 hours ago Up 7 hours 0.0.0.0:8080-\u003e80/tcp docker-test C:\\Users\\26505\u003edocker ps -a #历史容器 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 177a03668b45 centos \"/bin/bash\" 4 minutes ago Exited (0) 3 minutes ago stoic_rosalind bc1f05966db8 mysql \"docker-entrypoint.s…\" 7 hours ago Up 7 hours 33060/tcp, 0.0.0.0:3307-\u003e3306/tcp mysql 741b6a4bccc2 docker/getting-started \"/docker-entrypoint.…\" 7 hours ago Up 7 hours 0.0.0.0:8080-\u003e80/tcp docker-test 70b02a4a1833 hello-world \"/hello\" 7 hours ago Exited (0) 7 hours ago stupefied_neumann ","date":"2021-04-06","objectID":"/docker/:5:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"退出容器 exit #退出并停止容器 ctrl+P+Q #退出终端不停止容器 ","date":"2021-04-06","objectID":"/docker/:6:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"删除容器 rm -f docker rm 容器id #不能删除正在运行的容器 docker rm -f $(docker pa -aq) #删除全部容器 docker ps -a -q|xargs docker rm #删除全部容器(管道) ","date":"2021-04-06","objectID":"/docker/:7:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"启动停止容器 docker start id #启动 docker restart id #重启 docker stop id #停止 docker kill id #强制停止 ","date":"2021-04-06","objectID":"/docker/:8:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"常用的其他命令 ","date":"2021-04-06","objectID":"/docker/:9:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"后台启动 docker run -d centos #问题 :docker ps 发现centos停止了 # 常见的坑，后台运行后，就必须有一个前台进程，docker发现没有应用，就自动停止了 #nginx 容器启动后，没有提供服务，就会立刻停止 ","date":"2021-04-06","objectID":"/docker/:9:1","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"日志命令 docker logs --help docker logs -tf --tail 10 id #查看后10条日志 docker logs -tf id #查看所有日志 docker run -d centos /bin/sh -C \"while true ;do echo tanjindong;sleep 1;done\" ","date":"2021-04-06","objectID":"/docker/:9:2","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"查看容器中的进程信息 # top命令 docker top --help docker top id ","date":"2021-04-06","objectID":"/docker/:9:3","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"查看镜像源数据 # inspect docker inspect id C:\\Users\\26505\u003edocker inspect 741b6a4bccc2 [ { \"Id\": \"741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3\", \"Created\": \"2021-03-21T07:20:22.6575041Z\", \"Path\": \"/docker-entrypoint.sh\", \"Args\": [ \"nginx\", \"-g\", \"daemon off;\" ], \"State\": { \"Status\": \"running\", \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 2067, \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2021-03-21T07:20:26.022246Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, \"Image\": \"sha256:3ba8f2ff0727d36bccad59f6344f7f3a101bcd9c70b984aa2dd006914c496cb8\", \"ResolvConfPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/hostname\", \"HostsPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/hosts\", \"LogPath\": \"/var/lib/docker/containers/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3/741b6a4bccc29177c95e953ecf827855cba60c91694c46aba6c53ff21fdbbbf3-json.log\", \"Name\": \"/docker-test\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"MountLabel\": \"\", \"ProcessLabel\": \"\", \"AppArmorProfile\": \"\", \"ExecIDs\": [ \"4ac8b9a918d39e7560ebf5e35fad12ef83ed66cabc27035095870d4fe13ac56c\" ], \"HostConfig\": { \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": { \"Type\": \"json-file\", \"Config\": {} }, \"NetworkMode\": \"default\", \"PortBindings\": { \"80/tcp\": [ { \"HostIp\": \"\", \"HostPort\": \"8080\" } ] }, \"RestartPolicy\": { \"Name\": \"no\", \"MaximumRetryCount\": 0 }, \"AutoRemove\": false, \"VolumeDriver\": \"\", \"VolumesFrom\": null, \"CapAdd\": null, \"CapDrop\": null, \"CgroupnsMode\": \"host\", \"Dns\": [], \"DnsOptions\": [], \"DnsSearch\": [], \"ExtraHosts\": null, \"GroupAdd\": null, \"IpcMode\": \"private\", \"Cgroup\": \"\", \"Links\": null, \"OomScoreAdj\": 0, \"PidMode\": \"\", \"Privileged\": false, \"PublishAllPorts\": false, \"ReadonlyRootfs\": false, \"SecurityOpt\": null, \"UTSMode\": \"\", \"UsernsMode\": \"\", \"ShmSize\": 67108864, \"Runtime\": \"runc\", \"ConsoleSize\": [ 31, 120 ], \"Isolation\": \"\", \"CpuShares\": 0, \"Memory\": 0, \"NanoCpus\": 0, \"CgroupParent\": \"\", \"BlkioWeight\": 0, \"BlkioWeightDevice\": [], \"BlkioDeviceReadBps\": null, \"BlkioDeviceWriteBps\": null, \"BlkioDeviceReadIOps\": null, \"BlkioDeviceWriteIOps\": null, \"CpuPeriod\": 0, \"CpuQuota\": 0, \"CpuRealtimePeriod\": 0, \"CpuRealtimeRuntime\": 0, \"CpusetCpus\": \"\", \"CpusetMems\": \"\", \"Devices\": [], \"DeviceCgroupRules\": null, \"DeviceRequests\": null, \"KernelMemory\": 0, \"KernelMemoryTCP\": 0, \"MemoryReservation\": 0, \"MemorySwap\": 0, \"MemorySwappiness\": null, \"OomKillDisable\": false, \"PidsLimit\": null, \"Ulimits\": null, \"CpuCount\": 0, \"CpuPercent\": 0, \"IOMaximumIOps\": 0, \"IOMaximumBandwidth\": 0, \"MaskedPaths\": [ \"/proc/asound\", \"/proc/acpi\", \"/proc/kcore\", \"/proc/keys\", \"/proc/latency_stats\", \"/proc/timer_list\", \"/proc/timer_stats\", \"/proc/sched_debug\", \"/proc/scsi\", \"/sys/firmware\" ], \"ReadonlyPaths\": [ \"/proc/bus\", \"/proc/fs\", \"/proc/irq\", \"/proc/sys\", \"/proc/sysrq-trigger\" ] }, \"GraphDriver\": { \"Data\": { \"LowerDir\": \"/var/lib/docker/overlay2/6d343bc9ad04de2e498e78ef2f579175c692ed808c08b393d1eb997f1dd5d84b-init/diff:/var/lib/docker/overlay2/214cc931af263a16f14aeb6d585e2dbee7150a57e19e84650bfdc32734a5846f/diff:/var/lib/docker/overlay2/47fae1cab0a2404c969f4cea1cfcb6b054b1bbdea8d8c6149c21848a77c816dc/diff:/var/lib/docker/overlay2/17096a2500c8f19f644b2554a0bd01af1b469f6f3b1b0d47718f826fe6c1e01e/diff:/var/lib/docker/overlay2/bbe4a1e6f6189b486a01f819c7fc91f2c558eb60e3eda0a16629e9b40cef3937/diff:/var/lib/docker/overlay2/98581fdc9425566ddfa8a8b96d8fe61544f2140e026d1df3cbdc507d38f582cd/diff:/var/lib/docker/overlay2/66a3d69a78eff1300e49d125d6a2ad49e2e9b48f826c802ae6e654b83db3016d/diff:/var/lib/docker/overlay2/8dafe228d5bec8620615e6252f815baeb01884e592865f8edac2f7fec8317da8/diff:/var/lib/docker/overlay2/d0ca3a53296feb329ea10d4f75f54b57bed2bdf53b67a24de0a1b6d726877d85/diff\", \"MergedDir\": \"/var/l","date":"2021-04-06","objectID":"/docker/:9:4","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"进入当前正在运行的容器 docker exec -it 容器id bashshell docker ps # 方式一 进入容器之后开启一个新的终端(常用) docker exec -it id /bin/bash #方式二 进入执行的终端 docker attach 容器id 正在执行的代码。。。。。 ","date":"2021-04-06","objectID":"/docker/:9:5","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"从容器拷贝文件到主机 cp docker cp id:/home/test.java /home docker cp 容器id:容器目录 本机目录 ","date":"2021-04-06","objectID":"/docker/:9:6","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"作业一：部署nginx docker pull nginx #下载镜像 docker images docker run -d --name nginx-01 -p 3344:80 nginx #运行容器 curl localhost:3344 #测试 pi@raspberrypi:~ $ docker exec -it nginx-01 /bin/bash #进入容器 root@9ddb6ad99473:/# whereis nginx nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx root@9ddb6ad99473:/# cd etc/nginx/ root@9ddb6ad99473:/etc/nginx# ls conf.d fastcgi_params koi-utf koi-win mime.types modules nginx.conf scgi_params uwsgi_params win-utf pi@raspberrypi:~ $ docker stop nginx-01 #停止容器 nginx-01 pi@raspberrypi:~ $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES #每次修改nginx配置，都需要进入容器，十分麻烦，映射路径，达到修改容器配置的目的，数据卷技术！！！！ ","date":"2021-04-06","objectID":"/docker/:10:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"作业二：部署tomcat #官方使用 docker run -it --rm tomcat:9.0 #之前都是后台，停止了之后，容器还可以查到，docker run -it --rm用完即删，一般用来测试 #下载启动 docker pull tomcat docker images docker run -d --name tomcat-01 -p 3355:8080 tomcat #运行 外部3355 but 原因：官方镜像最简化，所以找不到资源文件： docker exec -it tomcat-01 /bin/bash #进入容器 cp -r webapps.dist/* webapps ","date":"2021-04-06","objectID":"/docker/:11:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"作业三：部署es+kibana # elasticsearch暴露端口十分多 # ES 十分耗内存 # 数据一般挂载在安全目录 # --net somenetwork ？网络配置 docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.11.2 docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.11.2 C:\\Users\\26505\u003ecurl localhost:9200 { \"name\" : \"2ab0292e5b49\", \"cluster_name\" : \"docker-cluster\", \"cluster_uuid\" : \"661wGGJlSRqiLH_ht2P48A\", \"version\" : { \"number\" : \"7.11.2\", \"build_flavor\" : \"default\", \"build_type\" : \"docker\", \"build_hash\" : \"3e5a16cfec50876d20ea77b075070932c6464c7d\", \"build_date\" : \"2021-03-06T05:54:38.141101Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.7.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } # 启动之后非常卡 how to 解决 docker stats 查看cpu状态 docker stats # 解决一：增加内存限制，修改配置文件， -e 环境的配置修改 docker run -d --name elasticsearch -p 9201:9200 -p 9301:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" elasticsearch:7.11.2 使用kibana连接ES： ","date":"2021-04-06","objectID":"/docker/:12:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"可视化工具 portainer(不是最佳选择，先用) # -v /var/run/docker.sock 挂载，里面数据挂载到本机 # --privileged=true 授权，本机可访问 docker run -d -p 8088:9000 \\ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer 测试访问：8088 Rancher（CI/CD） docker镜像原理 UFS 联合文件系统，分层轻量，分层下载，分层加载，多镜像共用 公共内核(bootfs) 对于一个OS，rootfs可以很小，只需要包含基本的命令、工具和程序库就可以了，因为底层直接用host的kernel，自己只需要提供rootfs就可以了，由此可见，不同版本的Linux发行版，bootfs是相同的，只是rootfs不同罢了。 bootfs引导启动非常慢，rootfs库启动非常快，所以虚拟机启动分钟级别，docker启动秒级。 分层理解： ","date":"2021-04-06","objectID":"/docker/:13:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"如何打包一个自己的镜像：commit docker commit #提交容器 docker commit -m=\"提交描述信息\" -a=\"作者\" 容器id 目标镜像名:[tag] docker commit -a=\"jd\" -m=\"add webapps\" 7sssdvhfgs tomcat02:1.0 容器数据卷 如果数据都在容器中，容器删除之后，数据就会丢失，需求：数据可持久化， MySQL，容器删除了，MySQL数据就没了，MySQL可以保存在本地吗？ 数据共享技术，docker容器中产生的数据同步到本地， 卷技术，？目录挂载，将容器内的目录挂载在宿主机上，持久化与同步操作，容器间数据可以共享 # 方式一：使用-v挂载 docker run -d -v 主机目录:容器目录 docker run -it -v /home/ceshi:/home --name ubuntu01 ubuntu /bin/bash docker inspect 容器id docker stop 1bfb0a3ad95e #停止docker 容器 sudo nano test.txt #修改Host文件 docker start 1bfb0a3ad95e #重新启动 # 进入容器查看文件变化 pi@raspberrypi:~ $ docker exec -it 1bfb0a3ad95e /bin/bash root@1bfb0a3ad95e:/# cd /home root@1bfb0a3ad95e:/home# ls test test.b test.java test.txt root@1bfb0a3ad95e:/home# cat test/txt cat: test/txt: No such file or directory root@1bfb0a3ad95e:/home# cat test.txt yasethbitgejk nadeuioaguhno arezln # 容器内的数据依旧是同步的！！！！！！ # 通过-v挂载配置文件和资源文件，就不用进入容器修改，只用修改本地，容器自动同步 ","date":"2021-04-06","objectID":"/docker/:14:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"部署MySQL mysql数据持久化问题 docker pull mysql:5.7 #需要配置密码 -e MYSQL_ROOT_PASSWORD=my-secret-pw # docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag docker run -d -p 3310:3306 --name mysql-test -v H:\\myNotsBooks\\docker\\conf:/etc/mysql/conf.d -v H:\\myNotsBooks\\docker\\data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 链接成功： 数据挂载成功：（conf） 即使删除容器，本地的数据卷依旧没有丢失，这就达到了数据持久化 ","date":"2021-04-06","objectID":"/docker/:15:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"具名和匿名挂载 #匿名挂载 # -v 容器内路径！ docker run -d -P --name nginx-test -v /etc/nginx nginx # 查看所有卷volume的挂载情况 pi@raspberrypi:/home/ceshi $ docker run -d -P --name nginx-test -v /etc/nginx nginx 9f4ba2383cab2eedc09916c2191858b88673cc43ef85194b42eb67cb8c2bca54 pi@raspberrypi:/home/ceshi $ docker volume --help Usage: docker volume COMMAND Manage volumes Commands: create Create a volume inspect Display detailed information on one or more volumes ls List volumes prune Remove all unused local volumes rm Remove one or more volumes Run 'docker volume COMMAND --help' for more information on a command. pi@raspberrypi:/home/ceshi $ docker volume ls DRIVER VOLUME NAME local 27f1cec7789cd92096fc7177238808528b7201f2b7f2628c57fc4f350bff7c09 #匿名挂载 local 28ce6884130cf729f12f33decf67c96f0bab95032c193302553cd9050f8ff7e8 # -v 的时候只写了容器内部的路径 #具名挂载 pi@raspberrypi:~ $ docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx nginx 70500d6c7b7f937a953990007fc0af3db4628df5687eead2081abdfaeb582b4f pi@raspberrypi:~ $ docker volume ls DRIVER VOLUME NAME local 27f1cec7789cd92096fc7177238808528b7201f2b7f2628c57fc4f350bff7c09 local 28ce6884130cf729f12f33decf67c96f0bab95032c193302553cd9050f8ff7e8 local jumingfs pi@raspberrypi:~ $ docker volume inspect nginx-juming [] Error: No such volume: nginx-juming pi@raspberrypi:~ $ docker volume inspect jumingfs [ { \"CreatedAt\": \"2021-03-25T11:06:02+08:00\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/jumingfs/_data\", \"Name\": \"jumingfs\", \"Options\": null, \"Scope\": \"local\" } ] 所有docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/jumingfs/_data 我们通过具名挂载可以方便找到我们的一个大卷，大多数情况下使用的是具名挂载 ","date":"2021-04-06","objectID":"/docker/:16:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"如何区分是具名挂载还是匿名挂载还是指定路径挂载 -v 容器内路径 #匿名挂载 -v 卷名:容器内路径 #具名挂载 -v /宿主机路径:容器内路径 #指定路径挂载 ","date":"2021-04-06","objectID":"/docker/:17:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"扩展 #设置容器权限，对挂载数据卷有限制 docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx:ro nginx docker run -d -P --name nginx-juming -v jumingfs:/etc/nginx:rw nginx # ro 只能通过宿主机来操作，不能通过容器内部操作 # 默认rw: 可读可写 Dockerfile:构建docker的文件 一段命令脚本 pi@raspberrypi:/home/docker-test-file-volume $ docker build -f ./dockerfile1 -t jd/centos:1.0 . #构建镜像 Sending build context to Docker daemon 2.048kB Step 1/4 : FROM ubuntu ---\u003e 3324772e8bdf Step 2/4 : VOLUME [\"volume01\",\"volume02\"] ---\u003e Running in e07670d15bd9 Removing intermediate container e07670d15bd9 ---\u003e 067080c3c46e Step 3/4 : CMD echo \"........end........\" ---\u003e Running in 0ac9ebb25a05 Removing intermediate container 0ac9ebb25a05 ---\u003e 5fa9a5e368ba Step 4/4 : CMD /bin/bash ---\u003e Running in 492dcb1825df Removing intermediate container 492dcb1825df ---\u003e e5bd1def5d82 Successfully built e5bd1def5d82 Successfully tagged jd/centos:1.0 pi@raspberrypi:/home/docker-test-file-volume $ docker images #查看镜像 REPOSITORY TAG IMAGE ID CREATED SIZE jd/centos 1.0 e5bd1def5d82 7 seconds ago 49.8MB portainer/portainer latest 9b438d60114e 6 days ago 62.4MB nginx latest 4f718772a0b3 13 days ago 103MB ubuntu latest 3324772e8bdf 5 months ago 49.8MB hello-world latest 851163c78e4a 14 months ago 4.85kB java 8 d23bdf5b1b1b 4 years ago 643MB pi@raspberrypi:/home/docker-test-file-volume $ cat dockerfile1 FROM ubuntu VOLUME [\"volume01\",\"volume02\"] #匿名挂载 CMD echo \"........end........\" CMD /bin/bash docker inspect id #查看卷挂载路径 ","date":"2021-04-06","objectID":"/docker/:18:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"多个docker同步数据 # 多个MySQL数据同步 # 启动三个容器 docker run -it --name docker01 jd/centos:1.0 docker run -it --name docker02 --volumes-from docker01 jd/centos:1.0 docker run -it --name docker03 --volumes-from docker01 jd/centos:1.0 # 进入docker01创建文件 root@450d606a17a0:/# pi@raspberrypi:/ $ docker attach 0721edbafafb root@0721edbafafb:/# ls bin dev home media opt root sbin sys usr volume01 boot etc lib mnt proc run srv tmp var volume02 root@0721edbafafb:/# cd vo bash: cd: vo: No such file or directory root@0721edbafafb:/# cd volume01 root@0721edbafafb:/volume01# ls root@0721edbafafb:/volume01# touch docker01.txt touch: setting times of 'docker01.txt': Operation not permitted root@0721edbafafb:/volume01# ls docker01.txt #进入docker02查看 pi@raspberrypi:/ $ docker attach 450d606a17a0 root@450d606a17a0:/# ls bin dev home media opt root sbin sys usr volume01 boot etc lib mnt proc run srv tmp var volume02 root@450d606a17a0:/# cd volume01 root@450d606a17a0:/volume01# ls docker01.txt docker02 volumesfrom docker01 docker03 volumesfrom docker01 如果把1删除了，2，3还在吗？？？ 发现还在，只要有一个容器使用，就依旧存在，共享备份机制，双向拷贝的概念 # 多个mysql实现数据共享 docker run -d -p 3301:3306 --name mysql01 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 docker run -d -p 3302:3306 --name mysql02 --volumes-from mysql01 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 #这个时候可以实现两个容器数据同步 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止， 但是一旦持久化挂载-v到本地，本地不会被删除！！！！ ","date":"2021-04-06","objectID":"/docker/:19:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"dockerfile 命令参数脚本 1、编写一个dockerfile文件 2、docker build 一个镜像 3、docker run 运行容器 4、docker push 发布镜像（dockerhub,阿里云镜像） 查看一下官方这么做的： FROM scratch ADD centos-8-x86_64.tar.xz / LABEL org.label-schema.schema-version=\"1.0\" org.label-schema.name=\"CentOS Base Image\" org.label-schema.vendor=\"CentOS\" org.label-schema.license=\"GPLv2\" org.label-schema.build-date=\"20201204\" CMD [\"/bin/bash\"] ","date":"2021-04-06","objectID":"/docker/:20:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"构建过程 从上到下顺序执行，指令大写，每个指令就会创建一个新的镜像层 企业交付的标准！！！！！ ","date":"2021-04-06","objectID":"/docker/:21:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"dockerfile指令 dockerHub 80% 来自FROM scratch FROM #基础镜像，一切从这里开始构建 MAINTAINER #镜像是谁写的，姓名+邮箱 RUN #构建镜像时需要运行的命令 ADD #步骤，tomcat压缩包，添加内容 WORKDIR #镜像的工作目录 VOLUME #挂载卷 EXPOSE #指定暴露端口原来-p CMD #指定这个容器启动的时候运行的命令，只有最后一个会失效，可被替代 ENTRYPOINT #指定这个容器启动的时候运行的命令，可追加 ONBUILD #当构建一个被继承dockerfile,触发指令 COPY #类似ADD，拷贝文件到镜像 ENV #构建的时候设置环境变量 -e 自己写一个dockerfile：：：：：：：：： ＃　entos-vim-ip FROM centos MAINTAINER 金东\u003c2650523664@qq.com ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"------end-----\" CMD /bin/bash docker build -f centos-vim-ip -t mycentos:1.0 . docker images docker run -it --name mycentostest mycentos:1.0 # 现在vim 与 ifconfig命令都可以用了,官方不可用 docker history mycentos:1.0 ","date":"2021-04-06","objectID":"/docker/:22:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"CMD与ENTRYPOINT区别 FROM centos CMD [\"ls\",\"-a\"]　# 指定容器启动时运行的命令，只有最后一个生效，可被替代 H:\\myNotsBooks\\docker\\dockerfile\u003edocker run -it cmdtest -l docker: Error response from daemon: OCI runtime create failed: container_linux.go:370: starting container process caused: exec: \"-l\": executable file not found in $PATH: unknown. # cmd的清理下，-l代替了CMD [\"ls\",\"-a\"],但是-l不是命令，所以报错 H:\\myNotsBooks\\docker\\dockerfile\u003edocker run -it cmdtest ls -al #这就对了 total 56 drwxr-xr-x 1 root root 4096 Mar 25 14:21 . drwxr-xr-x 1 root root 4096 Mar 25 14:21 .. -rwxr-xr-x 1 root root 0 Mar 25 14:21 .dockerenv lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -\u003e usr/bin drwxr-xr-x 5 root root 360 Mar 25 14:21 dev drwxr-xr-x 1 root root 4096 Mar 25 14:21 etc drwxr-xr-x 2 root root 4096 Nov 3 15:22 home lrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -\u003e usr/lib lrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -\u003e usr/lib64 drwx------ 2 root root 4096 Dec 4 17:37 lost+found drwxr-xr-x 2 root root 4096 Nov 3 15:22 media drwxr-xr-x 2 root root 4096 Nov 3 15:22 mnt drwxr-xr-x 2 root root 4096 Nov 3 15:22 opt dr-xr-xr-x 196 root root 0 Mar 25 14:21 proc dr-xr-x--- 2 root root 4096 Dec 4 17:37 root drwxr-xr-x 11 root root 4096 Dec 4 17:37 run lrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -\u003e usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 15:22 srv dr-xr-xr-x 11 root root 0 Mar 25 14:21 sys drwxrwxrwt 7 root root 4096 Dec 4 17:37 tmp drwxr-xr-x 12 root root 4096 Dec 4 17:37 usr drwxr-xr-x 20 root root 4096 Dec 4 17:37 var #ENTRYPOINT 命令可追加 FROM centos ENTRYPOINT [\"ls\",\"-a\"] docker build -f docker-entrypoint-test -t entrypointtest . docker run -it entrypointtest H:\\myNotsBooks\\docker\\dockerfile\\cmd ENTRYPOINT\u003edocker run -it entrypointtest . .dockerenv dev home lib64 media opt root sbin sys usr .. bin etc lib lost+found mnt proc run srv tmp var H:\\myNotsBooks\\docker\\dockerfile\\cmd ENTRYPOINT\u003edocker run -it entrypointtest -l #加-l不报错,加到a前面了 total 56 drwxr-xr-x 1 root root 4096 Mar 25 14:29 . drwxr-xr-x 1 root root 4096 Mar 25 14:29 .. -rwxr-xr-x 1 root root 0 Mar 25 14:29 .dockerenv lrwxrwxrwx 1 root root 7 Nov 3 15:22 bin -\u003e usr/bin drwxr-xr-x 5 root root 360 Mar 25 14:29 dev drwxr-xr-x 1 root root 4096 Mar 25 14:29 etc drwxr-xr-x 2 root root 4096 Nov 3 15:22 home lrwxrwxrwx 1 root root 7 Nov 3 15:22 lib -\u003e usr/lib lrwxrwxrwx 1 root root 9 Nov 3 15:22 lib64 -\u003e usr/lib64 drwx------ 2 root root 4096 Dec 4 17:37 lost+found drwxr-xr-x 2 root root 4096 Nov 3 15:22 media drwxr-xr-x 2 root root 4096 Nov 3 15:22 mnt drwxr-xr-x 2 root root 4096 Nov 3 15:22 opt dr-xr-xr-x 195 root root 0 Mar 25 14:29 proc dr-xr-x--- 2 root root 4096 Dec 4 17:37 root drwxr-xr-x 11 root root 4096 Dec 4 17:37 run lrwxrwxrwx 1 root root 8 Nov 3 15:22 sbin -\u003e usr/sbin drwxr-xr-x 2 root root 4096 Nov 3 15:22 srv dr-xr-xr-x 11 root root 0 Mar 25 14:29 sys drwxrwxrwt 7 root root 4096 Dec 4 17:37 tmp drwxr-xr-x 12 root root 4096 Dec 4 17:37 usr drwxr-xr-x 20 root root 4096 Dec 4 17:37 var ","date":"2021-04-06","objectID":"/docker/:22:1","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"实战：tomcat镜像 1、准备镜像文件：tomcat jdk 2、编写dockerfile文件 FROM centos MAINTAINER jd\u003c2650523664@qq.com\u003e COPY readme.txt /usr/local/readme.txt ADD apache-tomcat-9.0.44.tar.gz /usr/local/ ADD jdk-8u201-linux-x64.tar.gz /usr/local/ RUN yum -y install vim ENV MYPATH /usr/local WORKDIR $MYPATH ENV JAVA_HOME /usr/local/jdk1.8.0_201 ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.44 ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.44 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080 CMD /usr/local/apache-tomcat-9.0.44/bin/startup.sh \u0026\u0026 tail -F /usr/local/apache-tomcat-9.0.44/bin/logs/catalina.out 3、构建镜像 docker build -t mytomcat . # 构建镜像 4、启动镜像 docker run -d -p 9090:8080 --name testmytomcat -v /root/environment/tomcat-test-3-26/test:/usr/local/apache-tomcat-9.0.44/webapps/test -v /root/environment/tomcat-test-3-26/tomlogs:/usr/local/apache-tomcat-9.0.44/logs mytomcat 5、访问测试 6、发布项目（由于实现了卷挂载，所以我们就直接在本地写项目发布就可以了） jps页面 \u003chtml\u003e \u003chead\u003e\u003ctitle\u003eHello World\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e Hello World!\u003cbr/\u003e \u003c% System.out.println(\"-----------start my tomcat-----\"); %\u003e \u003c/body\u003e \u003c/html\u003e web.xml文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\" metadata-complete=\"true\"\u003e \u003c/web-app\u003e ","date":"2021-04-06","objectID":"/docker/:23:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"发布镜像 ","date":"2021-04-06","objectID":"/docker/:24:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"dockerHub镜像 1、注册账户：https://registry.hub.docker.com/ 2、客户端提交镜像 [root@jd tomcat-test-3-26]# docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username [root@jd tomcat-test-3-26]# docker login -u hubu8023 Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded 3、发布镜像 [root@jd ~]# docker tag 5599ee6a7e53 hubu8023/mytest:1.0 [root@jd ~]# docker push hubu8023/mytest:1.0 [root@jd ~]# docker tag hello-world:latest hubu8023/myhello:2.0 #增加标签 [root@jd ~]# docker push hubu8023/myhello:2.0 # The push refers to repository [docker.io/hubu8023/myhello] f22b99068db9: Mounted from library/hello-world 2.0: digest: sha256:1b26826f602946860c279fce658f31050cff2c596583af237d971f4629b57792 size: 525 ","date":"2021-04-06","objectID":"/docker/:24:1","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"阿里云镜像 1、登录阿里云https://cr.console.aliyun.com/cn-hangzhou/instance/repositories 2、找到容器镜像服务 3、创建命名空间 4、创建容器镜像 5、浏览页面信息 登录阿里云Docker Registry $ sudo docker login --username=18871955259东 registry.cn-hangzhou.aliyuncs.com 用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。 您可以在访问凭证页面修改凭证密码。 从Registry中拉取镜像 $ sudo docker pull registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] 将镜像推送到Registry $ sudo docker login --username=18871955259东 registry.cn-hangzhou.aliyuncs.com $ sudo docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] $ sudo docker push registry.cn-hangzhou.aliyuncs.com/jda/testdockerjd:[镜像版本号] 请根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 小结： Docker网络 docker网络核心docker0: 两个容器之间如何访问？？？？？ docker run -d -P --name tomcat01 tomcat [root@jd ~]# docker exec -it tomcat01 ip addr 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 18: eth0@if19: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 查看容器内网IP地址，发现容器启动的时候得到一个eth0@if19 IP地址，这是docker分配的！！！ 现在能不能ping通容器？？？linux可以ping通容器内部 ","date":"2021-04-06","objectID":"/docker/:24:2","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"原理： 1、我们每启动一个docker容器，docker就会给容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0(桥接模式–evth-pair) 2、再启动一个docker容器，发现又多了一对网卡： # 容器的网卡都是成对出现的， # evth-pair就是一对虚拟设备接口，他们都是成对出现的，一端连接协议，一端彼此相连 # 正因为有这个特性，evth-pair充当一个桥梁，连接各种虚拟网络设备， 3、测试两个tomcat能不能互通： 网络模型 结论：tomcat01和tomcat02 共用一个路由器docker0, 所有的容器不指定网络，都是docker0路由的，docker会给容器分配一个默认可用IP 255.255.0.1/16 : 能用IP;255*255-0.0-255.255=255*255-1-1 255.255.0.1/24 : 能用IP;255*255-0.0-255.255=255-1-1 ","date":"2021-04-06","objectID":"/docker/:25:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"–link(基本不用) 场景：微服务或者springboot中database.url配置怎么写？？IP一直变 项目不重启，数据库IP变了，我们希望可以通过名字来访问容器 [root@jd ~]# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known # 实现tomcat03 ping tomcat02 [root@jd ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat 7dd6fe9dbe2e5732dfa53d3d2b2e6f14eb7abaccbf2771c44ae03db2dcc4faaf [root@jd ~]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.109 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.079 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.100 ms # 反向tomcat02 不能ping tomcat03 [root@jd ~]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 探究inspect: [root@jd ~]# docker network ls NETWORK ID NAME DRIVER SCOPE c592ad97632c bridge bridge local c9c57d03a4a4 host host local 85a3888c406a none null local [root@jd ~]# docker network inspect c592ad97632c #docker0网卡信息 docker inspect tomcat03 # 原理发现！！！！！！！！！！！！！！！！！！！！ # 查看tomcat03 hosts文件 docker exec -it tomcat03 cat /etc/hosts [root@jd ~]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.3 tomcat02 9dce1424d4fe #9dce1424d4fe tomcat02容器id 172.17.0.4 7dd6fe9dbe2e #7dd6fe9dbe2e tomcat03本机容器id 容器02： [root@jd ~]# docker exec -it tomcat02 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters 172.17.0.3 9dce1424d4fe 只要在这里增加容器03的网络配置就可以实现互通， 但是现在docker已经不建议使用–link技术了，自定义网络，不用docker0, docker0问题：他不支持容器名链接访问！ ！ ","date":"2021-04-06","objectID":"/docker/:26:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"自定义网络 # 查看所有网络 [root@jd ~]# docker network ls NETWORK ID NAME DRIVER SCOPE c592ad97632c bridge bridge local c9c57d03a4a4 host host local 85a3888c406a none null local 网络模式： bridge : 桥接模式（默认），自己创建也是使用bridge模式 none: 不配置网络， host: 和Linux主机共享网络 container: 容器网络连通（用的少，局限性很大） 测试 # 原来启动容器，默认--net bridge 二这个就是我们的docker0 docker run -d -P --name tomcat01 --net bridge tomcat docker run -d -P --name tomcat01 tomcat # docker0特点： 默认。域名不能访问，--link可以打通 # 因此我们需要自定义一个网络 [root@jd ~]# docker network --help Usage: docker network COMMAND Manage networks Commands: connect Connect a container to a network create Create a network disconnect Disconnect a container from a network inspect Display detailed information on one or more networks ls List networks prune Remove all unused networks rm Remove one or more networks docker network create --help # --subnet子网地址 192.168.0.2--------192.168.255.255 # --gateway 网关，路由器地址 docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mytestnet docker network ls [root@jd ~]# docker network inspect mytestnet [ { \"Name\": \"mytestnet\", \"Id\": \"779b38cb0d482db5eb7156e0ba327da1740a86d71106438f27f22f6ceee2e82e\", \"Created\": \"2021-03-27T14:17:45.675341638+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": {}, \"Options\": {}, \"Labels\": {} } ] 用自己创建的网络模式创建容器 [root@jd ~]# docker run -d -P --name tomcat-net-01 --net mytestnet tomcat 56554c258e04f1ed4c300e26d337ca39c35087aa4d92f782e0a2b87138484b99 [root@jd ~]# docker run -d -P --name tomcat-net-02 --net mytestnet tomcat 1ccb18d09020622d029b4373c6d09f40259b5944ee27269ee0195ad8bd94269 [root@jd ~]# docker network inspect mytestnet [ { \"Name\": \"mytestnet\", \"Id\": \"779b38cb0d482db5eb7156e0ba327da1740a86d71106438f27f22f6ceee2e82e\", \"Created\": \"2021-03-27T14:17:45.675341638+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"1ccb18d09020622d029b4373c6d09f40259b5944ee27269ee0195ad8bd942694\": { \"Name\": \"tomcat-net-02\", \"EndpointID\": \"fa949ca6e5a71662a6656b83ed483d812972e815e5f1fc8d1c4c1f33e714cadb\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" }, \"56554c258e04f1ed4c300e26d337ca39c35087aa4d92f782e0a2b87138484b99\": { \"Name\": \"tomcat-net-01\", \"EndpointID\": \"5e2022a9c3c27a9d225d7b2d54f2ab16196fff5cfa9aa3f9a28be4e4d2a8f649\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": {} } ] #此时tomcat-net-01与02就处于我们自己创建的网络模式中 好处： [root@jd ~]# docker exec -it tomcat-net-01 ping tomcat-net-02 PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data. 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=1 ttl=64 time=0.125 ms 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=2 ttl=64 time=0.085 ms 64 bytes from tomcat-net-02.mytestnet (192.168.0.3): icmp_seq=3 ttl=64 time=0.107 ms [root@jd ~]# docker exec -it tomcat-net-02 ping tomcat-net-01 PING tomcat-net-01 (192.168.0.2) 56(84) bytes of data. 64 bytes from tomcat-net-01.mytestnet (192.168.0.2): icmp_seq=1 ttl=64 time=0.108 ms 64 bytes from tomcat-net-01.mytestnet (192.168.0.2): icmp_seq=2 ttl=64 time=0.098 ms # 可以直接通过容器名称互通，不用使用--link 自定义网络已经维护好了对应关系，推荐使用自定义网络 redis集群，mysql集群使用不同的网络，保证集群的隔离性与数据安全 ，网络互相隔离 ","date":"2021-04-06","objectID":"/docker/:27:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"网络互通 测试 [root@jd ~]# docker run -d -P --name tomcat01 tomcat 999d0f449539783be990b3bb36f5036a4dc4419a8cfba1ffe9907e0bc08352d6 [root@jd ~]# docker run -d -P --name tomcat02 tomcat 5b6d4843a2fe7aede6cc377f4825dfb014bf035333ecf16d739576dc1a9b3237 [root@jd ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 5b6d4843a2fe tomcat \"catalina.sh run\" 6 seconds ago Up 5 seconds 0.0.0.0:49160-\u003e8080/tcp tomcat02 999d0f449539 tomcat \"catalina.sh run\" 16 seconds ago Up 16 seconds 0.0.0.0:49159-\u003e8080/tcp tomcat01 1ccb18d09020 tomcat \"catalina.sh run\" 15 minutes ago Up 15 minutes 0.0.0.0:49158-\u003e8080/tcp tomcat-net-02 56554c258e04 tomcat \"catalina.sh run\" 15 minutes ago Up 15 minutes 0.0.0.0:49157-\u003e8080/tcp tomcat-net-01 [root@jd ~]# docker network connect mytestnet tomcat01 [root@jd ~]# docker network inspect mytestnet 连通之后就是将tomcat01放在了mytestnet网络下 其实就是一个容器两个IP [root@jd ~]# docker exec -it tomcat-net-01 ping tomcat01 PING tomcat01 (192.168.0.4) 56(84) bytes of data. 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=1 ttl=64 time=0.126 ms 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=2 ttl=64 time=0.083 ms 64 bytes from tomcat01.mytestnet (192.168.0.4): icmp_seq=3 ttl=64 time=0.084 ms tomcat02依旧不同 加入需要跨网络操作容器，就需要使用dockers network connect mytestnet tomcat-sjvbk ","date":"2021-04-06","objectID":"/docker/:28:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["15"],"content":"部署redis集群 分片+高可用+负载均衡 # 创建网络 docker network create redis-net --subnet 172.38.0.0/16 docker network ls docker network inspect redis-net # 通过脚本创建6个redis for port in $(seq 1 6); \\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003e/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done for port in $(seq 1 6); \\ do \\ mkdir -p /mydata/redis/node-${port}/conf touch /mydata/redis/node-${port}/conf/redis.conf cat \u003c\u003c EOF \u003e/mydata/redis/node-${port}/conf/redis.conf port 6379 bind 0.0.0.0 cluster-enabled yes cluster-config-file nodes.conf cluster-node-timeout 5000 cluster-announce-ip 172.38.0.1${port} cluster-announce-port 6379 cluster-announce-bus-port 16379 appendonly yes EOF done # 创建6个redis节点 docker run -p 6371:6379 -p 16371:16379 --name redis-1 \\ -v /mydata/redis/node-1/data:/data \\ -v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis-net --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf docker run -p 6373:6379 -p 16373:16379 --name redis-3 \\ -v /mydata/redis/node-3/data:/data \\ -v /mydata/redis/node-3/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis-net --ip 172.38.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf # 通过脚本一次启动6个redis容器 docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \\ -v /mydata/redis/node-${port}/data:/data \\ -v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \\ -d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf done docker ps # 交互模式进节点 docker exec -it redis-1 /bin/sh # 创建redis集群 redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 \\ 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 \\ 172.38.0.16:6379 --cluster-replicas 1 # 输入yes 测试 redis-cli -c cluster info cluster nodes /data # redis-cli -c 127.0.0.1:6379\u003e cluster info cluster_state:ok cluster_slots_assigned:16384 cluster_slots_ok:16384 cluster_slots_pfail:0 cluster_slots_fail:0 cluster_known_nodes:6 cluster_size:3 cluster_current_epoch:7 cluster_my_epoch:1 cluster_stats_messages_ping_sent:866 cluster_stats_messages_pong_sent:847 cluster_stats_messages_fail_sent:5 cluster_stats_messages_auth-ack_sent:1 cluster_stats_messages_update_sent:1 cluster_stats_messages_sent:1720 cluster_stats_messages_ping_received:842 cluster_stats_messages_pong_received:833 cluster_stats_messages_meet_received:5 cluster_stats_messages_fail_received:1 cluster_stats_messages_auth-req_received:1 cluster_stats_messages_received:1682 127.0.0.1:6379\u003e cluster nodes 9d043104052b4904cb3c6587ae09a72691953b02 172.38.0.13:6379@16379 slave #从d6411ab58802fd1408e66c304760d1f31688321b 0 1616830729000 7 connected 62ae6caadcf0a38c0d5c3a26c1364026a926b7e9 172.38.0.15:6379@16379 slave #从69169db2f42fb6d9015a23b7fe7cb13a8e6d62b1 0 1616830730548 5 connected 53634e5afa3791069ca0b97183be5bd1d4496bb4 172.38.0.16:6379@16379 slave #从344c681321b27f5b53f59674fb21876889a92020 0 1616830730548 6 connected 344c681321b27f5b53f59674fb21876889a92020 172.38.0.12:6379@16379 master - 0 1616830730648 2 connected 5461-10922 #主 d6411ab58802fd1408e66c304760d1f31688321b 172.38.0.14:6379@16379 master - 0 1616830729000 7 connected 10923-16383 #主 69169db2f42fb6d9015a23b7fe7cb13a8e6d62b1 172.38.0.11:6379@16379 myself,master - 0 1616830730000 1 connected 0-5460 #主 127.0.0.1:6379\u003e get a -\u003e Redirected to slot [15495] located at 172.38.0.14:6379 \"b\" springboot项目部署 1、构建项目 2、打包应用 3、编写dockerfile FROM java:8 COPY *.jar /app/ CMD [\"----server.port=8080------\"] EXPOSE 9980 ENTRYPOINT [\"java\",\"-jar\",\"/app/posttimer.jar\"] 4、构建镜像 docker build -t posttimer . [root@jd posttimer]# docker build -t posttimer . Sending build context to Docker daemon 56.69MB Step 1/5 : FROM java:8 8: Pulling from library/java 5040bd298390: Pull comple","date":"2021-04-06","objectID":"/docker/:29:0","tags":["docker"],"title":"Docker","uri":"/docker/"},{"categories":["数据库"],"content":"一、Nosql概述 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:1:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"为什么使用Nosql 1、单机Mysql时代 90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题 数据量增加到一定程度，单机数据库就放不下了 数据的索引（B+ Tree）,一个机器内存也存放不下 访问量变大后（读写混合），一台服务器承受不住。 2、Memcached(缓存) + Mysql + 垂直拆分（读写分离） 网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！ 优化过程经历了以下几个过程： 优化数据库的数据结构和索引(难度大) 文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了 MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。 3、分库分表 + 水平拆分 + Mysql集群 4、如今最近的年代 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题。 目前一个基本的互联网项目 为什么要用NoSQL ？ 用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！ 这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！ ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:1:1","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"什么是Nosql NoSQL = Not Only SQL（不仅仅是SQL） Not Only Structured Query Language 关系型数据库：列+行，同一个表下数据的结构是一样的。 非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。 NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:1:2","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"Nosql特点 方便扩展（数据之间没有关系，很好扩展！） 大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！） 数据类型是多样型的！（不需要事先设计数据库，随取随用） 传统的 RDBMS 和 NoSQL 传统的 RDBMS(关系型数据库) - 结构化组织 - SQL - 数据和关系都存在单独的表中 row col - 操作，数据定义语言 - 严格的一致性 - 基础的事务 - ... Nosql - 不仅仅是数据 - 没有固定的查询语言 - 键值对存储，列存储，文档存储，图形数据库（社交关系） - 最终一致性 - CAP定理和BASE - 高性能，高可用，高扩展 - ... 了解：3V + 3高 大数据时代的3V ：主要是描述问题的 海量Velume 多样Variety 实时Velocity 大数据时代的3高 ： 主要是对程序的要求 高并发 高可扩 高性能 真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:1:3","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"阿里巴巴演进分析 推荐阅读：阿里云的这群疯子https://yq.aliyun.com/articles/653511 # 商品信息 - 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。 # 商品描述、评论(文字居多) - 文档型数据库：MongoDB # 图片 - 分布式文件系统 FastDFS - 淘宝：TFS - Google: GFS - Hadoop: HDFS - 阿里云: oss # 商品关键字 用于搜索 - 搜索引擎：solr,elasticsearch - 阿里：Isearch 多隆 # 商品热门的波段信息 - 内存数据库：Redis，Memcache # 商品交易，外部支付接口 - 第三方应用 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:1:4","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"Nosql的四大分类 KV键值对 新浪：Redis 美团：Redis + Tair 阿里、百度：Redis + Memcache 文档型数据库（bson数据格式）： MongoDB(掌握) 基于分布式文件存储的数据库。C++编写，用于处理大量文档。 MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。 ConthDB 列存储数据库 HBase(大数据必学) 分布式文件系统 图关系数据库 用于广告推荐，社交网络 Neo4j、InfoGrid 分类 Examples举例 典型应用场景 数据模型 优点 缺点 键值对（key-value） Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB 内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。 Key 指向 Value 的键值对，通常用hash table来实现 查找速度快 数据无结构化，通常只被当作字符串或者二进制数据 列存储数据库 Cassandra, HBase, Riak 分布式的文件系统 以列簇式存储，将同一列数据存在一起 查找速度快，可扩展性强，更容易进行分布式扩展 功能相对局限 文档型数据库 CouchDB, MongoDb Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容） Key-Value对应的键值对，Value为结构化数据 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 查询性能不高，而且缺乏统一的查询语法。 图形(Graph)数据库 Neo4J, InfoGrid, Infinite Graph 社交网络，推荐系统等。专注于构建关系图谱 图结构 利用图结构相关算法。比如最短路径寻址，N度关系查找等 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:1:5","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"二、Redis入门 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:2:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"概述 Redis是什么？ Redis（Remote Dictionary Server )，即远程字典服务。 是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 Redis能该干什么？ 内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF） 高效率、用于高速缓冲 发布订阅系统 地图信息分析 计时器、计数器(eg：浏览量) 。。。 特性 多样的数据类型 持久化 集群 事务 … ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:2:1","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"环境搭建 官网：https://redis.io/ 推荐使用Linux服务器学习。 windows版本的Redis已经停更很久了… ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:2:2","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"Windows安装 https://github.com/dmajkic/redis 解压安装包 开启redis-server.exe 启动redis-cli.exe测试 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:2:3","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"Linux安装 下载安装包！redis-5.0.8.tar.gz 解压Redis的安装包！程序一般放在 /opt 目录下 基本环境安装 yum install gcc-c++ # 然后进入redis目录下执行 make # 然后执行 make install redis默认安装路径 /usr/local/bin 将redis的配置文件复制到 程序安装目录 /usr/local/bin/kconfig下 redis默认不是后台启动的，需要修改配置文件！ 通过制定的配置文件启动redis服务 使用redis-cli连接指定的端口号测试，Redis的默认端口6379 查看redis进程是否开启 关闭Redis服务 shutdown 再次查看进程是否存在 后面我们会使用单机多Redis启动集群测试 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:2:4","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"测试性能 **redis-benchmark：**Redis官方提供的性能测试工具，参数选项如下： 简单测试： # 测试：100个并发连接 100000请求 redis-benchmark -h localhost -p 6379 -c 100 -n 100000 12 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:2:5","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"基础知识 redis默认有16个数据库 默认使用的第0个; 16个数据库为：DB 0~DB 15 默认使用DB 0 ，可以使用select n切换到DB n，dbsize可以查看当前数据库的大小，与key数量相关。 127.0.0.1:6379\u003e config get databases # 命令行查看数据库数量databases 1) \"databases\" 2) \"16\" 127.0.0.1:6379\u003e select 8 # 切换数据库 DB 8 OK 127.0.0.1:6379[8]\u003e dbsize # 查看数据库大小 (integer) 0 # 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。 127.0.0.1:6379\u003e set name sakura OK 127.0.0.1:6379\u003e SELECT 8 OK 127.0.0.1:6379[8]\u003e get name # db8中并不能获取db0中的键值对。 (nil) 127.0.0.1:6379[8]\u003e DBSIZE (integer) 0 127.0.0.1:6379[8]\u003e SELECT 0 OK 127.0.0.1:6379\u003e keys * 1) \"counter:__rand_int__\" 2) \"mylist\" 3) \"name\" 4) \"key:__rand_int__\" 5) \"myset:__rand_int__\" 127.0.0.1:6379\u003e DBSIZE # size和key个数相关 (integer) 5 keys * ：查看当前数据库中所有的key。 flushdb：清空当前数据库中的键值对。 flushall：清空所有数据库的键值对。 Redis是单线程的，Redis是基于内存操作的。 所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。 那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+ Redis为什么单线程还这么快？ 误区1：高性能的服务器一定是多线程的？ 误区2：多线程（CPU上下文会切换！）一定比单线程效率高！ 核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:2:6","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"三、五大数据类型 Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:3:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"Redis-key 在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。 下面学习的命令： exists key：判断键是否存在 del key：删除键值对 move key db：将键值对移动到指定数据库 expire key second：设置键值对的过期时间 type key：查看value的数据类型 127.0.0.1:6379\u003e keys * # 查看当前数据库所有key (empty list or set) 127.0.0.1:6379\u003e set name qinjiang # set key OK 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e keys * 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e move age 1 # 将键值对移动到指定数据库 (integer) 1 127.0.0.1:6379\u003e EXISTS age # 判断键是否存在 (integer) 0 # 不存在 127.0.0.1:6379\u003e EXISTS name (integer) 1 # 存在 127.0.0.1:6379\u003e SELECT 1 OK 127.0.0.1:6379[1]\u003e keys * 1) \"age\" 127.0.0.1:6379[1]\u003e del age # 删除键值对 (integer) 1 # 删除个数 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e EXPIRE age 15 # 设置键值对的过期时间 (integer) 1 # 设置成功 开始计数 127.0.0.1:6379\u003e ttl age # 查看key的过期剩余时间 (integer) 13 127.0.0.1:6379\u003e ttl age (integer) 11 127.0.0.1:6379\u003e ttl age (integer) 9 127.0.0.1:6379\u003e ttl age (integer) -2 # -2 表示key过期，-1表示key未设置过期时间 127.0.0.1:6379\u003e get age # 过期的key 会被自动delete (nil) 127.0.0.1:6379\u003e keys * 1) \"name\" 127.0.0.1:6379\u003e type name # 查看value的数据类型 string 关于TTL命令 Redis的key，通过TTL命令返回key的过期时间，一般来说有3种： 当前key没有设置过期时间，所以会返回-1. 当前key有设置过期时间，而且key已经过期，所以会返回-2. 当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间. 关于重命名RENAME和RENAMENX RENAME key newkey修改 key 的名称 RENAMENX key newkey仅当 newkey 不存在时，将 key 改名为 newkey 。 更多命令学习：https://www.redis.net.cn/order/ [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wBVZtGVm-1597890996517)(狂神说 Redis.assets/image-20200813114228439.png)] ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:3:1","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"String(字符串) 普通的set、get直接略过。 命令 描述 示例 APPEND key value 向指定的key的value后追加字符串 127.0.0.1:6379\u003e set msg hello OK 127.0.0.1:6379\u003e append msg \" world\" (integer) 11 127.0.0.1:6379\u003e get msg “hello world” DECR/INCR key 将指定key的value数值进行+1/-1(仅对于数字) 127.0.0.1:6379\u003e set age 20 OK 127.0.0.1:6379\u003e incr age (integer) 21 127.0.0.1:6379\u003e decr age (integer) 20 INCRBY/DECRBY key n 按指定的步长对数值进行加减 127.0.0.1:6379\u003e INCRBY age 5 (integer) 25 127.0.0.1:6379\u003e DECRBY age 10 (integer) 15 INCRBYFLOAT key n 为数值加上浮点型数值 127.0.0.1:6379\u003e INCRBYFLOAT age 5.2 “20.2” STRLEN key 获取key保存值的字符串长度 127.0.0.1:6379\u003e get msg “hello world” 127.0.0.1:6379\u003e STRLEN msg (integer) 11 GETRANGE key start end 按起止位置获取字符串（闭区间，起止位置都取） 127.0.0.1:6379\u003e get msg “hello world” 127.0.0.1:6379\u003e GETRANGE msg 3 9 “lo worl” SETRANGE key offset value 用指定的value 替换key中 offset开始的值 127.0.0.1:6379\u003e SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379\u003e get msg “tehello” GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 127.0.0.1:6379\u003e GETSET msg test “hello world” SETNX key value 仅当key不存在时进行set 127.0.0.1:6379\u003e SETNX msg test (integer) 0 127.0.0.1:6379\u003e SETNX name sakura (integer) 1 SETEX key seconds value set 键值对并设置过期时间 127.0.0.1:6379\u003e setex name 10 root OK 127.0.0.1:6379\u003e get name (nil) MSET key1 value1 [key2 value2..] 批量set键值对 127.0.0.1:6379\u003e MSET k1 v1 k2 v2 k3 v3 OK MSETNX key1 value1 [key2 value2..] 批量设置键值对，仅当参数中所有的key都不存在时执行 127.0.0.1:6379\u003e MSETNX k1 v1 k4 v4 (integer) 0 MGET key1 [key2..] 批量获取多个key保存的值 127.0.0.1:6379\u003e MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3” PSETEX key milliseconds value 和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间， getset key value 如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值 String类似的使用场景：value除了是字符串还可以是数字，用途举例： 计数器 统计多单位的数量：uid:123666：follow 0 粉丝数 对象存储缓存 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:3:2","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"List(列表) Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边） 一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。 首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等 正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN 命令 描述 LPUSH/RPUSH key value1[value2..] 从左边/右边向列表中PUSH值(一个或者多个)。 LRANGE key start end 获取list 起止元素==（索引从左往右 递增）== LPUSHX/RPUSHX key value 向已存在的列名中push值（一个或者多个） `LINSERT key BEFORE AFTER pivot value` LLEN key 查看列表长度 LINDEX key index 通过索引获取列表元素 LSET key index value 通过索引为元素设值 LPOP/RPOP key 从最左边/最右边移除值 并返回 RPOPLPUSH source destination 将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部 LTRIM key start end 通过下标截取指定范围内的列表 LREM key count value List中是允许value重复的 count \u003e 0：从头部开始搜索 然后删除指定的value 至多删除count个 count \u003c 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。 BLPOP/BRPOP key1[key2] timout 移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOPLPUSH source destination timeout 和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 ---------------------------LPUSH---RPUSH---LRANGE-------------------------------- 127.0.0.1:6379\u003e LPUSH mylist k1 # LPUSH mylist=\u003e{1} (integer) 1 127.0.0.1:6379\u003e LPUSH mylist k2 # LPUSH mylist=\u003e{2,1} (integer) 2 127.0.0.1:6379\u003e RPUSH mylist k3 # RPUSH mylist=\u003e{2,1,3} (integer) 3 127.0.0.1:6379\u003e get mylist # 普通的get是无法获取list值的 (error) WRONGTYPE Operation against a key holding the wrong kind of value 127.0.0.1:6379\u003e LRANGE mylist 0 4 # LRANGE 获取起止位置范围内的元素 1) \"k2\" 2) \"k1\" 3) \"k3\" 127.0.0.1:6379\u003e LRANGE mylist 0 2 1) \"k2\" 2) \"k1\" 3) \"k3\" 127.0.0.1:6379\u003e LRANGE mylist 0 1 1) \"k2\" 2) \"k1\" 127.0.0.1:6379\u003e LRANGE mylist 0 -1 # 获取全部元素 1) \"k2\" 2) \"k1\" 3) \"k3\" ---------------------------LPUSHX---RPUSHX----------------------------------- 127.0.0.1:6379\u003e LPUSHX list v1 # list不存在 LPUSHX失败 (integer) 0 127.0.0.1:6379\u003e LPUSHX list v1 v2 (integer) 0 127.0.0.1:6379\u003e LPUSHX mylist k4 k5 # 向mylist中 左边 PUSH k4 k5 (integer) 5 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"k1\" 5) \"k3\" ---------------------------LINSERT--LLEN--LINDEX--LSET---------------------------- 127.0.0.1:6379\u003e LINSERT mylist after k2 ins_key1 # 在k2元素后 插入ins_key1 (integer) 6 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"ins_key1\" 5) \"k1\" 6) \"k3\" 127.0.0.1:6379\u003e LLEN mylist # 查看mylist的长度 (integer) 6 127.0.0.1:6379\u003e LINDEX mylist 3 # 获取下标为3的元素 \"ins_key1\" 127.0.0.1:6379\u003e LINDEX mylist 0 \"k5\" 127.0.0.1:6379\u003e LSET mylist 3 k6 # 将下标3的元素 set值为k6 OK 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k5\" 2) \"k4\" 3) \"k2\" 4) \"k6\" 5) \"k1\" 6) \"k3\" ---------------------------LPOP--RPOP-------------------------- 127.0.0.1:6379\u003e LPOP mylist # 左侧(头部)弹出 \"k5\" 127.0.0.1:6379\u003e RPOP mylist # 右侧(尾部)弹出 \"k3\" ---------------------------RPOPLPUSH-------------------------- 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" 3) \"k6\" 4) \"k1\" 127.0.0.1:6379\u003e RPOPLPUSH mylist newlist # 将mylist的最后一个值(k1)弹出，加入到newlist的头部 \"k1\" 127.0.0.1:6379\u003e LRANGE newlist 0 -1 1) \"k1\" 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" 3) \"k6\" ---------------------------LTRIM-------------------------- 127.0.0.1:6379\u003e LTRIM mylist 0 1 # 截取mylist中的 0~1部分 OK 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"k4\" 2) \"k2\" # 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2 ---------------------------LREM-------------------------- 127.0.0.1:6379\u003e LREM mylist 3 k2 # 从头部开始搜索 至多删除3个 k2 (integer) 3 # 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2 127.0.0.1:6379\u003e LREM mylist -2 k2 #从尾部开始搜索 至多删除2个 k2 (integer) 2 # 删除后：mylist: k2,k2,k2,k4,k2,k2 ---------------------------BLPOP--BRPOP-------------------------- mylist: k2,k2,k2,k4,k2,k2 newlist: k1 127.0.0.1:6379\u003e BLPOP newlist mylist 30 # 从newlist中弹出第一个值，mylist作为候选 1) \"newlist\" # 弹出 2) \"k1\" 127.0.0.1:6379\u003e BLPOP newlist mylist 30 1) \"mylist\" # 由于newlist空了 从mylist中弹出 2) \"k2\" 127.0.0.1:6379\u003e BLPOP newlist 30 (30.10s) # 超时了 127.0.0.1:6379\u003e BLPOP newlist 30 # 我们连接另一个客户端向newlist中push了test, 阻塞被解决。 1) \"newlist\" 2) \"test\" (12.54s) 小结 list实际上是一个链表，before Node after , left, right 都可以插入值 如果key不存在，则创建新的链表 如果key存在，新增内容 如果移除了所有值，空链表，也代表不存在 在两边插入或者改动值，效率最高！修改中间元素，效率相对较低 应用： 消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop） ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:3:3","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"Set(集合) Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 命令 描述 SADD key member1[member2..] 向集合中无序增加一个/多个成员 SCARD key 获取集合的成员数 SMEMBERS key 返回集合中所有的成员 SISMEMBER key member 查询member元素是否是集合的成员,结果是无序的 SRANDMEMBER key [count] 随机返回集合中count个成员，count缺省值为1 SPOP key [count] 随机移除并返回集合中count个成员，count缺省值为1 SMOVE source destination member 将source集合的成员member移动到destination集合 SREM key member1[member2..] 移除集合中一个/多个成员 SDIFF key1[key2..] 返回所有集合的差集 key1- key2 - … SDIFFSTORE destination key1[key2..] 在SDIFF的基础上，将结果保存到集合中==(覆盖)==。不能保存到其他类型key噢！ SINTER key1 [key2..] 返回所有集合的交集 SINTERSTORE destination key1[key2..] 在SINTER的基础上，存储结果到集合中。覆盖 SUNION key1 [key2..] 返回所有集合的并集 SUNIONSTORE destination key1 [key2..] 在SUNION的基础上，存储结果到及和张。覆盖 SSCAN KEY [MATCH pattern] [COUNT count] 在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分 ---------------SADD--SCARD--SMEMBERS--SISMEMBER-------------------- 127.0.0.1:6379\u003e SADD myset m1 m2 m3 m4 # 向myset中增加成员 m1~m4 (integer) 4 127.0.0.1:6379\u003e SCARD myset # 获取集合的成员数目 (integer) 4 127.0.0.1:6379\u003e smembers myset # 获取集合中所有成员 1) \"m4\" 2) \"m3\" 3) \"m2\" 4) \"m1\" 127.0.0.1:6379\u003e SISMEMBER myset m5 # 查询m5是否是myset的成员 (integer) 0 # 不是，返回0 127.0.0.1:6379\u003e SISMEMBER myset m2 (integer) 1 # 是，返回1 127.0.0.1:6379\u003e SISMEMBER myset m3 (integer) 1 ---------------------SRANDMEMBER--SPOP---------------------------------- 127.0.0.1:6379\u003e SRANDMEMBER myset 3 # 随机返回3个成员 1) \"m2\" 2) \"m3\" 3) \"m4\" 127.0.0.1:6379\u003e SRANDMEMBER myset # 随机返回1个成员 \"m3\" 127.0.0.1:6379\u003e SPOP myset 2 # 随机移除并返回2个成员 1) \"m1\" 2) \"m4\" # 将set还原到{m1,m2,m3,m4} ---------------------SMOVE--SREM---------------------------------------- 127.0.0.1:6379\u003e SMOVE myset newset m3 # 将myset中m3成员移动到newset集合 (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset 1) \"m4\" 2) \"m2\" 3) \"m1\" 127.0.0.1:6379\u003e SMEMBERS newset 1) \"m3\" 127.0.0.1:6379\u003e SREM newset m3 # 从newset中移除m3元素 (integer) 1 127.0.0.1:6379\u003e SMEMBERS newset (empty list or set) # 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算 # setx=\u003e{m1,m2,m4,m6}, sety=\u003e{m2,m5,m6}, setz=\u003e{m1,m3,m6} -----------------------------SDIFF------------------------------------ 127.0.0.1:6379\u003e SDIFF setx sety setz # 等价于setx-sety-setz 1) \"m4\" 127.0.0.1:6379\u003e SDIFF setx sety # setx - sety 1) \"m4\" 2) \"m1\" 127.0.0.1:6379\u003e SDIFF sety setx # sety - setx 1) \"m5\" -------------------------SINTER--------------------------------------- # 共同关注（交集） 127.0.0.1:6379\u003e SINTER setx sety setz # 求 setx、sety、setx的交集 1) \"m6\" 127.0.0.1:6379\u003e SINTER setx sety # 求setx sety的交集 1) \"m2\" 2) \"m6\" -------------------------SUNION--------------------------------------- 127.0.0.1:6379\u003e SUNION setx sety setz # setx sety setz的并集 1) \"m4\" 2) \"m6\" 3) \"m3\" 4) \"m2\" 5) \"m1\" 6) \"m5\" 127.0.0.1:6379\u003e SUNION setx sety # setx sety 并集 1) \"m4\" 2) \"m6\" 3) \"m2\" 4) \"m1\" 5) \"m5\" ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:3:4","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"Hash（哈希） Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。 Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。 命令 描述 HSET key field value 将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0 HMSET key field1 value1 [field2 value2..] 同时将多个 field-value (域-值)对设置到哈希表 key 中。 HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。 HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。 HGET key field value 获取存储在哈希表中指定字段的值 HMGET key field1 [field2..] 获取所有给定字段的值 HGETALL key 获取在哈希表key 的所有字段和值 HKEYS key 获取哈希表key中所有的字段 HLEN key 获取哈希表中字段的数量 HVALS key 获取哈希表中所有值 HDEL key field1 [field2..] 删除哈希表key中一个/多个field字段 HINCRBY key field n 为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段 HINCRBYFLOAT key field n 为哈希表 key 中的指定字段的浮点数值加上增量 n。 HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对。 ------------------------HSET--HMSET--HSETNX---------------- 127.0.0.1:6379\u003e HSET studentx name sakura # 将studentx哈希表作为一个对象，设置name为sakura (integer) 1 127.0.0.1:6379\u003e HSET studentx name gyc # 重复设置field进行覆盖，并返回0 (integer) 0 127.0.0.1:6379\u003e HSET studentx age 20 # 设置studentx的age为20 (integer) 1 127.0.0.1:6379\u003e HMSET studentx sex 1 tel 15623667886 # 设置sex为1，tel为15623667886 OK 127.0.0.1:6379\u003e HSETNX studentx name gyc # HSETNX 设置已存在的field (integer) 0 # 失败 127.0.0.1:6379\u003e HSETNX studentx email 12345@qq.com (integer) 1 # 成功 ----------------------HEXISTS-------------------------------- 127.0.0.1:6379\u003e HEXISTS studentx name # name字段在studentx中是否存在 (integer) 1 # 存在 127.0.0.1:6379\u003e HEXISTS studentx addr (integer) 0 # 不存在 -------------------HGET--HMGET--HGETALL----------- 127.0.0.1:6379\u003e HGET studentx name # 获取studentx中name字段的value \"gyc\" 127.0.0.1:6379\u003e HMGET studentx name age tel # 获取studentx中name、age、tel字段的value 1) \"gyc\" 2) \"20\" 3) \"15623667886\" 127.0.0.1:6379\u003e HGETALL studentx # 获取studentx中所有的field及其value 1) \"name\" 2) \"gyc\" 3) \"age\" 4) \"20\" 5) \"sex\" 6) \"1\" 7) \"tel\" 8) \"15623667886\" 9) \"email\" 10) \"12345@qq.com\" --------------------HKEYS--HLEN--HVALS-------------- 127.0.0.1:6379\u003e HKEYS studentx # 查看studentx中所有的field 1) \"name\" 2) \"age\" 3) \"sex\" 4) \"tel\" 5) \"email\" 127.0.0.1:6379\u003e HLEN studentx # 查看studentx中的字段数量 (integer) 5 127.0.0.1:6379\u003e HVALS studentx # 查看studentx中所有的value 1) \"gyc\" 2) \"20\" 3) \"1\" 4) \"15623667886\" 5) \"12345@qq.com\" -------------------------HDEL-------------------------- 127.0.0.1:6379\u003e HDEL studentx sex tel # 删除studentx 中的sex、tel字段 (integer) 2 127.0.0.1:6379\u003e HKEYS studentx 1) \"name\" 2) \"age\" 3) \"email\" -------------HINCRBY--HINCRBYFLOAT------------------------ 127.0.0.1:6379\u003e HINCRBY studentx age 1 # studentx的age字段数值+1 (integer) 21 127.0.0.1:6379\u003e HINCRBY studentx name 1 # 非整数字型字段不可用 (error) ERR hash value is not an integer 127.0.0.1:6379\u003e HINCRBYFLOAT studentx weight 0.6 # weight字段增加0.6 \"90.8\" Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！Hash更适合于对象的存储，Sring更加适合字符串存储！ ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:3:5","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"Zset（有序集合） 不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。 score相同：按字典顺序排序 有序集合的成员是唯一的,但分数(score)却可以重复。 命令 描述 ZADD key score member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数 ZCARD key 获取有序集合的成员数 ZCOUNT key min max 计算在有序集合中指定区间score的成员数 ZINCRBY key n member 有序集合中对指定成员的分数加上增量 n ZSCORE key member 返回有序集中，成员的分数值 ZRANK key member 返回有序集合中指定成员的索引 ZRANGE key start end 通过索引区间返回有序集合成指定区间内的成员 ZRANGEBYLEX key min max 通过字典区间返回有序集合的成员 ZRANGEBYSCORE key min max 通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()== ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量 ZREM key member1 [member2..] 移除有序集合中一个/多个成员 ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员 ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员 ZREVRANGE key start end 返回有序集中指定区间内的成员，通过索引，分数从高到底 ZREVRANGEBYSCORRE key max min 返回有序集中指定分数区间内的成员，分数从高到低排序 ZREVRANGEBYLEX key max min 返回有序集中指定字典区间内的成员，按字典顺序倒序 ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 ZINTERSTORE destination numkeys key1 [key2 ..] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score ZUNIONSTORE destination numkeys key1 [key2..] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中 ZSCAN key cursor [MATCH pattern\\] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值） -------------------ZADD--ZCARD--ZCOUNT-------------- 127.0.0.1:6379\u003e ZADD myzset 1 m1 2 m2 3 m3 # 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2.. (integer) 2 127.0.0.1:6379\u003e ZCARD myzset # 获取有序集合的成员数 (integer) 2 127.0.0.1:6379\u003e ZCOUNT myzset 0 1 # 获取score在 [0,1]区间的成员数量 (integer) 1 127.0.0.1:6379\u003e ZCOUNT myzset 0 2 (integer) 2 ----------------ZINCRBY--ZSCORE-------------------------- 127.0.0.1:6379\u003e ZINCRBY myzset 5 m2 # 将成员m2的score +5 \"7\" 127.0.0.1:6379\u003e ZSCORE myzset m1 # 获取成员m1的score \"1\" 127.0.0.1:6379\u003e ZSCORE myzset m2 \"7\" --------------ZRANK--ZRANGE----------------------------------- 127.0.0.1:6379\u003e ZRANK myzset m1 # 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加 (integer) 0 127.0.0.1:6379\u003e ZRANK myzset m2 (integer) 2 127.0.0.1:6379\u003e ZRANGE myzset 0 1 # 获取索引在 0~1的成员 1) \"m1\" 2) \"m3\" 127.0.0.1:6379\u003e ZRANGE myzset 0 -1 # 获取全部成员 1) \"m1\" 2) \"m3\" 3) \"m2\" #testset=\u003e{abc,add,amaze,apple,back,java,redis} score均为0 ------------------ZRANGEBYLEX--------------------------------- 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + # 返回所有成员 1) \"abc\" 2) \"add\" 3) \"amaze\" 4) \"apple\" 5) \"back\" 6) \"java\" 7) \"redis\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + LIMIT 0 3 # 分页 按索引显示查询结果的 0,1,2条记录 1) \"abc\" 2) \"add\" 3) \"amaze\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset - + LIMIT 3 3 # 显示 3,4,5条记录 1) \"apple\" 2) \"back\" 3) \"java\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset (- [apple # 显示 (-,apple] 区间内的成员 1) \"abc\" 2) \"add\" 3) \"amaze\" 4) \"apple\" 127.0.0.1:6379\u003e ZRANGEBYLEX testset [apple [java # 显示 [apple,java]字典区间的成员 1) \"apple\" 2) \"back\" 3) \"java\" -----------------------ZRANGEBYSCORE--------------------- 127.0.0.1:6379\u003e ZRANGEBYSCORE myzset 1 10 # 返回score在 [1,10]之间的的成员 1) \"m1\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e ZRANGEBYSCORE myzset 1 5 1) \"m1\" 2) \"m3\" --------------------ZLEXCOUNT----------------------------- 127.0.0.1:6379\u003e ZLEXCOUNT testset - + (integer) 7 127.0.0.1:6379\u003e ZLEXCOUNT testset [apple [java (integer) 3 ------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE-------------------------------- 127.0.0.1:6379\u003e ZREM testset abc # 移除成员abc (integer) 1 127.0.0.1:6379\u003e ZREMRANGEBYLEX testset [apple [java # 移除字典区间[apple,java]中的所有成员 (integer) 3 127.0.0.1:6379\u003e ZREMRANGEBYRANK testset 0 1 # 移除排名0~1的所有成员 (integer) 2 127.0.0.1:6379\u003e ZREMRANGEBYSCORE myzset 0 3 # 移除score在 [0,3]的成员 (integer) 2 # testset=\u003e {abc,add,apple,amaze,back,java,redis} score均为0 # myzset=\u003e {(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)} ----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX----------- 127.0.0.1:6379\u003e ZREVRANGE myzset 0 3 # 按score递减排序，然后按索引，返回结果的 0~3 1) \"m9\" 2) \"m7\" 3) \"m4\" 4) \"m3\" 127.0.0.1:6379\u003e ZREVRANGE myzset 2 4 # 返回排序结果的 索引的2~4 1) \"m4\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e ZREVRANGEBYSCORE myzset 6 2 # 按score递减顺序 返回集合中分数在[2,6]之间的成员 1) \"m4\" 2) \"m3\" 3) \"m2\" 127.0.0.1:6379\u003e","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:3:6","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"四、三种特殊数据类型 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:4:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"Geospatial(地理位置) 使用经纬度定位地理坐标并用一个有序集合zset保存，所以zset命令也可以使用 命令 描述 geoadd key longitud(经度) latitude(纬度) member [..] 将具体经纬度的坐标存入一个有序集合 geopos key member [member..] 获取集合中的一个/多个成员坐标 geodist key member1 member2 [unit] 返回两个给定位置之间的距离。默认以米作为单位。 `georadius key longitude latitude radius m km GEORADIUSBYMEMBER key member radius... 功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。 geohash key member1 [member2..] 返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。 有效经纬度 有效的经度从-180度到180度。 有效的纬度从-85.05112878度到85.05112878度。 指定单位的参数 unit 必须是以下单位的其中一个： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 关于GEORADIUS的参数 通过georadius就可以完成 附近的人功能 withcoord:带上坐标 withdist:带上距离，单位与半径单位相同 COUNT n : 只显示前n个(按距离递增排序) ----------------georadius--------------------- 127.0.0.1:6379\u003e GEORADIUS china:city 120 30 500 km withcoord withdist # 查询经纬度(120,30)坐标500km半径内的成员 1) 1) \"hangzhou\" 2) \"29.4151\" 3) 1) \"120.20000249147415\" 2) \"30.199999888333501\" 2) 1) \"shanghai\" 2) \"205.3611\" 3) 1) \"121.40000134706497\" 2) \"31.400000253193539\" ------------geohash--------------------------- 127.0.0.1:6379\u003e geohash china:city yichang shanghai # 获取成员经纬坐标的geohash表示 1) \"wmrjwbr5250\" 2) \"wtw6ds0y300\" ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:4:1","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"Hyperloglog(基数统计) Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。 花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。 因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。 其底层使用string数据类型 什么是基数？ 数据集中不重复的元素的个数。 应用场景： 网页的访问量（UV）：一个用户多次访问，也只能算作一个人。 传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是计数，Hyperloglog就能帮助我们利用最小的空间完成。 命令 描述 PFADD key element1 [elememt2..] 添加指定元素到 HyperLogLog 中 PFCOUNT key [key] 返回给定 HyperLogLog 的基数估算值。 PFMERGE destkey sourcekey [sourcekey..] 将多个 HyperLogLog 合并为一个 HyperLogLog ----------PFADD--PFCOUNT--------------------- 127.0.0.1:6379\u003e PFADD myelemx a b c d e f g h i j k # 添加元素 (integer) 1 127.0.0.1:6379\u003e type myelemx # hyperloglog底层使用String string 127.0.0.1:6379\u003e PFCOUNT myelemx # 估算myelemx的基数 (integer) 11 127.0.0.1:6379\u003e PFADD myelemy i j k z m c b v p q s (integer) 1 127.0.0.1:6379\u003e PFCOUNT myelemy (integer) 11 ----------------PFMERGE----------------------- 127.0.0.1:6379\u003e PFMERGE myelemz myelemx myelemy # 合并myelemx和myelemy 成为myelemz OK 127.0.0.1:6379\u003e PFCOUNT myelemz # 估算基数 (integer) 17 如果允许容错，那么一定可以使用Hyperloglog ! 如果不允许容错，就使用set或者自己的数据类型即可 ！ ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:4:2","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"BitMaps(位图) 使用位存储，信息状态只有 0 和 1 Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。 应用场景 签到统计、状态统计 命令 描述 setbit key offset value 为指定key的offset位设置值 getbit key offset 获取offset位的值 bitcount key [start end] 统计字符串被设置为1的bit数，也可以指定统计范围按字节 bitop operration destkey key[key..] 对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。 BITPOS key bit [start] [end] 返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位 ------------setbit--getbit-------------- 127.0.0.1:6379\u003e setbit sign 0 1 # 设置sign的第0位为 1 (integer) 0 127.0.0.1:6379\u003e setbit sign 2 1 # 设置sign的第2位为 1 不设置默认 是0 (integer) 0 127.0.0.1:6379\u003e setbit sign 3 1 (integer) 0 127.0.0.1:6379\u003e setbit sign 5 1 (integer) 0 127.0.0.1:6379\u003e type sign string 127.0.0.1:6379\u003e getbit sign 2 # 获取第2位的数值 (integer) 1 127.0.0.1:6379\u003e getbit sign 3 (integer) 1 127.0.0.1:6379\u003e getbit sign 4 # 未设置默认是0 (integer) 0 -----------bitcount---------------------------- 127.0.0.1:6379\u003e BITCOUNT sign # 统计sign中为1的位数 (integer) 4 bitmaps的底层 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PlszjhS-1597890996519)(D:\\我\\MyBlog\\狂神说 Redis.assets\\image-20200803234336175.png)] 这样设置以后你能get到的值是：\\xA2\\x80，所以bitmaps是一串从左到右的二进制串 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:4:3","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"五、事务 Redis的单条命令是保证原子性的，但是redis事务不能保证原子性 Redis事务本质：一组命令的集合。 —————– 队列 set set set 执行 ——————- 事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。 一次性 顺序性 排他性 Redis事务没有隔离级别的概念 Redis单条命令是保证原子性的，但是事务不保证原子性！ ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:5:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"Redis事务操作过程 开启事务（multi） 命令入队 执行事务（exec） 所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。 127.0.0.1:6379\u003e multi # 开启事务 OK 127.0.0.1:6379\u003e set k1 v1 # 命令入队 QUEUED 127.0.0.1:6379\u003e set k2 v2 # .. QUEUED 127.0.0.1:6379\u003e get k1 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e keys * QUEUED 127.0.0.1:6379\u003e exec # 事务执行 1) OK 2) OK 3) \"v1\" 4) OK 5) 1) \"k3\" 2) \"k2\" 3) \"k1\" 取消事务(discurd) 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e DISCARD # 放弃事务 OK 127.0.0.1:6379\u003e EXEC (error) ERR EXEC without MULTI # 当前未开启事务 127.0.0.1:6379\u003e get k1 # 被放弃事务中命令并未执行 (nil) ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:5:1","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"事务错误 代码语法错误（编译时异常）所有的命令都不执行 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e error k1 # 这是一条语法错误命令 (error) ERR unknown command `error`, with args beginning with: `k1`, # 会报错但是不影响后续命令入队 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e EXEC (error) EXECABORT Transaction discarded because of previous errors. # 执行报错 127.0.0.1:6379\u003e get k1 (nil) # 其他命令并没有被执行 代码逻辑错误 (运行时异常) **其他命令可以正常执行 ** »\u003e 所以不保证事务原子性 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e INCR k1 # 这条命令逻辑错误（对字符串进行增量） QUEUED 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e exec 1) OK 2) OK 3) (error) ERR value is not an integer or out of range # 运行时报错 4) \"v2\" # 其他命令正常执行 # 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。 # 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:5:2","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"监控 悲观锁： 很悲观，认为什么时候都会出现问题，无论做什么都会加锁 乐观锁： 很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据 获取version 更新的时候比较version 使用watch key监控指定数据，相当于乐观锁加锁。 正常执行 127.0.0.1:6379\u003e set money 100 # 设置余额:100 OK 127.0.0.1:6379\u003e set use 0 # 支出使用:0 OK 127.0.0.1:6379\u003e watch money # 监视money (上锁) OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY use 20 QUEUED 127.0.0.1:6379\u003e exec # 监视值没有被中途修改，事务正常执行 1) (integer) 80 2) (integer) 20 测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion） 我们启动另外一个客户端模拟插队线程。 线程1： 127.0.0.1:6379\u003e watch money # money上锁 OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY use 20 QUEUED 127.0.0.1:6379\u003e # 此时事务并没有执行 模拟线程插队，线程2： 127.0.0.1:6379\u003e INCRBY money 500 # 修改了线程一中监视的money (integer) 600 12 回到线程1，执行事务： 127.0.0.1:6379\u003e EXEC # 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败 (nil) # 没有结果，说明事务执行失败 127.0.0.1:6379\u003e get money # 线程2 修改生效 \"600\" 127.0.0.1:6379\u003e get use # 线程1事务执行失败，数值没有被修改 \"0\" 解锁获取最新值，然后再加锁进行事务。 unwatch进行解锁。 注意：每次提交执行exec后都会自动释放锁，不管是否成功 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:5:3","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"六、Jedis 使用Java来操作Redis，Jedis是Redis官方推荐使用的Java连接redis的客户端。 导入依赖 \u003c!--导入jredis的包--\u003e \u003cdependency\u003e \u003cgroupId\u003eredis.clients\u003c/groupId\u003e \u003cartifactId\u003ejedis\u003c/artifactId\u003e \u003cversion\u003e3.2.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--fastjson--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.70\u003c/version\u003e \u003c/dependency\u003e 编码测试 连接数据库 修改redis的配置文件 vim /usr/local/bin/myconfig/redis.conf 1 将只绑定本地注释 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4IRUFJ95-1597890996520)(狂神说 Redis.assets/image-20200813161921480.png)] 保护模式改为 no [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oKjIVapw-1597890996521)(狂神说 Redis.assets/image-20200813161939847.png)] 允许后台运行 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-c2IMvpZL-1597890996522)(狂神说 Redis.assets/image-20200813161954567.png)] 开放端口6379 firewall-cmd --zone=public --add-port=6379/tcp --permanet 1 重启防火墙服务 systemctl restart firewalld.service 1 阿里云服务器控制台配置安全组 重启redis-server [root@AlibabaECS bin]# redis-server myconfig/redis.conf 1 操作命令 TestPing.java public class TestPing { public static void main(String[] args) { Jedis jedis = new Jedis(\"192.168.xx.xxx\", 6379); String response = jedis.ping(); System.out.println(response); // PONG } } 断开连接 事务 public class TestTX { public static void main(String[] args) { Jedis jedis = new Jedis(\"39.99.xxx.xx\", 6379); JSONObject jsonObject = new JSONObject(); jsonObject.put(\"hello\", \"world\"); jsonObject.put(\"name\", \"kuangshen\"); // 开启事务 Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); // jedis.watch(result) try { multi.set(\"user1\", result); multi.set(\"user2\", result); // 执行事务 multi.exec(); }catch (Exception e){ // 放弃事务 multi.discard(); } finally { // 关闭连接 System.out.println(jedis.get(\"user1\")); System.out.println(jedis.get(\"user2\")); jedis.close(); } } } ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:6:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"七、SpringBoot整合 导入依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。 jedis：采用的直连，多个线程操作的话，是不安全的。如果要避免不安全，使用jedis pool连接池！更像BIO模式 lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式 我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个自动配置类xxxAutoConfiguration,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。 那么就一定还存在一个RedisProperties类 之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。 先看Jedis: @ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的 然后再看Lettuce： 完美生效。 现在我们回到RedisAutoConfiguratio 只有两个简单的Bean RedisTemplate StringRedisTemplate 当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。 在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的 说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties 这是一些基本的配置属性。 还有一些连接池相关的配置。注意使用时一定使用Lettuce的连接池。 编写配置文件 # 配置redis spring.redis.host=39.99.xxx.xx spring.redis.port=6379 使用RedisTemplate @SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { // redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // opsForValue 操作字符串 类似String // opsForList 操作List 类似List // opsForHah // 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务和基本的CRUD // 获取连接对象 //RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); //connection.flushDb(); //connection.flushAll(); redisTemplate.opsForValue().set(\"mykey\",\"kuangshen\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\")); } } 测试结果 此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出： 这时候就关系到存储对象的序列化问题，在网络中传输的对象也是一样需要序列化，否者就全是乱码。 我们转到看那个默认的RedisTemplate内部什么样子： 在最开始就能看到几个关于序列化的参数。 默认的序列化器是采用JDK序列化器 而默认的RedisTemplate中的所有序列化器都是使用这个序列化器： 后续我们定制RedisTemplate就可以对其进行修改。 RedisSerializer提供了多种序列化方案： 直接调用RedisSerializer的静态方法来返回序列化器，然后set 自己new 相应的实现类，然后set 定制RedisTemplate的模板： 我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。 @Configuration public class RedisConfig { @Bean public RedisTemplate\u003cString, Object\u003e redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { // 将template 泛型设置为 \u003cString, Object\u003e RedisTemplate\u003cString, Object\u003e template = new RedisTemplate(); // 连接工厂，不必修改 template.setConnectionFactory(redisConnectionFactory); /* * 序列化设置 */ // key、hash的key 采用 String序列化方式 template.setKeySerializer(RedisSerializer.string()); template.setHashKeySerializer(RedisSerializer.string()); // value、hash的value 采用 Jackson 序列化方式 template.setValueSerializer(RedisSerializer.json()); template.setHashValueSerializer(RedisSerializer.json()); template.afterPropertiesSet(); return template; } } 这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oc8kJP08-1597890996523)(狂神说 Redis.assets/image-20200817175638086.png)] ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:7:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"八、自定义Redis工具类 使用RedisTemplate需要频繁调用.opForxxx然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是将这些常用的公共API抽取出来封装成为一个工具类，然后直接使用工具类来间接操作Redis,不但效率高并且易用。 工具类参考博客： https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html https://www.cnblogs.com/zhzhlong/p/11434284.html ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:8:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"九、Redis.conf 容量单位不区分大小写，G和GB有区别 可以使用 include 组合多个配置问题 网络配置 日志输出级别 日志输出文件 持久化规则 由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中 持久化方式： RDB AOF RDB文件相关 主从复制 Security模块中进行密码设置 客户端连接相关 maxclients 10000 最大客户端数量 maxmemory \u003cbytes\u003e 最大内存限制 maxmemory-policy noeviction # 内存达到限制值的处理策略 redis 中的默认的过期策略是 volatile-lru 。 设置方式 config set maxmemory-policy volatile-lru 1 maxmemory-policy 六种方式 **1、volatile-lru：**只对设置了过期时间的key进行LRU（默认值） 2、allkeys-lru ： 删除lru算法的key **3、volatile-random：**随机删除即将过期key **4、allkeys-random：**随机删除 5、volatile-ttl ： 删除即将过期的 6、noeviction ： 永不过期，返回错误 AOF相关部分 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:9:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"十、持久化—RDB RDB：Redis Databases [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-C0mm1D4A-1597890996524)(狂神说 Redis.assets/image-20200818122236614.png)] ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:10:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"什么是RDB 在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ； 默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:10:1","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"工作原理 在进行 RDB 的时候，redis 的主线程是不会做 io 操作的，主线程会 fork 一个子线程来完成该操作； Redis 调用forks。同时拥有父进程和子进程。 子进程将数据集写入到一个临时 RDB 文件中。 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。 这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。) ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:10:2","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"触发机制 save的规则满足的情况下，会自动触发rdb原则 执行flushall命令，也会触发我们的rdb原则 退出redis，也会自动产生rdb文件 save 使用 save 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了； 由于 save 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求。 flushall命令 flushall 命令也会触发持久化 ； 触发持久化规则 满足配置条件中的触发条件 ； 可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。 bgsave bgsave 是异步进行，进行持久化的时候，redis 还可以将继续响应客户端请求 ； bgsave和save对比 命令 save bgsave IO类型 同步 异步 阻塞？ 是 是（阻塞发生在fock()，通常非常快） 复杂度 O(n) O(n) 优点 不会消耗额外的内存 不阻塞客户端命令 缺点 阻塞客户端命令 需要fock子进程，消耗内存 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:10:3","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"优缺点 优点： 适合大规模的数据恢复 对数据的完整性要求不高 缺点： 需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。 fork进程的时候，会占用一定的内容空间。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:10:4","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"十一、持久化AOF Append Only File 将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z8wr9lBW-1597890996525)(狂神说 Redis.assets/image-20200818123711375.png)] 以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:11:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"什么是AOF 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。 如果要使用AOF，需要修改配置文件： appendonly no yes则表示启用AOF 默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！ 如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件 redis给我们提供了一个工具redis-check-aof --fix 优点和缺点 appendonly yes # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用 appendfilename \"appendonly.aof\" # appendfsync always # 每次修改都会sync 消耗性能 appendfsync everysec # 每秒执行一次 sync 可能会丢失这一秒的数据 # appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快 优点 每一次修改都会同步，文件的完整性会更加好 没秒同步一次，可能会丢失一秒的数据 从不同步，效率最高 缺点 相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！ Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:11:1","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"十二、RDB和AOP选择 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:12:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"RDB 和 AOF 对比 RDB AOF 启动优先级 低 高 体积 小 大 恢复速度 快 慢 数据安全性 丢数据 根据策略决定 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:12:1","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"如何选择使用哪种持久化方式？ 一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。 有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:12:2","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"十三、Redis发布与订阅 Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IBT2pjCa-1597890996526)(狂神说 Redis.assets/image-20200818162849693.png)] 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:13:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"命令 命令 描述 PSUBSCRIBE pattern [pattern..] 订阅一个或多个符合给定模式的频道。 PUNSUBSCRIBE pattern [pattern..] 退订一个或多个符合给定模式的频道。 PUBSUB subcommand [argument[argument]] 查看订阅与发布系统状态。 PUBLISH channel message 向指定频道发布消息 SUBSCRIBE channel [channel..] 订阅给定的一个或多个频道。 SUBSCRIBE channel [channel..] 退订一个或多个频道 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:13:1","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"示例 ------------订阅端---------------------- 127.0.0.1:6379\u003e SUBSCRIBE sakura # 订阅sakura频道 Reading messages... (press Ctrl-C to quit) # 等待接收消息 1) \"subscribe\" # 订阅成功的消息 2) \"sakura\" 3) (integer) 1 1) \"message\" # 接收到来自sakura频道的消息 \"hello world\" 2) \"sakura\" 3) \"hello world\" 1) \"message\" # 接收到来自sakura频道的消息 \"hello i am sakura\" 2) \"sakura\" 3) \"hello i am sakura\" --------------消息发布端------------------- 127.0.0.1:6379\u003e PUBLISH sakura \"hello world\" # 发布消息到sakura频道 (integer) 1 127.0.0.1:6379\u003e PUBLISH sakura \"hello i am sakura\" # 发布消息 (integer) 1 -----------------查看活跃的频道------------ 127.0.0.1:6379\u003e PUBSUB channels 1) \"sakura\" ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:13:2","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"原理 每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。 客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:13:3","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"缺点 如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。 这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:13:4","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"应用 消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现） 多人在线聊天室。 稍微复杂的场景，我们就会使用消息中间件MQ处理。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:13:5","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"十四、Redis主从复制 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:14:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。 默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:14:1","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。 故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式 负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。 高可用基石：主从复制还是哨兵和集群能够实施的基础。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:14:2","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"为什么使用集群 单台服务器难以负载大量的请求 单台服务器故障率高，系统崩坏概率大 单台服务器内存容量有限。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:14:3","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"环境配置 我们在讲解配置文件的时候，注意到有一个replication模块 (见Redis.conf中第8条) 查看当前库的信息：info replication 127.0.0.1:6379\u003e info replication # Replication role:master # 角色 connected_slaves:0 # 从机数量 master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息： 端口号 pid文件名 日志文件名 rdb文件名 启动单机多服务集群： ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:14:4","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"一主二从配置 ==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！ 认老大！一主（79）二从（80，81） 使用SLAVEOF host port就可以为从机配置主机了。 然后主机上也能看到从机的状态： 我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:14:5","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"使用规则 从机只能读，不能写，主机可读可写但是多用于写。 127.0.0.1:6381\u003e set name sakura # 从机6381写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6380\u003e set name sakura # 从机6380写入失败 (error) READONLY You can't write against a read only replica. 127.0.0.1:6379\u003e set name sakura OK 127.0.0.1:6379\u003e get name \"sakura\" 当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。 当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。 第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机： 从机手动执行命令slaveof no one,这样执行以后从机会独立出来成为一个主机 使用哨兵模式（自动选举） 如果没有老大了，这个时候能不能选择出来一个老大呢？手动！ 如果主机断开了连接，我们可以使用SLAVEOF no one让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！ ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:14:6","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"十五、哨兵模式 更多信息参考博客：https://www.jianshu.com/p/06ab9daf921d 主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。 单机单个哨兵 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-2ENYVAPp-1597890996527)(狂神说 Redis.assets/image-20200818233231154.png)] 哨兵的作用： 通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。 当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。 多哨兵模式 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Ga1RyfVc-1597890996528)(狂神说 Redis.assets/image-20200818233316478.png)] 哨兵的核心配置 sentinel monitor mymaster 127.0.0.1 6379 1 数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。 测试 redis-sentinel xxx/sentinel.conf 成功启动哨兵模式 此时哨兵监视着我们的主机6379，当我们断开主机后： 哨兵模式优缺点 优点： 哨兵集群，基于主从复制模式，所有主从复制的优点，它都有 主从可以切换，故障可以转移，系统的可用性更好 哨兵模式是主从模式的升级，手动到自动，更加健壮 缺点： Redis不好在线扩容，集群容量一旦达到上限，在线扩容就十分麻烦 实现哨兵模式的配置其实是很麻烦的，里面有很多配置项 哨兵模式的全部配置 完整的哨兵模式配置文件 sentinel.conf # Example sentinel.conf # 哨兵sentinel实例运行的端口 默认26379 port 26379 # 哨兵sentinel的工作目录 dir /tmp # 哨兵sentinel监控的redis主节点的 ip port # master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符\".-_\"组成。 # quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了 # sentinel monitor \u003cmaster-name\u003e \u003cip\u003e \u003credis-port\u003e \u003cquorum\u003e sentinel monitor mymaster 127.0.0.1 6379 1 # 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码 # 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 # sentinel auth-pass \u003cmaster-name\u003e \u003cpassword\u003e sentinel auth-pass mymaster MySUPER--secret-0123passw0rd # 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒 # sentinel down-after-milliseconds \u003cmaster-name\u003e \u003cmilliseconds\u003e sentinel down-after-milliseconds mymaster 30000 # 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步， 这个数字越小，完成failover所需的时间就越长， 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。 # sentinel parallel-syncs \u003cmaster-name\u003e \u003cnumslaves\u003e sentinel parallel-syncs mymaster 1 # 故障转移的超时时间 failover-timeout 可以用在以下这些方面： #1. 同一个sentinel对同一个master两次failover之间的间隔时间。 #2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。 #3.当想要取消一个正在进行的failover所需要的时间。 #4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 # 默认三分钟 # sentinel failover-timeout \u003cmaster-name\u003e \u003cmilliseconds\u003e sentinel failover-timeout mymaster 180000 # SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。 #对于脚本的运行结果有以下规则： #若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10 #若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。 #如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。 #一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 #通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本， #这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数， #一个是事件的类型， #一个是事件的描述。 #如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。 #通知脚本 # sentinel notification-script \u003cmaster-name\u003e \u003cscript-path\u003e sentinel notification-script mymaster /var/redis/notify.sh # 客户端重新配置主节点参数脚本 # 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。 # 以下参数将会在调用脚本时传给脚本: # \u003cmaster-name\u003e \u003crole\u003e \u003cstate\u003e \u003cfrom-ip\u003e \u003cfrom-port\u003e \u003cto-ip\u003e \u003cto-port\u003e # 目前\u003cstate\u003e总是“failover”, # \u003crole\u003e是“leader”或者“observer”中的一个。 # 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的 # 这个脚本应该是通用的，能被多次调用，不是针对性的。 # sentinel client-reconfig-script \u003cmaster-name\u003e \u003cscript-path\u003e sentinel client-reconfig-script mymaster /var/redis/reconfig.sh ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:15:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"十六、缓存穿透与雪崩 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:16:0","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"缓存穿透（查不到） 概念 在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。 解决方案 布隆过滤器 对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。 缓存空对象 一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。 这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间 即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:16:1","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"缓存击穿（量太大，缓存过期） 概念 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。 解决方案 设置热点数据永不过期 这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。 加互斥锁(分布式锁) 在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:16:2","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":["数据库"],"content":"缓存雪崩 概念 大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。 解决方案 redis高可用 这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群 限流降级 这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。 数据预热 数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。 ","date":"2021-04-06","objectID":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/:16:3","tags":["Redis"],"title":"Redis","uri":"/%E7%8B%82%E7%A5%9E%E8%AF%B4redis%E7%AC%94%E8%AE%B0csdn%E6%95%B4%E7%90%86%E7%89%88/"},{"categories":null,"content":" title: \"First\" subtitle: \"\" date: 2021-04-06T20:23:59+08:00 lastmod: 2021-04-06T20:23:59+08:00 draft: true author: \"\" authorLink: \"\" description: \"\" tags: [\"shrsr\"] categories: [\"15\"] hiddenFromHomePage: false hiddenFromSearch: false featuredImage: \"\" featuredImagePreview: \"\" toc: enable: true math: enable: false lightgallery: false license: \"\" 虽然不知道是如何 ","date":"0001-01-01","objectID":"/jenkins/:0:0","tags":null,"title":"","uri":"/jenkins/"}]