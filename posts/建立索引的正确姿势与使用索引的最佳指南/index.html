<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>建立索引的正确姿势与使用索引的最佳指南 - Eccentric&#39;s Note</title><meta name="Description" content="本站主要用来收集整理资料、记录笔记，方便自己查询使用。"><meta property="og:url" content="https://hubu8.github.io/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/">
  <meta property="og:site_name" content="Eccentric&#39;s Note">
  <meta property="og:title" content="建立索引的正确姿势与使用索引的最佳指南">
  <meta property="og:description" content="本站主要用来收集整理资料、记录笔记，方便自己查询使用。">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-11-26T16:00:30+08:00">
    <meta property="article:modified_time" content="2022-11-26T16:00:30+08:00">
    <meta property="article:tag" content="索引使用">
    <meta property="og:image" content="https://hubu8.github.io/logo.png">

  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:image" content="https://hubu8.github.io/logo.png">
  <meta name="twitter:title" content="建立索引的正确姿势与使用索引的最佳指南">
  <meta name="twitter:description" content="本站主要用来收集整理资料、记录笔记，方便自己查询使用。">
<meta name="application-name" content="Eccentric&#39;s Note">
<meta name="apple-mobile-web-app-title" content="Eccentric&#39;s Note"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="icon" href="/header_images/favicon-32x32.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://hubu8.github.io/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/" /><link rel="prev" href="https://hubu8.github.io/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/" /><link rel="next" href="https://hubu8.github.io/posts/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="/lib/fontawesome-free/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" href="/lib/animate/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "建立索引的正确姿势与使用索引的最佳指南",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/hubu8.github.io\/posts\/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97\/"
        },"genre": "posts","keywords": "索引使用","wordcount":  15284 ,
        "url": "https:\/\/hubu8.github.io\/posts\/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97\/","datePublished": "2022-11-26T16:00:30+08:00","dateModified": "2022-11-26T16:00:30+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "xxxx"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Eccentric&#39;s Note">Eccentric&#39;s Note</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/"> 首页 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/posts/"> 归档 </a><a class="menu-item" href="/pdflist/"> pdf </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="https://github.com/hubu8" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><a class="menu-item" href="/friend/" title="友链"> 友链 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Eccentric&#39;s Note">Eccentric&#39;s Note</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/" title="">首页</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/posts/" title="">归档</a><a class="menu-item" href="/pdflist/" title="">pdf</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="https://github.com/hubu8" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a class="menu-item" href="/friend/" title="友链">友链</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">建立索引的正确姿势与使用索引的最佳指南</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>xxxx</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>数据库</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2022-11-26">2022-11-26</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;约 15284 字&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;预计阅读 31 分钟&nbsp;<span id="/posts/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF%E4%B8%8E%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8C%87%E5%8D%97/" class="leancloud_visitors" data-flag-title="建立索引的正确姿势与使用索引的最佳指南">
                        <i class="far fa-eye fa-fw" aria-hidden="true"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#引言">引言</a></li>
    <li><a href="#一mysql各索引的优劣分析">一、MySQL各索引的优劣分析</a>
      <ul>
        <li><a href="#11主键索引存在的陷阱">1.1、主键索引存在的陷阱</a></li>
        <li><a href="#12联合索引存在的矛盾">1.2、联合索引存在的矛盾</a></li>
        <li><a href="#13前缀索引存在的弊端">1.3、前缀索引存在的弊端</a></li>
        <li><a href="#14全文索引存在的硬伤">1.4、全文索引存在的硬伤</a></li>
        <li><a href="#15唯一索引存在的快慢问题">1.5、唯一索引存在的快慢问题</a></li>
        <li><a href="#16哈希索引的致命问题">1.6、哈希索引的致命问题</a></li>
      </ul>
    </li>
    <li><a href="#二建立索引的正确姿势">二、建立索引的正确姿势</a>
      <ul>
        <li><a href="#21索引查询时的回表问题">2.1、索引查询时的回表问题</a></li>
        <li><a href="#22建立索引时需要遵守的原则">2.2、建立索引时需要遵守的原则</a></li>
        <li><a href="#23联合索引的最左前缀原则">2.3、联合索引的最左前缀原则</a></li>
      </ul>
    </li>
    <li><a href="#三索引失效与使用索引的正确姿势">三、索引失效与使用索引的正确姿势</a>
      <ul>
        <li><a href="#31索引失效的那些事儿">3.1、索引失效的那些事儿</a>
          <ul>
            <li><a href="#311执行分析工具---explain">3.1.1、执行分析工具 - ExPlain</a></li>
            <li><a href="#312查询中带有or会导致索引失效">3.1.2、查询中带有OR会导致索引失效</a></li>
            <li><a href="#313模糊查询中like以开头导致索引失效">3.1.3、模糊查询中like以%开头导致索引失效</a></li>
            <li><a href="#314字符类型查询时不带引号导致索引失效">3.1.4、字符类型查询时不带引号导致索引失效</a></li>
            <li><a href="#315索引字段参与计算导致索引失效">3.1.5、索引字段参与计算导致索引失效</a></li>
            <li><a href="#316字段被用于函数计算导致索引失效">3.1.6、字段被用于函数计算导致索引失效</a></li>
            <li><a href="#317违背最左前缀原则导致索引失效">3.1.7、违背最左前缀原则导致索引失效</a></li>
            <li><a href="#318不同字段值对比导致索引失效">3.1.8、不同字段值对比导致索引失效</a></li>
            <li><a href="#319反向范围操作导致索引失效">3.1.9、反向范围操作导致索引失效</a></li>
            <li><a href="#3110索引失效小结">3.1.10、索引失效小结</a></li>
          </ul>
        </li>
        <li><a href="#32使用索引的正确姿势">3.2、使用索引的正确姿势</a>
          <ul>
            <li><a href="#321索引覆盖">3.2.1、索引覆盖</a></li>
            <li><a href="#322索引下推">3.2.2、索引下推</a></li>
            <li><a href="#323mrrmulti-range-read机制">3.2.3、MRR(Multi-Range Read)机制</a></li>
            <li><a href="#324index-skip-scan索引跳跃式扫描">3.2.4、Index Skip Scan索引跳跃式扫描</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#四索引应用篇总结">四、索引应用篇总结</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><!--more-->
<h1 id="五mysql索引应用篇建立索引的正确姿势与使用索引的最佳指南">(五)MySQL索引应用篇：建立索引的正确姿势与使用索引的最佳指南！</h1>
<h2 id="引言">引言</h2>
<p>数据库索引，绝对是<code>MySQL</code>的核心功能之一，如果没有索引机制的数据库，那数据的检索效率绝对是令人无法接受的，毕竟没有索引的表数据，就如同一个普通的文本文件存储在磁盘中。在<a href="https://juejin.cn/post/7147609139974242317" target="_blank" rel="noopener noreffer ">《索引上篇》</a>中，我们对于<code>MySQL</code>提供的索引机制，从引入，到创建、使用、分类、管理&hellip;.等进行了全面阐述，相信经过上一篇的讲解后，大家对<code>MySQL</code>索引机制建立了系统化的认知，而本篇则会以上篇为基础，对索引机制进一步加深掌握。</p>
<p>不过在上篇中虽对数据库索引机制有了完善认知，但还不够，因为上篇仅是单纯的认知阶段，能否真正的在实际项目中运用好索引机制，还需要具备丰富的经验以及一些原则与方法论，比如下述一些关于索引的问题：</p>
<ul>
<li>索引虽然能给<code>MySQL</code>检索数据的效率带来质的飞跃，但加入索引未带来新问题吗？</li>
<li>既然索引能够提升查询性能，那是不是为表中每个字段建立索引，性能会更好？</li>
<li>一张数据表中，那些类型的字段不适合建立索引呢？又是因为什么原因呢？</li>
<li>表中会存在大量的字段，但其中那些字段建立索引才能够最大的性能收益呢？</li>
<li><code>MySQL</code>提供的索引种类也不少，一个字段上建立什么类型的索引才最好呢？</li>
<li>当表中存在多个索引时，一条查询<code>SQL</code>有多条路径可走，此时走哪条索引最好？</li>
<li><code>.......</code></li>
</ul>
<p>对于这些问题，如果仅靠上篇索引的知识，相信是很难回答具体的，那在本篇中，则重点讲解索引应用相关的方式方法，例如各索引优劣分析、建立索引的原则、使用索引的指南以及索引失效与索引优化等内容。</p>
<h2 id="一mysql各索引的优劣分析">一、MySQL各索引的优劣分析</h2>
<p>首先来聊聊索引机制带来的利害关系，有句古话曾说过：<strong>“凡事有利必有弊”</strong>，而<code>MySQL</code>的索引机制也不例外，引入索引机制后，能够给数据库带来的优势很明显：</p>
<ul>
<li>①整个数据库中，数据表的查询速度直线提升，数据量越大时效果越明显。</li>
<li>②通过创建唯一索引，可以确保数据表中的数据唯一性，无需额外建立唯一约束。</li>
<li>③在使用分组和排序时，同样可以显著减少<code>SQL</code>查询的分组和排序的时间。</li>
<li>④连表查询时，基于主外键字段上建立索引，可以带来十分明显的性能提升。</li>
<li>⑤索引默认是<code>B+Tree</code>有序结构，基于索引字段做范围查询时，效率会明显提高。</li>
<li>⑥从<code>MySQL</code>整体架构而言，减少了查询<code>SQL</code>的执行时间，提高了数据库整体吞吐量。</li>
</ul>
<p>看着上面一条又一条的好处，似乎感觉索引好处很大啊，对于这点确实毋庸置疑，但只有好处吗？<code>No</code>，同时也会带来一系列弊端，如：</p>
<ul>
<li>①建立索引会生成本地磁盘文件，需要额外的空间存储索引数据，磁盘占用率会变高。</li>
<li>②写入数据时，需要额外维护索引结构，增、删、改数据时，都需要额外操作索引。</li>
<li>③写入数据时维护索引需要额外的时间开销，执行写<code>SQL</code>时效率会降低，性能会下降。</li>
</ul>
<p>当然，但对数据库整体来说，索引带来的优势会大于劣势。不过也正由于索引存在弊端，因此索引不是越多越好，合理建立索引才是最佳选择。</p>
<blockquote>
<p>在上篇聊过，<code>MySQL</code>的索引也会分为多种类型，每个类型的索引多多少少都存在一些弊端，接下来聊聊其他类型的索引。</p></blockquote>
<h3 id="11主键索引存在的陷阱">1.1、主键索引存在的陷阱</h3>
<p>相信大家数据库的表中，主键一般都是使用自增<code>ID</code>，但这是为什么呢？有人可能会回答自增<code>ID</code>不会重复，确保了主键唯一性。这样也确实没错，但不会重复的又不仅仅只有自增<code>ID</code>，比如我使用随机的<code>UUID</code>也不会重复，为何不使用<code>UUID</code>呢？这是由于索引存在一个陷阱！</p>
<blockquote>
<p>众所周知，一张表中大多数情况下，会将主键索引以聚簇的形式存在磁盘中，上篇文章也聊到过，聚簇索引在存储数据时，表数据和索引数据是一起存放的。同时，<code>MySQL</code>默认的索引结构是<code>B+Tree</code>，也就代表着索引节点的数据是有序的。</p></blockquote>
<p>此时结合上面给出的一些信息，主键索引是聚簇索引，表数据和索引数据在一块、索引结构是有序的，那再反推前面给出的疑惑，为何不使用<code>UUID</code>呢？因为<code>UUID</code>是无序的，如果使用<code>UUID</code>作为主键，那么每当插入一条新数据，都有可能破坏原本的树结构，如下：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/index-suoyin.jpg"
        data-srcset="./images/index-suoyin.jpg, ./images/index-suoyin.jpg 1.5x, ./images/index-suoyin.jpg 2x"
        data-sizes="auto"
        alt="./images/index-suoyin.jpg"
        title="索引维护" />
比如上图中的灰色节点，是一条新插入的数据，此时经过计算后，应该排第二个位置，那就代表着后面的三个节点需要移动，然后给灰色节点挪出一个位置存储，从而确保索引的有序性。</p>
<blockquote>
<p>这里只是伪逻辑，目的是用于举例演示，实际上<code>B+</code>树索引结构不长这样，在《索引原理篇》会重新说一下这个点的。</p></blockquote>
<p>由于主键索引是聚簇索引，因此上述案例中，当后续节点需要挪动时，也就代表着还需要挪动表数据，如果是偶尔需要移动还行，但如果主键字段值无序，那代表着几乎每次插入都有可能导致树结构要调整。</p>
<blockquote>
<p>但使用自增<code>ID</code>就不会有这个问题，所有新插入的数据都会放到最后。</p></blockquote>
<p>因此大家数据表的主键，最好选用带顺序性的值，否则有可能掉入主键索引的“陷阱”中。</p>
<h3 id="12联合索引存在的矛盾">1.2、联合索引存在的矛盾</h3>
<p>为了多条件查询时的效率更高，一般都会同时对多个字段建立联合索引，但之前也聊到过，联合索引存在一个致命的问题，比如在用户表中，通过<code>id、name、age</code>三个字段建立一个联合索引，此时来了一条查询<code>SQL</code>，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_user</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;竹子&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;18&#34;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>而这条<code>SQL</code>语句是无法使用联合索引的，为什么呢？因为查询条件中，未包含联合索引的第一个字段，想要使用联合索引，那么查询条件中必须包含索引的第一个字段，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_user</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;竹子&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面这条<code>SQL</code>才是能命中多列索引的语句，因此在建立索引时也需要考虑这个问题，确保建立出的联合索引能够命中率够高。</p>
<h3 id="13前缀索引存在的弊端">1.3、前缀索引存在的弊端</h3>
<p>前缀索引的特点是短小精悍，我们可以利用一个字段的前<code>N</code>个字符创建索引，以这种形式创建的索引也被称之为前缀索引，相较于使用一个完整字段创建索引，前缀索引能够更加节省存储空间，当数据越多时，带来的优势越明显。</p>
<blockquote>
<p>不过前缀索引虽然带来了节省空间的好处，但也正由于其索引节点中，未存储一个字段的完整值，所以<code>MySQL</code>也无法通过前缀索引来完成<code>ORDER BY、GROUP BY</code>等分组排序工作，同时也无法完成覆盖扫描等操作。</p></blockquote>
<h3 id="14全文索引存在的硬伤">1.4、全文索引存在的硬伤</h3>
<p>之前做模糊查询时，通常都会使用<code>like%</code>语法，不过这种方式虽然能够实现效果，但随着表越来越大，数据越来越多时，其性能会出现明显下降，而全文索引的推出则能够完美解决该问题，可以利用全文索引代替<code>like%</code>语法实现模糊查询，它的性能会比<code>like%</code>快上<code>N</code>倍。</p>
<blockquote>
<p>全文索引虽然可以实现模糊查询，但也存在一系列硬伤，一起来看看。</p></blockquote>
<p>①由于全文索引是基于分词实现的，所以对一个字段建立全文索引后，<code>MySQL</code>会对该字段做分词处理，这些分词结果也会被存储在全文索引中，因此全文索引的文件会额外的大！</p>
<p>②由于全文索引对每个字段值都会做分词，因此当修改字段值后，分词是需要时间的，所以修改字段数据后不会立马自动更新全文索引，此时需要咱们写存储过程，并调用它手动更新全文索引中的数据。</p>
<p>③除开上述两点外，全文索引最大的硬伤在于对中文支持不够友好，类似于英文可以直接通过符号、空格来分词，但中文呢？一个词语来形容就是博大精深，无法精准的对一段文字做分词，因此全文索引在检索中文时，存在些许精准度问题。</p>
<blockquote>
<p>因此如果你项目规模较大，通常再引入<code>ElasticSearch、Solr、MeiliSearch</code>等搜索引擎是一个更佳的选择。</p></blockquote>
<h3 id="15唯一索引存在的快慢问题">1.5、唯一索引存在的快慢问题</h3>
<p>唯一索引有个很大的好处，就是查询数据时会比普通索引效率更高，因为基于普通索引的字段查询数据，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">TABLE_XX</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">COLUMN_XX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;XX&#34;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>假设<code>COLUMN_XX</code>字段上建立了一个普通索引，此时基于这个字段查询数据时，当查询到一条<code>COLUMN_XX = &quot;XX&quot;</code>的数据后，此时会继续走完整个索引树，因为可能会存在多条字段值相同的数据。</p>
<blockquote>
<p>但如果<code>COLUMN_XX</code>字段上建立的是唯一索引，当找到一条数据后就会立马停下检索，因此本身建立唯一索引的字段值就具备唯一性。</p></blockquote>
<p>因此唯一索引查询数据时，会比普通索引快上一截，但插入数据时就不同了，因为要确保数据不重复，所以插入前会检查一遍表中是否存在相同的数据。但普通索引则不需要考虑这个问题，因此普通索引的数据插入会快一些。</p>
<h3 id="16哈希索引的致命问题">1.6、哈希索引的致命问题</h3>
<p>哈希索引，也就是数据结构为<code>Hash</code>类型的索引，不过估计大家接触的比较少，毕竟创建索引时都默认用的<code>B+</code>树结构。但要比起查询速度，哈希索引绝对是<code>MySQL</code>中当之无愧的魁首！因为采用哈希结构的索引，会以哈希表的形式存储索引字段值，当基于该字段查询数据时，只需要经过一次哈希计算就可获取到数据。</p>
<blockquote>
<p>但哈希结构的致命问题在于无序，也就是无法基于哈希索引的字段做排序、分组等工作。</p></blockquote>
<p>因此如果你确定一个表中，不会做排序这类的工作，那可以适当选用哈希结构作为索引的数据结构，它会给你带来意想不到的性能收益~</p>
<h2 id="二建立索引的正确姿势">二、建立索引的正确姿势</h2>
<p>经过上述一系列分析后，简单讲明了每种索引类型存在的缺陷问题，但这跟我们本篇有啥关系呢？其实关系很大，因为只有当你了解了每种索引存在的劣势，才能更好的考虑并设计出合理的索引，而不是一股脑的盲目创建索引。</p>
<blockquote>
<p>那么在创建索引时，咱们应当遵守那些原理原则，才能创建出合理的索引呢？</p></blockquote>
<p>在实际项目场景中，当<code>SQL</code>查询性能较慢时，我们常常会有一个疑惑：<strong>表中哪个字段建立一个索引能带来最大的性能收益呢</strong>？一般来说，判断字段是否要添加的索引的依据，是看这个字段是否被经常当做查询条件使用，但也不能光依靠这一个依据来判断，比如用户表中的性别字段，就会经常被用做查询条件，但如果对性别字段建立一个索引，那对查询的性能提升并不大，因为性别就两个值：男/女（不包含泰国在内），那对其建立索引，索引文件中就只会有两个索引节点，大致情况如下：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/b81d3711e1394d319ab06fdb2594c509tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/b81d3711e1394d319ab06fdb2594c509tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/b81d3711e1394d319ab06fdb2594c509tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/b81d3711e1394d319ab06fdb2594c509tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/b81d3711e1394d319ab06fdb2594c509tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="性别索引" />
这种情况下，为性别建立一个索引，带来的性能收益显然不是太大。同时，上图中给出的案例，也不是索引真正的样子，如果表中存在主键索引或聚簇索引，对其他字段建立的索引，都是次级索引，也被称为辅助索引，其节点上的值，存储的并非一条完整的行数据，而是指向聚簇索引的索引字段值。</p>
<blockquote>
<p>如果基于辅助索引查询数据，最终数据会以何种方式被检索出来，这里就牵扯到<code>MySQL</code>中的一个新概念，也就是<code>SQL</code>执行时的回表问题。</p></blockquote>
<h3 id="21索引查询时的回表问题">2.1、索引查询时的回表问题</h3>
<p>什么叫做回表呢？意思就是指一条<code>SQL</code>语句在<code>MySQL</code>内部，要经过两次查询过程才能获取到数据。这是跟索引机制有关的，先来看看索引在<code>MySQL</code>内部真正的面貌：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/2549441191b14183b7df0c14aba85cbetplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/2549441191b14183b7df0c14aba85cbetplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/2549441191b14183b7df0c14aba85cbetplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/2549441191b14183b7df0c14aba85cbetplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/2549441191b14183b7df0c14aba85cbetplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="表中索引结构" />
在上图用户表中，基于<code>ID</code>字段先建立了一个主键索引，然后又基于<code>name</code>字段建立了一个普通索引，此时<code>MySQL</code>默认会选用主键索引作为聚簇索引，将表数据和主键索引存在同一个文件中，也就是主键索引的每个索引节点，都直接对应着行数据。而基于<code>name</code>字段建立的索引，其索引节点存放的则是指向聚簇索引的<code>ID</code>值。</p>
<blockquote>
<p>在这种情况下，假设有一条下述<code>SQL</code>，其内部查询过程是啥样的呢？</p></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_user</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;子竹&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先会走<code>name</code>字段的索引，然后找到对应的<code>ID</code>值，然后再基于查询到的<code>ID</code>值，再走<code>ID</code>字段的主键索引，最终得到一整条行数据并返回。</p>
<blockquote>
<p>在这个案例中，一条查询<code>SQL</code>经历了两次查询才获取到数据，这个过程则被称之为回表。</p></blockquote>
<p>回表动作会导致额外的查询开销，因此尽量可以基于主键做查询，如果实在需要使用非主键字段查询，那么尽量要写明查询的结果字段，而并非使用<code>*</code>。</p>
<blockquote>
<p>当然，实际情况中建立联合索引，利用索引覆盖特性，从而避免使用辅助索引，这样也能够消除回表动作，但关于这点后面再聊，先来说说建立索引需要遵循的一些原则。</p></blockquote>
<h3 id="22建立索引时需要遵守的原则">2.2、建立索引时需要遵守的原则</h3>
<p>前面说过一点，当建立索引仅考虑一个字段是否被经常用于查询是不够的，往往一个合适的索引需要更为细致与长远的思考，例如使用多个字段建立是否会更好？创建其他类型的索引性能是否会更佳？下面我们就一起来看看建立索引时，需要遵守的一些原则：</p>
<ul>
<li>①经常频繁用作查询条件的字段应酌情考虑为其创建索引。</li>
<li>②表的主外键或连表字段，必须建立索引，因为能很大程度提升连表查询的性能。</li>
<li>③建立索引的字段，一般值的区分性要足够高，这样才能提高索引的检索效率。</li>
<li>④建立索引的字段，值不应该过长，如果较长的字段要建立索引，可以选择前缀索引。</li>
<li>⑤建立联合索引，应当遵循最左前缀原则，将多个字段之间按优先级顺序组合。</li>
<li>⑥经常根据范围取值、排序、分组的字段应建立索引，因为索引有序，能加快排序时间。</li>
<li>⑦对于唯一索引，如果确认不会利用该字段排序，那可以将结构改为<code>Hash</code>结构。</li>
<li>⑧尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。</li>
</ul>
<p>同时，除开上述一些建立索引的原则外，在建立索引时还需有些注意点：</p>
<ul>
<li>❶值经常会增删改的字段，不合适建立索引，因为每次改变后需维护索引结构。</li>
<li>❷一个字段存在大量的重复值时，不适合建立索引，比如之前举例的性别字段。</li>
<li>❸索引不能参与计算，因此经常带函数查询的字段，并不适合建立索引。</li>
<li>❹一张表中的索引数量并不是越多越好，一般控制在<code>3</code>，最多不能超过<code>5</code>。</li>
<li>❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。</li>
<li>❻当表的数据较少，不应当建立索引，因为数据量不大时，维护索引反而开销更大。</li>
<li>❼索引的字段值无序时，不推荐建立索引，因为会造成页分裂，尤其是主键索引。</li>
</ul>
<p>对于索引机制，在建立时应当参考上述给出的意见，这每一条原则都是从实际经验中总结出来的，前面八条不一定要全面思考，但后面七条注意点，一定要牢记，如若你的索引符合后面七条中的描述，那一定要更改索引。</p>
<blockquote>
<p>对于每一条建议是为什么，在后面的《索引原理篇》讲完之后大家就会彻底理解，这里就不展开叙述了，接下来重点聊一下联合索引，以及它的最左前缀原则。</p></blockquote>
<h3 id="23联合索引的最左前缀原则">2.3、联合索引的最左前缀原则</h3>
<p>首先在讲最左前缀原则之前，先看看上述给出的一条原则：</p>
<ul>
<li>⑧尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。</li>
</ul>
<p>对于这一点是为什么呢？举个栗子理解，比如此时基于<code>X、Y、Z</code>字段建立了一个联合索引，实际上也相当于建立了三个索引：<code>X</code>、<code>X、Y</code>、<code>X、Y、Z</code>，因此只要查询中使用了这三组字段，都可以让联合索引生效。</p>
<blockquote>
<p>但如若查询中这三个字段不以<code>AND</code>形式出现，而是单独作为查询条件出现，那单值索引性能会好一些，但三个不同的索引，维护的代价也会高一些。</p></blockquote>
<p>其实联合索引的最左前缀原则，道理很简单的，就是组成联合索引的多个列，越靠左边优先级越高，同时也只有<code>SQL</code>查询条件中，包含了最左的字段，才能使用联合索引，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 基于上面的哪个X、Y、Z联合索引
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">tb</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;...&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;...&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面这条<code>SQL</code>就显然并不会使用联合索引，因为不符合最左前缀原则，最左侧的<code>X</code>字段未曾被使用。也正由于<code>MySQL</code>在使用联合索引时会遵循最左前缀原则，所以才在前面建立索引的建议中给出了一条：</p>
<ul>
<li>❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。</li>
</ul>
<p>因为将查询频率越高的字段放首位，就代表着查询时命中索引的几率越大。同时，<code>MySQL</code>的最左前缀原则，才匹配到范围查询时会停止匹配，比如<code>&gt;、&lt;、between、like</code>这类范围条件，并不会继续使用联合索引，举个栗子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">tb</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">X</span><span class="o">=</span><span class="s2">&#34;...&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="s2">&#34;...&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">Z</span><span class="o">=</span><span class="s2">&#34;...&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>当执行时，虽然上述<code>SQL</code>使用到<code>X、Y、Z</code>作为查询条件，但由于<code>Y</code>字段是<code>&gt;</code>范围查询，因此这里只能使用<code>X</code>索引，而不能使用<code>X、Y</code>或<code>X、Y、Z</code>索引。</p>
<blockquote>
<p>对于一条查询<code>SQL</code>是否用到了索引，或者一条查询<code>SQL</code>到底用了那个索引，其实可以通过<code>MySQL</code>自带的<code>explain</code>工具分析（后续讲解）。</p></blockquote>
<p>最后再来一个简单的栗子，加深一下对于联合索引的认知：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;竹子&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;竹子&#39;</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">A</span><span class="p">.</span><span class="w"> </span><span class="k">create</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="n">index_name</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="k">user</span><span class="p">(</span><span class="n">name</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="k">create</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="n">index_name</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="k">user</span><span class="p">(</span><span class="n">age</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">B</span><span class="p">.</span><span class="w"> </span><span class="k">create</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="n">index_name</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="k">user</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">age</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>比如上述这个案例中，对于这两条<code>SQL</code>选第一种方式创建索引，还是第二种呢？答案是<code>B</code>，因为两条<code>sql</code>完全能够利用到第二个创建的联合索引。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;竹子&#39;</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">where</span><span class="w">  </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;竹子&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>同时选<code>B</code>建立联合索引后，如上两条<code>SQL</code>都会利用到上面创建的联合索引，<code>SQL</code>是否走索引查询跟<code>where</code>后的条件顺序无关，因为<code>MySQL</code>优化器会优化，对<code>SQL</code>查询条件进行重排序。</p>
<h2 id="三索引失效与使用索引的正确姿势">三、索引失效与使用索引的正确姿势</h2>
<p>相信这一点大家看了有些懵，啥叫使用索引的正确姿势？索引不是<code>MySQL</code>执行<code>SQL</code>时自动选择的吗？我们只能建立索引，怎么使用啊？其实这里是指我们编写<code>SQL</code>时，要注意的点，毕竟<code>MySQL</code>查询时到底使不使用索引，这完全取决于你编写的<code>SQL</code>。</p>
<blockquote>
<p>但很多小伙伴在平时写<code>SQL</code>的时候，一般只追求实现业务功能，只要能够查询出相应的数据即可，压根不会过度考虑这条<code>SQL</code>应用到索引，那么这里就是给出一些经验之谈，讲清楚几点写<code>SQL</code>时的方法论。</p></blockquote>
<p>其实索引本身是一把双刃剑，用的好能够给我们带来异乎寻常的查询效率，用的不好则反而会带来额外的磁盘占用及写入操作时的维护开销。因此大家一定要切记，既然选择建了索引，那一定要利用它，否则还不如干脆别建，既能节省磁盘空间，又能提升写入效率。</p>
<h3 id="31索引失效的那些事儿">3.1、索引失效的那些事儿</h3>
<p>想要用好索引，那一定要先搞清楚那些情况会导致索引失效，弄明白这些事项之后，在写<code>SQL</code>的时候刻意避开，那你写出来的<code>SQL</code>十有八九是会用到索引的，那么在数据库中那些情况下会导致索引失效呢？下面一起来聊一聊，但单纯的讲概念会有种纸上谈兵的感觉，因此下面简单的举个案例，然后来说明索引失效的一些情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">+</span><span class="c1">---------+-----------+----------+----------+---------------------+
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">|</span><span class="w"> </span><span class="n">user_id</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">user_name</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">user_sex</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">password</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">register_time</span><span class="w">       </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">+</span><span class="c1">---------+-----------+----------+----------+---------------------+
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">|</span><span class="w">       </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="err">熊猫</span><span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="err">女</span><span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="mi">6666</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="mi">2022</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">14</span><span class="w"> </span><span class="mi">15</span><span class="p">:</span><span class="mi">22</span><span class="p">:</span><span class="mi">01</span><span class="w"> </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">|</span><span class="w">       </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="err">竹子</span><span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="err">男</span><span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="mi">1234</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="mi">2022</span><span class="o">-</span><span class="mi">09</span><span class="o">-</span><span class="mi">14</span><span class="w"> </span><span class="mi">16</span><span class="p">:</span><span class="mi">17</span><span class="p">:</span><span class="mi">44</span><span class="w"> </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">|</span><span class="w">       </span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="err">子竹</span><span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="err">男</span><span class="w">       </span><span class="o">|</span><span class="w"> </span><span class="mi">4321</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="mi">2022</span><span class="o">-</span><span class="mi">09</span><span class="o">-</span><span class="mi">16</span><span class="w"> </span><span class="mi">07</span><span class="p">:</span><span class="mi">42</span><span class="p">:</span><span class="mi">21</span><span class="w"> </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">+</span><span class="c1">---------+-----------+----------+----------+---------------------+
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="n">p_user_id</span><span class="o">`</span><span class="p">(</span><span class="o">`</span><span class="n">user_id</span><span class="o">`</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="n">unite_index</span><span class="o">`</span><span class="p">(</span><span class="o">`</span><span class="n">user_name</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">user_sex</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">password</span><span class="o">`</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此时对这张用户表，分别创建两个索引，第一个是基于<code>user_id</code>创建的主键索引，第二个是使用<code>user_name、user_sex、password</code>三个字段创建的联合索引。</p>
<blockquote>
<p>但想要查看一条<code>SQL</code>是否使用了索引，需要用到一个自带的分析工具<code>ExPlain</code>，下面简单介绍一下。</p></blockquote>
<h4 id="311执行分析工具---explain">3.1.1、执行分析工具 - ExPlain</h4>
<p>这里就对<code>explain</code>工具做一个简单介绍，后续《SQL优化篇》会详细讲解这个工具，先来看看这个工具/命令的作用，当在一条<code>SQL</code>前加上<code>explain</code>命令，执行这条<code>SQL</code>后会列出所有的执行方案：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">+</span><span class="c1">----+-------------+----------+------+---------------+------+---------+------+------+-------+
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">|</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">select_type</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">table</span><span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">possible_keys</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">key</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">key_len</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">ref</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="k">rows</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Extra</span><span class="w"> </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">+</span><span class="c1">----+-------------+----------+------+---------------+------+---------+------+------+-------+
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="o">|</span><span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">SIMPLE</span><span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="n">zz_users</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">ALL</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="k">NULL</span><span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">NULL</span><span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="o">|</span><span class="w">    </span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w">       </span><span class="o">|</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">+</span><span class="c1">----+-------------+----------+------+---------------+------+---------+------+------+-------+
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p><code>id</code>：这是执行计划的<code>ID</code>值，这个值越大，表示执行的优先级越高。</p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select_type
</span></span></code></pre></td></tr></table>
</div>
</div><p>：当前查询语句的类型，有如下几个值：</p>
<ul>
<li><code>simple</code>：简单查询。</li>
<li><code>primary</code>：复杂查询的外层查询。</li>
<li><code>subquery</code>：包含在查询语句中的子查询。</li>
<li><code>derived</code>：包含在<code>FROM</code>中的子查询。</li>
</ul>
</li>
<li>
<p><code>table</code>：表示当前这个执行计划是基于那张表执行的。</p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type
</span></span></code></pre></td></tr></table>
</div>
</div><p>：当前执行计划查询的类型，有几种情况：</p>
<ul>
<li><code>all</code>：表示走了全表查询，未命中索引或索引失效。</li>
<li><code>system</code>：表示要查询的表中仅有一条数据。</li>
<li><code>const</code>：表示当前<code>SQL</code>语句的查询条件中，可以命中索引查询。</li>
<li><code>range</code>：表示当前查询操作是查某个区间。</li>
<li><code>eq_ref</code>：表示目前在做多表关联查询。</li>
<li><code>ref</code>：表示目前使用了普通索引查询。</li>
<li><code>index</code>：表示目前<code>SQL</code>使用了辅助索引查询。</li>
</ul>
</li>
<li>
<p><code>possible_keys</code>：执行<code>SQL</code>时，优化器可能会选择的索引（最后执行不一定用）。</p>
</li>
<li>
<p><code>key</code>：查询语句执行时，用到的索引名字。</p>
</li>
<li>
<p><code>key_len</code>：这里表示索引字段使用的字节数。</p>
</li>
<li>
<p><code>ref</code>：这里显示使用了那种查询的类型。</p>
</li>
<li>
<p><code>rows</code>：当前查询语句可能会扫描多少行数据才能检索出结果。</p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Extra
</span></span></code></pre></td></tr></table>
</div>
</div><p>：这里是记录着额外的一些索引使用信息，有几种状态：</p>
<ul>
<li><code>using index</code>：表示目前使用了覆盖索引查询（稍后讲）。</li>
<li><code>using where</code>：表示使用了<code>where</code>子句查询，通常表示没使用索引。</li>
<li><code>using index condition</code>：表示查询条件使用到了联合索引的前面几个字段。</li>
<li><code>using temporary</code>：表示使用了临时表处理查询结果。</li>
<li><code>using filesort</code>：表示以索引字段之外的方式进行排序，效率较低。</li>
<li><code>select tables optimized away</code>：表示在索引字段上使用了聚合函数。</li>
</ul>
</li>
</ul>
<p>对于上述这么多的字段，其实目前不需要完全弄懂，本文只需要记住里面的<code>type</code>字段即可，<code>all</code>表示走全表扫描，<code>const、ref...</code>表示通过索引查询。</p>
<blockquote>
<p>下面一起来聊一聊索引失效的一些场景。</p></blockquote>
<h4 id="312查询中带有or会导致索引失效">3.1.2、查询中带有OR会导致索引失效</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="n">user_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;熊猫&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>例如上述这条<code>SQL</code>，其中既包含了主键索引的字段，又包含了联合索引的第一个字段，按理来说是会走索引查询的对吗？但看看执行结果：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/daba592fab5b4c47819a211cd828d5d7tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/daba592fab5b4c47819a211cd828d5d7tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/daba592fab5b4c47819a211cd828d5d7tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/daba592fab5b4c47819a211cd828d5d7tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/daba592fab5b4c47819a211cd828d5d7tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="or导致索引失效" />
从结果中可看到<code>type=ALL</code>，显然并未使用索引来查询，也就代表着，虽然所有查询条件都包含了索引字段，但由于使用了<code>OR</code>，最终导致索引失效。</p>
<h4 id="313模糊查询中like以开头导致索引失效">3.1.3、模糊查询中like以%开头导致索引失效</h4>
<p>众所周知，使用<code>like</code>关键字做模糊查询时，是可以使用索引的，那来看看下述这条<code>SQL</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_name</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s2">&#34;%熊&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在这条<code>SQL</code>中以联合索引中的第一个字段作为了查询条件，此时会使用索引吗？看看结果：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/2cdb8fa875314b2f954e08b2de836e43tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/2cdb8fa875314b2f954e08b2de836e43tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/2cdb8fa875314b2f954e08b2de836e43tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/2cdb8fa875314b2f954e08b2de836e43tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/2cdb8fa875314b2f954e08b2de836e43tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="like%*导致索引失效" />
结果中显示依旧走了全表扫描，并未使用索引，但<code>like</code>不以<code>%</code>开头，实际上是不会导致索引失效的，例如：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/0845a5a46db6400581a7eb37a102f3b1tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/0845a5a46db6400581a7eb37a102f3b1tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/0845a5a46db6400581a7eb37a102f3b1tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/0845a5a46db6400581a7eb37a102f3b1tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/0845a5a46db6400581a7eb37a102f3b1tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="%结尾" />
在这里以<code>%</code>结尾，其实可以使用联合索引来检索数据，并不会导致索引失效。</p>
<h4 id="314字符类型查询时不带引号导致索引失效">3.1.4、字符类型查询时不带引号导致索引失效</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 先插入一条user_name = 1111 的数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">VALUES</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="s2">&#34;1111&#34;</span><span class="p">,</span><span class="s2">&#34;男&#34;</span><span class="p">,</span><span class="s2">&#34;4321&#34;</span><span class="p">,</span><span class="s2">&#34;2022-09-17 23:48:29&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">111</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述这条<code>SQL</code>按理来说是没有半点问题的，目前是符合联合索引的最左匹配原则的，但来看看结果：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/ca01ae3e18e8420e845f8d771124218atplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/ca01ae3e18e8420e845f8d771124218atplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/ca01ae3e18e8420e845f8d771124218atplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/ca01ae3e18e8420e845f8d771124218atplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/ca01ae3e18e8420e845f8d771124218atplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="不带引号对比" />
从结果中很明显的可以看出，由于<code>user_name</code>是字符串类型的，因此查询时没带引号，竟然直接未使用索引，导致了索引失效（上面也放了对比图，大家可以仔细看看区别)。</p>
<h4 id="315索引字段参与计算导致索引失效">3.1.5、索引字段参与计算导致索引失效</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_id</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面这条<code>SQL</code>看着估计有些懵，但实际上很简单，就是查询<code>ID=2</code>的数据，理论上因为查询条件中使用了主键字段，应该会使用主键索引，但结果呢？
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/788432af3fc7440dac4d5ba843b25c00tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/788432af3fc7440dac4d5ba843b25c00tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/788432af3fc7440dac4d5ba843b25c00tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/788432af3fc7440dac4d5ba843b25c00tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/788432af3fc7440dac4d5ba843b25c00tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="索引字段参与计算" />
由于索引字段参与了计算，所以此时又导致了索引失效，因此大家要切记，千万不要让索引字段在<code>SQL</code>中参与计算，也包括使用一些聚合函数时也会导致索引失效，其根本原因就在于索引字段参与了计算导致的。</p>
<blockquote>
<p>这里的运算也包括<code>+、-、*、/、!.....</code>等一系列涉及字段计算的逻辑。</p></blockquote>
<h4 id="316字段被用于函数计算导致索引失效">3.1.6、字段被用于函数计算导致索引失效</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="k">SUBSTRING</span><span class="p">(</span><span class="n">user_name</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;竹子&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述中，我们使用<code>SUBSTRING</code>函数对<code>user_name</code>字段进行了截取，然后再用于条件查询，此时看看执行结果：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/4fa14046c5974fff961362832e249554tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/4fa14046c5974fff961362832e249554tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/4fa14046c5974fff961362832e249554tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/4fa14046c5974fff961362832e249554tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/4fa14046c5974fff961362832e249554tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="函数计算" />
很显然，并未使用索引查询，这也是意料之中的事情，毕竟这一条和<code>3.1.5</code>的原因大致相同，索引字段参与计算导致失效。</p>
<h4 id="317违背最左前缀原则导致索引失效">3.1.7、违背最左前缀原则导致索引失效</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="o">`</span><span class="n">user_sex</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;男&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="o">`</span><span class="n">password</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;1234&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述这条<code>SQL</code>中，显然用到了联合索引中的性别和密码字段，此时再看看结果：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/8c8614279bae43689a8cbe9f12917f3ftplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/8c8614279bae43689a8cbe9f12917f3ftplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/8c8614279bae43689a8cbe9f12917f3ftplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/8c8614279bae43689a8cbe9f12917f3ftplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/8c8614279bae43689a8cbe9f12917f3ftplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="违背最左匹配" />
由于违背了联合索引的最左前缀原则，因为没使用最左边的<code>user_name</code>字段，因此也导致索引失效，从而走了全表查询。</p>
<h4 id="318不同字段值对比导致索引失效">3.1.8、不同字段值对比导致索引失效</h4>
<p>从一张表中查询出一些值，然后根据这些值去其他表中筛选数据，这个业务也是实际项目中较为常见的场景，下面为了简单实现，就简单用姓名和性别模拟一下字段对比的场景：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">user_sex</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>按理来说，因为<code>user_name</code>属于联合索引的第一个字段，所以上述这条<code>SQL</code>中规中矩，理论上会走索引的，但看看结果：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/0fbf03533f9c4e979d2207432d408c95tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/0fbf03533f9c4e979d2207432d408c95tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/0fbf03533f9c4e979d2207432d408c95tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/0fbf03533f9c4e979d2207432d408c95tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/0fbf03533f9c4e979d2207432d408c95tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="字段对比" />
显然，这个场景也会导致索引无法使用，因此之后也要切记这点。</p>
<h4 id="319反向范围操作导致索引失效">3.1.9、反向范围操作导致索引失效</h4>
<p>一般来说，如果<code>SQL</code>属于正向范围查询，例如<code>&gt;、&lt;、between、like、in...</code>等操作时，索引是可以正常生效的，但如果<code>SQL</code>执行的是反向范围操作，例如<code>NOT IN、NOT LIKE、IS NOT NULL、!=、&lt;&gt;...</code>等操作时，就会出现问题，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">user_id</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">IN</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述<code>SQL</code>的意思很简单，也就是查询<code>user_id</code>不是<code>1,2,3</code>的数据，这里是基于主键索引字段<code>user_id</code>查询的，但会走索引吗？来看看结果：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/3b2e7542400b4140bcb03c6c260be841tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/3b2e7542400b4140bcb03c6c260be841tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/3b2e7542400b4140bcb03c6c260be841tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/3b2e7542400b4140bcb03c6c260be841tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/3b2e7542400b4140bcb03c6c260be841tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="范围查询对比" />
结果也很明显，使用<code>NOT</code>关键字做反向范围查询时，并不会走索引，索引此时失效了，但是做正向范围查询时，索引依旧有效。</p>
<blockquote>
<p>对于这一点，其实大家可以慢慢实验，并非所有的正向范围操作都会走索引，例如<code>IS NULL</code>就不会走，它的反向操作：<code>IS NOT NULL</code>同样不会走。</p></blockquote>
<h4 id="3110索引失效小结">3.1.10、索引失效小结</h4>
<p>在<code>MySQL</code>中还有一种特殊情况会导致索引失效，也就是当走索引扫描的行数超过表行数的<code>30%</code>时，<code>MySQL</code>会默认放弃索引查询，转而使用全表扫描的方式检索数据，因此这种情况下走索引的顺序磁盘<code>IO</code>，反而不一定有全表的随机磁盘<code>IO</code>快。</p>
<blockquote>
<p>还有一点要牢记：关于索引是否会失效，实际上也跟索引的数据结构、<code>MySQL</code>的版本、存储引擎的不同有关，例如一条<code>SQL</code>语句在<code>B+Tree</code>索引中会导致索引失效，但在哈希索引中却不会（好比<code>IS NULL/IS NOT NULL</code>），这种情况在不同版本、不同引擎中都有可能会体现出来。</p></blockquote>
<p>但到目前为止，大致上已经将<code>MySQL</code>中会导致索引失效的几种情况罗列说明了，接下来一起看看使用索引的正确姿势！</p>
<h3 id="32使用索引的正确姿势">3.2、使用索引的正确姿势</h3>
<p>其实到这里，对于如何使用索引才是正确的呢？总结如下：</p>
<ul>
<li>①查询<code>SQL</code>中尽量不要使用<code>OR</code>关键字，可以使用多<code>SQL</code>或子查询代替。</li>
<li>②模糊查询尽量不要以<code>%</code>开头，如果实在要实现这个功能可以建立全文索引。</li>
<li>③编写<code>SQL</code>时一定要注意字段的数据类型，否则<code>MySQL</code>的隐式转换会导致索引失效。</li>
<li>④一定不要在编写<code>SQL</code>时让索引字段执行计算工作，尽量将计算工作放在客户端中完成。</li>
<li>⑤对于索引字段尽量不要使用计算类函数，一定要使用时请记得将函数计算放在<code>=</code>后面。</li>
<li>⑥多条件的查询<code>SQL</code>一定要使用联合索引中的第一个字段，否则会打破最左匹配原则。</li>
<li>⑦对于需要对比多个字段的查询业务时，可以拆分为连表查询，使用临时表代替。</li>
<li>⑧在<code>SQL</code>中不要使用反范围性的查询条件，大部分反范围性、不等性查询都会让索引失效。</li>
<li>⑨<code>.......</code></li>
</ul>
<p>实际上无非就是根据前面给出的索引失效情况，尽量让自己编写的<code>SQL</code>不会导致索引失效即可，写出来的<code>SQL</code>能走索引查询，那就能在很大程度上提升数据检索的效率。</p>
<blockquote>
<p>不过这些也属于<code>SQL</code>优化的内容，因此更多、更具体的<code>SQL</code>编写准则，会在之后的《SQL调优篇》详细讲解。</p></blockquote>
<p>接下来再重点讲几个较重要的内容，既索引覆盖、索引下推、<code>Multi-Range Read</code>机制、索引跳跃式扫描机制。</p>
<h4 id="321索引覆盖">3.2.1、索引覆盖</h4>
<p>在之前聊到过，由于表中只能存在一个聚簇索引，一般都为主键索引，而建立的其他索引都为辅助索引，包括联合索引也例外，最终索引节点上存储的都是指向主键索引的值，拿前面的用户表为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="o">`</span><span class="n">user_name</span><span class="o">`=</span><span class="s2">&#34;竹子&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="o">`</span><span class="n">user_sex</span><span class="o">`=</span><span class="s2">&#34;男&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>虽然这条<code>SQL</code>会走联合索引查询，但是基于联合索引查询出来的值仅是一个指向主键索引的<code>ID</code>，然后会拿着这个<code>ID</code>再去主键索引中查一遍，这个过程之前聊过，被称为回表过程。</p>
<blockquote>
<p>那么回表问题无法解决吗？必须得经过两次查询才能得到数据吗？答案并非如此。</p></blockquote>
<p>比如假设此时只需要<code>user_name、user_sex、password</code>这三个字段的信息，此时<code>SQL</code>语句可以更改为如下情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">user_name</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">user_sex</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">password</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">user_name</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;竹子&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="o">`</span><span class="n">user_sex</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;男&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>此时将<code>SQL</code>更改为查询所需的列后，就不会发生回表现象，<code>Why</code>？再这里很多小伙伴可能会疑惑，这是什么道理啊？因为此时所需的<code>user_name、user_sex、password</code>三个字段数据，在联合索引中完全包含，因此可以直接通过联合索引获取到数据。</p>
<blockquote>
<p>但如果查询时用<code>*</code>，因为联合索引中不具备完整的一行数据，只能再次转向聚簇索引中获取完整的行数据，因此到这里大家应该也明白了为什么查询数据时，不能用<code>*</code>的原因，这是因为会导致索引覆盖失效，造成回表问题。</p></blockquote>
<p>当然，再来提一点比较有意思的事情，先看<code>SQL</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">user_name</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">user_sex</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">FROM</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">password</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;1234&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="o">`</span><span class="n">user_sex</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;男&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>比如上述这条<code>SQL</code>，显然是不符合联合索引的最左前缀匹配原则的，但来看看执行结果：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="./images/d6cf8c136e86473fac747f4bb430cfcetplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        data-srcset="./images/d6cf8c136e86473fac747f4bb430cfcetplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp, ./images/d6cf8c136e86473fac747f4bb430cfcetplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 1.5x, ./images/d6cf8c136e86473fac747f4bb430cfcetplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp 2x"
        data-sizes="auto"
        alt="./images/d6cf8c136e86473fac747f4bb430cfcetplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp"
        title="索引覆盖" />
这个结果是不是很令你惊讶，通过<code>EXPLAIN</code>分析的结果显示，这条<code>SQL</code>竟然使用了索引，这是什么原因呢？也是因为索引覆盖。</p>
<blockquote>
<p>一句话概述：就是要查询的列，在使用的索引中已经包含，被所使用的索引覆盖，这种情况称之为索引覆盖。</p></blockquote>
<h4 id="322索引下推">3.2.2、索引下推</h4>
<p>索引下推是<code>MySQL5.6</code>版本以后引入的一种优化机制，还是以之前的用户表为例，先来看一条<code>SQL</code>语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">VALUES</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s2">&#34;竹竹&#34;</span><span class="p">,</span><span class="s2">&#34;女&#34;</span><span class="p">,</span><span class="s2">&#34;8888&#34;</span><span class="p">,</span><span class="s2">&#34;2022-09-20 22:17:21&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_users</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="o">`</span><span class="n">user_name</span><span class="o">`</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s2">&#34;竹%&#34;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="o">`</span><span class="n">user_sex</span><span class="o">`=</span><span class="s2">&#34;男&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>首先为了更加直观的讲清楚索引下推，因此先再向用户表中增加一条数据。然后再来看看后面的查询<code>SQL</code>，这条<code>SQL</code>会使用联合索引吗？答案是会的，但只能部分使用，因为联合索引的每个节点信息大致如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">[</span><span class="nt">&#34;熊猫&#34;</span><span class="p">,</span><span class="nt">&#34;女&#34;</span><span class="p">,</span><span class="nt">&#34;6666&#34;</span><span class="err">]</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="err">[</span><span class="nt">&#34;竹子&#34;</span><span class="p">,</span><span class="nt">&#34;男&#34;</span><span class="p">,</span><span class="nt">&#34;1234&#34;</span><span class="err">]</span> <span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="err">[</span><span class="nt">&#34;子竹&#34;</span><span class="p">,</span><span class="nt">&#34;男&#34;</span><span class="p">,</span><span class="nt">&#34;4321&#34;</span><span class="err">]</span> <span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="err">[</span><span class="nt">&#34;1111&#34;</span><span class="p">,</span><span class="nt">&#34;男&#34;</span><span class="p">,</span><span class="nt">&#34;4321&#34;</span><span class="err">]</span> <span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="err">[</span><span class="nt">&#34;竹竹&#34;</span><span class="p">,</span><span class="nt">&#34;女&#34;</span><span class="p">,</span><span class="nt">&#34;8888&#34;</span><span class="err">]</span> <span class="p">:</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="err">复制代码</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于前面使用的是模糊查询，但<code>%</code>在结尾，因此可以使用<code>竹</code>这个字作为条件在联合索引中查询，整个查询过程如下：</p>
<ul>
<li>①利用联合索引中的<code>user_name</code>字段找出「竹子、竹竹」两个索引节点。</li>
<li>②返回索引节点存储的值「<code>2、5</code>」给<code>Server</code>层，然后去逐一做回表扫描。</li>
<li>③在<code>Server</code>层中根据<code>user_sex=&quot;男&quot;</code>这个条件逐条判断，最终筛选到「竹子」这条数据。</li>
</ul>
<p>有人或许会疑惑，为什么<code>user_sex=&quot;男&quot;</code>这个条件不在联合索引中处理呢？因为前面是模糊查询，所以拼接起来是这样的：<code>竹x男</code>，由于这个<code>x</code>是未知的，因此无法根据最左前缀原则去匹配数据，最终这里只能使用联合索引中<code>user_name</code>字段的一部分，后续的<code>user_sex=&quot;男&quot;</code>还需要回到<code>Server</code>层处理。</p>
<blockquote>
<p>那什么又叫做索引下推呢？也就是将<code>Server</code>层筛选数据的工作，下推到引擎层处理。</p></blockquote>
<p>以前面的案例来讲解，<code>MySQL5.6</code>加入索引下推机制后，其执行过程是什么样子的呢？</p>
<ul>
<li>①利用联合索引中的<code>user_name</code>字段找出「竹子、竹竹」两个索引节点。</li>
<li>②根据<code>user_sex=&quot;男&quot;</code>这个条件在索引节点中逐个判断，从而得到「竹子」这个节点。</li>
<li>③最终将「竹子」这个节点对应的「<code>2</code>」返回给<code>Server</code>层，然后聚簇索引中回表拿数据。</li>
</ul>
<p>相较于没有索引下推之前，原本需要做「<code>2、5</code>」两次回表查询，但在拥有索引下推之后，仅需做「<code>2</code>」一次回表查询。</p>
<blockquote>
<p>索引下推在<code>MySQL5.6</code>版本之后是默认开启的，可以通过命令<code>set optimizer_switch='index_condition_pushdown=off|on';</code>命令来手动管理。</p></blockquote>
<h4 id="323mrrmulti-range-read机制">3.2.3、MRR(Multi-Range Read)机制</h4>
<p><code>Multi-Range Read</code>简称为<code>MRR</code>机制，这也是和索引下推一同在<code>MySQL5.6</code>版本中引入的性能优化措施，那什么叫做<code>MRR</code>优化呢？</p>
<blockquote>
<p>一般来说，在实际业务中我们应当尽量通过索引覆盖的特性，减少回表操作以降低<code>IO</code>次数，但在很多时候往往又不得不做回表才能查询到数据，但回表显然会导致产生大量磁盘<code>IO</code>，同时更严重的一点是：还会产生大量的离散<code>IO</code>，下面举个例子来理解。</p></blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">zz_student_score</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="o">`</span><span class="n">score</span><span class="o">`</span><span class="w"> </span><span class="k">BETWEEN</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="mi">59</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上述这条<code>SQL</code>所做的工作很简单，就是在学生成绩表中查询所有成绩未及格的学生信息，假设成绩字段上存在一个普通索引，那思考一下，这条<code>SQL</code>的执行流程是什么样的呢？</p>
<ul>
<li>①先在成绩字段的索引上找到<code>0</code>分的节点，然后拿着<code>ID</code>去回表得到成绩零分的学生信息。</li>
<li>②再次回到成绩索引，继续找到所有<code>1</code>分的节点，继续回表得到<code>1</code>分的学生信息。</li>
<li>③再次回到成绩索引，继续找到所有<code>2</code>分的节点&hellip;&hellip;</li>
<li>④周而复始，不断重复这个过程，直到将<code>0~59</code>分的所有学生信息全部拿到为止。</li>
</ul>
<p>那此时假设此时成绩<code>0~5</code>分的表数据，位于磁盘空间的<code>page_01</code>页上，而成绩为<code>5~10</code>分的数据，位于磁盘空间的<code>page_02</code>页上，成绩为<code>10~15</code>分的数据，又位于磁盘空间的<code>page_01</code>页上。此时回表查询时就会导致在<code>page_01、page_02</code>两页空间上来回切换，但<code>0~5、10~15</code>分的数据完全可以合并，然后读一次<code>page_01</code>就可以了，既能减少<code>IO</code>次数，同时还避免了离散<code>IO</code>。</p>
<blockquote>
<p>而<code>MRR</code>机制就主要是解决这个问题的，针对于辅助索引的回表查询，减少离散<code>IO</code>，并且将随机<code>IO</code>转换为顺序<code>IO</code>，从而提高查询效率。</p></blockquote>
<p>那<code>MRR</code>机制具体是怎么做的呢？<code>MRR</code>机制中，对于辅助索引中查询出的<code>ID</code>，会将其放到缓冲区的<code>read_rnd_buffer</code>中，然后等全部的索引检索工作完成后，或者缓冲区中的数据达到<code>read_rnd_buffer_size</code>大小时，此时<code>MySQL</code>会对缓冲区中的数据排序，从而得到一个有序的<code>ID</code>集合：<code>rest_sort</code>，最终再根据顺序<code>IO</code>去聚簇/主键索引中回表查询数据。</p>
<blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">SET @@optimizer_switch=&#39;mrr=on|off,mrr_cost_based=on|off&#39;;
</span></span></code></pre></td></tr></table>
</div>
</div></blockquote>
<p>可以通过上述这条命令开启或关闭<code>MRR</code>机制，<code>MySQL5.6</code>及以后的版本是默认开启的。</p>
<h4 id="324index-skip-scan索引跳跃式扫描">3.2.4、Index Skip Scan索引跳跃式扫描</h4>
<p>在讲联合索引时，咱们提到过最左前缀匹配原则，也就是<code>SQL</code>的查询条件中必须要包含联合索引的第一个字段，这样才能命中联合索引查询，但实际上这条规则也并不是<code>100%</code>遵循的。因为在<code>MySQL8.x</code>版本中加入了一个新的优化机制，也就是索引跳跃式扫描，这种机制使得咱们即使查询条件中，没有使用联合索引的第一个字段，也依旧可以使用联合索引，看起来就像跳过了联合索引中的第一个字段一样，这也是跳跃扫描的名称由来。</p>
<blockquote>
<p>但跳跃扫描究竟是怎么实现的呢？上个栗子快速理解一下。</p></blockquote>
<p>比如此时通过<code>(A、B、C)</code>三个列建立了一个联合索引，此时有如下一条<code>SQL</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">tb_xx</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">`</span><span class="n">xxx</span><span class="o">`</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">`</span><span class="n">xxx</span><span class="o">`</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>按理来说，这条<code>SQL</code>既不符合最左前缀原则，也不具备使用索引覆盖的条件，因此绝对是不会走联合索引查询的，但思考一个问题，这条<code>SQL</code>中都已经使用了联合索引中的两个字段，结果还不能使用索引，这似乎有点亏啊对不？因此<code>MySQL8.x</code>推出了跳跃扫描机制，但跳跃扫描并不是真正的“跳过了”第一个字段，而是优化器为你重构了<code>SQL</code>，比如上述这条<code>SQL</code>则会重构成如下情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">tb_xx</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">`</span><span class="n">xxx</span><span class="o">`</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">`</span><span class="n">xxx</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">UNION</span><span class="w"> </span><span class="k">ALL</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">tb_xx</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">`</span><span class="n">xxx</span><span class="o">`</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">`</span><span class="n">xxx</span><span class="o">`</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;yyy&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">......</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="o">`</span><span class="n">tb_xx</span><span class="o">`</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">`</span><span class="n">xxx</span><span class="o">`</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="k">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">`</span><span class="n">xxx</span><span class="o">`</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&#34;zzz&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="err">复制代码</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其实也就是<code>MySQL</code>优化器会自动对联合索引中的第一个字段的值去重，然后基于去重后的值全部拼接起来查一遍，一句话来概述就是：<strong>虽然你没用第一个字段，但我给你加上去，今天这个联合索引你就得用，不用也得给我用</strong>。</p>
<blockquote>
<p>当然，如果熟悉<code>Oracle</code>数据库的小伙伴应该知道，跳跃扫描机制在<code>Oracle</code>中早就有了，但为什么<code>MySQL8.0</code>版本才推出这个机制呢？还记得咱们在<a href="https://juejin.cn/post/7143614079532269598#heading-1" target="_blank" rel="noopener noreffer ">《MySQL架构篇》</a>中的闲谈嘛？<code>MySQL</code>几经转手后，最终归到了<code>Oracle</code>旗下，因此跳跃扫描机制仅是<code>Oracle</code>公司：从<code>Oracle</code>搬到了“自己的<code>MySQL</code>”上而已。</p></blockquote>
<p>但是跳跃扫描机制也有很多限制，比如多表联查时无法触发、<code>SQL</code>条件中有分组操作也无法触发、<code>SQL</code>中用了<code>DISTINCT</code>去重也无法触发&hellip;..，总之有很多限制条件，具体的可以参考<a href="https://link.juejin.cn/?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F8.0%2Fen%2Frange-optimization.html" target="_blank" rel="noopener noreffer ">《MySQL官网8.0-跳跃扫描》</a>。</p>
<blockquote>
<p>其实这个跳跃性扫描机制，只有在唯一性较差的情况下，才能发挥出不错的效果，如果你联合索引的第一个字段，是一个值具备唯一性的字段，那去重一次再拼接，几乎就等价于走一次全表。</p></blockquote>
<p><em>最后，可以通过通过<code>set @@optimizer_switch = 'skip_scan=off|on';</code>命令来选择开启或关闭跳跃式扫描机制。当然，该参数仅限<code>MySQL8.0</code>以上的版本，如果在此之下的版本暂时就不用考虑了。</em></p>
<h2 id="四索引应用篇总结">四、索引应用篇总结</h2>
<p>至此，<code>MySQL</code>索引应用篇，也就是索引中篇就结束了，相信大家认真看完本篇之后，对于索引的掌握性、熟练程度绝对会更上一层楼，因为本章中从索引的优劣分析，到建立索引的原则、索引失效的情景、使用索引的正确姿势、<code>MySQL</code>对于索引的优化机制等各方面，对索引进行了进一步阐述。</p>
<blockquote>
<p>经历中、上两篇的阐述后，对于<code>MySQL</code>索引这个大体系已经建立出了完整的认知，下一篇就是《索引原理篇》啦，在中、上两篇中抛出了很多疑惑，都留在了索引原理篇中去分析，因为只有当你真正搞懂了索引的底层实现，才能更好的理解一些前面给出的建议、定论及概念。</p></blockquote>
<p>当然，如果你认为我的文章对你有帮助，那可以动动发财的小手，点上一个免费的小赞赞~，点赞量足够多可加快《索引原理篇》的解锁进度，更文速度完全取决于诸位的点赞数量！当然，就算不给赞，《索引原理篇》也不会缺席噢！最后再给出两条关于索引的查询命令：</p>
<ul>
<li><code>show status like '%Handler_read%';</code>查看当前会话的索引使用情况。</li>
<li><code>show global status like 'Handler_read%';</code>：查询全局索引使用情况。</li>
</ul>
<p>这两条命令在之后的《SQL调优篇》中会用到的，这些命令中的信息对于调优会有不小的参考价值，当然，对于详细的分析在后续的篇章中再详细讲解咯！</p></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-11-26</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8/">索引使用</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E7%B4%A2%E5%BC%95%E5%88%9D%E8%AF%86%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E5%88%86%E7%B1%BB%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%AE%A1%E7%90%86/" class="prev" rel="prev" title="索引初识:索引机制、分类、使用与管理"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>索引初识:索引机制、分类、使用与管理</a>
            <a href="/posts/umi4-%E9%9B%86%E6%88%90%E9%98%BF%E9%87%8C%E4%BD%8E%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6lowcode-engine/" class="next" rel="next" title="Umi4 集成阿里低代码框架lowcode-engine">Umi4 集成阿里低代码框架lowcode-engine<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line"><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="http://jerry-cdn.b0.upaiyun.com/hit-kounter/hit-kounter-lc-0.2.0.js"></script><span data-hk-page="current"> - </span></div><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.147.7">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.3.0"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2021 - 2025</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">xxxx</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><script type="text/javascript" src="/lib/valine/Valine.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/algoliasearch/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"valine":{"appId":"rTeTnudkYwu3cz5ejsdiKdFm-gzGzoHsz","appKey":"SfE7A8tmPKu2F6Pf5LMUewa4","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@15.1.2/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":false,"highlight":true,"lang":"zh-CN","meta":["nick","mail"],"pageSize":10,"placeholder":"在这里留下足迹吧!","recordIP":true,"visitor":true}},"search":{"algoliaAppID":"CT9HNMDY0J","algoliaIndex":"hugo","algoliaSearchKey":"e48b980a6aaab08129f8a8d9a425c47b","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
